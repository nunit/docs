{
  "404.html": {
    "href": "404.html",
    "title": "Page Not Found | NUnit Docs",
    "summary": "Page Not Found We're sorry, but the page you're looking for cannot be found on the site. Feel free to Open an issue in the NUnit Docs GitHub Repository with the URL or content you expected to exist, and we'll be happy to look into it."
  },
  "api/NUnit.Common.ColorConsole.html": {
    "href": "api/NUnit.Common.ColorConsole.html",
    "title": "Class ColorConsole | NUnit Docs",
    "summary": "Class ColorConsole Sets the console color in the constructor and resets it in the dispose Inheritance object ColorConsole Implements IDisposable Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Common Assembly: nunitlite.dll Syntax public class ColorConsole : IDisposable Constructors View Source ColorConsole(ColorStyle) Initializes a new instance of the ColorConsole class. Declaration public ColorConsole(ColorStyle style) Parameters Type Name Description ColorStyle style The color style to use. Methods View Source Dispose() If color is enabled, restores the console colors to their defaults Declaration public void Dispose() View Source GetColor(ColorStyle) By using styles, we can keep everything consistent Declaration public static ConsoleColor GetColor(ColorStyle style) Parameters Type Name Description ColorStyle style Returns Type Description ConsoleColor Implements IDisposable"
  },
  "api/NUnit.Common.ColorConsoleWriter.html": {
    "href": "api/NUnit.Common.ColorConsoleWriter.html",
    "title": "Class ColorConsoleWriter | NUnit Docs",
    "summary": "Class ColorConsoleWriter Inheritance object MarshalByRefObject TextWriter ExtendedTextWriter ExtendedTextWrapper ColorConsoleWriter Implements IDisposable IAsyncDisposable Inherited Members ExtendedTextWrapper.Write(char) ExtendedTextWrapper.Write(string) ExtendedTextWrapper.WriteLine(string) ExtendedTextWrapper.Dispose(bool) ExtendedTextWrapper.Encoding TextWriter.Null TextWriter.CoreNewLine TextWriter.Close() TextWriter.Dispose() TextWriter.DisposeAsync() TextWriter.Flush() TextWriter.Write(char[]) TextWriter.Write(char[], int, int) TextWriter.Write(ReadOnlySpan<char>) TextWriter.Write(bool) TextWriter.Write(int) TextWriter.Write(uint) TextWriter.Write(long) TextWriter.Write(ulong) TextWriter.Write(float) TextWriter.Write(double) TextWriter.Write(decimal) TextWriter.Write(object) TextWriter.Write(StringBuilder) TextWriter.Write(string, object) TextWriter.Write(string, object, object) TextWriter.Write(string, object, object, object) TextWriter.Write(string, params object[]) TextWriter.Write(string, params ReadOnlySpan<object>) TextWriter.WriteLine() TextWriter.WriteLine(char) TextWriter.WriteLine(char[]) TextWriter.WriteLine(char[], int, int) TextWriter.WriteLine(ReadOnlySpan<char>) TextWriter.WriteLine(bool) TextWriter.WriteLine(int) TextWriter.WriteLine(uint) TextWriter.WriteLine(long) TextWriter.WriteLine(ulong) TextWriter.WriteLine(float) TextWriter.WriteLine(double) TextWriter.WriteLine(decimal) TextWriter.WriteLine(StringBuilder) TextWriter.WriteLine(object) TextWriter.WriteLine(string, object) TextWriter.WriteLine(string, object, object) TextWriter.WriteLine(string, object, object, object) TextWriter.WriteLine(string, params object[]) TextWriter.WriteLine(string, params ReadOnlySpan<object>) TextWriter.WriteAsync(char) TextWriter.WriteAsync(string) TextWriter.WriteAsync(StringBuilder, CancellationToken) TextWriter.WriteAsync(char[]) TextWriter.WriteAsync(char[], int, int) TextWriter.WriteAsync(ReadOnlyMemory<char>, CancellationToken) TextWriter.WriteLineAsync(char) TextWriter.WriteLineAsync(string) TextWriter.WriteLineAsync(StringBuilder, CancellationToken) TextWriter.WriteLineAsync(char[]) TextWriter.WriteLineAsync(char[], int, int) TextWriter.WriteLineAsync(ReadOnlyMemory<char>, CancellationToken) TextWriter.WriteLineAsync() TextWriter.FlushAsync() TextWriter.FlushAsync(CancellationToken) TextWriter.Synchronized(TextWriter) TextWriter.CreateBroadcasting(params TextWriter[]) TextWriter.FormatProvider TextWriter.NewLine MarshalByRefObject.GetLifetimeService() MarshalByRefObject.InitializeLifetimeService() MarshalByRefObject.MemberwiseClone(bool) object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Common Assembly: nunitlite.dll Syntax public class ColorConsoleWriter : ExtendedTextWrapper, IDisposable, IAsyncDisposable Constructors View Source ColorConsoleWriter() Construct a ColorConsoleWriter. Declaration public ColorConsoleWriter() View Source ColorConsoleWriter(bool) Construct a ColorConsoleWriter. Declaration public ColorConsoleWriter(bool colorEnabled) Parameters Type Name Description bool colorEnabled Flag indicating whether color should be enabled Fields View Source ColorEnabled Declaration public bool ColorEnabled Field Value Type Description bool Methods View Source Write(ColorStyle, string) Writes the value with the specified style. Declaration public override void Write(ColorStyle style, string value) Parameters Type Name Description ColorStyle style The style. string value The value. Overrides ExtendedTextWrapper.Write(ColorStyle, string) View Source WriteLabel(string, object) Writes the label and the option that goes with it. Declaration public override void WriteLabel(string label, object option) Parameters Type Name Description string label The label. object option The option. Overrides ExtendedTextWrapper.WriteLabel(string, object) View Source WriteLabel(string, object, ColorStyle) Writes the label and the option that goes with it and optionally writes a new line. Declaration public override void WriteLabel(string label, object option, ColorStyle valueStyle) Parameters Type Name Description string label The label. object option The option. ColorStyle valueStyle The color to display the value with Overrides ExtendedTextWrapper.WriteLabel(string, object, ColorStyle) View Source WriteLabelLine(string, object) Writes the label and the option that goes with it followed by a new line. Declaration public override void WriteLabelLine(string label, object option) Parameters Type Name Description string label The label. object option The option. Overrides ExtendedTextWrapper.WriteLabelLine(string, object) View Source WriteLabelLine(string, object, ColorStyle) Writes the label and the option that goes with it followed by a new line. Declaration public override void WriteLabelLine(string label, object option, ColorStyle valueStyle) Parameters Type Name Description string label The label. object option The option. ColorStyle valueStyle The color to display the value with Overrides ExtendedTextWrapper.WriteLabelLine(string, object, ColorStyle) View Source WriteLine(ColorStyle, string) Writes the value with the specified style. Declaration public override void WriteLine(ColorStyle style, string value) Parameters Type Name Description ColorStyle style The style. string value The value. Overrides ExtendedTextWrapper.WriteLine(ColorStyle, string) Implements IDisposable IAsyncDisposable"
  },
  "api/NUnit.Common.ColorStyle.html": {
    "href": "api/NUnit.Common.ColorStyle.html",
    "title": "Enum ColorStyle | NUnit Docs",
    "summary": "Enum ColorStyle ColorStyle enumerates the various styles used in the console display Namespace: NUnit.Common Assembly: nunitlite.dll Syntax public enum ColorStyle Fields Name Description Default The default color for items that don't fit into the other categories Error Color for errors and exceptions Failure Color for failed tests Header Color for headers Help Color for help text Label Color for labels Output Test output Pass Color for passed tests SectionHeader Color for each of the section headers SubHeader Color for sub-headers Value Color for values, usually go beside labels Warning Color for warnings, ignored or skipped tests"
  },
  "api/NUnit.Common.CommandLineOptions.html": {
    "href": "api/NUnit.Common.CommandLineOptions.html",
    "title": "Class CommandLineOptions | NUnit Docs",
    "summary": "Class CommandLineOptions CommandLineOptions is the base class the specific option classes used for nunit3-console and nunitlite. It encapsulates all common settings and features of both. This is done to ensure that common features remain common and for the convenience of having the code in a common location. The class inherits from the Mono Options OptionSet class and provides a central location for defining and parsing options. Inheritance object Collection<Option> KeyedCollection<string, Option> OptionSet CommandLineOptions NUnitLiteOptions Implements IList<Option> ICollection<Option> IList ICollection IReadOnlyList<Option> IReadOnlyCollection<Option> IEnumerable<Option> IEnumerable Inherited Members OptionSet.MessageLocalizer(string) OptionSet.GetKeyForItem(Option) OptionSet.InsertItem(int, Option) OptionSet.RemoveItem(int) OptionSet.SetItem(int, Option) OptionSet.Add(Option) OptionSet.Add(string, Action<string>) OptionSet.Add(string, string, Action<string>) OptionSet.Add(string, OptionAction<string, string>) OptionSet.Add(string, string, OptionAction<string, string>) OptionSet.Add<T>(string, Action<T>) OptionSet.Add<T>(string, string, Action<T>) OptionSet.Add<TKey, TValue>(string, OptionAction<TKey, TValue>) OptionSet.Add<TKey, TValue>(string, string, OptionAction<TKey, TValue>) OptionSet.CreateOptionContext() OptionSet.Parse(IEnumerable<string>) OptionSet.GetOptionParts(string, out string, out string, out string, out string) OptionSet.Parse(string, OptionContext) OptionSet.WriteOptionDescriptions(TextWriter) KeyedCollection<string, Option>.Contains(string) KeyedCollection<string, Option>.TryGetValue(string, out Option) KeyedCollection<string, Option>.Remove(string) KeyedCollection<string, Option>.ChangeItemKey(Option, string) KeyedCollection<string, Option>.ClearItems() KeyedCollection<string, Option>.GetKeyForItem(Option) KeyedCollection<string, Option>.InsertItem(int, Option) KeyedCollection<string, Option>.RemoveItem(int) KeyedCollection<string, Option>.SetItem(int, Option) KeyedCollection<string, Option>.Comparer KeyedCollection<string, Option>.this[string] KeyedCollection<string, Option>.Dictionary Collection<Option>.Clear() Collection<Option>.CopyTo(Option[], int) Collection<Option>.Contains(Option) Collection<Option>.GetEnumerator() Collection<Option>.IndexOf(Option) Collection<Option>.Insert(int, Option) Collection<Option>.Remove(Option) Collection<Option>.RemoveAt(int) Collection<Option>.ClearItems() Collection<Option>.Count Collection<Option>.Items Collection<Option>.this[int] object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Common Assembly: nunitlite.dll Syntax public class CommandLineOptions : OptionSet, IList<Option>, ICollection<Option>, IList, ICollection, IReadOnlyList<Option>, IReadOnlyCollection<Option>, IEnumerable<Option>, IEnumerable Constructors View Source CommandLineOptions(bool, params string[]) Declaration public CommandLineOptions(bool requireInputFile, params string[] args) Parameters Type Name Description bool requireInputFile string[] args Properties View Source DefaultTestNamePattern Declaration public string DefaultTestNamePattern { get; } Property Value Type Description string View Source DefaultTimeout Declaration public int DefaultTimeout { get; } Property Value Type Description int View Source DefaultTimeoutSpecified Declaration public bool DefaultTimeoutSpecified { get; } Property Value Type Description bool View Source DisplayTestLabels Declaration public string DisplayTestLabels { get; } Property Value Type Description string View Source ErrFile Declaration public string ErrFile { get; } Property Value Type Description string View Source ErrFileSpecified Declaration public bool ErrFileSpecified { get; } Property Value Type Description bool View Source ErrorMessages Declaration public IList<string> ErrorMessages { get; } Property Value Type Description IList<string> View Source Explore Declaration public bool Explore { get; } Property Value Type Description bool View Source ExploreOutputSpecifications Declaration public IList<OutputSpecification> ExploreOutputSpecifications { get; } Property Value Type Description IList<OutputSpecification> View Source InputFile Declaration public string InputFile { get; } Property Value Type Description string View Source InputFileRequired Indicates whether an input file is required on the command-line. Note that multiple input files are never allowed. Declaration public bool InputFileRequired { get; set; } Property Value Type Description bool View Source InternalTraceLevel Declaration public string InternalTraceLevel { get; } Property Value Type Description string View Source InternalTraceLevelSpecified Declaration public bool InternalTraceLevelSpecified { get; } Property Value Type Description bool View Source NoColor Declaration public bool NoColor { get; } Property Value Type Description bool View Source NoHeader Declaration public bool NoHeader { get; } Property Value Type Description bool View Source NumberOfTestWorkers Declaration public int NumberOfTestWorkers { get; } Property Value Type Description int View Source NumberOfTestWorkersSpecified Declaration public bool NumberOfTestWorkersSpecified { get; } Property Value Type Description bool View Source OutFile Declaration public string OutFile { get; } Property Value Type Description string View Source OutFileSpecified Declaration public bool OutFileSpecified { get; } Property Value Type Description bool View Source PreFilters Declaration public IList<string> PreFilters { get; } Property Value Type Description IList<string> View Source RandomSeed Declaration public int RandomSeed { get; } Property Value Type Description int View Source RandomSeedSpecified Declaration public bool RandomSeedSpecified { get; } Property Value Type Description bool View Source ResultOutputSpecifications Declaration public IList<OutputSpecification> ResultOutputSpecifications { get; } Property Value Type Description IList<OutputSpecification> View Source ShowHelp Declaration public bool ShowHelp { get; } Property Value Type Description bool View Source ShowVersion Declaration public bool ShowVersion { get; } Property Value Type Description bool View Source StopOnError Declaration public bool StopOnError { get; } Property Value Type Description bool View Source TeamCity Declaration public bool TeamCity { get; } Property Value Type Description bool View Source TestList Declaration public IList<string> TestList { get; } Property Value Type Description IList<string> View Source TestParameters Declaration public IDictionary<string, string> TestParameters { get; } Property Value Type Description IDictionary<string, string> View Source WaitBeforeExit Declaration public bool WaitBeforeExit { get; } Property Value Type Description bool View Source WhereClause Declaration public string WhereClause { get; } Property Value Type Description string View Source WhereClauseSpecified Declaration public bool WhereClauseSpecified { get; } Property Value Type Description bool View Source WorkDirectory Declaration public string WorkDirectory { get; } Property Value Type Description string View Source WorkDirectorySpecified Declaration public bool WorkDirectorySpecified { get; } Property Value Type Description bool Methods View Source CheckOptionCombinations() Declaration protected virtual void CheckOptionCombinations() View Source ConfigureOptions(bool) Declaration protected virtual void ConfigureOptions(bool allowInputFile) Parameters Type Name Description bool allowInputFile View Source RequiredInt(string, string) Declaration protected int RequiredInt(string val, string option) Parameters Type Name Description string val string option Returns Type Description int View Source RequiredValue(string, string, params string[]) Case is ignored when val is compared to validValues. When a match is found, the returned value will be in the canonical case from validValues. Declaration protected string RequiredValue(string val, string option, params string[] validValues) Parameters Type Name Description string val string option string[] validValues Returns Type Description string View Source Validate() Declaration public bool Validate() Returns Type Description bool Implements IList<T> ICollection<T> IList ICollection IReadOnlyList<T> IReadOnlyCollection<T> IEnumerable<T> IEnumerable"
  },
  "api/NUnit.Common.ExtendedTextWrapper.html": {
    "href": "api/NUnit.Common.ExtendedTextWrapper.html",
    "title": "Class ExtendedTextWrapper | NUnit Docs",
    "summary": "Class ExtendedTextWrapper ExtendedTextWrapper wraps a TextWriter and makes it look like an ExtendedTextWriter. All style indications are ignored. It's used when text is being written to a file. Inheritance object MarshalByRefObject TextWriter ExtendedTextWriter ExtendedTextWrapper ColorConsoleWriter Implements IDisposable IAsyncDisposable Inherited Members TextWriter.Null TextWriter.CoreNewLine TextWriter.Close() TextWriter.Dispose() TextWriter.DisposeAsync() TextWriter.Flush() TextWriter.Write(char[]) TextWriter.Write(char[], int, int) TextWriter.Write(ReadOnlySpan<char>) TextWriter.Write(bool) TextWriter.Write(int) TextWriter.Write(uint) TextWriter.Write(long) TextWriter.Write(ulong) TextWriter.Write(float) TextWriter.Write(double) TextWriter.Write(decimal) TextWriter.Write(object) TextWriter.Write(StringBuilder) TextWriter.Write(string, object) TextWriter.Write(string, object, object) TextWriter.Write(string, object, object, object) TextWriter.Write(string, params object[]) TextWriter.Write(string, params ReadOnlySpan<object>) TextWriter.WriteLine() TextWriter.WriteLine(char) TextWriter.WriteLine(char[]) TextWriter.WriteLine(char[], int, int) TextWriter.WriteLine(ReadOnlySpan<char>) TextWriter.WriteLine(bool) TextWriter.WriteLine(int) TextWriter.WriteLine(uint) TextWriter.WriteLine(long) TextWriter.WriteLine(ulong) TextWriter.WriteLine(float) TextWriter.WriteLine(double) TextWriter.WriteLine(decimal) TextWriter.WriteLine(StringBuilder) TextWriter.WriteLine(object) TextWriter.WriteLine(string, object) TextWriter.WriteLine(string, object, object) TextWriter.WriteLine(string, object, object, object) TextWriter.WriteLine(string, params object[]) TextWriter.WriteLine(string, params ReadOnlySpan<object>) TextWriter.WriteAsync(char) TextWriter.WriteAsync(string) TextWriter.WriteAsync(StringBuilder, CancellationToken) TextWriter.WriteAsync(char[]) TextWriter.WriteAsync(char[], int, int) TextWriter.WriteAsync(ReadOnlyMemory<char>, CancellationToken) TextWriter.WriteLineAsync(char) TextWriter.WriteLineAsync(string) TextWriter.WriteLineAsync(StringBuilder, CancellationToken) TextWriter.WriteLineAsync(char[]) TextWriter.WriteLineAsync(char[], int, int) TextWriter.WriteLineAsync(ReadOnlyMemory<char>, CancellationToken) TextWriter.WriteLineAsync() TextWriter.FlushAsync() TextWriter.FlushAsync(CancellationToken) TextWriter.Synchronized(TextWriter) TextWriter.CreateBroadcasting(params TextWriter[]) TextWriter.FormatProvider TextWriter.NewLine MarshalByRefObject.GetLifetimeService() MarshalByRefObject.InitializeLifetimeService() MarshalByRefObject.MemberwiseClone(bool) object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Common Assembly: nunitlite.dll Syntax public class ExtendedTextWrapper : ExtendedTextWriter, IDisposable, IAsyncDisposable Constructors View Source ExtendedTextWrapper(TextWriter) Declaration public ExtendedTextWrapper(TextWriter writer) Parameters Type Name Description TextWriter writer View Source ExtendedTextWrapper(TextWriter, bool) Declaration public ExtendedTextWrapper(TextWriter writer, bool shouldDisposeWriter) Parameters Type Name Description TextWriter writer bool shouldDisposeWriter Properties View Source Encoding Gets the encoding for this ExtendedTextWriter Declaration public override Encoding Encoding { get; } Property Value Type Description Encoding Overrides TextWriter.Encoding Methods View Source Dispose(bool) Dispose the Extended TextWriter Declaration protected override void Dispose(bool disposing) Parameters Type Name Description bool disposing Overrides TextWriter.Dispose(bool) View Source Write(ColorStyle, string) Writes the value with the specified style. Declaration public override void Write(ColorStyle style, string value) Parameters Type Name Description ColorStyle style The style. string value The value. Overrides ExtendedTextWriter.Write(ColorStyle, string) View Source Write(char) Write a single char value Declaration public override void Write(char value) Parameters Type Name Description char value Overrides TextWriter.Write(char) View Source Write(string) Write a string value Declaration public override void Write(string value) Parameters Type Name Description string value Overrides TextWriter.Write(string) View Source WriteLabel(string, object) Writes the label and the option that goes with it. Declaration public override void WriteLabel(string label, object option) Parameters Type Name Description string label The label. object option The option. Overrides ExtendedTextWriter.WriteLabel(string, object) View Source WriteLabel(string, object, ColorStyle) Writes the label and the option that goes with it. Declaration public override void WriteLabel(string label, object option, ColorStyle valueStyle) Parameters Type Name Description string label The label. object option The option. ColorStyle valueStyle The color to display the value with Overrides ExtendedTextWriter.WriteLabel(string, object, ColorStyle) View Source WriteLabelLine(string, object) Writes the label and the option that goes with it followed by a new line. Declaration public override void WriteLabelLine(string label, object option) Parameters Type Name Description string label The label. object option The option. Overrides ExtendedTextWriter.WriteLabelLine(string, object) View Source WriteLabelLine(string, object, ColorStyle) Writes the label and the option that goes with it followed by a new line. Declaration public override void WriteLabelLine(string label, object option, ColorStyle valueStyle) Parameters Type Name Description string label The label. object option The option. ColorStyle valueStyle The color to display the value with Overrides ExtendedTextWriter.WriteLabelLine(string, object, ColorStyle) View Source WriteLine(ColorStyle, string) Writes the value with the specified style Declaration public override void WriteLine(ColorStyle style, string value) Parameters Type Name Description ColorStyle style The style. string value The value. Overrides ExtendedTextWriter.WriteLine(ColorStyle, string) View Source WriteLine(string) Write a string value followed by a NewLine Declaration public override void WriteLine(string value) Parameters Type Name Description string value Overrides TextWriter.WriteLine(string) Implements IDisposable IAsyncDisposable"
  },
  "api/NUnit.Common.ExtendedTextWriter.html": {
    "href": "api/NUnit.Common.ExtendedTextWriter.html",
    "title": "Class ExtendedTextWriter | NUnit Docs",
    "summary": "Class ExtendedTextWriter ExtendedTextWriter extends the TextWriter abstract class to support displaying text in color. Inheritance object MarshalByRefObject TextWriter ExtendedTextWriter ExtendedTextWrapper Implements IDisposable IAsyncDisposable Inherited Members TextWriter.Null TextWriter.CoreNewLine TextWriter.Close() TextWriter.Dispose(bool) TextWriter.Dispose() TextWriter.DisposeAsync() TextWriter.Flush() TextWriter.Write(char) TextWriter.Write(char[]) TextWriter.Write(char[], int, int) TextWriter.Write(ReadOnlySpan<char>) TextWriter.Write(bool) TextWriter.Write(int) TextWriter.Write(uint) TextWriter.Write(long) TextWriter.Write(ulong) TextWriter.Write(float) TextWriter.Write(double) TextWriter.Write(decimal) TextWriter.Write(string) TextWriter.Write(object) TextWriter.Write(StringBuilder) TextWriter.Write(string, object) TextWriter.Write(string, object, object) TextWriter.Write(string, object, object, object) TextWriter.Write(string, params object[]) TextWriter.Write(string, params ReadOnlySpan<object>) TextWriter.WriteLine() TextWriter.WriteLine(char) TextWriter.WriteLine(char[]) TextWriter.WriteLine(char[], int, int) TextWriter.WriteLine(ReadOnlySpan<char>) TextWriter.WriteLine(bool) TextWriter.WriteLine(int) TextWriter.WriteLine(uint) TextWriter.WriteLine(long) TextWriter.WriteLine(ulong) TextWriter.WriteLine(float) TextWriter.WriteLine(double) TextWriter.WriteLine(decimal) TextWriter.WriteLine(string) TextWriter.WriteLine(StringBuilder) TextWriter.WriteLine(object) TextWriter.WriteLine(string, object) TextWriter.WriteLine(string, object, object) TextWriter.WriteLine(string, object, object, object) TextWriter.WriteLine(string, params object[]) TextWriter.WriteLine(string, params ReadOnlySpan<object>) TextWriter.WriteAsync(char) TextWriter.WriteAsync(string) TextWriter.WriteAsync(StringBuilder, CancellationToken) TextWriter.WriteAsync(char[]) TextWriter.WriteAsync(char[], int, int) TextWriter.WriteAsync(ReadOnlyMemory<char>, CancellationToken) TextWriter.WriteLineAsync(char) TextWriter.WriteLineAsync(string) TextWriter.WriteLineAsync(StringBuilder, CancellationToken) TextWriter.WriteLineAsync(char[]) TextWriter.WriteLineAsync(char[], int, int) TextWriter.WriteLineAsync(ReadOnlyMemory<char>, CancellationToken) TextWriter.WriteLineAsync() TextWriter.FlushAsync() TextWriter.FlushAsync(CancellationToken) TextWriter.Synchronized(TextWriter) TextWriter.CreateBroadcasting(params TextWriter[]) TextWriter.FormatProvider TextWriter.Encoding TextWriter.NewLine MarshalByRefObject.GetLifetimeService() MarshalByRefObject.InitializeLifetimeService() MarshalByRefObject.MemberwiseClone(bool) object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Common Assembly: nunitlite.dll Syntax public abstract class ExtendedTextWriter : TextWriter, IDisposable, IAsyncDisposable Constructors View Source ExtendedTextWriter() Declaration protected ExtendedTextWriter() Methods View Source Write(ColorStyle, string) Writes the value with the specified style. Declaration public abstract void Write(ColorStyle style, string value) Parameters Type Name Description ColorStyle style The style. string value The value. View Source WriteLabel(string, object) Writes the label and the option that goes with it. Declaration public abstract void WriteLabel(string label, object option) Parameters Type Name Description string label The label. object option The option. View Source WriteLabel(string, object, ColorStyle) Writes the label and the option that goes with it. Declaration public abstract void WriteLabel(string label, object option, ColorStyle valueStyle) Parameters Type Name Description string label The label. object option The option. ColorStyle valueStyle The color to display the value with View Source WriteLabelLine(string, object) Writes the label and the option that goes with it followed by a new line. Declaration public abstract void WriteLabelLine(string label, object option) Parameters Type Name Description string label The label. object option The option. View Source WriteLabelLine(string, object, ColorStyle) Writes the label and the option that goes with it followed by a new line. Declaration public abstract void WriteLabelLine(string label, object option, ColorStyle valueStyle) Parameters Type Name Description string label The label. object option The option. ColorStyle valueStyle The color to display the value with View Source WriteLine(ColorStyle, string) Writes the value with the specified style Declaration public abstract void WriteLine(ColorStyle style, string value) Parameters Type Name Description ColorStyle style The style. string value The value. Implements IDisposable IAsyncDisposable"
  },
  "api/NUnit.Common.OutputSpecification.html": {
    "href": "api/NUnit.Common.OutputSpecification.html",
    "title": "Class OutputSpecification | NUnit Docs",
    "summary": "Class OutputSpecification OutputSpecification encapsulates a file output path and format for use in saving the results of a run. Inheritance object OutputSpecification Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Common Assembly: nunitlite.dll Syntax public class OutputSpecification Constructors View Source OutputSpecification(string) Construct an OutputSpecification from an option value. Declaration public OutputSpecification(string spec) Parameters Type Name Description string spec The option value string. Properties View Source Format Gets the name of the format to be used Declaration public string Format { get; } Property Value Type Description string View Source OutputPath Gets the path to which output will be written Declaration public string OutputPath { get; } Property Value Type Description string"
  },
  "api/NUnit.Common.TestNameParser.html": {
    "href": "api/NUnit.Common.TestNameParser.html",
    "title": "Class TestNameParser | NUnit Docs",
    "summary": "Class TestNameParser TestNameParser is used to parse the arguments to the -run option, separating testnames at the correct point. Inheritance object TestNameParser Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Common Assembly: nunitlite.dll Syntax public static class TestNameParser Methods View Source Parse(string) Parse the -run argument and return an array of argument Declaration public static string[] Parse(string argument) Parameters Type Name Description string argument argument Returns Type Description string[]"
  },
  "api/NUnit.Common.TestSelectionParser.html": {
    "href": "api/NUnit.Common.TestSelectionParser.html",
    "title": "Class TestSelectionParser | NUnit Docs",
    "summary": "Class TestSelectionParser Inheritance object TestSelectionParser Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Common Assembly: nunitlite.dll Syntax public class TestSelectionParser Constructors View Source TestSelectionParser() Declaration public TestSelectionParser() Methods View Source Parse(string) Declaration public string Parse(string input) Parameters Type Name Description string input Returns Type Description string View Source ParseFilterElement() Parse a single filter element such as a category expression and return the xml representation of the filter. Declaration public string ParseFilterElement() Returns Type Description string View Source ParseFilterExpression() Parse a single term or an or expression, returning the XML Declaration public string ParseFilterExpression() Returns Type Description string View Source ParseFilterTerm() Parse a single element or an and expression and return the xml Declaration public string ParseFilterTerm() Returns Type Description string"
  },
  "api/NUnit.Common.TestSelectionParserException.html": {
    "href": "api/NUnit.Common.TestSelectionParserException.html",
    "title": "Class TestSelectionParserException | NUnit Docs",
    "summary": "Class TestSelectionParserException TestSelectionParserException is thrown when an error is found while parsing the selection expression. Inheritance object Exception TestSelectionParserException Implements ISerializable Inherited Members Exception.GetBaseException() Exception.ToString() Exception.GetType() Exception.TargetSite Exception.Message Exception.Data Exception.InnerException Exception.HelpLink Exception.Source Exception.HResult Exception.StackTrace Exception.SerializeObjectState object.MemberwiseClone() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Common Assembly: nunitlite.dll Syntax public class TestSelectionParserException : Exception, ISerializable Constructors View Source TestSelectionParserException(string) Construct with a message Declaration public TestSelectionParserException(string message) Parameters Type Name Description string message View Source TestSelectionParserException(string, Exception) Construct with a message and inner exception Declaration public TestSelectionParserException(string message, Exception innerException) Parameters Type Name Description string message Exception innerException Implements ISerializable"
  },
  "api/NUnit.Common.Token.html": {
    "href": "api/NUnit.Common.Token.html",
    "title": "Class Token | NUnit Docs",
    "summary": "Class Token Inheritance object Token Inherited Members object.GetType() object.MemberwiseClone() object.Equals(object, object) object.ReferenceEquals(object, object) Namespace: NUnit.Common Assembly: nunitlite.dll Syntax public class Token Constructors View Source Token(TokenKind) Declaration public Token(TokenKind kind) Parameters Type Name Description TokenKind kind View Source Token(TokenKind, char) Declaration public Token(TokenKind kind, char ch) Parameters Type Name Description TokenKind kind char ch View Source Token(TokenKind, string) Declaration public Token(TokenKind kind, string text) Parameters Type Name Description TokenKind kind string text Properties View Source Kind Declaration public TokenKind Kind { get; } Property Value Type Description TokenKind View Source Pos Declaration public int Pos { get; set; } Property Value Type Description int View Source Text Declaration public string Text { get; } Property Value Type Description string Methods View Source Equals(object) Declaration public override bool Equals(object obj) Parameters Type Name Description object obj Returns Type Description bool Overrides object.Equals(object) View Source GetHashCode() Declaration public override int GetHashCode() Returns Type Description int Overrides object.GetHashCode() View Source ToString() Declaration public override string ToString() Returns Type Description string Overrides object.ToString() Operators View Source operator ==(Token, Token) Declaration public static bool operator ==(Token t1, Token t2) Parameters Type Name Description Token t1 Token t2 Returns Type Description bool View Source operator !=(Token, Token) Declaration public static bool operator !=(Token t1, Token t2) Parameters Type Name Description Token t1 Token t2 Returns Type Description bool"
  },
  "api/NUnit.Common.TokenKind.html": {
    "href": "api/NUnit.Common.TokenKind.html",
    "title": "Enum TokenKind | NUnit Docs",
    "summary": "Enum TokenKind Namespace: NUnit.Common Assembly: nunitlite.dll Syntax public enum TokenKind Fields Name Description Eof String Symbol Word"
  },
  "api/NUnit.Common.Tokenizer.html": {
    "href": "api/NUnit.Common.Tokenizer.html",
    "title": "Class Tokenizer | NUnit Docs",
    "summary": "Class Tokenizer Tokenizer class performs lexical analysis for the TestSelectionParser. It recognizes a very limited set of tokens: words, symbols and quoted strings. This is sufficient for the simple DSL we use to select which tests to run. Inheritance object Tokenizer Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Common Assembly: nunitlite.dll Syntax public class Tokenizer Constructors View Source Tokenizer(string) Declaration public Tokenizer(string input) Parameters Type Name Description string input Properties View Source LookAhead Declaration public Token LookAhead { get; } Property Value Type Description Token Methods View Source NextToken() Declaration public Token NextToken() Returns Type Description Token"
  },
  "api/NUnit.Common.html": {
    "href": "api/NUnit.Common.html",
    "title": "Namespace NUnit.Common | NUnit Docs",
    "summary": "Namespace NUnit.Common Classes ColorConsole Sets the console color in the constructor and resets it in the dispose ColorConsoleWriter CommandLineOptions CommandLineOptions is the base class the specific option classes used for nunit3-console and nunitlite. It encapsulates all common settings and features of both. This is done to ensure that common features remain common and for the convenience of having the code in a common location. The class inherits from the Mono Options OptionSet class and provides a central location for defining and parsing options. ExtendedTextWrapper ExtendedTextWrapper wraps a TextWriter and makes it look like an ExtendedTextWriter. All style indications are ignored. It's used when text is being written to a file. ExtendedTextWriter ExtendedTextWriter extends the TextWriter abstract class to support displaying text in color. OutputSpecification OutputSpecification encapsulates a file output path and format for use in saving the results of a run. TestNameParser TestNameParser is used to parse the arguments to the -run option, separating testnames at the correct point. TestSelectionParser TestSelectionParserException TestSelectionParserException is thrown when an error is found while parsing the selection expression. Token Tokenizer Tokenizer class performs lexical analysis for the TestSelectionParser. It recognizes a very limited set of tokens: words, symbols and quoted strings. This is sufficient for the simple DSL we use to select which tests to run. Enums ColorStyle ColorStyle enumerates the various styles used in the console display TokenKind"
  },
  "api/NUnit.Compatibility.AttributeHelper.html": {
    "href": "api/NUnit.Compatibility.AttributeHelper.html",
    "title": "Class AttributeHelper | NUnit Docs",
    "summary": "Class AttributeHelper Provides a platform-independent methods for getting attributes for use by AttributeConstraint and AttributeExistsConstraint. Inheritance object AttributeHelper Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Compatibility Assembly: nunit.framework.dll Syntax public static class AttributeHelper Methods View Source GetCustomAttributes(object, Type, bool) Gets the custom attributes from the given object. Declaration public static Attribute[] GetCustomAttributes(object actual, Type attributeType, bool inherit) Parameters Type Name Description object actual The actual. Type attributeType Type of the attribute. bool inherit if set to true [inherit]. Returns Type Description Attribute[] A list of the given attribute on the given object."
  },
  "api/NUnit.Compatibility.LongLivedMarshalByRefObject.html": {
    "href": "api/NUnit.Compatibility.LongLivedMarshalByRefObject.html",
    "title": "Class LongLivedMarshalByRefObject | NUnit Docs",
    "summary": "Class LongLivedMarshalByRefObject A MarshalByRefObject that lives forever Inheritance object MarshalByRefObject LongLivedMarshalByRefObject FrameworkController FrameworkController.FrameworkControllerAction Inherited Members MarshalByRefObject.GetLifetimeService() MarshalByRefObject.MemberwiseClone(bool) object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Compatibility Assembly: nunit.framework.dll Syntax public class LongLivedMarshalByRefObject : MarshalByRefObject Constructors View Source LongLivedMarshalByRefObject() Declaration public LongLivedMarshalByRefObject() Methods View Source InitializeLifetimeService() Obtains a lifetime service object to control the lifetime policy for this instance. Declaration [Obsolete(\"Preventing throwing PlatformNotSupportedException\")] public override object InitializeLifetimeService() Returns Type Description object Overrides MarshalByRefObject.InitializeLifetimeService()"
  },
  "api/NUnit.Compatibility.html": {
    "href": "api/NUnit.Compatibility.html",
    "title": "Namespace NUnit.Compatibility | NUnit Docs",
    "summary": "Namespace NUnit.Compatibility Classes AttributeHelper Provides a platform-independent methods for getting attributes for use by AttributeConstraint and AttributeExistsConstraint. LongLivedMarshalByRefObject A MarshalByRefObject that lives forever"
  },
  "api/NUnit.Framework.ActionTargets.html": {
    "href": "api/NUnit.Framework.ActionTargets.html",
    "title": "Enum ActionTargets | NUnit Docs",
    "summary": "Enum ActionTargets The different targets a test action attribute can be applied to Namespace: NUnit.Framework Assembly: nunit.framework.dll Syntax [Flags] public enum ActionTargets Fields Name Description Default Default target, which is determined by where the action attribute is attached Suite Target a suite of test cases Test Target a individual test case"
  },
  "api/NUnit.Framework.ApartmentAttribute.html": {
    "href": "api/NUnit.Framework.ApartmentAttribute.html",
    "title": "Class ApartmentAttribute | NUnit Docs",
    "summary": "Class ApartmentAttribute Marks a test as needing to be run in a particular threading apartment state. This will cause it to run in a separate thread if necessary. Inheritance object Attribute NUnitAttribute PropertyAttribute ApartmentAttribute Implements IApplyToTest Inherited Members PropertyAttribute.ApplyToTest(Test) PropertyAttribute.Properties Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object, object) object.ReferenceEquals(object, object) Namespace: NUnit.Framework Assembly: nunit.framework.dll Syntax [AttributeUsage(AttributeTargets.Assembly|AttributeTargets.Class|AttributeTargets.Method, AllowMultiple = false, Inherited = true)] public class ApartmentAttribute : PropertyAttribute, IApplyToTest Constructors View Source ApartmentAttribute(ApartmentState) Construct an ApartmentAttribute Declaration public ApartmentAttribute(ApartmentState apartmentState) Parameters Type Name Description ApartmentState apartmentState The apartment state that this test must be run under. You must pass in a valid apartment state. Implements IApplyToTest"
  },
  "api/NUnit.Framework.Api.DefaultTestAssemblyBuilder.html": {
    "href": "api/NUnit.Framework.Api.DefaultTestAssemblyBuilder.html",
    "title": "Class DefaultTestAssemblyBuilder | NUnit Docs",
    "summary": "Class DefaultTestAssemblyBuilder DefaultTestAssemblyBuilder loads a single assembly and builds a TestSuite containing test fixtures present in the assembly. Inheritance object DefaultTestAssemblyBuilder Implements ITestAssemblyBuilder Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework.Api Assembly: nunit.framework.dll Syntax public class DefaultTestAssemblyBuilder : ITestAssemblyBuilder Constructors View Source DefaultTestAssemblyBuilder() Initializes a new instance of the DefaultTestAssemblyBuilder class. Declaration public DefaultTestAssemblyBuilder() Methods View Source Build(Assembly, IDictionary<string, object>) Build a suite of tests from a provided assembly Declaration public ITest Build(Assembly assembly, IDictionary<string, object> options) Parameters Type Name Description Assembly assembly The assembly from which tests are to be built IDictionary<string, object> options A dictionary of options to use in building the suite Returns Type Description ITest A TestSuite containing the tests found in the assembly View Source Build(string, IDictionary<string, object>) Build a suite of tests given the name or the location of an assembly Declaration public ITest Build(string assemblyNameOrPath, IDictionary<string, object> options) Parameters Type Name Description string assemblyNameOrPath The name or the location of the assembly. IDictionary<string, object> options A dictionary of options to use in building the suite Returns Type Description ITest A TestSuite containing the tests found in the assembly Implements ITestAssemblyBuilder"
  },
  "api/NUnit.Framework.Api.FrameworkController.CountTestsAction.html": {
    "href": "api/NUnit.Framework.Api.FrameworkController.CountTestsAction.html",
    "title": "Class FrameworkController.CountTestsAction | NUnit Docs",
    "summary": "Class FrameworkController.CountTestsAction CountTestsAction counts the number of test cases in the loaded TestSuite held by the FrameworkController. Inheritance object MarshalByRefObject LongLivedMarshalByRefObject FrameworkController.FrameworkControllerAction FrameworkController.CountTestsAction Inherited Members LongLivedMarshalByRefObject.InitializeLifetimeService() MarshalByRefObject.GetLifetimeService() MarshalByRefObject.MemberwiseClone(bool) object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework.Api Assembly: nunit.framework.dll Syntax public class FrameworkController.CountTestsAction : FrameworkController.FrameworkControllerAction Constructors View Source CountTestsAction(FrameworkController, string?, object) Construct a CountsTestAction and perform the count of test cases. Declaration public CountTestsAction(FrameworkController controller, string? filter, object handler) Parameters Type Name Description FrameworkController controller A FrameworkController holding the TestSuite whose cases are to be counted string filter A string containing the XML representation of the filter to use object handler A callback handler used to report results"
  },
  "api/NUnit.Framework.Api.FrameworkController.ExploreTestsAction.html": {
    "href": "api/NUnit.Framework.Api.FrameworkController.ExploreTestsAction.html",
    "title": "Class FrameworkController.ExploreTestsAction | NUnit Docs",
    "summary": "Class FrameworkController.ExploreTestsAction ExploreTestsAction returns info about the tests in an assembly Inheritance object MarshalByRefObject LongLivedMarshalByRefObject FrameworkController.FrameworkControllerAction FrameworkController.ExploreTestsAction Inherited Members LongLivedMarshalByRefObject.InitializeLifetimeService() MarshalByRefObject.GetLifetimeService() MarshalByRefObject.MemberwiseClone(bool) object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework.Api Assembly: nunit.framework.dll Syntax public class FrameworkController.ExploreTestsAction : FrameworkController.FrameworkControllerAction Constructors View Source ExploreTestsAction(FrameworkController, string?, object) Initializes a new instance of the FrameworkController.ExploreTestsAction class. Declaration public ExploreTestsAction(FrameworkController controller, string? filter, object handler) Parameters Type Name Description FrameworkController controller The controller for which this action is being performed. string filter Filter used to control which tests are included (NYI) object handler The callback handler."
  },
  "api/NUnit.Framework.Api.FrameworkController.FrameworkControllerAction.html": {
    "href": "api/NUnit.Framework.Api.FrameworkController.FrameworkControllerAction.html",
    "title": "Class FrameworkController.FrameworkControllerAction | NUnit Docs",
    "summary": "Class FrameworkController.FrameworkControllerAction FrameworkControllerAction is the base class for all actions performed against a FrameworkController. Inheritance object MarshalByRefObject LongLivedMarshalByRefObject FrameworkController.FrameworkControllerAction FrameworkController.CountTestsAction FrameworkController.ExploreTestsAction FrameworkController.LoadTestsAction FrameworkController.RunAsyncAction FrameworkController.RunTestsAction FrameworkController.StopRunAction Inherited Members LongLivedMarshalByRefObject.InitializeLifetimeService() MarshalByRefObject.GetLifetimeService() MarshalByRefObject.MemberwiseClone(bool) object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework.Api Assembly: nunit.framework.dll Syntax public abstract class FrameworkController.FrameworkControllerAction : LongLivedMarshalByRefObject Constructors View Source FrameworkControllerAction() Declaration protected FrameworkControllerAction()"
  },
  "api/NUnit.Framework.Api.FrameworkController.LoadTestsAction.html": {
    "href": "api/NUnit.Framework.Api.FrameworkController.LoadTestsAction.html",
    "title": "Class FrameworkController.LoadTestsAction | NUnit Docs",
    "summary": "Class FrameworkController.LoadTestsAction LoadTestsAction loads a test into the FrameworkController Inheritance object MarshalByRefObject LongLivedMarshalByRefObject FrameworkController.FrameworkControllerAction FrameworkController.LoadTestsAction Inherited Members LongLivedMarshalByRefObject.InitializeLifetimeService() MarshalByRefObject.GetLifetimeService() MarshalByRefObject.MemberwiseClone(bool) object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework.Api Assembly: nunit.framework.dll Syntax public class FrameworkController.LoadTestsAction : FrameworkController.FrameworkControllerAction Constructors View Source LoadTestsAction(FrameworkController, object) LoadTestsAction loads the tests in an assembly. Declaration public LoadTestsAction(FrameworkController controller, object handler) Parameters Type Name Description FrameworkController controller The controller. object handler The callback handler."
  },
  "api/NUnit.Framework.Api.FrameworkController.RunAsyncAction.html": {
    "href": "api/NUnit.Framework.Api.FrameworkController.RunAsyncAction.html",
    "title": "Class FrameworkController.RunAsyncAction | NUnit Docs",
    "summary": "Class FrameworkController.RunAsyncAction RunAsyncAction initiates an asynchronous test run, returning immediately Inheritance object MarshalByRefObject LongLivedMarshalByRefObject FrameworkController.FrameworkControllerAction FrameworkController.RunAsyncAction Inherited Members LongLivedMarshalByRefObject.InitializeLifetimeService() MarshalByRefObject.GetLifetimeService() MarshalByRefObject.MemberwiseClone(bool) object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework.Api Assembly: nunit.framework.dll Syntax public class FrameworkController.RunAsyncAction : FrameworkController.FrameworkControllerAction Constructors View Source RunAsyncAction(FrameworkController, string?, object) Construct a RunAsyncAction and run all tests in the loaded TestSuite. Declaration public RunAsyncAction(FrameworkController controller, string? filter, object handler) Parameters Type Name Description FrameworkController controller A FrameworkController holding the TestSuite to run string filter A string containing the XML representation of the filter to use object handler A callback handler used to report results"
  },
  "api/NUnit.Framework.Api.FrameworkController.RunTestsAction.html": {
    "href": "api/NUnit.Framework.Api.FrameworkController.RunTestsAction.html",
    "title": "Class FrameworkController.RunTestsAction | NUnit Docs",
    "summary": "Class FrameworkController.RunTestsAction RunTestsAction runs the loaded TestSuite held by the FrameworkController. Inheritance object MarshalByRefObject LongLivedMarshalByRefObject FrameworkController.FrameworkControllerAction FrameworkController.RunTestsAction Inherited Members LongLivedMarshalByRefObject.InitializeLifetimeService() MarshalByRefObject.GetLifetimeService() MarshalByRefObject.MemberwiseClone(bool) object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework.Api Assembly: nunit.framework.dll Syntax public class FrameworkController.RunTestsAction : FrameworkController.FrameworkControllerAction Constructors View Source RunTestsAction(FrameworkController, string?, object) Construct a RunTestsAction and run all tests in the loaded TestSuite. Declaration public RunTestsAction(FrameworkController controller, string? filter, object handler) Parameters Type Name Description FrameworkController controller A FrameworkController holding the TestSuite to run string filter A string containing the XML representation of the filter to use object handler A callback handler used to report results"
  },
  "api/NUnit.Framework.Api.FrameworkController.StopRunAction.html": {
    "href": "api/NUnit.Framework.Api.FrameworkController.StopRunAction.html",
    "title": "Class FrameworkController.StopRunAction | NUnit Docs",
    "summary": "Class FrameworkController.StopRunAction StopRunAction stops an ongoing run. Inheritance object MarshalByRefObject LongLivedMarshalByRefObject FrameworkController.FrameworkControllerAction FrameworkController.StopRunAction Inherited Members LongLivedMarshalByRefObject.InitializeLifetimeService() MarshalByRefObject.GetLifetimeService() MarshalByRefObject.MemberwiseClone(bool) object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework.Api Assembly: nunit.framework.dll Syntax public class FrameworkController.StopRunAction : FrameworkController.FrameworkControllerAction Constructors View Source StopRunAction(FrameworkController, bool, object) Construct a StopRunAction and stop any ongoing run. If no run is in process, no error is raised. Declaration public StopRunAction(FrameworkController controller, bool force, object handler) Parameters Type Name Description FrameworkController controller The FrameworkController for which a run is to be stopped. bool force True the stop should be forced, false for a cooperative stop. object handler A callback handler used to report results Remarks A forced stop will cause threads and processes to be killed as needed."
  },
  "api/NUnit.Framework.Api.FrameworkController.html": {
    "href": "api/NUnit.Framework.Api.FrameworkController.html",
    "title": "Class FrameworkController | NUnit Docs",
    "summary": "Class FrameworkController FrameworkController provides a facade for use in loading, browsing and running tests without requiring a reference to the NUnit framework. All calls are encapsulated in constructors for this class and its nested classes, which only require the types of the Common Type System as arguments. The controller supports four actions: Load, Explore, Count and Run. They are intended to be called by a driver, which should allow for proper sequencing of calls. Load must be called before any of the other actions. The driver may support other actions, such as reload on run, by combining these calls. Inheritance object MarshalByRefObject LongLivedMarshalByRefObject FrameworkController Inherited Members LongLivedMarshalByRefObject.InitializeLifetimeService() MarshalByRefObject.GetLifetimeService() MarshalByRefObject.MemberwiseClone(bool) object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework.Api Assembly: nunit.framework.dll Syntax public class FrameworkController : LongLivedMarshalByRefObject Constructors View Source FrameworkController(Assembly, string, IDictionary) Construct a FrameworkController using the default builder and runner. Declaration public FrameworkController(Assembly assembly, string idPrefix, IDictionary settings) Parameters Type Name Description Assembly assembly The test assembly string idPrefix A prefix used for all test ids created under this controller. IDictionary settings A Dictionary of settings to use in loading and running the tests View Source FrameworkController(Assembly, string, IDictionary, string, string) Construct a FrameworkController, specifying the types to be used for the runner and builder. This constructor is provided for purposes of development. Declaration public FrameworkController(Assembly assembly, string idPrefix, IDictionary settings, string runnerType, string builderType) Parameters Type Name Description Assembly assembly The test assembly string idPrefix A prefix used for all test ids created under this controller. IDictionary settings A Dictionary of settings to use in loading and running the tests string runnerType The Type of the test runner string builderType The Type of the test builder View Source FrameworkController(string, string?, IDictionary) Construct a FrameworkController using the default builder and runner. Declaration public FrameworkController(string assemblyNameOrPath, string? idPrefix, IDictionary settings) Parameters Type Name Description string assemblyNameOrPath The AssemblyName or path to the test assembly string idPrefix A prefix used for all test ids created under this controller. IDictionary settings A Dictionary of settings to use in loading and running the tests View Source FrameworkController(string, string?, IDictionary, string, string) Construct a FrameworkController, specifying the types to be used for the runner and builder. This constructor is provided for purposes of development. Declaration public FrameworkController(string assemblyNameOrPath, string? idPrefix, IDictionary settings, string runnerType, string builderType) Parameters Type Name Description string assemblyNameOrPath The full AssemblyName or the path to the test assembly string idPrefix A prefix used for all test ids created under this controller. IDictionary settings A Dictionary of settings to use in loading and running the tests string runnerType The Type of the test runner string builderType The Type of the test builder Properties View Source AssemblyNameOrPath Gets the AssemblyName or the path for which this FrameworkController was created Declaration public string AssemblyNameOrPath { get; } Property Value Type Description string View Source Builder Gets the ITestAssemblyBuilder used by this controller instance. Declaration public ITestAssemblyBuilder Builder { get; } Property Value Type Description ITestAssemblyBuilder The builder. View Source Runner Gets the ITestAssemblyRunner used by this controller instance. Declaration public ITestAssemblyRunner Runner { get; } Property Value Type Description ITestAssemblyRunner The runner. Methods View Source CountTests(string?) Counts the number of test cases in the loaded TestSuite Declaration public int CountTests(string? filter) Parameters Type Name Description string filter A string containing the XML representation of the filter to use Returns Type Description int The number of tests View Source ExploreTests(string?) Returns info about the tests in an assembly Declaration public string ExploreTests(string? filter) Parameters Type Name Description string filter A string containing the XML representation of the filter to use Returns Type Description string The XML result of exploring the tests View Source InsertEnvironmentElement(TNode) Inserts environment element Declaration public static TNode InsertEnvironmentElement(TNode targetNode) Parameters Type Name Description TNode targetNode Target node Returns Type Description TNode The new node View Source InsertSettingsElement(TNode, IDictionary<string, object>) Inserts settings element Declaration public static TNode InsertSettingsElement(TNode targetNode, IDictionary<string, object> settings) Parameters Type Name Description TNode targetNode Target node IDictionary<string, object> settings Settings dictionary Returns Type Description TNode The new node View Source LoadTests() Loads the tests in the assembly Declaration public string LoadTests() Returns Type Description string View Source RunTests(Action<string>, string) Runs the tests in an assembly synchronously reporting back the test results through the callback or through the return value Declaration public string RunTests(Action<string> callback, string filter) Parameters Type Name Description Action<string> callback The callback that receives the test results string filter A string containing the XML representation of the filter to use Returns Type Description string The XML result of the test run View Source RunTests(string?) Runs the tests in an assembly Declaration public string RunTests(string? filter) Parameters Type Name Description string filter A string containing the XML representation of the filter to use Returns Type Description string The XML result of the test run View Source StopRun(bool) Stops the test run Declaration public void StopRun(bool force) Parameters Type Name Description bool force True to force the stop, false for a cooperative stop"
  },
  "api/NUnit.Framework.Api.ITestAssemblyBuilder.html": {
    "href": "api/NUnit.Framework.Api.ITestAssemblyBuilder.html",
    "title": "Interface ITestAssemblyBuilder | NUnit Docs",
    "summary": "Interface ITestAssemblyBuilder The ITestAssemblyBuilder interface is implemented by a class that is able to build a suite of tests given an assembly or an assembly filename. Namespace: NUnit.Framework.Api Assembly: nunit.framework.dll Syntax public interface ITestAssemblyBuilder Methods View Source Build(Assembly, IDictionary<string, object>) Build a suite of tests from a provided assembly Declaration ITest Build(Assembly assembly, IDictionary<string, object> options) Parameters Type Name Description Assembly assembly The assembly from which tests are to be built IDictionary<string, object> options A dictionary of options to use in building the suite Returns Type Description ITest A TestSuite containing the tests found in the assembly View Source Build(string, IDictionary<string, object>) Build a suite of tests given the filename of an assembly Declaration ITest Build(string assemblyName, IDictionary<string, object> options) Parameters Type Name Description string assemblyName The filename of the assembly from which tests are to be built IDictionary<string, object> options A dictionary of options to use in building the suite Returns Type Description ITest A TestSuite containing the tests found in the assembly"
  },
  "api/NUnit.Framework.Api.ITestAssemblyRunner.html": {
    "href": "api/NUnit.Framework.Api.ITestAssemblyRunner.html",
    "title": "Interface ITestAssemblyRunner | NUnit Docs",
    "summary": "Interface ITestAssemblyRunner The ITestAssemblyRunner interface is implemented by classes that are able to execute a suite of tests loaded from an assembly. Namespace: NUnit.Framework.Api Assembly: nunit.framework.dll Syntax public interface ITestAssemblyRunner Properties View Source IsTestComplete Indicates whether a test run is complete Declaration bool IsTestComplete { get; } Property Value Type Description bool View Source IsTestLoaded Indicates whether a test has been loaded Declaration bool IsTestLoaded { get; } Property Value Type Description bool View Source IsTestRunning Indicates whether a test is currently running Declaration bool IsTestRunning { get; } Property Value Type Description bool View Source LoadedTest Gets the tree of loaded tests, or null if no tests have been loaded. Declaration ITest? LoadedTest { get; } Property Value Type Description ITest View Source Result Gets the tree of test results, if the test run is completed, otherwise null. Declaration ITestResult? Result { get; } Property Value Type Description ITestResult Methods View Source CountTestCases(ITestFilter) Count Test Cases using a filter Declaration int CountTestCases(ITestFilter filter) Parameters Type Name Description ITestFilter filter The filter to apply Returns Type Description int The number of test cases found View Source ExploreTests(ITestFilter) Explore the test cases using a filter Declaration ITest ExploreTests(ITestFilter filter) Parameters Type Name Description ITestFilter filter The filter to apply Returns Type Description ITest Test Assembly with test cases that matches the filter View Source Load(Assembly, IDictionary<string, object>) Loads the tests found in an Assembly, returning an indication of whether or not the load succeeded. Declaration ITest Load(Assembly assembly, IDictionary<string, object> settings) Parameters Type Name Description Assembly assembly The assembly to load IDictionary<string, object> settings Dictionary of options to use in loading the test Returns Type Description ITest An ITest representing the loaded tests View Source Load(string, IDictionary<string, object>) Loads the tests found in an Assembly, returning an indication of whether or not the load succeeded. Declaration ITest Load(string assemblyName, IDictionary<string, object> settings) Parameters Type Name Description string assemblyName File name of the assembly to load IDictionary<string, object> settings Dictionary of options to use in loading the test Returns Type Description ITest An ITest representing the loaded tests View Source Run(ITestListener, ITestFilter) Run selected tests and return a test result. The test is run synchronously, and the listener interface is notified as it progresses. Declaration ITestResult Run(ITestListener listener, ITestFilter filter) Parameters Type Name Description ITestListener listener Interface to receive ITestListener notifications. ITestFilter filter A test filter used to select tests to be run Returns Type Description ITestResult View Source RunAsync(ITestListener, ITestFilter) Run selected tests asynchronously, notifying the listener interface as it progresses. Declaration void RunAsync(ITestListener listener, ITestFilter filter) Parameters Type Name Description ITestListener listener Interface to receive EventListener notifications. ITestFilter filter A test filter used to select tests to be run View Source StopRun(bool) Signal any test run that is in process to stop. Return without error if no test is running. Declaration void StopRun(bool force) Parameters Type Name Description bool force If true, kill any test-running threads View Source WaitForCompletion(int) Wait for the ongoing run to complete. Declaration bool WaitForCompletion(int timeout) Parameters Type Name Description int timeout Time to wait in milliseconds Returns Type Description bool True if the run completed, otherwise false"
  },
  "api/NUnit.Framework.Api.NUnitTestAssemblyRunner.html": {
    "href": "api/NUnit.Framework.Api.NUnitTestAssemblyRunner.html",
    "title": "Class NUnitTestAssemblyRunner | NUnit Docs",
    "summary": "Class NUnitTestAssemblyRunner Implementation of ITestAssemblyRunner Inheritance object NUnitTestAssemblyRunner Implements ITestAssemblyRunner Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework.Api Assembly: nunit.framework.dll Syntax public class NUnitTestAssemblyRunner : ITestAssemblyRunner Constructors View Source NUnitTestAssemblyRunner(ITestAssemblyBuilder) Initializes a new instance of the NUnitTestAssemblyRunner class. Declaration public NUnitTestAssemblyRunner(ITestAssemblyBuilder builder) Parameters Type Name Description ITestAssemblyBuilder builder The builder. Properties View Source DefaultLevelOfParallelism Gets the default level of parallel execution (worker threads) Declaration public static int DefaultLevelOfParallelism { get; } Property Value Type Description int View Source IsTestComplete Indicates whether a test run is complete Declaration public bool IsTestComplete { get; } Property Value Type Description bool View Source IsTestLoaded Indicates whether a test is loaded Declaration public bool IsTestLoaded { get; } Property Value Type Description bool View Source IsTestRunning Indicates whether a test is running Declaration public bool IsTestRunning { get; } Property Value Type Description bool View Source LoadedTest The tree of tests that was loaded by the builder Declaration public ITest? LoadedTest { get; } Property Value Type Description ITest View Source Result The test result, if a run has completed Declaration public ITestResult? Result { get; } Property Value Type Description ITestResult Methods View Source CountTestCases(ITestFilter) Count Test Cases using a filter Declaration public int CountTestCases(ITestFilter filter) Parameters Type Name Description ITestFilter filter The filter to apply Returns Type Description int The number of test cases found View Source ExploreTests(ITestFilter) Explore the test cases using a filter Declaration public ITest ExploreTests(ITestFilter filter) Parameters Type Name Description ITestFilter filter The filter to apply Returns Type Description ITest Test Assembly with test cases that matches the filter View Source Load(Assembly, IDictionary<string, object>) Loads the tests found in an Assembly Declaration public ITest Load(Assembly assembly, IDictionary<string, object> settings) Parameters Type Name Description Assembly assembly The assembly to load IDictionary<string, object> settings Dictionary of option settings for loading the assembly Returns Type Description ITest A Test Assembly containing all loaded tests View Source Load(string, IDictionary<string, object>) Loads the tests found in an Assembly Declaration public ITest Load(string assemblyNameOrPath, IDictionary<string, object> settings) Parameters Type Name Description string assemblyNameOrPath File name or path of the assembly to load IDictionary<string, object> settings Dictionary of option settings for loading the assembly Returns Type Description ITest A Test Assembly containing all loaded tests View Source Run(ITestListener, ITestFilter) Run selected tests and return a test result. The test is run synchronously, and the listener interface is notified as it progresses. Declaration public ITestResult Run(ITestListener listener, ITestFilter filter) Parameters Type Name Description ITestListener listener Interface to receive EventListener notifications. ITestFilter filter A test filter used to select tests to be run Returns Type Description ITestResult The test results from the run View Source RunAsync(ITestListener, ITestFilter) Run selected tests asynchronously, notifying the listener interface as it progresses. Declaration public void RunAsync(ITestListener listener, ITestFilter filter) Parameters Type Name Description ITestListener listener Interface to receive EventListener notifications. ITestFilter filter A test filter used to select tests to be run Remarks RunAsync is a template method, calling various abstract and virtual methods to be overridden by derived classes. View Source StopRun(bool) Signal any test run that is in process to stop. Return without error if no test is running. Declaration public void StopRun(bool force) Parameters Type Name Description bool force If true, kill any tests that are currently running View Source WaitForCompletion(int) Wait for the ongoing run to complete. Declaration public bool WaitForCompletion(int timeout) Parameters Type Name Description int timeout Time to wait in milliseconds Returns Type Description bool True if the run completed, otherwise false View Source WrapInNUnitCallContext(Action) This method is a no-op in .NET Standard builds. Declaration protected void WrapInNUnitCallContext(Action action) Parameters Type Name Description Action action View Source WrapInNUnitCallContext<T>(Func<T>) This method is a no-op in .NET Standard builds. Declaration protected T WrapInNUnitCallContext<T>(Func<T> function) Parameters Type Name Description Func<T> function Returns Type Description T Type Parameters Name Description T Implements ITestAssemblyRunner"
  },
  "api/NUnit.Framework.Api.html": {
    "href": "api/NUnit.Framework.Api.html",
    "title": "Namespace NUnit.Framework.Api | NUnit Docs",
    "summary": "Namespace NUnit.Framework.Api Classes DefaultTestAssemblyBuilder DefaultTestAssemblyBuilder loads a single assembly and builds a TestSuite containing test fixtures present in the assembly. FrameworkController FrameworkController provides a facade for use in loading, browsing and running tests without requiring a reference to the NUnit framework. All calls are encapsulated in constructors for this class and its nested classes, which only require the types of the Common Type System as arguments. The controller supports four actions: Load, Explore, Count and Run. They are intended to be called by a driver, which should allow for proper sequencing of calls. Load must be called before any of the other actions. The driver may support other actions, such as reload on run, by combining these calls. FrameworkController.CountTestsAction CountTestsAction counts the number of test cases in the loaded TestSuite held by the FrameworkController. FrameworkController.ExploreTestsAction ExploreTestsAction returns info about the tests in an assembly FrameworkController.FrameworkControllerAction FrameworkControllerAction is the base class for all actions performed against a FrameworkController. FrameworkController.LoadTestsAction LoadTestsAction loads a test into the FrameworkController FrameworkController.RunAsyncAction RunAsyncAction initiates an asynchronous test run, returning immediately FrameworkController.RunTestsAction RunTestsAction runs the loaded TestSuite held by the FrameworkController. FrameworkController.StopRunAction StopRunAction stops an ongoing run. NUnitTestAssemblyRunner Implementation of ITestAssemblyRunner Interfaces ITestAssemblyBuilder The ITestAssemblyBuilder interface is implemented by a class that is able to build a suite of tests given an assembly or an assembly filename. ITestAssemblyRunner The ITestAssemblyRunner interface is implemented by classes that are able to execute a suite of tests loaded from an assembly."
  },
  "api/NUnit.Framework.Assert.html": {
    "href": "api/NUnit.Framework.Assert.html",
    "title": "Class Assert | NUnit Docs",
    "summary": "Class Assert The Assert class contains a collection of static methods that implement the most common assertions used in NUnit. Inheritance object AssertBase Assert ClassicAssert Inherited Members AssertBase.ConvertMessageWithArgs(string, object[]) object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework Assembly: nunit.framework.dll Syntax public abstract class Assert : AssertBase Constructors View Source Assert() Declaration protected Assert() Methods View Source ByVal(object?, IResolveConstraint, string, string, string) Apply a constraint to an actual value. Returns without throwing an exception when inside a multiple assert block. Used as a synonym for That in rare cases where a private setter causes a Visual Basic compilation error. Declaration public static void ByVal(object? actual, IResolveConstraint expression, string message = \"\", string actualExpression = \"\", string constraintExpression = \"\") Parameters Type Name Description object actual The actual value to test IResolveConstraint expression A Constraint expression to be applied string message The message that will be displayed on failure string actualExpression string constraintExpression Remarks This method is provided for use by VB developers needing to test the value of properties with private setters. View Source Catch(TestDelegate) Verifies that a delegate throws an exception when called and returns it. The returned exception may be null when inside a multiple assert block. Declaration public static Exception? Catch(TestDelegate code) Parameters Type Name Description TestDelegate code A TestDelegate Returns Type Description Exception View Source Catch(TestDelegate, string, params object?[]?) Verifies that a delegate throws an exception when called and returns it. The returned exception may be null when inside a multiple assert block. Declaration public static Exception? Catch(TestDelegate code, string message, params object?[]? args) Parameters Type Name Description TestDelegate code A TestDelegate string message The message that will be displayed on failure object[] args Arguments to be used in formatting the message Returns Type Description Exception View Source Catch(Type, TestDelegate) Verifies that a delegate throws an exception of a certain Type or one derived from it when called and returns it. The returned exception may be null when inside a multiple assert block. Declaration public static Exception? Catch(Type expectedExceptionType, TestDelegate code) Parameters Type Name Description Type expectedExceptionType The expected Exception Type TestDelegate code A TestDelegate Returns Type Description Exception View Source Catch(Type, TestDelegate, string, params object?[]?) Verifies that a delegate throws an exception of a certain Type or one derived from it when called and returns it. The returned exception may be null when inside a multiple assert block. Declaration public static Exception? Catch(Type expectedExceptionType, TestDelegate code, string message, params object?[]? args) Parameters Type Name Description Type expectedExceptionType The expected Exception Type TestDelegate code A TestDelegate string message The message that will be displayed on failure object[] args Arguments to be used in formatting the message Returns Type Description Exception View Source CatchAsync(AsyncTestDelegate) Verifies that an async delegate throws an exception when called and returns it. The returned exception may be null when inside a multiple assert block. Declaration public static Exception? CatchAsync(AsyncTestDelegate code) Parameters Type Name Description AsyncTestDelegate code A TestDelegate Returns Type Description Exception View Source CatchAsync(AsyncTestDelegate, string, params object?[]?) Verifies that an async delegate throws an exception when called and returns it. The returned exception may be null when inside a multiple assert block. Declaration public static Exception? CatchAsync(AsyncTestDelegate code, string message, params object?[]? args) Parameters Type Name Description AsyncTestDelegate code A TestDelegate string message The message that will be displayed on failure object[] args Arguments to be used in formatting the message Returns Type Description Exception View Source CatchAsync(Type, AsyncTestDelegate) Verifies that an async delegate throws an exception of a certain Type or one derived from it when called and returns it. The returned exception may be null when inside a multiple assert block. Declaration public static Exception? CatchAsync(Type expectedExceptionType, AsyncTestDelegate code) Parameters Type Name Description Type expectedExceptionType The expected Exception Type AsyncTestDelegate code A TestDelegate Returns Type Description Exception View Source CatchAsync(Type, AsyncTestDelegate, string, params object?[]?) Verifies that an async delegate throws an exception of a certain Type or one derived from it when called and returns it. The returned exception may be null when inside a multiple assert block. Declaration public static Exception? CatchAsync(Type expectedExceptionType, AsyncTestDelegate code, string message, params object?[]? args) Parameters Type Name Description Type expectedExceptionType The expected Exception Type AsyncTestDelegate code A TestDelegate string message The message that will be displayed on failure object[] args Arguments to be used in formatting the message Returns Type Description Exception View Source CatchAsync<TActual>(AsyncTestDelegate) Verifies that an async delegate throws an exception of a certain Type or one derived from it when called and returns it. The returned exception may be null when inside a multiple assert block. Declaration public static TActual? CatchAsync<TActual>(AsyncTestDelegate code) where TActual : Exception Parameters Type Name Description AsyncTestDelegate code A TestDelegate Returns Type Description TActual Type Parameters Name Description TActual View Source CatchAsync<TActual>(AsyncTestDelegate, string, params object?[]?) Verifies that an async delegate throws an exception of a certain Type or one derived from it when called and returns it. The returned exception may be null when inside a multiple assert block. Declaration public static TActual? CatchAsync<TActual>(AsyncTestDelegate code, string message, params object?[]? args) where TActual : Exception Parameters Type Name Description AsyncTestDelegate code A TestDelegate string message The message that will be displayed on failure object[] args Arguments to be used in formatting the message Returns Type Description TActual Type Parameters Name Description TActual View Source Catch<TActual>(TestDelegate) Verifies that a delegate throws an exception of a certain Type or one derived from it when called and returns it. The returned exception may be null when inside a multiple assert block. Declaration public static TActual? Catch<TActual>(TestDelegate code) where TActual : Exception Parameters Type Name Description TestDelegate code A TestDelegate Returns Type Description TActual Type Parameters Name Description TActual View Source Catch<TActual>(TestDelegate, string, params object?[]?) Verifies that a delegate throws an exception of a certain Type or one derived from it when called and returns it. The returned exception may be null when inside a multiple assert block. Declaration public static TActual? Catch<TActual>(TestDelegate code, string message, params object?[]? args) where TActual : Exception Parameters Type Name Description TestDelegate code A TestDelegate string message The message that will be displayed on failure object[] args Arguments to be used in formatting the message Returns Type Description TActual Type Parameters Name Description TActual View Source Charlie() An alias of the corresponding Assert.Pass() method. Charlie Poole was the lead of NUnit for 21 years, across at least 207 releases in 37 different repositories, authoring 4,898 commits across them. He participated in 2,990 issues, 1,305 PRs, and impacted 6,992,983 lines of code. NUnit was downloaded from NuGet 225+ million times during his tenure. And those are only the numbers ones we can easily find; our numbers are sourced from after NUnit moved the project to GitHub in 2011, which means there are at least 9 additional years of work not quantified above. This assertion attempts to pay homage to Charlie, who by virtue of his contributions has helped untold millions of tests pass. Declaration public static void Charlie() View Source DoesNotThrow(TestDelegate) Verifies that a delegate does not throw an exception. Declaration public static void DoesNotThrow(TestDelegate code) Parameters Type Name Description TestDelegate code A TestDelegate View Source DoesNotThrow(TestDelegate, string, params object?[]?) Verifies that a delegate does not throw an exception Declaration public static void DoesNotThrow(TestDelegate code, string message, params object?[]? args) Parameters Type Name Description TestDelegate code A TestDelegate string message The message that will be displayed on failure object[] args Arguments to be used in formatting the message View Source DoesNotThrowAsync(AsyncTestDelegate) Verifies that an async delegate does not throw an exception. Declaration public static void DoesNotThrowAsync(AsyncTestDelegate code) Parameters Type Name Description AsyncTestDelegate code A TestDelegate View Source DoesNotThrowAsync(AsyncTestDelegate, string, params object?[]?) Verifies that an async delegate does not throw an exception Declaration public static void DoesNotThrowAsync(AsyncTestDelegate code, string message, params object?[]? args) Parameters Type Name Description AsyncTestDelegate code A TestDelegate string message The message that will be displayed on failure object[] args Arguments to be used in formatting the message View Source EnterMultipleScope() Enters a multiple assert scope. Wraps code containing a series of assertions, which should all be executed, even if they fail. Failed results are saved and reported when the returned IDisposable is disposed. Declaration public static IDisposable EnterMultipleScope() Returns Type Description IDisposable An IDisposable which when disposed leaves the multiple assertion scope. View Source Fail() Marks the test as failed. Returns without throwing an exception when inside a multiple assert block. Declaration public static void Fail() View Source Fail(string) Marks the test as failed with the message and arguments that are passed in. Returns without throwing an exception when inside a multiple assert block. Declaration public static void Fail(string message) Parameters Type Name Description string message The message to initialize the AssertionException with. View Source Ignore() Throws an IgnoreException. This causes the test to be reported as ignored. Declaration public static void Ignore() View Source Ignore(string) Throws an IgnoreException with the message and arguments that are passed in. This causes the test to be reported as ignored. Declaration public static void Ignore(string message) Parameters Type Name Description string message The message to initialize the AssertionException with. View Source Inconclusive() Throws an InconclusiveException. This causes the test to be reported as Inconclusive. Declaration public static void Inconclusive() View Source Inconclusive(string) Throws an InconclusiveException with the message and arguments that are passed in. This causes the test to be reported as inconclusive. Declaration public static void Inconclusive(string message) Parameters Type Name Description string message The message to initialize the InconclusiveException with. View Source Multiple(AsyncTestDelegate) Wraps code containing a series of assertions, which should all be executed, even if they fail. Failed results are saved and reported at the end of the code block. Declaration public static void Multiple(AsyncTestDelegate testDelegate) Parameters Type Name Description AsyncTestDelegate testDelegate A TestDelegate to be executed in Multiple Assertion mode. View Source Multiple(TestDelegate) Wraps code containing a series of assertions, which should all be executed, even if they fail. Failed results are saved and reported at the end of the code block. Declaration public static void Multiple(TestDelegate testDelegate) Parameters Type Name Description TestDelegate testDelegate A TestDelegate to be executed in Multiple Assertion mode. View Source MultipleAsync(AsyncTestDelegate) Wraps code containing a series of assertions, which should all be executed, even if they fail. Failed results are saved and reported at the end of the code block. Declaration public static Task MultipleAsync(AsyncTestDelegate testDelegate) Parameters Type Name Description AsyncTestDelegate testDelegate An AsyncTestDelegate to be executed in Multiple Assertion mode. Returns Type Description Task View Source Pass() Throws a SuccessException with the message and arguments that are passed in. This allows a test to be cut short, with a result of success returned to NUnit. Declaration public static void Pass() View Source Pass(string) Throws a SuccessException with the message and arguments that are passed in. This allows a test to be cut short, with a result of success returned to NUnit. Declaration public static void Pass(string message) Parameters Type Name Description string message The message to initialize the AssertionException with. View Source That(TestDelegate, IResolveConstraint, NUnitString, string, string) Apply a constraint to a delegate. Returns without throwing an exception when inside a multiple assert block. Declaration public static void That(TestDelegate code, IResolveConstraint constraint, NUnitString message = default, string actualExpression = \"\", string constraintExpression = \"\") Parameters Type Name Description TestDelegate code A TestDelegate to be executed IResolveConstraint constraint A Constraint expression to be applied NUnitString message The message that will be displayed on failure string actualExpression string constraintExpression View Source That(TestDelegate, IResolveConstraint, FormattableString, string, string) Apply a constraint to a delegate. Returns without throwing an exception when inside a multiple assert block. Declaration public static void That(TestDelegate code, IResolveConstraint constraint, FormattableString message, string actualExpression = \"\", string constraintExpression = \"\") Parameters Type Name Description TestDelegate code A TestDelegate to be executed IResolveConstraint constraint A Constraint expression to be applied FormattableString message The message that will be displayed on failure string actualExpression string constraintExpression View Source That(TestDelegate, IResolveConstraint, Func<string>, string, string) Apply a constraint to a delegate. Returns without throwing an exception when inside a multiple assert block. Declaration public static void That(TestDelegate code, IResolveConstraint constraint, Func<string> getExceptionMessage, string actualExpression = \"\", string constraintExpression = \"\") Parameters Type Name Description TestDelegate code A TestDelegate to be executed IResolveConstraint constraint A Constraint expression to be applied Func<string> getExceptionMessage A function to build the message included with the Exception string actualExpression string constraintExpression View Source That(bool, NUnitString, string) Asserts that a condition is true. Returns without throwing an exception when inside a multiple assert block. Declaration public static void That(bool condition, NUnitString message = default, string actualExpression = \"\") Parameters Type Name Description bool condition The evaluated condition NUnitString message The message to display if the condition is false string actualExpression View Source That(bool, FormattableString, string) Asserts that a condition is true. Returns without throwing an exception when inside a multiple assert block. Declaration public static void That(bool condition, FormattableString message, string actualExpression = \"\") Parameters Type Name Description bool condition The evaluated condition FormattableString message The message to display if the condition is false string actualExpression View Source That(bool, Func<string>, string) Asserts that a condition is true. Returns without throwing an exception when inside a multiple assert block. Declaration public static void That(bool condition, Func<string> getExceptionMessage, string actualExpression = \"\") Parameters Type Name Description bool condition The evaluated condition Func<string> getExceptionMessage A function to build the message included with the Exception string actualExpression View Source That(Func<bool>, NUnitString, string) Asserts that a condition is true. Returns without throwing an exception when inside a multiple assert block. Declaration public static void That(Func<bool> condition, NUnitString message = default, string actualExpression = \"\") Parameters Type Name Description Func<bool> condition A lambda that returns a Boolean NUnitString message The message to display if the condition is false string actualExpression View Source That(Func<bool>, FormattableString, string) Asserts that a condition is true. Returns without throwing an exception when inside a multiple assert block. Declaration public static void That(Func<bool> condition, FormattableString message, string actualExpression = \"\") Parameters Type Name Description Func<bool> condition A lambda that returns a Boolean FormattableString message The message to display if the condition is false string actualExpression View Source That(Func<bool>, Func<string>, string) Asserts that a condition is true. Returns without throwing an exception when inside a multiple assert block. Declaration public static void That(Func<bool> condition, Func<string> getExceptionMessage, string actualExpression = \"\") Parameters Type Name Description Func<bool> condition A lambda that returns a Boolean Func<string> getExceptionMessage A function to build the message included with the Exception string actualExpression View Source ThatAsync(AsyncTestDelegate, IResolveConstraint, NUnitString, string, string) Apply a constraint to an async delegate. Returns without throwing an exception when inside a multiple assert block. Declaration public static Task ThatAsync(AsyncTestDelegate code, IResolveConstraint constraint, NUnitString message = default, string actualExpression = \"\", string constraintExpression = \"\") Parameters Type Name Description AsyncTestDelegate code An AsyncTestDelegate to be executed IResolveConstraint constraint A Constraint expression to be applied NUnitString message The message that will be displayed on failure string actualExpression string constraintExpression Returns Type Description Task Awaitable. View Source ThatAsync(AsyncTestDelegate, IResolveConstraint, FormattableString, string, string) Apply a constraint to an async delegate. Returns without throwing an exception when inside a multiple assert block. Declaration public static Task ThatAsync(AsyncTestDelegate code, IResolveConstraint constraint, FormattableString message, string actualExpression = \"\", string constraintExpression = \"\") Parameters Type Name Description AsyncTestDelegate code An AsyncTestDelegate to be executed IResolveConstraint constraint A Constraint expression to be applied FormattableString message The message that will be displayed on failure string actualExpression string constraintExpression Returns Type Description Task Awaitable. View Source ThatAsync<T>(Func<Task<T>>, IResolveConstraint, NUnitString, string, string) Apply a constraint to an async delegate. Returns without throwing an exception when inside a multiple assert block. Declaration public static Task ThatAsync<T>(Func<Task<T>> code, IResolveConstraint constraint, NUnitString message = default, string actualExpression = \"\", string constraintExpression = \"\") Parameters Type Name Description Func<Task<T>> code An async method to be executed IResolveConstraint constraint A Constraint expression to be applied NUnitString message The message that will be displayed on failure string actualExpression string constraintExpression Returns Type Description Task Awaitable. Type Parameters Name Description T View Source ThatAsync<T>(Func<Task<T>>, IResolveConstraint, FormattableString, string, string) Apply a constraint to an async delegate. Returns without throwing an exception when inside a multiple assert block. Declaration public static Task ThatAsync<T>(Func<Task<T>> code, IResolveConstraint constraint, FormattableString message, string actualExpression = \"\", string constraintExpression = \"\") Parameters Type Name Description Func<Task<T>> code An async method to be executed IResolveConstraint constraint A Constraint expression to be applied FormattableString message The message that will be displayed on failure string actualExpression string constraintExpression Returns Type Description Task Awaitable. Type Parameters Name Description T View Source That<TActual>(ActualValueDelegate<TActual>, IResolveConstraint, NUnitString, string, string) Apply a constraint to a delegate. Returns without throwing an exception when inside a multiple assert block. Declaration public static void That<TActual>(ActualValueDelegate<TActual> del, IResolveConstraint expr, NUnitString message = default, string actualExpression = \"\", string constraintExpression = \"\") Parameters Type Name Description ActualValueDelegate<TActual> del An ActualValueDelegate returning the value to be tested IResolveConstraint expr A Constraint expression to be applied NUnitString message The message that will be displayed on failure string actualExpression string constraintExpression Type Parameters Name Description TActual The Type being compared. View Source That<TActual>(ActualValueDelegate<TActual>, IResolveConstraint, FormattableString, string, string) Apply a constraint to a delegate. Returns without throwing an exception when inside a multiple assert block. Declaration public static void That<TActual>(ActualValueDelegate<TActual> del, IResolveConstraint expr, FormattableString message, string actualExpression = \"\", string constraintExpression = \"\") Parameters Type Name Description ActualValueDelegate<TActual> del An ActualValueDelegate returning the value to be tested IResolveConstraint expr A Constraint expression to be applied FormattableString message The message that will be displayed on failure string actualExpression string constraintExpression Type Parameters Name Description TActual The Type being compared. View Source That<TActual>(ActualValueDelegate<TActual>, IResolveConstraint, Func<string>, string, string) Apply a constraint to a delegate. Returns without throwing an exception when inside a multiple assert block. Declaration public static void That<TActual>(ActualValueDelegate<TActual> del, IResolveConstraint expr, Func<string> getExceptionMessage, string actualExpression = \"\", string constraintExpression = \"\") Parameters Type Name Description ActualValueDelegate<TActual> del An ActualValueDelegate returning the value to be tested IResolveConstraint expr A Constraint expression to be applied Func<string> getExceptionMessage A function to build the message included with the Exception string actualExpression string constraintExpression Type Parameters Name Description TActual The Type being compared. View Source That<TActual>(TActual, IResolveConstraint, NUnitString, string, string) Apply a constraint to an actual value. Returns without throwing an exception when inside a multiple assert block. Declaration public static void That<TActual>(TActual actual, IResolveConstraint expression, NUnitString message = default, string actualExpression = \"\", string constraintExpression = \"\") Parameters Type Name Description TActual actual The actual value to test IResolveConstraint expression A Constraint expression to be applied NUnitString message The message that will be displayed on failure string actualExpression string constraintExpression Type Parameters Name Description TActual The Type being compared. View Source That<TActual>(TActual, IResolveConstraint, FormattableString, string, string) Apply a constraint to an actual value. Returns without throwing an exception when inside a multiple assert block. Declaration public static void That<TActual>(TActual actual, IResolveConstraint expression, FormattableString message, string actualExpression = \"\", string constraintExpression = \"\") Parameters Type Name Description TActual actual The actual value to test IResolveConstraint expression A Constraint expression to be applied FormattableString message The message that will be displayed on failure string actualExpression string constraintExpression Type Parameters Name Description TActual The Type being compared. View Source That<TActual>(TActual, IResolveConstraint, Func<string>, string, string) Apply a constraint to an actual value. Returns without throwing an exception when inside a multiple assert block. Declaration public static void That<TActual>(TActual actual, IResolveConstraint expression, Func<string> getExceptionMessage, string actualExpression = \"\", string constraintExpression = \"\") Parameters Type Name Description TActual actual The actual value to test IResolveConstraint expression A Constraint expression to be applied Func<string> getExceptionMessage A function to build the message included with the Exception string actualExpression string constraintExpression Type Parameters Name Description TActual The Type being compared. View Source Throws(IResolveConstraint, TestDelegate) Verifies that a delegate throws a particular exception when called. The returned exception may be null when inside a multiple assert block. Declaration public static Exception? Throws(IResolveConstraint expression, TestDelegate code) Parameters Type Name Description IResolveConstraint expression A constraint to be satisfied by the exception TestDelegate code A TestSnippet delegate Returns Type Description Exception View Source Throws(IResolveConstraint, TestDelegate, string, params object?[]?) Verifies that a delegate throws a particular exception when called. The returned exception may be null when inside a multiple assert block. Declaration public static Exception? Throws(IResolveConstraint expression, TestDelegate code, string message, params object?[]? args) Parameters Type Name Description IResolveConstraint expression A constraint to be satisfied by the exception TestDelegate code A TestSnippet delegate string message The message that will be displayed on failure object[] args Arguments to be used in formatting the message Returns Type Description Exception View Source Throws(Type, TestDelegate) Verifies that a delegate throws a particular exception when called. The returned exception may be null when inside a multiple assert block. Declaration public static Exception? Throws(Type expectedExceptionType, TestDelegate code) Parameters Type Name Description Type expectedExceptionType The exception Type expected TestDelegate code A TestDelegate Returns Type Description Exception View Source Throws(Type, TestDelegate, string, params object?[]?) Verifies that a delegate throws a particular exception when called. The returned exception may be null when inside a multiple assert block. Declaration public static Exception? Throws(Type expectedExceptionType, TestDelegate code, string message, params object?[]? args) Parameters Type Name Description Type expectedExceptionType The exception Type expected TestDelegate code A TestDelegate string message The message that will be displayed on failure object[] args Arguments to be used in formatting the message Returns Type Description Exception View Source ThrowsAsync(IResolveConstraint, AsyncTestDelegate) Verifies that an async delegate throws a particular exception when called. The returned exception may be null when inside a multiple assert block. Declaration public static Exception? ThrowsAsync(IResolveConstraint expression, AsyncTestDelegate code) Parameters Type Name Description IResolveConstraint expression A constraint to be satisfied by the exception AsyncTestDelegate code A TestSnippet delegate Returns Type Description Exception View Source ThrowsAsync(IResolveConstraint, AsyncTestDelegate, string, params object?[]?) Verifies that an async delegate throws a particular exception when called. The returned exception may be null when inside a multiple assert block. Declaration public static Exception? ThrowsAsync(IResolveConstraint expression, AsyncTestDelegate code, string message, params object?[]? args) Parameters Type Name Description IResolveConstraint expression A constraint to be satisfied by the exception AsyncTestDelegate code A TestSnippet delegate string message The message that will be displayed on failure object[] args Arguments to be used in formatting the message Returns Type Description Exception View Source ThrowsAsync(Type, AsyncTestDelegate) Verifies that an async delegate throws a particular exception when called. The returned exception may be null when inside a multiple assert block. Declaration public static Exception? ThrowsAsync(Type expectedExceptionType, AsyncTestDelegate code) Parameters Type Name Description Type expectedExceptionType The exception Type expected AsyncTestDelegate code A TestDelegate Returns Type Description Exception View Source ThrowsAsync(Type, AsyncTestDelegate, string, params object?[]?) Verifies that an async delegate throws a particular exception when called. The returned exception may be null when inside a multiple assert block. Declaration public static Exception? ThrowsAsync(Type expectedExceptionType, AsyncTestDelegate code, string message, params object?[]? args) Parameters Type Name Description Type expectedExceptionType The exception Type expected AsyncTestDelegate code A TestDelegate string message The message that will be displayed on failure object[] args Arguments to be used in formatting the message Returns Type Description Exception View Source ThrowsAsync<TActual>(AsyncTestDelegate) Verifies that an async delegate throws a particular exception when called. The returned exception may be null when inside a multiple assert block. Declaration public static TActual? ThrowsAsync<TActual>(AsyncTestDelegate code) where TActual : Exception Parameters Type Name Description AsyncTestDelegate code A TestDelegate Returns Type Description TActual Type Parameters Name Description TActual Type of the expected exception View Source ThrowsAsync<TActual>(AsyncTestDelegate, string, params object?[]?) Verifies that an async delegate throws a particular exception when called. The returned exception may be null when inside a multiple assert block. Declaration public static TActual? ThrowsAsync<TActual>(AsyncTestDelegate code, string message, params object?[]? args) where TActual : Exception Parameters Type Name Description AsyncTestDelegate code A TestDelegate string message The message that will be displayed on failure object[] args Arguments to be used in formatting the message Returns Type Description TActual Type Parameters Name Description TActual Type of the expected exception View Source Throws<TActual>(TestDelegate) Verifies that a delegate throws a particular exception when called. The returned exception may be null when inside a multiple assert block. Declaration public static TActual? Throws<TActual>(TestDelegate code) where TActual : Exception Parameters Type Name Description TestDelegate code A TestDelegate Returns Type Description TActual Type Parameters Name Description TActual Type of the expected exception View Source Throws<TActual>(TestDelegate, string, params object?[]?) Verifies that a delegate throws a particular exception when called. The returned exception may be null when inside a multiple assert block. Declaration public static TActual? Throws<TActual>(TestDelegate code, string message, params object?[]? args) where TActual : Exception Parameters Type Name Description TestDelegate code A TestDelegate string message The message that will be displayed on failure object[] args Arguments to be used in formatting the message Returns Type Description TActual Type Parameters Name Description TActual Type of the expected exception View Source Warn(string) Issues a warning using the message and arguments provided. Declaration public static void Warn(string message) Parameters Type Name Description string message The message to display."
  },
  "api/NUnit.Framework.AssertBase.html": {
    "href": "api/NUnit.Framework.AssertBase.html",
    "title": "Class AssertBase | NUnit Docs",
    "summary": "Class AssertBase Base class for different Assert, containing helper functions Inheritance object AssertBase Assert CollectionAssert DirectoryAssert FileAssert StringAssert Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework Assembly: nunit.framework.dll Syntax public abstract class AssertBase Constructors View Source AssertBase() Declaration protected AssertBase() Methods View Source ConvertMessageWithArgs(string, object?[]?) Check if message comes with args, and convert that to a formatted string Declaration protected static string ConvertMessageWithArgs(string message, object?[]? args) Parameters Type Name Description string message object[] args Returns Type Description string"
  },
  "api/NUnit.Framework.AssertionException.html": {
    "href": "api/NUnit.Framework.AssertionException.html",
    "title": "Class AssertionException | NUnit Docs",
    "summary": "Class AssertionException Thrown when an assertion failed. Inheritance object Exception ResultStateException AssertionException Implements ISerializable Inherited Members Exception.GetBaseException() Exception.ToString() Exception.GetType() Exception.TargetSite Exception.Message Exception.Data Exception.InnerException Exception.HelpLink Exception.Source Exception.HResult Exception.StackTrace Exception.SerializeObjectState object.MemberwiseClone() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework Assembly: nunit.framework.dll Syntax public class AssertionException : ResultStateException, ISerializable Constructors View Source AssertionException(string) Declaration public AssertionException(string message) Parameters Type Name Description string message The error message that explains the reason for the exception View Source AssertionException(string, Exception?) Declaration public AssertionException(string message, Exception? inner) Parameters Type Name Description string message The error message that explains the reason for the exception Exception inner The exception that caused the current exception Properties View Source ResultState Gets the ResultState provided by this exception Declaration public override ResultState ResultState { get; } Property Value Type Description ResultState Overrides ResultStateException.ResultState Implements ISerializable"
  },
  "api/NUnit.Framework.Assume.html": {
    "href": "api/NUnit.Framework.Assume.html",
    "title": "Class Assume | NUnit Docs",
    "summary": "Class Assume Provides static methods to express the assumptions that must be met for a test to give a meaningful result. If an assumption is not met, the test should produce an inconclusive result. Inheritance object Assume Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.GetHashCode() Namespace: NUnit.Framework Assembly: nunit.framework.dll Syntax public abstract class Assume Constructors View Source Assume() Declaration protected Assume() Methods View Source ReferenceEquals(object, object) DO NOT USE! The ReferenceEquals method throws an InvalidOperationException. This is done to make sure there is no mistake by calling this function. Declaration public static void ReferenceEquals(object a, object b) Parameters Type Name Description object a The left object. object b The right object. View Source That(bool, NUnitString, string) Asserts that a condition is true. If the condition is false, the method throws an InconclusiveException. Declaration public static void That(bool condition, NUnitString message = default, string actualExpression = \"\") Parameters Type Name Description bool condition The evaluated condition NUnitString message The message to display if the condition is false string actualExpression View Source That(bool, FormattableString, string) Asserts that a condition is true. If the condition is false, the method throws an InconclusiveException. Declaration public static void That(bool condition, FormattableString message, string actualExpression = \"\") Parameters Type Name Description bool condition The evaluated condition FormattableString message The message to display if the condition is false string actualExpression View Source That(bool, Func<string>, string) Asserts that a condition is true. If the condition is false, the method throws an InconclusiveException. Declaration public static void That(bool condition, Func<string> getExceptionMessage, string actualExpression = \"\") Parameters Type Name Description bool condition The evaluated condition Func<string> getExceptionMessage A function to build the message included with the Exception string actualExpression View Source That(Func<bool>, NUnitString, string) Asserts that a condition is true. If the condition is false, the method throws an InconclusiveException. Declaration public static void That(Func<bool> condition, NUnitString message = default, string actualExpression = \"\") Parameters Type Name Description Func<bool> condition A lambda that returns a Boolean NUnitString message The message to display if the condition is false string actualExpression View Source That(Func<bool>, FormattableString, string) Asserts that a condition is true. If the condition is false, the method throws an InconclusiveException. Declaration public static void That(Func<bool> condition, FormattableString message, string actualExpression = \"\") Parameters Type Name Description Func<bool> condition A lambda that returns a Boolean FormattableString message The message to display if the condition is false string actualExpression View Source That(Func<bool>, Func<string>, string) Asserts that a condition is true. If the condition is false, the method throws an InconclusiveException. Declaration public static void That(Func<bool> condition, Func<string> getExceptionMessage, string actualExpression = \"\") Parameters Type Name Description Func<bool> condition A lambda that returns a Boolean Func<string> getExceptionMessage A function to build the message included with the Exception string actualExpression View Source That<TActual>(ActualValueDelegate<TActual>, IResolveConstraint, NUnitString, string, string) Apply a constraint to an actual value, succeeding if the constraint is satisfied and throwing an InconclusiveException on failure. Declaration public static void That<TActual>(ActualValueDelegate<TActual> del, IResolveConstraint expr, NUnitString message = default, string actualExpression = \"\", string constraintExpression = \"\") Parameters Type Name Description ActualValueDelegate<TActual> del An ActualValueDelegate returning the value to be tested IResolveConstraint expr A Constraint expression to be applied NUnitString message The message that will be displayed on failure string actualExpression string constraintExpression Type Parameters Name Description TActual The Type being compared. View Source That<TActual>(ActualValueDelegate<TActual>, IResolveConstraint, FormattableString, string, string) Apply a constraint to an actual value, succeeding if the constraint is satisfied and throwing an InconclusiveException on failure. Declaration public static void That<TActual>(ActualValueDelegate<TActual> del, IResolveConstraint expr, FormattableString message, string actualExpression = \"\", string constraintExpression = \"\") Parameters Type Name Description ActualValueDelegate<TActual> del An ActualValueDelegate returning the value to be tested IResolveConstraint expr A Constraint expression to be applied FormattableString message The message that will be displayed on failure string actualExpression string constraintExpression Type Parameters Name Description TActual The Type being compared. View Source That<TActual>(ActualValueDelegate<TActual>, IResolveConstraint, Func<string>, string, string) Apply a constraint to an actual value, succeeding if the constraint is satisfied and throwing an InconclusiveException on failure. Declaration public static void That<TActual>(ActualValueDelegate<TActual> del, IResolveConstraint expr, Func<string> getExceptionMessage, string actualExpression = \"\", string constraintExpression = \"\") Parameters Type Name Description ActualValueDelegate<TActual> del An ActualValueDelegate returning the value to be tested IResolveConstraint expr A Constraint expression to be applied Func<string> getExceptionMessage A function to build the message included with the Exception string actualExpression string constraintExpression Type Parameters Name Description TActual The Type being compared. View Source That<TActual>(TActual, IResolveConstraint, NUnitString, string, string) Apply a constraint to an actual value, succeeding if the constraint is satisfied and throwing an InconclusiveException on failure. Declaration public static void That<TActual>(TActual actual, IResolveConstraint expression, NUnitString message = default, string actualExpression = \"\", string constraintExpression = \"\") Parameters Type Name Description TActual actual The actual value to test IResolveConstraint expression A Constraint expression to be applied NUnitString message The message that will be displayed on failure string actualExpression string constraintExpression Type Parameters Name Description TActual The Type being compared. View Source That<TActual>(TActual, IResolveConstraint, FormattableString, string, string) Apply a constraint to an actual value, succeeding if the constraint is satisfied and throwing an InconclusiveException on failure. Declaration public static void That<TActual>(TActual actual, IResolveConstraint expression, FormattableString message, string actualExpression = \"\", string constraintExpression = \"\") Parameters Type Name Description TActual actual The actual value to test IResolveConstraint expression A Constraint expression to be applied FormattableString message The message that will be displayed on failure string actualExpression string constraintExpression Type Parameters Name Description TActual The Type being compared. View Source That<TActual>(TActual, IResolveConstraint, Func<string>, string, string) Apply a constraint to an actual value, succeeding if the constraint is satisfied and throwing an InconclusiveException on failure. Declaration public static void That<TActual>(TActual actual, IResolveConstraint expression, Func<string> getExceptionMessage, string actualExpression = \"\", string constraintExpression = \"\") Parameters Type Name Description TActual actual The actual value to test IResolveConstraint expression A Constraint expression to be applied Func<string> getExceptionMessage A function to build the message included with the Exception string actualExpression string constraintExpression Type Parameters Name Description TActual The Type being compared."
  },
  "api/NUnit.Framework.AsyncTestDelegate.html": {
    "href": "api/NUnit.Framework.AsyncTestDelegate.html",
    "title": "Delegate AsyncTestDelegate | NUnit Docs",
    "summary": "Delegate AsyncTestDelegate Delegate used by tests that execute async code and capture any thrown exception. Namespace: NUnit.Framework Assembly: nunit.framework.dll Syntax public delegate Task AsyncTestDelegate() Returns Type Description Task Delegate used by tests that execute async code and capture any thrown exception. Constructors View Source AsyncTestDelegate(object, nint) Declaration public AsyncTestDelegate(object @object, nint method) Parameters Type Name Description object object nint method Methods View Source BeginInvoke(AsyncCallback, object) Declaration public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object @object) Parameters Type Name Description AsyncCallback callback object object Returns Type Description IAsyncResult View Source EndInvoke(IAsyncResult) Declaration public virtual Task EndInvoke(IAsyncResult result) Parameters Type Name Description IAsyncResult result Returns Type Description Task View Source Invoke() Declaration public virtual Task Invoke() Returns Type Description Task"
  },
  "api/NUnit.Framework.AuthorAttribute.html": {
    "href": "api/NUnit.Framework.AuthorAttribute.html",
    "title": "Class AuthorAttribute | NUnit Docs",
    "summary": "Class AuthorAttribute Provides the author of a test or test fixture. Inheritance object Attribute NUnitAttribute PropertyAttribute AuthorAttribute Implements IApplyToTest Inherited Members PropertyAttribute.ApplyToTest(Test) PropertyAttribute.Properties Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object, object) object.ReferenceEquals(object, object) Namespace: NUnit.Framework Assembly: nunit.framework.dll Syntax [AttributeUsage(AttributeTargets.Assembly|AttributeTargets.Class|AttributeTargets.Method, AllowMultiple = true, Inherited = false)] public class AuthorAttribute : PropertyAttribute, IApplyToTest Constructors View Source AuthorAttribute(string) Initializes a new instance of the AuthorAttribute class. Declaration public AuthorAttribute(string name) Parameters Type Name Description string name The name of the author. View Source AuthorAttribute(string, string) Initializes a new instance of the AuthorAttribute class. Declaration public AuthorAttribute(string name, string email) Parameters Type Name Description string name The name of the author. string email The email address of the author. Implements IApplyToTest"
  },
  "api/NUnit.Framework.CancelAfterAttribute.html": {
    "href": "api/NUnit.Framework.CancelAfterAttribute.html",
    "title": "Class CancelAfterAttribute | NUnit Docs",
    "summary": "Class CancelAfterAttribute Applies a timeout in milliseconds to a test. When applied to a method, the test's cancellation token is cancelled if the timeout is exceeded. Inheritance object Attribute NUnitAttribute PropertyAttribute CancelAfterAttribute Implements IApplyToTest IApplyToContext Inherited Members PropertyAttribute.ApplyToTest(Test) PropertyAttribute.Properties Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object, object) object.ReferenceEquals(object, object) Namespace: NUnit.Framework Assembly: nunit.framework.dll Syntax [AttributeUsage(AttributeTargets.Class|AttributeTargets.Method, AllowMultiple = false, Inherited = false)] public class CancelAfterAttribute : PropertyAttribute, IApplyToTest, IApplyToContext Remarks The user has to monitor this cancellation token. Constructors View Source CancelAfterAttribute(int) Construct a CancelAfterAttribute given a time in milliseconds Declaration public CancelAfterAttribute(int timeout) Parameters Type Name Description int timeout The timeout value in milliseconds Implements IApplyToTest IApplyToContext"
  },
  "api/NUnit.Framework.CategoryAttribute.html": {
    "href": "api/NUnit.Framework.CategoryAttribute.html",
    "title": "Class CategoryAttribute | NUnit Docs",
    "summary": "Class CategoryAttribute Applies a category to a test Inheritance object Attribute NUnitAttribute CategoryAttribute Implements IApplyToTest Inherited Members Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object, object) object.ReferenceEquals(object, object) Namespace: NUnit.Framework Assembly: nunit.framework.dll Syntax [AttributeUsage(AttributeTargets.Assembly|AttributeTargets.Class|AttributeTargets.Method, AllowMultiple = true, Inherited = true)] public class CategoryAttribute : NUnitAttribute, IApplyToTest Constructors View Source CategoryAttribute() Protected constructor uses the Type name as the name of the category. Declaration protected CategoryAttribute() View Source CategoryAttribute(string) Construct attribute for a given category based on a name. The name may not contain the characters ',', '+', '-' or '!'. However, this is not checked in the constructor since it would cause an error to arise at as the test was loaded without giving a clear indication of where the problem is located. The error is handled in NUnitFramework.cs by marking the test as not runnable. Declaration public CategoryAttribute(string name) Parameters Type Name Description string name The name of the category Fields View Source categoryName The name of the category Declaration protected string categoryName Field Value Type Description string Properties View Source Name The name of the category Declaration public string Name { get; } Property Value Type Description string Methods View Source ApplyToTest(Test) Modifies a test by adding a category to it. Declaration public void ApplyToTest(Test test) Parameters Type Name Description Test test The test to modify Implements IApplyToTest"
  },
  "api/NUnit.Framework.CombinatorialAttribute.html": {
    "href": "api/NUnit.Framework.CombinatorialAttribute.html",
    "title": "Class CombinatorialAttribute | NUnit Docs",
    "summary": "Class CombinatorialAttribute Marks a test to use a combinatorial join of any argument data provided. Since this is the default, the attribute is optional. Inheritance object Attribute NUnitAttribute CombiningStrategyAttribute CombinatorialAttribute Implements ITestBuilder IApplyToTest Inherited Members CombiningStrategyAttribute.BuildFrom(IMethodInfo, Test) CombiningStrategyAttribute.ApplyToTest(Test) Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object, object) object.ReferenceEquals(object, object) Namespace: NUnit.Framework Assembly: nunit.framework.dll Syntax [AttributeUsage(AttributeTargets.Method, AllowMultiple = false, Inherited = false)] public class CombinatorialAttribute : CombiningStrategyAttribute, ITestBuilder, IApplyToTest Constructors View Source CombinatorialAttribute() Default constructor Declaration public CombinatorialAttribute() Implements ITestBuilder IApplyToTest"
  },
  "api/NUnit.Framework.CombiningStrategyAttribute.html": {
    "href": "api/NUnit.Framework.CombiningStrategyAttribute.html",
    "title": "Class CombiningStrategyAttribute | NUnit Docs",
    "summary": "Class CombiningStrategyAttribute Marks a test as using a particular CombiningStrategy to join any supplied parameter data. Since this is the default, the attribute is optional. Inheritance object Attribute NUnitAttribute CombiningStrategyAttribute CombinatorialAttribute PairwiseAttribute SequentialAttribute TheoryAttribute Implements ITestBuilder IApplyToTest Inherited Members Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object, object) object.ReferenceEquals(object, object) Namespace: NUnit.Framework Assembly: nunit.framework.dll Syntax [AttributeUsage(AttributeTargets.Method, AllowMultiple = false, Inherited = false)] public abstract class CombiningStrategyAttribute : NUnitAttribute, ITestBuilder, IApplyToTest Constructors View Source CombiningStrategyAttribute(ICombiningStrategy, IParameterDataProvider) Construct a CombiningStrategyAttribute incorporating an ICombiningStrategy and an IParameterDataProvider. Declaration protected CombiningStrategyAttribute(ICombiningStrategy strategy, IParameterDataProvider provider) Parameters Type Name Description ICombiningStrategy strategy Combining strategy to be used in combining data IParameterDataProvider provider An IParameterDataProvider to supply data View Source CombiningStrategyAttribute(object, object) Construct a CombiningStrategyAttribute incorporating an object that implements ICombiningStrategy and an IParameterDataProvider. This constructor is provided for CLS compliance. Declaration protected CombiningStrategyAttribute(object strategy, object provider) Parameters Type Name Description object strategy Combining strategy to be used in combining data object provider An IParameterDataProvider to supply data Methods View Source ApplyToTest(Test) Modify the test by adding the name of the combining strategy to the properties. Declaration public void ApplyToTest(Test test) Parameters Type Name Description Test test The test to modify View Source BuildFrom(IMethodInfo, Test?) Builds any number of tests from the specified method and context. Declaration public IEnumerable<TestMethod> BuildFrom(IMethodInfo method, Test? suite) Parameters Type Name Description IMethodInfo method The MethodInfo for which tests are to be constructed. Test suite The suite to which the tests will be added. Returns Type Description IEnumerable<TestMethod> Implements ITestBuilder IApplyToTest"
  },
  "api/NUnit.Framework.Constraints.ActualValueDelegate-1.html": {
    "href": "api/NUnit.Framework.Constraints.ActualValueDelegate-1.html",
    "title": "Delegate ActualValueDelegate<TActual> | NUnit Docs",
    "summary": "Delegate ActualValueDelegate<TActual> Delegate used to delay evaluation of the actual value to be used in evaluating a constraint Namespace: NUnit.Framework.Constraints Assembly: nunit.framework.dll Syntax public delegate TActual ActualValueDelegate<TActual>() Returns Type Description TActual Delegate used to delay evaluation of the actual value to be used in evaluating a constraint Type Parameters Name Description TActual Constructors View Source ActualValueDelegate(object, nint) Declaration public ActualValueDelegate(object @object, nint method) Parameters Type Name Description object object nint method Methods View Source BeginInvoke(AsyncCallback, object) Declaration public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object @object) Parameters Type Name Description AsyncCallback callback object object Returns Type Description IAsyncResult View Source EndInvoke(IAsyncResult) Declaration public virtual TActual EndInvoke(IAsyncResult result) Parameters Type Name Description IAsyncResult result Returns Type Description TActual View Source Invoke() Declaration public virtual TActual Invoke() Returns Type Description TActual"
  },
  "api/NUnit.Framework.Constraints.AllItemsConstraint.html": {
    "href": "api/NUnit.Framework.Constraints.AllItemsConstraint.html",
    "title": "Class AllItemsConstraint | NUnit Docs",
    "summary": "Class AllItemsConstraint AllItemsConstraint applies another constraint to each item in a collection, succeeding if they all succeed. Inheritance object Constraint PrefixConstraint AllItemsConstraint Implements IConstraint IResolveConstraint Inherited Members PrefixConstraint.BaseConstraint PrefixConstraint.DescriptionPrefix PrefixConstraint.Description Constraint.ApplyTo<TActual>(ActualValueDelegate<TActual>) Constraint.ApplyTo<TActual>(ref TActual) Constraint.ApplyToAsync<TActual>(Func<Task<TActual>>) Constraint.GetTestObject<TActual>(ActualValueDelegate<TActual>) Constraint.ToString() Constraint.GetStringRepresentation(IEnumerable) Constraint.GetStringRepresentation() Constraint.After(int) Constraint.After(int, int) Constraint.Arguments Constraint.Builder Constraint.And Constraint.With Constraint.Or object.GetType() object.MemberwiseClone() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework.Constraints Assembly: nunit.framework.dll Syntax public class AllItemsConstraint : PrefixConstraint, IConstraint, IResolveConstraint Constructors View Source AllItemsConstraint(IConstraint) Construct an AllItemsConstraint on top of an existing constraint Declaration public AllItemsConstraint(IConstraint itemConstraint) Parameters Type Name Description IConstraint itemConstraint Properties View Source DisplayName The display name of this Constraint for use by ToString(). The default value is the name of the constraint with trailing \"Constraint\" removed. Derived classes may set this to another name in their constructors. Declaration public override string DisplayName { get; } Property Value Type Description string Overrides Constraint.DisplayName Methods View Source ApplyTo<TActual>(TActual) Apply the item constraint to each item in the collection, failing if any item fails. Declaration public override ConstraintResult ApplyTo<TActual>(TActual actual) Parameters Type Name Description TActual actual Returns Type Description ConstraintResult Type Parameters Name Description TActual Overrides Constraint.ApplyTo<TActual>(TActual) Implements IConstraint IResolveConstraint"
  },
  "api/NUnit.Framework.Constraints.AllOperator.html": {
    "href": "api/NUnit.Framework.Constraints.AllOperator.html",
    "title": "Class AllOperator | NUnit Docs",
    "summary": "Class AllOperator Represents a constraint that succeeds if all the members of a collection match a base constraint. Inheritance object ConstraintOperator PrefixOperator CollectionOperator AllOperator Inherited Members PrefixOperator.Reduce(ConstraintBuilder.ConstraintStack) ConstraintOperator.left_precedence ConstraintOperator.right_precedence ConstraintOperator.LeftContext ConstraintOperator.RightContext ConstraintOperator.LeftPrecedence ConstraintOperator.RightPrecedence object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework.Constraints Assembly: nunit.framework.dll Syntax public class AllOperator : CollectionOperator Constructors View Source AllOperator() Declaration public AllOperator() Methods View Source ApplyPrefix(IConstraint) Returns a constraint that will apply the argument to the members of a collection, succeeding if they all succeed. Declaration public override IConstraint ApplyPrefix(IConstraint constraint) Parameters Type Name Description IConstraint constraint Returns Type Description IConstraint Overrides PrefixOperator.ApplyPrefix(IConstraint)"
  },
  "api/NUnit.Framework.Constraints.AndConstraint.html": {
    "href": "api/NUnit.Framework.Constraints.AndConstraint.html",
    "title": "Class AndConstraint | NUnit Docs",
    "summary": "Class AndConstraint AndConstraint succeeds only if both members succeed. Inheritance object Constraint BinaryConstraint AndConstraint Implements IConstraint IResolveConstraint Inherited Members BinaryConstraint.Left BinaryConstraint.Right Constraint.ApplyTo<TActual>(ActualValueDelegate<TActual>) Constraint.ApplyTo<TActual>(ref TActual) Constraint.ApplyToAsync<TActual>(Func<Task<TActual>>) Constraint.GetTestObject<TActual>(ActualValueDelegate<TActual>) Constraint.ToString() Constraint.GetStringRepresentation(IEnumerable) Constraint.GetStringRepresentation() Constraint.After(int) Constraint.After(int, int) Constraint.DisplayName Constraint.Arguments Constraint.Builder Constraint.And Constraint.With Constraint.Or object.GetType() object.MemberwiseClone() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework.Constraints Assembly: nunit.framework.dll Syntax public class AndConstraint : BinaryConstraint, IConstraint, IResolveConstraint Constructors View Source AndConstraint(IConstraint, IConstraint) Create an AndConstraint from two other constraints Declaration public AndConstraint(IConstraint left, IConstraint right) Parameters Type Name Description IConstraint left The first constraint IConstraint right The second constraint Properties View Source Description Gets text describing a constraint Declaration public override string Description { get; } Property Value Type Description string Overrides Constraint.Description Methods View Source ApplyTo<TActual>(TActual) Apply both member constraints to an actual value, succeeding only if both of them succeed. Declaration public override ConstraintResult ApplyTo<TActual>(TActual actual) Parameters Type Name Description TActual actual The actual value Returns Type Description ConstraintResult True if the constraints both succeeded Type Parameters Name Description TActual Overrides Constraint.ApplyTo<TActual>(TActual) Implements IConstraint IResolveConstraint"
  },
  "api/NUnit.Framework.Constraints.AndOperator.html": {
    "href": "api/NUnit.Framework.Constraints.AndOperator.html",
    "title": "Class AndOperator | NUnit Docs",
    "summary": "Class AndOperator Operator that requires both its arguments to succeed Inheritance object ConstraintOperator BinaryOperator AndOperator Inherited Members BinaryOperator.Reduce(ConstraintBuilder.ConstraintStack) BinaryOperator.LeftPrecedence BinaryOperator.RightPrecedence ConstraintOperator.left_precedence ConstraintOperator.right_precedence ConstraintOperator.LeftContext ConstraintOperator.RightContext object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework.Constraints Assembly: nunit.framework.dll Syntax public class AndOperator : BinaryOperator Constructors View Source AndOperator() Construct an AndOperator Declaration public AndOperator() Methods View Source ApplyOperator(IConstraint, IConstraint) Apply the operator to produce an AndConstraint Declaration public override IConstraint ApplyOperator(IConstraint left, IConstraint right) Parameters Type Name Description IConstraint left IConstraint right Returns Type Description IConstraint Overrides BinaryOperator.ApplyOperator(IConstraint, IConstraint)"
  },
  "api/NUnit.Framework.Constraints.AnyOfConstraint.html": {
    "href": "api/NUnit.Framework.Constraints.AnyOfConstraint.html",
    "title": "Class AnyOfConstraint | NUnit Docs",
    "summary": "Class AnyOfConstraint AnyOfConstraint is used to determine whether the value is equal to any of the expected values. Inheritance object Constraint AnyOfConstraint Implements IConstraint IResolveConstraint Inherited Members Constraint.ApplyTo<TActual>(ActualValueDelegate<TActual>) Constraint.ApplyTo<TActual>(ref TActual) Constraint.ApplyToAsync<TActual>(Func<Task<TActual>>) Constraint.GetTestObject<TActual>(ActualValueDelegate<TActual>) Constraint.ToString() Constraint.GetStringRepresentation(IEnumerable) Constraint.After(int) Constraint.After(int, int) Constraint.DisplayName Constraint.Arguments Constraint.Builder Constraint.And Constraint.With Constraint.Or object.GetType() object.MemberwiseClone() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework.Constraints Assembly: nunit.framework.dll Syntax public class AnyOfConstraint : Constraint, IConstraint, IResolveConstraint Constructors View Source AnyOfConstraint(ICollection) Construct a AnyOfConstraint Declaration public AnyOfConstraint(ICollection expected) Parameters Type Name Description ICollection expected Collection of expected values Properties View Source Description The Description of what this constraint tests, for use in messages and in the ConstraintResult. Declaration public override string Description { get; } Property Value Type Description string Overrides Constraint.Description View Source IgnoreCase Flag the constraint to ignore case and return self. Declaration public AnyOfConstraint IgnoreCase { get; } Property Value Type Description AnyOfConstraint View Source IgnoreLineEndingFormat Flag the constraint to ignore line ending format (\\r vs. \\n vs. \\r\\n) and return self. Declaration public AnyOfConstraint IgnoreLineEndingFormat { get; } Property Value Type Description AnyOfConstraint View Source IgnoreWhiteSpace Flag the constraint to ignore white space and return self. Declaration public AnyOfConstraint IgnoreWhiteSpace { get; } Property Value Type Description AnyOfConstraint Methods View Source ApplyTo<TActual>(TActual) Test whether item is present in expected collection Declaration public override ConstraintResult ApplyTo<TActual>(TActual actual) Parameters Type Name Description TActual actual Actual item Returns Type Description ConstraintResult Type Parameters Name Description TActual Actual item type Overrides Constraint.ApplyTo<TActual>(TActual) View Source GetStringRepresentation() Returns the string representation of this constraint Declaration protected override string GetStringRepresentation() Returns Type Description string Overrides Constraint.GetStringRepresentation() View Source Using(IComparer) Flag the constraint to use the supplied IComparer object. Declaration public AnyOfConstraint Using(IComparer comparer) Parameters Type Name Description IComparer comparer The IComparer object to use. Returns Type Description AnyOfConstraint View Source Using(IEqualityComparer) Flag the constraint to use the supplied IEqualityComparer object. Declaration public AnyOfConstraint Using(IEqualityComparer comparer) Parameters Type Name Description IEqualityComparer comparer The IEqualityComparer object to use. Returns Type Description AnyOfConstraint View Source UsingPropertiesComparer() Enables comparing of instance properties. Declaration public AnyOfConstraint UsingPropertiesComparer() Returns Type Description AnyOfConstraint Remarks This allows comparing classes that don't implement IEquatable<T> without having to compare each property separately in own code. View Source UsingPropertiesComparer(Func<PropertiesComparerConfigurationUntyped, PropertiesComparerConfigurationUntyped>) Enables comparing of instance properties. Declaration public AnyOfConstraint UsingPropertiesComparer(Func<PropertiesComparerConfigurationUntyped, PropertiesComparerConfigurationUntyped> configure) Parameters Type Name Description Func<PropertiesComparerConfigurationUntyped, PropertiesComparerConfigurationUntyped> configure Returns Type Description AnyOfConstraint Remarks This allows comparing classes that don't implement IEquatable<T> without having to compare each property separately in own code. View Source Using<T>(IComparer<T>) Flag the constraint to use the supplied IComparer object. Declaration public AnyOfConstraint Using<T>(IComparer<T> comparer) Parameters Type Name Description IComparer<T> comparer The IComparer object to use. Returns Type Description AnyOfConstraint Type Parameters Name Description T View Source Using<T>(IEqualityComparer<T>) Flag the constraint to use the supplied IEqualityComparer object. Declaration public AnyOfConstraint Using<T>(IEqualityComparer<T> comparer) Parameters Type Name Description IEqualityComparer<T> comparer The IComparer object to use. Returns Type Description AnyOfConstraint Type Parameters Name Description T View Source Using<T>(Comparison<T>) Flag the constraint to use the supplied Comparison object. Declaration public AnyOfConstraint Using<T>(Comparison<T> comparer) Parameters Type Name Description Comparison<T> comparer The Comparison object to use. Returns Type Description AnyOfConstraint Type Parameters Name Description T View Source Using<T>(Func<T, T, bool>) Flag the constraint to use the supplied boolean-returning delegate. Declaration public AnyOfConstraint Using<T>(Func<T, T, bool> comparer) Parameters Type Name Description Func<T, T, bool> comparer The supplied boolean-returning delegate to use. Returns Type Description AnyOfConstraint Type Parameters Name Description T Implements IConstraint IResolveConstraint"
  },
  "api/NUnit.Framework.Constraints.AssignableFromConstraint.html": {
    "href": "api/NUnit.Framework.Constraints.AssignableFromConstraint.html",
    "title": "Class AssignableFromConstraint | NUnit Docs",
    "summary": "Class AssignableFromConstraint AssignableFromConstraint is used to test that an object can be assigned from a given Type. Inheritance object Constraint TypeConstraint AssignableFromConstraint Implements IConstraint IResolveConstraint Inherited Members TypeConstraint.expectedType TypeConstraint.actualType TypeConstraint.ApplyTo<TActual>(TActual) TypeConstraint.Description Constraint.ApplyTo<TActual>(ActualValueDelegate<TActual>) Constraint.ApplyTo<TActual>(ref TActual) Constraint.ApplyToAsync<TActual>(Func<Task<TActual>>) Constraint.GetTestObject<TActual>(ActualValueDelegate<TActual>) Constraint.ToString() Constraint.GetStringRepresentation(IEnumerable) Constraint.GetStringRepresentation() Constraint.After(int) Constraint.After(int, int) Constraint.DisplayName Constraint.Arguments Constraint.Builder Constraint.And Constraint.With Constraint.Or object.GetType() object.MemberwiseClone() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework.Constraints Assembly: nunit.framework.dll Syntax public class AssignableFromConstraint : TypeConstraint, IConstraint, IResolveConstraint Constructors View Source AssignableFromConstraint(Type) Construct an AssignableFromConstraint for the type provided Declaration public AssignableFromConstraint(Type type) Parameters Type Name Description Type type Methods View Source Matches(object?) Apply the constraint to an actual value, returning true if it succeeds Declaration protected override bool Matches(object? actual) Parameters Type Name Description object actual The actual argument Returns Type Description bool True if the constraint succeeds, otherwise false. Overrides TypeConstraint.Matches(object?) Implements IConstraint IResolveConstraint"
  },
  "api/NUnit.Framework.Constraints.AssignableToConstraint.html": {
    "href": "api/NUnit.Framework.Constraints.AssignableToConstraint.html",
    "title": "Class AssignableToConstraint | NUnit Docs",
    "summary": "Class AssignableToConstraint AssignableToConstraint is used to test that an object can be assigned to a given Type. Inheritance object Constraint TypeConstraint AssignableToConstraint Implements IConstraint IResolveConstraint Inherited Members TypeConstraint.expectedType TypeConstraint.actualType TypeConstraint.ApplyTo<TActual>(TActual) TypeConstraint.Description Constraint.ApplyTo<TActual>(ActualValueDelegate<TActual>) Constraint.ApplyTo<TActual>(ref TActual) Constraint.ApplyToAsync<TActual>(Func<Task<TActual>>) Constraint.GetTestObject<TActual>(ActualValueDelegate<TActual>) Constraint.ToString() Constraint.GetStringRepresentation(IEnumerable) Constraint.GetStringRepresentation() Constraint.After(int) Constraint.After(int, int) Constraint.DisplayName Constraint.Arguments Constraint.Builder Constraint.And Constraint.With Constraint.Or object.GetType() object.MemberwiseClone() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework.Constraints Assembly: nunit.framework.dll Syntax public class AssignableToConstraint : TypeConstraint, IConstraint, IResolveConstraint Constructors View Source AssignableToConstraint(Type) Construct an AssignableToConstraint for the type provided Declaration public AssignableToConstraint(Type type) Parameters Type Name Description Type type Methods View Source Matches(object?) Apply the constraint to an actual value, returning true if it succeeds Declaration protected override bool Matches(object? actual) Parameters Type Name Description object actual The actual argument Returns Type Description bool True if the constraint succeeds, otherwise false. Overrides TypeConstraint.Matches(object?) Implements IConstraint IResolveConstraint"
  },
  "api/NUnit.Framework.Constraints.AttributeConstraint.html": {
    "href": "api/NUnit.Framework.Constraints.AttributeConstraint.html",
    "title": "Class AttributeConstraint | NUnit Docs",
    "summary": "Class AttributeConstraint AttributeConstraint tests that a specified attribute is present on a Type or other provider and that the value of the attribute satisfies some other constraint. Inheritance object Constraint PrefixConstraint AttributeConstraint Implements IConstraint IResolveConstraint Inherited Members PrefixConstraint.BaseConstraint PrefixConstraint.DescriptionPrefix PrefixConstraint.Description Constraint.ApplyTo<TActual>(ActualValueDelegate<TActual>) Constraint.ApplyTo<TActual>(ref TActual) Constraint.ApplyToAsync<TActual>(Func<Task<TActual>>) Constraint.GetTestObject<TActual>(ActualValueDelegate<TActual>) Constraint.ToString() Constraint.GetStringRepresentation(IEnumerable) Constraint.After(int) Constraint.After(int, int) Constraint.DisplayName Constraint.Arguments Constraint.Builder Constraint.And Constraint.With Constraint.Or object.GetType() object.MemberwiseClone() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework.Constraints Assembly: nunit.framework.dll Syntax public class AttributeConstraint : PrefixConstraint, IConstraint, IResolveConstraint Constructors View Source AttributeConstraint(Type, IConstraint) Constructs an AttributeConstraint for a specified attribute Type and base constraint. Declaration public AttributeConstraint(Type type, IConstraint baseConstraint) Parameters Type Name Description Type type IConstraint baseConstraint Methods View Source ApplyTo<TActual>(TActual) Determines whether the Type or other provider has the expected attribute and if its value matches the additional constraint specified. Declaration public override ConstraintResult ApplyTo<TActual>(TActual actual) Parameters Type Name Description TActual actual Returns Type Description ConstraintResult Type Parameters Name Description TActual Overrides Constraint.ApplyTo<TActual>(TActual) View Source GetStringRepresentation() Returns a string representation of the constraint. Declaration protected override string GetStringRepresentation() Returns Type Description string Overrides Constraint.GetStringRepresentation() Implements IConstraint IResolveConstraint"
  },
  "api/NUnit.Framework.Constraints.AttributeExistsConstraint.html": {
    "href": "api/NUnit.Framework.Constraints.AttributeExistsConstraint.html",
    "title": "Class AttributeExistsConstraint | NUnit Docs",
    "summary": "Class AttributeExistsConstraint AttributeExistsConstraint tests for the presence of a specified attribute on a Type. Inheritance object Constraint AttributeExistsConstraint Implements IConstraint IResolveConstraint Inherited Members Constraint.ApplyTo<TActual>(ActualValueDelegate<TActual>) Constraint.ApplyTo<TActual>(ref TActual) Constraint.ApplyToAsync<TActual>(Func<Task<TActual>>) Constraint.GetTestObject<TActual>(ActualValueDelegate<TActual>) Constraint.ToString() Constraint.GetStringRepresentation(IEnumerable) Constraint.GetStringRepresentation() Constraint.After(int) Constraint.After(int, int) Constraint.DisplayName Constraint.Arguments Constraint.Builder Constraint.And Constraint.With Constraint.Or object.GetType() object.MemberwiseClone() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework.Constraints Assembly: nunit.framework.dll Syntax public class AttributeExistsConstraint : Constraint, IConstraint, IResolveConstraint Constructors View Source AttributeExistsConstraint(Type) Constructs an AttributeExistsConstraint for a specific attribute Type Declaration public AttributeExistsConstraint(Type type) Parameters Type Name Description Type type Properties View Source Description The Description of what this constraint tests, for use in messages and in the ConstraintResult. Declaration public override string Description { get; } Property Value Type Description string Overrides Constraint.Description Methods View Source ApplyTo<TActual>(TActual) Tests whether the object provides the expected attribute. Declaration public override ConstraintResult ApplyTo<TActual>(TActual actual) Parameters Type Name Description TActual actual A Type, MethodInfo, or other ICustomAttributeProvider Returns Type Description ConstraintResult True if the expected attribute is present, otherwise false Type Parameters Name Description TActual Overrides Constraint.ApplyTo<TActual>(TActual) Implements IConstraint IResolveConstraint"
  },
  "api/NUnit.Framework.Constraints.AttributeOperator.html": {
    "href": "api/NUnit.Framework.Constraints.AttributeOperator.html",
    "title": "Class AttributeOperator | NUnit Docs",
    "summary": "Class AttributeOperator Operator that tests for the presence of a particular attribute on a type and optionally applies further tests to the attribute. Inheritance object ConstraintOperator SelfResolvingOperator AttributeOperator Inherited Members ConstraintOperator.left_precedence ConstraintOperator.right_precedence ConstraintOperator.LeftContext ConstraintOperator.RightContext ConstraintOperator.LeftPrecedence ConstraintOperator.RightPrecedence object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework.Constraints Assembly: nunit.framework.dll Syntax public class AttributeOperator : SelfResolvingOperator Constructors View Source AttributeOperator(Type) Construct an AttributeOperator for a particular Type Declaration public AttributeOperator(Type type) Parameters Type Name Description Type type The Type of attribute tested Methods View Source Reduce(ConstraintStack) Reduce produces a constraint from the operator and any arguments. It takes the arguments from the constraint stack and pushes the resulting constraint on it. Declaration public override void Reduce(ConstraintBuilder.ConstraintStack stack) Parameters Type Name Description ConstraintBuilder.ConstraintStack stack Overrides ConstraintOperator.Reduce(ConstraintBuilder.ConstraintStack)"
  },
  "api/NUnit.Framework.Constraints.BinaryConstraint.html": {
    "href": "api/NUnit.Framework.Constraints.BinaryConstraint.html",
    "title": "Class BinaryConstraint | NUnit Docs",
    "summary": "Class BinaryConstraint BinaryConstraint is the abstract base of all constraints that combine two other constraints in some fashion. Inheritance object Constraint BinaryConstraint AndConstraint OrConstraint Implements IConstraint IResolveConstraint Inherited Members Constraint.ApplyTo<TActual>(TActual) Constraint.ApplyTo<TActual>(ActualValueDelegate<TActual>) Constraint.ApplyTo<TActual>(ref TActual) Constraint.ApplyToAsync<TActual>(Func<Task<TActual>>) Constraint.GetTestObject<TActual>(ActualValueDelegate<TActual>) Constraint.ToString() Constraint.GetStringRepresentation(IEnumerable) Constraint.GetStringRepresentation() Constraint.After(int) Constraint.After(int, int) Constraint.DisplayName Constraint.Description Constraint.Arguments Constraint.Builder Constraint.And Constraint.With Constraint.Or object.GetType() object.MemberwiseClone() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework.Constraints Assembly: nunit.framework.dll Syntax public abstract class BinaryConstraint : Constraint, IConstraint, IResolveConstraint Constructors View Source BinaryConstraint(IConstraint, IConstraint) Construct a BinaryConstraint from two other constraints Declaration protected BinaryConstraint(IConstraint left, IConstraint right) Parameters Type Name Description IConstraint left The first constraint IConstraint right The second constraint Fields View Source Left The first constraint being combined Declaration protected IConstraint Left Field Value Type Description IConstraint View Source Right The second constraint being combined Declaration protected IConstraint Right Field Value Type Description IConstraint Implements IConstraint IResolveConstraint"
  },
  "api/NUnit.Framework.Constraints.BinaryOperator.html": {
    "href": "api/NUnit.Framework.Constraints.BinaryOperator.html",
    "title": "Class BinaryOperator | NUnit Docs",
    "summary": "Class BinaryOperator Abstract base class for all binary operators Inheritance object ConstraintOperator BinaryOperator AndOperator InsteadOperator OrOperator Inherited Members ConstraintOperator.left_precedence ConstraintOperator.right_precedence ConstraintOperator.LeftContext ConstraintOperator.RightContext object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework.Constraints Assembly: nunit.framework.dll Syntax public abstract class BinaryOperator : ConstraintOperator Constructors View Source BinaryOperator() Declaration protected BinaryOperator() Properties View Source LeftPrecedence Gets the left precedence of the operator Declaration public override int LeftPrecedence { get; } Property Value Type Description int Overrides ConstraintOperator.LeftPrecedence View Source RightPrecedence Gets the right precedence of the operator Declaration public override int RightPrecedence { get; } Property Value Type Description int Overrides ConstraintOperator.RightPrecedence Methods View Source ApplyOperator(IConstraint, IConstraint) Abstract method that produces a constraint by applying the operator to its left and right constraint arguments. Declaration public abstract IConstraint ApplyOperator(IConstraint left, IConstraint right) Parameters Type Name Description IConstraint left IConstraint right Returns Type Description IConstraint View Source Reduce(ConstraintStack) Reduce produces a constraint from the operator and any arguments. It takes the arguments from the constraint stack and pushes the resulting constraint on it. Declaration public override void Reduce(ConstraintBuilder.ConstraintStack stack) Parameters Type Name Description ConstraintBuilder.ConstraintStack stack Overrides ConstraintOperator.Reduce(ConstraintBuilder.ConstraintStack)"
  },
  "api/NUnit.Framework.Constraints.CollectionConstraint.html": {
    "href": "api/NUnit.Framework.Constraints.CollectionConstraint.html",
    "title": "Class CollectionConstraint | NUnit Docs",
    "summary": "Class CollectionConstraint CollectionConstraint is the abstract base class for constraints that operate on collections. Inheritance object Constraint CollectionConstraint CollectionItemsEqualConstraint CollectionOrderedConstraint EmptyCollectionConstraint Implements IConstraint IResolveConstraint Inherited Members Constraint.ApplyTo<TActual>(ActualValueDelegate<TActual>) Constraint.ApplyTo<TActual>(ref TActual) Constraint.ApplyToAsync<TActual>(Func<Task<TActual>>) Constraint.GetTestObject<TActual>(ActualValueDelegate<TActual>) Constraint.ToString() Constraint.GetStringRepresentation(IEnumerable) Constraint.GetStringRepresentation() Constraint.After(int) Constraint.After(int, int) Constraint.DisplayName Constraint.Description Constraint.Arguments Constraint.Builder Constraint.And Constraint.With Constraint.Or object.GetType() object.MemberwiseClone() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework.Constraints Assembly: nunit.framework.dll Syntax public abstract class CollectionConstraint : Constraint, IConstraint, IResolveConstraint Constructors View Source CollectionConstraint() Construct an empty CollectionConstraint Declaration protected CollectionConstraint() View Source CollectionConstraint(object?) Construct a CollectionConstraint Declaration protected CollectionConstraint(object? arg) Parameters Type Name Description object arg Methods View Source ApplyTo<TActual>(TActual) Test whether the constraint is satisfied by a given value Declaration public override ConstraintResult ApplyTo<TActual>(TActual actual) Parameters Type Name Description TActual actual The value to be tested Returns Type Description ConstraintResult True for success, false for failure Type Parameters Name Description TActual Overrides Constraint.ApplyTo<TActual>(TActual) View Source IsEmpty(IEnumerable) Determines whether the specified enumerable is empty. Declaration protected static bool IsEmpty(IEnumerable enumerable) Parameters Type Name Description IEnumerable enumerable The enumerable. Returns Type Description bool true if the specified enumerable is empty; otherwise, false. View Source Matches(IEnumerable) Protected method to be implemented by derived classes Declaration protected abstract bool Matches(IEnumerable collection) Parameters Type Name Description IEnumerable collection Returns Type Description bool Implements IConstraint IResolveConstraint"
  },
  "api/NUnit.Framework.Constraints.CollectionEquivalentConstraint.html": {
    "href": "api/NUnit.Framework.Constraints.CollectionEquivalentConstraint.html",
    "title": "Class CollectionEquivalentConstraint | NUnit Docs",
    "summary": "Class CollectionEquivalentConstraint CollectionEquivalentConstraint is used to determine whether two collections are equivalent. Inheritance object Constraint CollectionConstraint CollectionItemsEqualConstraint CollectionEquivalentConstraint Implements IConstraint IResolveConstraint Inherited Members CollectionItemsEqualConstraint.Using(IComparer) CollectionItemsEqualConstraint.Using<T>(IComparer<T>) CollectionItemsEqualConstraint.Using<T>(Comparison<T>) CollectionItemsEqualConstraint.Using(IEqualityComparer) CollectionItemsEqualConstraint.Using<T>(IEqualityComparer<T>) CollectionItemsEqualConstraint.Using<T>(Func<T, T, bool>) CollectionItemsEqualConstraint.UsingPropertiesComparer() CollectionItemsEqualConstraint.UsingPropertiesComparer(Func<PropertiesComparerConfigurationUntyped, PropertiesComparerConfigurationUntyped>) CollectionItemsEqualConstraint.ItemsEqual(object, object) CollectionItemsEqualConstraint.Tally(IEnumerable) CollectionItemsEqualConstraint.IgnoringCase CollectionItemsEqualConstraint.IgnoringWhiteSpace CollectionItemsEqualConstraint.IgnoringLineEndingFormat CollectionItemsEqualConstraint.UsingExternalComparer CollectionItemsEqualConstraint.IgnoreCase CollectionItemsEqualConstraint.IgnoreWhiteSpace CollectionItemsEqualConstraint.IgnoreLineEndingFormat CollectionConstraint.IsEmpty(IEnumerable) Constraint.ApplyTo<TActual>(ActualValueDelegate<TActual>) Constraint.ApplyTo<TActual>(ref TActual) Constraint.ApplyToAsync<TActual>(Func<Task<TActual>>) Constraint.GetTestObject<TActual>(ActualValueDelegate<TActual>) Constraint.ToString() Constraint.GetStringRepresentation(IEnumerable) Constraint.GetStringRepresentation() Constraint.After(int) Constraint.After(int, int) Constraint.Arguments Constraint.Builder Constraint.And Constraint.With Constraint.Or object.GetType() object.MemberwiseClone() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework.Constraints Assembly: nunit.framework.dll Syntax public class CollectionEquivalentConstraint : CollectionItemsEqualConstraint, IConstraint, IResolveConstraint Constructors View Source CollectionEquivalentConstraint(IEnumerable) Construct a CollectionEquivalentConstraint Declaration public CollectionEquivalentConstraint(IEnumerable expected) Parameters Type Name Description IEnumerable expected Expected collection. Properties View Source Description The Description of what this constraint tests, for use in messages and in the ConstraintResult. Declaration public override string Description { get; } Property Value Type Description string Overrides Constraint.Description View Source DisplayName The display name of this Constraint for use by ToString(). The default value is the name of the constraint with trailing \"Constraint\" removed. Derived classes may set this to another name in their constructors. Declaration public override string DisplayName { get; } Property Value Type Description string Overrides Constraint.DisplayName Methods View Source ApplyTo<TActual>(TActual) Test whether the collection is equivalent to the expected. Declaration public override ConstraintResult ApplyTo<TActual>(TActual actual) Parameters Type Name Description TActual actual Actual collection to compare. Returns Type Description ConstraintResult A CollectionEquivalentConstraintResult indicating whether or not the two collections are equivalent. Type Parameters Name Description TActual Actual collection type. Overrides CollectionConstraint.ApplyTo<TActual>(TActual) View Source Matches(IEnumerable) Protected method to be implemented by derived classes Declaration protected override bool Matches(IEnumerable actual) Parameters Type Name Description IEnumerable actual Returns Type Description bool Overrides CollectionConstraint.Matches(IEnumerable) View Source Using<TActualElement, TExpectedElement>(Func<TActualElement, TExpectedElement, bool>) Flag the constraint to use the supplied predicate function Declaration public CollectionEquivalentConstraint Using<TActualElement, TExpectedElement>(Func<TActualElement, TExpectedElement, bool> comparison) Parameters Type Name Description Func<TActualElement, TExpectedElement, bool> comparison The comparison function to use. Returns Type Description CollectionEquivalentConstraint Self. Type Parameters Name Description TActualElement The type of the elements in the actual value. TExpectedElement The type of the elements in the expected value. Implements IConstraint IResolveConstraint"
  },
  "api/NUnit.Framework.Constraints.CollectionEquivalentConstraintResult.html": {
    "href": "api/NUnit.Framework.Constraints.CollectionEquivalentConstraintResult.html",
    "title": "Class CollectionEquivalentConstraintResult | NUnit Docs",
    "summary": "Class CollectionEquivalentConstraintResult Provides a ConstraintResult for the CollectionEquivalentConstraint. Inheritance object ConstraintResult CollectionEquivalentConstraintResult Inherited Members ConstraintResult.WriteMessageTo(MessageWriter) ConstraintResult.WriteActualValueTo(MessageWriter) ConstraintResult.ActualValue ConstraintResult.Status ConstraintResult.IsSuccess ConstraintResult.Name ConstraintResult.Description object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework.Constraints Assembly: nunit.framework.dll Syntax public class CollectionEquivalentConstraintResult : ConstraintResult Constructors View Source CollectionEquivalentConstraintResult(CollectionEquivalentConstraint, CollectionTallyResult, object?, bool) Construct a CollectionEquivalentConstraintResult using a CollectionTally.CollectionTallyResult. Declaration public CollectionEquivalentConstraintResult(CollectionEquivalentConstraint constraint, CollectionTally.CollectionTallyResult tallyResult, object? actual, bool isSuccess) Parameters Type Name Description CollectionEquivalentConstraint constraint Source CollectionEquivalentConstraint. CollectionTally.CollectionTallyResult tallyResult Result of the collection comparison. object actual Actual collection to compare. bool isSuccess Whether or not the CollectionEquivalentConstraint succeeded. Methods View Source WriteAdditionalLinesTo(MessageWriter) Write any additional lines (following Expected: and But was:) for a failing constraint. Declaration public override void WriteAdditionalLinesTo(MessageWriter writer) Parameters Type Name Description MessageWriter writer The MessageWriter to write the failure message to. Overrides ConstraintResult.WriteAdditionalLinesTo(MessageWriter)"
  },
  "api/NUnit.Framework.Constraints.CollectionItemsEqualConstraint.html": {
    "href": "api/NUnit.Framework.Constraints.CollectionItemsEqualConstraint.html",
    "title": "Class CollectionItemsEqualConstraint | NUnit Docs",
    "summary": "Class CollectionItemsEqualConstraint CollectionItemsEqualConstraint is the abstract base class for all collection constraints that apply some notion of item equality as a part of their operation. Inheritance object Constraint CollectionConstraint CollectionItemsEqualConstraint CollectionEquivalentConstraint CollectionSubsetConstraint CollectionSupersetConstraint DictionaryContainsKeyValuePairConstraint DictionaryContainsValueConstraint UniqueItemsConstraint Implements IConstraint IResolveConstraint Inherited Members CollectionConstraint.IsEmpty(IEnumerable) CollectionConstraint.ApplyTo<TActual>(TActual) CollectionConstraint.Matches(IEnumerable) Constraint.ApplyTo<TActual>(ActualValueDelegate<TActual>) Constraint.ApplyTo<TActual>(ref TActual) Constraint.ApplyToAsync<TActual>(Func<Task<TActual>>) Constraint.GetTestObject<TActual>(ActualValueDelegate<TActual>) Constraint.ToString() Constraint.GetStringRepresentation(IEnumerable) Constraint.GetStringRepresentation() Constraint.After(int) Constraint.After(int, int) Constraint.DisplayName Constraint.Description Constraint.Arguments Constraint.Builder Constraint.And Constraint.With Constraint.Or object.GetType() object.MemberwiseClone() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework.Constraints Assembly: nunit.framework.dll Syntax public abstract class CollectionItemsEqualConstraint : CollectionConstraint, IConstraint, IResolveConstraint Constructors View Source CollectionItemsEqualConstraint() Construct an empty CollectionConstraint Declaration protected CollectionItemsEqualConstraint() View Source CollectionItemsEqualConstraint(object?) Construct a CollectionConstraint Declaration protected CollectionItemsEqualConstraint(object? arg) Parameters Type Name Description object arg Properties View Source IgnoreCase Flag the constraint to ignore case and return self. Declaration public CollectionItemsEqualConstraint IgnoreCase { get; } Property Value Type Description CollectionItemsEqualConstraint View Source IgnoreLineEndingFormat Flag the constraint to ignore line ending format (\\r vs. \\n vs. \\r\\n) and return self. Declaration public CollectionItemsEqualConstraint IgnoreLineEndingFormat { get; } Property Value Type Description CollectionItemsEqualConstraint View Source IgnoreWhiteSpace Flag the constraint to ignore white space and return self. Declaration public CollectionItemsEqualConstraint IgnoreWhiteSpace { get; } Property Value Type Description CollectionItemsEqualConstraint View Source IgnoringCase Get a flag indicating whether the user requested that case be ignored. Declaration protected bool IgnoringCase { get; } Property Value Type Description bool View Source IgnoringLineEndingFormat Get a flag indicating whether the user requested that line ending format be ignored. Declaration protected bool IgnoringLineEndingFormat { get; } Property Value Type Description bool View Source IgnoringWhiteSpace Get a flag indicating whether the user requested that white space be ignored. Declaration protected bool IgnoringWhiteSpace { get; } Property Value Type Description bool View Source UsingExternalComparer Get a flag indicating whether any external comparers are in use. Declaration protected bool UsingExternalComparer { get; } Property Value Type Description bool Methods View Source ItemsEqual(object?, object?) Compares two collection members for equality Declaration protected bool ItemsEqual(object? x, object? y) Parameters Type Name Description object x object y Returns Type Description bool View Source Tally(IEnumerable) Return a new CollectionTally for use in making tests Declaration protected CollectionTally Tally(IEnumerable c) Parameters Type Name Description IEnumerable c The collection to be included in the tally Returns Type Description CollectionTally View Source Using(IComparer) Flag the constraint to use the supplied IComparer object. Declaration public CollectionItemsEqualConstraint Using(IComparer comparer) Parameters Type Name Description IComparer comparer The IComparer object to use. Returns Type Description CollectionItemsEqualConstraint View Source Using(IEqualityComparer) Flag the constraint to use the supplied IEqualityComparer object. Declaration public CollectionItemsEqualConstraint Using(IEqualityComparer comparer) Parameters Type Name Description IEqualityComparer comparer The IComparer object to use. Returns Type Description CollectionItemsEqualConstraint View Source UsingPropertiesComparer() Enables comparing of instance properties. Declaration public CollectionItemsEqualConstraint UsingPropertiesComparer() Returns Type Description CollectionItemsEqualConstraint Remarks This allows comparing classes that don't implement IEquatable<T> without having to compare each property separately in own code. View Source UsingPropertiesComparer(Func<PropertiesComparerConfigurationUntyped, PropertiesComparerConfigurationUntyped>) Enables comparing of instance properties. Declaration public CollectionItemsEqualConstraint UsingPropertiesComparer(Func<PropertiesComparerConfigurationUntyped, PropertiesComparerConfigurationUntyped> configure) Parameters Type Name Description Func<PropertiesComparerConfigurationUntyped, PropertiesComparerConfigurationUntyped> configure Returns Type Description CollectionItemsEqualConstraint Remarks This allows comparing classes that don't implement IEquatable<T> without having to compare each property separately in own code. View Source Using<T>(IComparer<T>) Flag the constraint to use the supplied IComparer object. Declaration public CollectionItemsEqualConstraint Using<T>(IComparer<T> comparer) Parameters Type Name Description IComparer<T> comparer The IComparer object to use. Returns Type Description CollectionItemsEqualConstraint Type Parameters Name Description T View Source Using<T>(IEqualityComparer<T>) Flag the constraint to use the supplied IEqualityComparer object. Declaration public CollectionItemsEqualConstraint Using<T>(IEqualityComparer<T> comparer) Parameters Type Name Description IEqualityComparer<T> comparer The IComparer object to use. Returns Type Description CollectionItemsEqualConstraint Type Parameters Name Description T View Source Using<T>(Comparison<T>) Flag the constraint to use the supplied Comparison object. Declaration public CollectionItemsEqualConstraint Using<T>(Comparison<T> comparison) Parameters Type Name Description Comparison<T> comparison The Comparison object to use. Returns Type Description CollectionItemsEqualConstraint Type Parameters Name Description T View Source Using<T>(Func<T, T, bool>) Flag the constraint to use the supplied boolean-returning delegate. Declaration public CollectionItemsEqualConstraint Using<T>(Func<T, T, bool> comparer) Parameters Type Name Description Func<T, T, bool> comparer The supplied boolean-returning delegate to use. Returns Type Description CollectionItemsEqualConstraint Type Parameters Name Description T Implements IConstraint IResolveConstraint"
  },
  "api/NUnit.Framework.Constraints.CollectionOperator.html": {
    "href": "api/NUnit.Framework.Constraints.CollectionOperator.html",
    "title": "Class CollectionOperator | NUnit Docs",
    "summary": "Class CollectionOperator Abstract base for operators that indicate how to apply a constraint to items in a collection. Inheritance object ConstraintOperator PrefixOperator CollectionOperator AllOperator NoneOperator SomeOperator Inherited Members PrefixOperator.Reduce(ConstraintBuilder.ConstraintStack) PrefixOperator.ApplyPrefix(IConstraint) ConstraintOperator.left_precedence ConstraintOperator.right_precedence ConstraintOperator.LeftContext ConstraintOperator.RightContext ConstraintOperator.LeftPrecedence ConstraintOperator.RightPrecedence object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework.Constraints Assembly: nunit.framework.dll Syntax public abstract class CollectionOperator : PrefixOperator Constructors View Source CollectionOperator() Constructs a CollectionOperator Declaration protected CollectionOperator()"
  },
  "api/NUnit.Framework.Constraints.CollectionOrderedConstraint.html": {
    "href": "api/NUnit.Framework.Constraints.CollectionOrderedConstraint.html",
    "title": "Class CollectionOrderedConstraint | NUnit Docs",
    "summary": "Class CollectionOrderedConstraint CollectionOrderedConstraint is used to test whether a collection is ordered. Inheritance object Constraint CollectionConstraint CollectionOrderedConstraint Implements IConstraint IResolveConstraint Inherited Members CollectionConstraint.IsEmpty(IEnumerable) Constraint.ApplyTo<TActual>(ActualValueDelegate<TActual>) Constraint.ApplyTo<TActual>(ref TActual) Constraint.ApplyToAsync<TActual>(Func<Task<TActual>>) Constraint.GetTestObject<TActual>(ActualValueDelegate<TActual>) Constraint.ToString() Constraint.GetStringRepresentation(IEnumerable) Constraint.After(int) Constraint.After(int, int) Constraint.Arguments Constraint.Builder Constraint.And Constraint.With Constraint.Or object.GetType() object.MemberwiseClone() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework.Constraints Assembly: nunit.framework.dll Syntax public class CollectionOrderedConstraint : CollectionConstraint, IConstraint, IResolveConstraint Constructors View Source CollectionOrderedConstraint() Construct a CollectionOrderedConstraint Declaration public CollectionOrderedConstraint() Properties View Source Ascending If used performs a default ascending comparison Declaration public CollectionOrderedConstraint Ascending { get; } Property Value Type Description CollectionOrderedConstraint View Source Descending If used performs a reverse comparison Declaration public CollectionOrderedConstraint Descending { get; } Property Value Type Description CollectionOrderedConstraint View Source Description The Description of what this constraint tests, for use in messages and in the ConstraintResult. Declaration public override string Description { get; } Property Value Type Description string Overrides Constraint.Description View Source DisplayName The display name of this Constraint for use by ToString(). The default value is the name of the constraint with trailing \"Constraint\" removed. Derived classes may set this to another name in their constructors. Declaration public override string DisplayName { get; } Property Value Type Description string Overrides Constraint.DisplayName View Source Then Then signals a break between two ordering steps Declaration public CollectionOrderedConstraint Then { get; } Property Value Type Description CollectionOrderedConstraint Methods View Source ApplyTo<TActual>(TActual) Test whether the constraint is satisfied by a given value Declaration public override ConstraintResult ApplyTo<TActual>(TActual actual) Parameters Type Name Description TActual actual The value to be tested Returns Type Description ConstraintResult True for success, false for failure Type Parameters Name Description TActual Overrides CollectionConstraint.ApplyTo<TActual>(TActual) View Source By(string) Modifies the constraint to test ordering by the value of a specified property and returns self. Declaration public CollectionOrderedConstraint By(string propertyName) Parameters Type Name Description string propertyName Returns Type Description CollectionOrderedConstraint View Source GetStringRepresentation() Returns the string representation of the constraint. Declaration protected override string GetStringRepresentation() Returns Type Description string Overrides Constraint.GetStringRepresentation() View Source Matches(IEnumerable) Test whether the collection is ordered Declaration protected override bool Matches(IEnumerable actual) Parameters Type Name Description IEnumerable actual Returns Type Description bool Overrides CollectionConstraint.Matches(IEnumerable) View Source Using(IComparer) Modifies the constraint to use an IComparer and returns self. Declaration public CollectionOrderedConstraint Using(IComparer comparer) Parameters Type Name Description IComparer comparer Returns Type Description CollectionOrderedConstraint View Source Using<T>(IComparer<T>) Modifies the constraint to use an IComparer<T> and returns self. Declaration public CollectionOrderedConstraint Using<T>(IComparer<T> comparer) Parameters Type Name Description IComparer<T> comparer Returns Type Description CollectionOrderedConstraint Type Parameters Name Description T View Source Using<T>(Comparison<T>) Modifies the constraint to use a Comparison<T> and returns self. Declaration public CollectionOrderedConstraint Using<T>(Comparison<T> comparer) Parameters Type Name Description Comparison<T> comparer Returns Type Description CollectionOrderedConstraint Type Parameters Name Description T Implements IConstraint IResolveConstraint"
  },
  "api/NUnit.Framework.Constraints.CollectionSubsetConstraint.html": {
    "href": "api/NUnit.Framework.Constraints.CollectionSubsetConstraint.html",
    "title": "Class CollectionSubsetConstraint | NUnit Docs",
    "summary": "Class CollectionSubsetConstraint CollectionSubsetConstraint is used to determine whether one collection is a subset of another Inheritance object Constraint CollectionConstraint CollectionItemsEqualConstraint CollectionSubsetConstraint Implements IConstraint IResolveConstraint Inherited Members CollectionItemsEqualConstraint.Using(IComparer) CollectionItemsEqualConstraint.Using<T>(IComparer<T>) CollectionItemsEqualConstraint.Using<T>(Comparison<T>) CollectionItemsEqualConstraint.Using(IEqualityComparer) CollectionItemsEqualConstraint.Using<T>(IEqualityComparer<T>) CollectionItemsEqualConstraint.Using<T>(Func<T, T, bool>) CollectionItemsEqualConstraint.UsingPropertiesComparer() CollectionItemsEqualConstraint.UsingPropertiesComparer(Func<PropertiesComparerConfigurationUntyped, PropertiesComparerConfigurationUntyped>) CollectionItemsEqualConstraint.ItemsEqual(object, object) CollectionItemsEqualConstraint.Tally(IEnumerable) CollectionItemsEqualConstraint.IgnoringCase CollectionItemsEqualConstraint.IgnoringWhiteSpace CollectionItemsEqualConstraint.IgnoringLineEndingFormat CollectionItemsEqualConstraint.UsingExternalComparer CollectionItemsEqualConstraint.IgnoreCase CollectionItemsEqualConstraint.IgnoreWhiteSpace CollectionItemsEqualConstraint.IgnoreLineEndingFormat CollectionConstraint.IsEmpty(IEnumerable) Constraint.ApplyTo<TActual>(ActualValueDelegate<TActual>) Constraint.ApplyTo<TActual>(ref TActual) Constraint.ApplyToAsync<TActual>(Func<Task<TActual>>) Constraint.GetTestObject<TActual>(ActualValueDelegate<TActual>) Constraint.ToString() Constraint.GetStringRepresentation(IEnumerable) Constraint.GetStringRepresentation() Constraint.After(int) Constraint.After(int, int) Constraint.Arguments Constraint.Builder Constraint.And Constraint.With Constraint.Or object.GetType() object.MemberwiseClone() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework.Constraints Assembly: nunit.framework.dll Syntax public class CollectionSubsetConstraint : CollectionItemsEqualConstraint, IConstraint, IResolveConstraint Constructors View Source CollectionSubsetConstraint(IEnumerable) Construct a CollectionSubsetConstraint Declaration public CollectionSubsetConstraint(IEnumerable expected) Parameters Type Name Description IEnumerable expected The collection that the actual value is expected to be a subset of Properties View Source Description The Description of what this constraint tests, for use in messages and in the ConstraintResult. Declaration public override string Description { get; } Property Value Type Description string Overrides Constraint.Description View Source DisplayName The display name of this Constraint for use by ToString(). The default value is the name of the constraint with trailing \"Constraint\" removed. Derived classes may set this to another name in their constructors. Declaration public override string DisplayName { get; } Property Value Type Description string Overrides Constraint.DisplayName Methods View Source ApplyTo<TActual>(TActual) Test whether the constraint is satisfied by a given value. Declaration public override ConstraintResult ApplyTo<TActual>(TActual actual) Parameters Type Name Description TActual actual Returns Type Description ConstraintResult Type Parameters Name Description TActual Overrides CollectionConstraint.ApplyTo<TActual>(TActual) View Source Matches(IEnumerable) Test whether the actual collection is a subset of the expected collection provided. Declaration protected override bool Matches(IEnumerable actual) Parameters Type Name Description IEnumerable actual Returns Type Description bool Overrides CollectionConstraint.Matches(IEnumerable) View Source Using<TSubsetElement, TSupersetElement>(Func<TSubsetElement, TSupersetElement, bool>) Flag the constraint to use the supplied predicate function Declaration public CollectionSubsetConstraint Using<TSubsetElement, TSupersetElement>(Func<TSubsetElement, TSupersetElement, bool> comparison) Parameters Type Name Description Func<TSubsetElement, TSupersetElement, bool> comparison The comparison function to use. Returns Type Description CollectionSubsetConstraint Self. Type Parameters Name Description TSubsetElement The type of the elements in the actual subset. TSupersetElement The type of the elements in the expected superset. Implements IConstraint IResolveConstraint"
  },
  "api/NUnit.Framework.Constraints.CollectionSupersetConstraint.html": {
    "href": "api/NUnit.Framework.Constraints.CollectionSupersetConstraint.html",
    "title": "Class CollectionSupersetConstraint | NUnit Docs",
    "summary": "Class CollectionSupersetConstraint CollectionSupersetConstraint is used to determine whether one collection is a superset of another Inheritance object Constraint CollectionConstraint CollectionItemsEqualConstraint CollectionSupersetConstraint Implements IConstraint IResolveConstraint Inherited Members CollectionItemsEqualConstraint.Using(IComparer) CollectionItemsEqualConstraint.Using<T>(IComparer<T>) CollectionItemsEqualConstraint.Using<T>(Comparison<T>) CollectionItemsEqualConstraint.Using(IEqualityComparer) CollectionItemsEqualConstraint.Using<T>(IEqualityComparer<T>) CollectionItemsEqualConstraint.Using<T>(Func<T, T, bool>) CollectionItemsEqualConstraint.UsingPropertiesComparer() CollectionItemsEqualConstraint.UsingPropertiesComparer(Func<PropertiesComparerConfigurationUntyped, PropertiesComparerConfigurationUntyped>) CollectionItemsEqualConstraint.ItemsEqual(object, object) CollectionItemsEqualConstraint.Tally(IEnumerable) CollectionItemsEqualConstraint.IgnoringCase CollectionItemsEqualConstraint.IgnoringWhiteSpace CollectionItemsEqualConstraint.IgnoringLineEndingFormat CollectionItemsEqualConstraint.UsingExternalComparer CollectionItemsEqualConstraint.IgnoreCase CollectionItemsEqualConstraint.IgnoreWhiteSpace CollectionItemsEqualConstraint.IgnoreLineEndingFormat CollectionConstraint.IsEmpty(IEnumerable) Constraint.ApplyTo<TActual>(ActualValueDelegate<TActual>) Constraint.ApplyTo<TActual>(ref TActual) Constraint.ApplyToAsync<TActual>(Func<Task<TActual>>) Constraint.GetTestObject<TActual>(ActualValueDelegate<TActual>) Constraint.ToString() Constraint.GetStringRepresentation(IEnumerable) Constraint.GetStringRepresentation() Constraint.After(int) Constraint.After(int, int) Constraint.Arguments Constraint.Builder Constraint.And Constraint.With Constraint.Or object.GetType() object.MemberwiseClone() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework.Constraints Assembly: nunit.framework.dll Syntax public class CollectionSupersetConstraint : CollectionItemsEqualConstraint, IConstraint, IResolveConstraint Constructors View Source CollectionSupersetConstraint(IEnumerable) Construct a CollectionSupersetConstraint Declaration public CollectionSupersetConstraint(IEnumerable expected) Parameters Type Name Description IEnumerable expected The collection that the actual value is expected to be a superset of Properties View Source Description The Description of what this constraint tests, for use in messages and in the ConstraintResult. Declaration public override string Description { get; } Property Value Type Description string Overrides Constraint.Description View Source DisplayName The display name of this Constraint for use by ToString(). The default value is the name of the constraint with trailing \"Constraint\" removed. Derived classes may set this to another name in their constructors. Declaration public override string DisplayName { get; } Property Value Type Description string Overrides Constraint.DisplayName Methods View Source ApplyTo<TActual>(TActual) Test whether the constraint is satisfied by a given value. Declaration public override ConstraintResult ApplyTo<TActual>(TActual actual) Parameters Type Name Description TActual actual Returns Type Description ConstraintResult Type Parameters Name Description TActual Overrides CollectionConstraint.ApplyTo<TActual>(TActual) View Source Matches(IEnumerable) Test whether the actual collection is a superset of the expected collection provided. Declaration protected override bool Matches(IEnumerable actual) Parameters Type Name Description IEnumerable actual Returns Type Description bool Overrides CollectionConstraint.Matches(IEnumerable) View Source Using<TSupersetElement, TSubsetElement>(Func<TSupersetElement, TSubsetElement, bool>) Flag the constraint to use the supplied predicate function Declaration public CollectionSupersetConstraint Using<TSupersetElement, TSubsetElement>(Func<TSupersetElement, TSubsetElement, bool> comparison) Parameters Type Name Description Func<TSupersetElement, TSubsetElement, bool> comparison The comparison function to use. Returns Type Description CollectionSupersetConstraint Self. Type Parameters Name Description TSupersetElement The type of the elements in the actual superset. TSubsetElement The type of the elements in the expected subset. Implements IConstraint IResolveConstraint"
  },
  "api/NUnit.Framework.Constraints.CollectionTally.CollectionTallyResult.html": {
    "href": "api/NUnit.Framework.Constraints.CollectionTally.CollectionTallyResult.html",
    "title": "Class CollectionTally.CollectionTallyResult | NUnit Docs",
    "summary": "Class CollectionTally.CollectionTallyResult The result of a CollectionTally. Inheritance object CollectionTally.CollectionTallyResult Inherited Members object.GetType() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework.Constraints Assembly: nunit.framework.dll Syntax public sealed class CollectionTally.CollectionTallyResult Constructors View Source CollectionTallyResult(List<object>, List<object>) Initializes a new instance of the CollectionTally.CollectionTallyResult class with the given fields. Declaration public CollectionTallyResult(List<object> missingItems, List<object> extraItems) Parameters Type Name Description List<object> missingItems List<object> extraItems Properties View Source ExtraItems Items that were not in the expected collection. Declaration public List<object> ExtraItems { get; } Property Value Type Description List<object> View Source MissingItems Items that were not accounted for in the expected collection. Declaration public List<object> MissingItems { get; } Property Value Type Description List<object>"
  },
  "api/NUnit.Framework.Constraints.CollectionTally.html": {
    "href": "api/NUnit.Framework.Constraints.CollectionTally.html",
    "title": "Class CollectionTally | NUnit Docs",
    "summary": "Class CollectionTally CollectionTally counts (tallies) the number of occurrences of each object in one or more enumerations. Inheritance object CollectionTally Inherited Members object.GetType() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework.Constraints Assembly: nunit.framework.dll Syntax public sealed class CollectionTally Constructors View Source CollectionTally(NUnitEqualityComparer, IEnumerable) Construct a CollectionTally object from a comparer and a collection. Declaration public CollectionTally(NUnitEqualityComparer comparer, IEnumerable c) Parameters Type Name Description NUnitEqualityComparer comparer The comparer to use for equality. IEnumerable c The expected collection to compare against. Properties View Source Result The result of the comparison between the two collections. Declaration public CollectionTally.CollectionTallyResult Result { get; } Property Value Type Description CollectionTally.CollectionTallyResult Methods View Source TryRemove(IEnumerable) Try to remove a set of objects from the tally. Declaration public void TryRemove(IEnumerable c) Parameters Type Name Description IEnumerable c The objects to remove. View Source TryRemove(object) Try to remove an object from the tally. Declaration public void TryRemove(object o) Parameters Type Name Description object o The object to remove."
  },
  "api/NUnit.Framework.Constraints.ComparisonAdapter.html": {
    "href": "api/NUnit.Framework.Constraints.ComparisonAdapter.html",
    "title": "Class ComparisonAdapter | NUnit Docs",
    "summary": "Class ComparisonAdapter ComparisonAdapter class centralizes all comparisons of values in NUnit, adapting to the use of any provided IComparer, IComparer<T> or Comparison<T>. Inheritance object ComparisonAdapter Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework.Constraints Assembly: nunit.framework.dll Syntax public abstract class ComparisonAdapter Constructors View Source ComparisonAdapter() Declaration protected ComparisonAdapter() Properties View Source Default Gets the default ComparisonAdapter, which wraps an NUnitComparer object. Declaration public static ComparisonAdapter Default { get; } Property Value Type Description ComparisonAdapter Methods View Source Compare(object?, object?) Compares two objects Declaration public abstract int Compare(object? expected, object? actual) Parameters Type Name Description object expected object actual Returns Type Description int View Source For(IComparer) Returns a ComparisonAdapter that wraps an IComparer Declaration public static ComparisonAdapter For(IComparer comparer) Parameters Type Name Description IComparer comparer Returns Type Description ComparisonAdapter View Source For<T>(IComparer<T>) Returns a ComparisonAdapter that wraps an IComparer<T> Declaration public static ComparisonAdapter For<T>(IComparer<T> comparer) Parameters Type Name Description IComparer<T> comparer Returns Type Description ComparisonAdapter Type Parameters Name Description T View Source For<T>(Comparison<T>) Returns a ComparisonAdapter that wraps a Comparison<T> Declaration public static ComparisonAdapter For<T>(Comparison<T> comparer) Parameters Type Name Description Comparison<T> comparer Returns Type Description ComparisonAdapter Type Parameters Name Description T"
  },
  "api/NUnit.Framework.Constraints.ComparisonConstraint.html": {
    "href": "api/NUnit.Framework.Constraints.ComparisonConstraint.html",
    "title": "Class ComparisonConstraint | NUnit Docs",
    "summary": "Class ComparisonConstraint Abstract base class for constraints that compare values to determine if one is greater than, equal to or less than the other. Inheritance object Constraint ComparisonConstraint GreaterThanConstraint GreaterThanOrEqualConstraint LessThanConstraint LessThanOrEqualConstraint Implements IConstraint IResolveConstraint Inherited Members Constraint.ApplyTo<TActual>(ActualValueDelegate<TActual>) Constraint.ApplyTo<TActual>(ref TActual) Constraint.ApplyToAsync<TActual>(Func<Task<TActual>>) Constraint.GetTestObject<TActual>(ActualValueDelegate<TActual>) Constraint.ToString() Constraint.GetStringRepresentation(IEnumerable) Constraint.GetStringRepresentation() Constraint.After(int) Constraint.After(int, int) Constraint.DisplayName Constraint.Arguments Constraint.Builder Constraint.And Constraint.With Constraint.Or object.GetType() object.MemberwiseClone() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework.Constraints Assembly: nunit.framework.dll Syntax public abstract class ComparisonConstraint : Constraint, IConstraint, IResolveConstraint Constructors View Source ComparisonConstraint(object, string) Initializes a new instance of the ComparisonConstraint class. Declaration protected ComparisonConstraint(object expected, string comparisonText) Parameters Type Name Description object expected The value against which to make a comparison. string comparisonText The text indicating the type of comparison. Properties View Source Description The Description of what this constraint tests, for use in messages and in the ConstraintResult. Declaration public override string Description { get; } Property Value Type Description string Overrides Constraint.Description View Source Percent Switches the .Within() modifier to interpret its tolerance as a percentage that the actual values is allowed to deviate from the expected value. Declaration public ComparisonConstraint Percent { get; } Property Value Type Description ComparisonConstraint Self Methods View Source ApplyTo<TActual>(TActual) Test whether the constraint is satisfied by a given value Declaration public override ConstraintResult ApplyTo<TActual>(TActual actual) Parameters Type Name Description TActual actual The value to be tested Returns Type Description ConstraintResult A ConstraintResult Type Parameters Name Description TActual Overrides Constraint.ApplyTo<TActual>(TActual) View Source PerformComparison(ComparisonAdapter, object, object, Tolerance) Protected function overridden by derived class to actually perform the comparison Declaration protected abstract bool PerformComparison(ComparisonAdapter comparer, object actual, object expected, Tolerance tolerance) Parameters Type Name Description ComparisonAdapter comparer object actual object expected Tolerance tolerance Returns Type Description bool View Source Using(IComparer) Modifies the constraint to use an IComparer and returns self Declaration public ComparisonConstraint Using(IComparer comparer) Parameters Type Name Description IComparer comparer The comparer used for comparison tests Returns Type Description ComparisonConstraint A constraint modified to use the given comparer View Source Using<T>(IComparer<T>) Modifies the constraint to use an IComparer<T> and returns self Declaration public ComparisonConstraint Using<T>(IComparer<T> comparer) Parameters Type Name Description IComparer<T> comparer The comparer used for comparison tests Returns Type Description ComparisonConstraint A constraint modified to use the given comparer Type Parameters Name Description T View Source Using<T>(Comparison<T>) Modifies the constraint to use a Comparison<T> and returns self Declaration public ComparisonConstraint Using<T>(Comparison<T> comparer) Parameters Type Name Description Comparison<T> comparer The comparer used for comparison tests Returns Type Description ComparisonConstraint A constraint modified to use the given comparer Type Parameters Name Description T View Source Within(object) Set the tolerance for use in this comparison Declaration public ComparisonConstraint Within(object amount) Parameters Type Name Description object amount Returns Type Description ComparisonConstraint Implements IConstraint IResolveConstraint"
  },
  "api/NUnit.Framework.Constraints.Constraint.html": {
    "href": "api/NUnit.Framework.Constraints.Constraint.html",
    "title": "Class Constraint | NUnit Docs",
    "summary": "Class Constraint The Constraint class is the base of all built-in constraints within NUnit. It provides the operator overloads used to combine constraints. Inheritance object Constraint AnyOfConstraint AttributeExistsConstraint BinaryConstraint CollectionConstraint ComparisonConstraint ContainsConstraint CountZeroConstraint DefaultConstraint DictionaryContainsKeyConstraint EmptyConstraint EmptyDirectoryConstraint EmptyGuidConstraint EqualConstraint EqualDateTimeOffsetConstraintWithSameOffset EqualNumericWithoutUsingConstraint<T> EqualStringWithoutUsingConstraint EqualTimeBaseConstraint<T> EqualTimeBasedConstraintWithTimeSpanTolerance<T> EqualUsingConstraint<T> ExactCountConstraint FalseConstraint FileOrDirectoryExistsConstraint MultipleOfConstraint NaNConstraint NullConstraint PredicateConstraint<T> PrefixConstraint PropertyExistsConstraint RangeConstraint RegexConstraint SameAsConstraint StringConstraint ThrowsExceptionConstraint ThrowsNothingConstraint TrueConstraint TypeConstraint XmlSerializableConstraint Implements IConstraint IResolveConstraint Inherited Members object.GetType() object.MemberwiseClone() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework.Constraints Assembly: nunit.framework.dll Syntax public abstract class Constraint : IConstraint, IResolveConstraint Constructors View Source Constraint(params object?[]) Construct a constraint with optional arguments Declaration protected Constraint(params object?[] args) Parameters Type Name Description object[] args Arguments to be saved Properties View Source And Returns a ConstraintExpression by appending And to the current constraint. Declaration public ConstraintExpression And { get; } Property Value Type Description ConstraintExpression View Source Arguments Arguments provided to this Constraint, for use in formatting the description. Declaration public object?[] Arguments { get; } Property Value Type Description object[] View Source Builder The ConstraintBuilder holding this constraint Declaration public ConstraintBuilder? Builder { get; set; } Property Value Type Description ConstraintBuilder View Source Description The Description of what this constraint tests, for use in messages and in the ConstraintResult. Declaration public abstract string Description { get; } Property Value Type Description string View Source DisplayName The display name of this Constraint for use by ToString(). The default value is the name of the constraint with trailing \"Constraint\" removed. Derived classes may set this to another name in their constructors. Declaration public virtual string DisplayName { get; } Property Value Type Description string View Source Or Returns a ConstraintExpression by appending Or to the current constraint. Declaration public ConstraintExpression Or { get; } Property Value Type Description ConstraintExpression View Source With Returns a ConstraintExpression by appending And to the current constraint. Declaration public ConstraintExpression With { get; } Property Value Type Description ConstraintExpression Methods View Source After(int) Returns a DelayedConstraint.WithRawDelayInterval with the specified delay time. Declaration public DelayedConstraint.WithRawDelayInterval After(int delay) Parameters Type Name Description int delay The delay, which defaults to milliseconds. Returns Type Description DelayedConstraint.WithRawDelayInterval View Source After(int, int) Returns a DelayedConstraint with the specified delay time and polling interval. Declaration public DelayedConstraint After(int delayInMilliseconds, int pollingInterval) Parameters Type Name Description int delayInMilliseconds The delay in milliseconds. int pollingInterval The interval at which to test the constraint, in milliseconds. Returns Type Description DelayedConstraint View Source ApplyToAsync<TActual>(Func<Task<TActual>>) Applies the constraint to a delegate that returns the task. The default implementation simply evaluates the delegate and awaits the task but derived classes may override it to provide for delayed processing. Declaration public virtual Task<ConstraintResult> ApplyToAsync<TActual>(Func<Task<TActual>> taskDel) Parameters Type Name Description Func<Task<TActual>> taskDel Returns Type Description Task<ConstraintResult> Type Parameters Name Description TActual View Source ApplyTo<TActual>(ActualValueDelegate<TActual>) Applies the constraint to an ActualValueDelegate that returns the value to be tested. The default implementation simply evaluates the delegate but derived classes may override it to provide for delayed processing. Declaration public virtual ConstraintResult ApplyTo<TActual>(ActualValueDelegate<TActual> del) Parameters Type Name Description ActualValueDelegate<TActual> del An ActualValueDelegate Returns Type Description ConstraintResult A ConstraintResult Type Parameters Name Description TActual View Source ApplyTo<TActual>(TActual) Applies the constraint to an actual value, returning a ConstraintResult. Declaration public abstract ConstraintResult ApplyTo<TActual>(TActual actual) Parameters Type Name Description TActual actual The value to be tested Returns Type Description ConstraintResult A ConstraintResult Type Parameters Name Description TActual View Source ApplyTo<TActual>(ref TActual) Test whether the constraint is satisfied by a given reference. The default implementation simply dereferences the value but derived classes may override it to provide for delayed processing. Declaration [Obsolete(\"This was never implemented and will be removed.\")] public virtual ConstraintResult ApplyTo<TActual>(ref TActual actual) Parameters Type Name Description TActual actual A reference to the value to be tested Returns Type Description ConstraintResult A ConstraintResult Type Parameters Name Description TActual View Source GetStringRepresentation() Returns the string representation of this constraint Declaration protected virtual string GetStringRepresentation() Returns Type Description string View Source GetStringRepresentation(IEnumerable) Returns the string representation of this constraint and the passed in arguments Declaration protected string GetStringRepresentation(IEnumerable arguments) Parameters Type Name Description IEnumerable arguments Returns Type Description string View Source GetTestObject<TActual>(ActualValueDelegate<TActual>) Retrieves the value to be tested from an ActualValueDelegate. The default implementation simply evaluates the delegate but derived classes may override it to provide for delayed processing. Declaration protected virtual object? GetTestObject<TActual>(ActualValueDelegate<TActual> del) Parameters Type Name Description ActualValueDelegate<TActual> del An ActualValueDelegate Returns Type Description object Delegate evaluation result Type Parameters Name Description TActual View Source ToString() Default override of ToString returns the constraint DisplayName followed by any arguments within angle brackets. Declaration public override string ToString() Returns Type Description string Overrides object.ToString() Operators View Source operator &(Constraint, Constraint) This operator creates a constraint that is satisfied only if both argument constraints are satisfied. Declaration public static Constraint operator &(Constraint left, Constraint right) Parameters Type Name Description Constraint left Constraint right Returns Type Description Constraint View Source operator |(Constraint, Constraint) This operator creates a constraint that is satisfied if either of the argument constraints is satisfied. Declaration public static Constraint operator |(Constraint left, Constraint right) Parameters Type Name Description Constraint left Constraint right Returns Type Description Constraint View Source operator !(Constraint) This operator creates a constraint that is satisfied if the argument constraint is not satisfied. Declaration public static Constraint operator !(Constraint constraint) Parameters Type Name Description Constraint constraint Returns Type Description Constraint Implements IConstraint IResolveConstraint"
  },
  "api/NUnit.Framework.Constraints.ConstraintBuilder.ConstraintStack.html": {
    "href": "api/NUnit.Framework.Constraints.ConstraintBuilder.ConstraintStack.html",
    "title": "Class ConstraintBuilder.ConstraintStack | NUnit Docs",
    "summary": "Class ConstraintBuilder.ConstraintStack ConstraintStack is a type-safe stack for holding Constraints Inheritance object ConstraintBuilder.ConstraintStack Inherited Members object.GetType() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework.Constraints Assembly: nunit.framework.dll Syntax public sealed class ConstraintBuilder.ConstraintStack Constructors View Source ConstraintStack(ConstraintBuilder) Initializes a new instance of the ConstraintBuilder.ConstraintStack class. Declaration public ConstraintStack(ConstraintBuilder builder) Parameters Type Name Description ConstraintBuilder builder The ConstraintBuilder using this stack. Properties View Source Empty Gets a value indicating whether this ConstraintBuilder.ConstraintStack is empty. Declaration public bool Empty { get; } Property Value Type Description bool true if empty; otherwise, false. Methods View Source Pop() Pops this topmost constraint from the stack. As a side effect, the constraint's Builder field is set to null. Declaration public IConstraint Pop() Returns Type Description IConstraint The topmost constraint on the stack View Source Push(IConstraint) Pushes the specified constraint. As a side effect, the constraint's Builder field is set to the ConstraintBuilder owning this stack. Declaration public void Push(IConstraint constraint) Parameters Type Name Description IConstraint constraint The constraint to put onto the stack"
  },
  "api/NUnit.Framework.Constraints.ConstraintBuilder.html": {
    "href": "api/NUnit.Framework.Constraints.ConstraintBuilder.html",
    "title": "Class ConstraintBuilder | NUnit Docs",
    "summary": "Class ConstraintBuilder ConstraintBuilder maintains the stacks that are used in processing a ConstraintExpression. An OperatorStack is used to hold operators that are waiting for their operands to be reorganized. a ConstraintStack holds input constraints as well as the results of each operator applied. Inheritance object ConstraintBuilder Implements IResolveConstraint Inherited Members object.GetType() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework.Constraints Assembly: nunit.framework.dll Syntax public sealed class ConstraintBuilder : IResolveConstraint Constructors View Source ConstraintBuilder() Initializes a new instance of the ConstraintBuilder class. Declaration public ConstraintBuilder() Methods View Source Append(Constraint) Appends the specified constraint to the expression by pushing it on the constraint stack. Declaration public void Append(Constraint constraint) Parameters Type Name Description Constraint constraint The constraint to push. View Source Append(ConstraintOperator) Appends the specified operator to the expression by first reducing the operator stack and then pushing the new operator on the stack. Declaration public void Append(ConstraintOperator op) Parameters Type Name Description ConstraintOperator op The operator to push. View Source Replace(Constraint) Replaces the last pushed constraint with the specified constraint. Declaration public void Replace(Constraint constraint) Parameters Type Name Description Constraint constraint The constraint to replace the lastPushed with. View Source Resolve() Resolves this instance, returning a Constraint. If the Builder is not currently in a resolvable state, an exception is thrown. Declaration public IConstraint Resolve() Returns Type Description IConstraint The resolved constraint Implements IResolveConstraint"
  },
  "api/NUnit.Framework.Constraints.ConstraintExpression.html": {
    "href": "api/NUnit.Framework.Constraints.ConstraintExpression.html",
    "title": "Class ConstraintExpression | NUnit Docs",
    "summary": "Class ConstraintExpression ConstraintExpression represents a compound constraint in the process of being constructed from a series of syntactic elements. Individual elements are appended to the expression as they are reorganized. When a constraint is appended, it is returned as the value of the operation so that modifiers may be applied. However, any partially built expression is attached to the constraint for later resolution. When an operator is appended, the partial expression is returned. If it's a self-resolving operator, then a ResolvableConstraintExpression is returned. Inheritance object ConstraintExpression ItemsConstraintExpression ResolvableConstraintExpression Inherited Members object.GetType() object.MemberwiseClone() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework.Constraints Assembly: nunit.framework.dll Syntax public class ConstraintExpression Constructors View Source ConstraintExpression() Initializes a new instance of the ConstraintExpression class. Declaration public ConstraintExpression() View Source ConstraintExpression(ConstraintBuilder) Initializes a new instance of the ConstraintExpression class passing in a ConstraintBuilder, which may be pre-populated. Declaration public ConstraintExpression(ConstraintBuilder builder) Parameters Type Name Description ConstraintBuilder builder The builder. Fields View Source builder The ConstraintBuilder holding the elements recognized so far Declaration protected readonly ConstraintBuilder builder Field Value Type Description ConstraintBuilder Properties View Source All Returns a ConstraintExpression, which will apply the following constraint to all members of a collection, succeeding if all of them succeed. Declaration public ConstraintExpression All { get; } Property Value Type Description ConstraintExpression View Source Count Returns a new ConstraintExpression, which will apply the following constraint to the Count property of the object being tested. Declaration public ResolvableConstraintExpression Count { get; } Property Value Type Description ResolvableConstraintExpression View Source Default Returns a constraint that tests for default value Declaration public DefaultConstraint Default { get; } Property Value Type Description DefaultConstraint View Source Empty Returns a constraint that tests for empty Declaration public EmptyConstraint Empty { get; } Property Value Type Description EmptyConstraint View Source Even Returns a constraint that tests for a number to be even (i.e. a multiple of two) Declaration public MultipleOfConstraint Even { get; } Property Value Type Description MultipleOfConstraint View Source Exist Returns a constraint that succeeds if the value is a file or directory and it exists. Declaration public Constraint Exist { get; } Property Value Type Description Constraint View Source False Returns a constraint that tests for False Declaration public FalseConstraint False { get; } Property Value Type Description FalseConstraint View Source InnerException Returns a new ConstraintExpression, which will apply the following constraint to the InnerException property of the object being tested. Declaration public ResolvableConstraintExpression InnerException { get; } Property Value Type Description ResolvableConstraintExpression View Source Length Returns a new ConstraintExpression, which will apply the following constraint to the Length property of the object being tested. Declaration public ResolvableConstraintExpression Length { get; } Property Value Type Description ResolvableConstraintExpression View Source Message Returns a new ConstraintExpression, which will apply the following constraint to the Message property of the object being tested. Declaration public ResolvableConstraintExpression Message { get; } Property Value Type Description ResolvableConstraintExpression View Source NaN Returns a constraint that tests for NaN Declaration public NaNConstraint NaN { get; } Property Value Type Description NaNConstraint View Source Negative Returns a constraint that tests for a negative value Declaration public LessThanConstraint Negative { get; } Property Value Type Description LessThanConstraint View Source No Returns a ConstraintExpression that negates any following constraint. Declaration public ConstraintExpression No { get; } Property Value Type Description ConstraintExpression View Source None Returns a ConstraintExpression, which will apply the following constraint to all members of a collection, succeeding if all of them fail. Declaration public ConstraintExpression None { get; } Property Value Type Description ConstraintExpression View Source Not Returns a ConstraintExpression that negates any following constraint. Declaration public ConstraintExpression Not { get; } Property Value Type Description ConstraintExpression View Source Null Returns a constraint that tests for null Declaration public NullConstraint Null { get; } Property Value Type Description NullConstraint View Source Odd Returns a constraint that tests for a number to be odd. Declaration public MultipleOfConstraint Odd { get; } Property Value Type Description MultipleOfConstraint View Source One Returns a ItemsConstraintExpression, which will apply the following constraint to a collection of length one, succeeding only if exactly one of them succeeds. Declaration public ItemsConstraintExpression One { get; } Property Value Type Description ItemsConstraintExpression View Source Ordered Returns a constraint that tests whether a collection is ordered Declaration public CollectionOrderedConstraint Ordered { get; } Property Value Type Description CollectionOrderedConstraint View Source Positive Returns a constraint that tests for a positive value Declaration public GreaterThanConstraint Positive { get; } Property Value Type Description GreaterThanConstraint View Source Some Returns a ConstraintExpression, which will apply the following constraint to all members of a collection, succeeding if at least one of them succeeds. Declaration public ConstraintExpression Some { get; } Property Value Type Description ConstraintExpression View Source True Returns a constraint that tests for True Declaration public TrueConstraint True { get; } Property Value Type Description TrueConstraint View Source Unique Returns a constraint that tests whether a collection contains all unique items. Declaration public UniqueItemsConstraint Unique { get; } Property Value Type Description UniqueItemsConstraint View Source WhiteSpace Returns a constraint that tests for white-space Declaration public WhiteSpaceConstraint WhiteSpace { get; } Property Value Type Description WhiteSpaceConstraint View Source With With is currently a NOP - reserved for future use. Declaration public ConstraintExpression With { get; } Property Value Type Description ConstraintExpression View Source XmlSerializable Returns a constraint that tests whether an object graph is serializable in XML format. Declaration public XmlSerializableConstraint XmlSerializable { get; } Property Value Type Description XmlSerializableConstraint View Source Zero Returns a constraint that tests if item is equal to zero Declaration public EqualConstraint Zero { get; } Property Value Type Description EqualConstraint Methods View Source AnyOf(ICollection) Returns a constraint that tests if an item is equal to any of expected values Declaration public AnyOfConstraint AnyOf(ICollection expected) Parameters Type Name Description ICollection expected Expected values Returns Type Description AnyOfConstraint View Source AnyOf(params object?[]?) Returns a constraint that tests if an item is equal to any of parameters Declaration public AnyOfConstraint AnyOf(params object?[]? expected) Parameters Type Name Description object[] expected Expected values Returns Type Description AnyOfConstraint View Source Append(Constraint) Appends a constraint to the expression and returns that constraint, which is associated with the current state of the expression being built. Note that the constraint is not reduced at this time. For example, if there is a NotOperator on the stack we don't reduce and return a NotConstraint. The original constraint must be returned because it may support modifiers that are yet to be applied. Declaration public Constraint Append(Constraint constraint) Parameters Type Name Description Constraint constraint Returns Type Description Constraint View Source Append(ConstraintOperator) Appends an operator to the expression and returns the resulting expression itself. Declaration public ConstraintExpression Append(ConstraintOperator op) Parameters Type Name Description ConstraintOperator op Returns Type Description ConstraintExpression View Source Append(SelfResolvingOperator) Appends a self-resolving operator to the expression and returns a new ResolvableConstraintExpression. Declaration public ResolvableConstraintExpression Append(SelfResolvingOperator op) Parameters Type Name Description SelfResolvingOperator op Returns Type Description ResolvableConstraintExpression View Source Append<T>(T) Appends a constraint to the expression and returns that constraint, which is associated with the current state of the expression being built. Note that the constraint is not reduced at this time. For example, if there is a NotOperator on the stack we don't reduce and return a NotConstraint. The original constraint must be returned because it may support modifiers that are yet to be applied. Declaration public T Append<T>(T constraint) where T : Constraint Parameters Type Name Description T constraint Returns Type Description T Type Parameters Name Description T View Source AssignableFrom(Type) Returns a constraint that tests whether the actual value is assignable from the type supplied as an argument. Declaration public AssignableFromConstraint AssignableFrom(Type expectedType) Parameters Type Name Description Type expectedType Returns Type Description AssignableFromConstraint View Source AssignableFrom<TExpected>() Returns a constraint that tests whether the actual value is assignable from the type supplied as an argument. Declaration public AssignableFromConstraint AssignableFrom<TExpected>() Returns Type Description AssignableFromConstraint Type Parameters Name Description TExpected View Source AssignableTo(Type) Returns a constraint that tests whether the actual value is assignable from the type supplied as an argument. Declaration public AssignableToConstraint AssignableTo(Type expectedType) Parameters Type Name Description Type expectedType Returns Type Description AssignableToConstraint View Source AssignableTo<TExpected>() Returns a constraint that tests whether the actual value is assignable from the type supplied as an argument. Declaration public AssignableToConstraint AssignableTo<TExpected>() Returns Type Description AssignableToConstraint Type Parameters Name Description TExpected View Source AtLeast(object) Returns a constraint that tests whether the actual value is greater than or equal to the supplied argument Declaration public GreaterThanOrEqualConstraint AtLeast(object expected) Parameters Type Name Description object expected Returns Type Description GreaterThanOrEqualConstraint View Source AtMost(object) Returns a constraint that tests whether the actual value is less than or equal to the supplied argument Declaration public LessThanOrEqualConstraint AtMost(object expected) Parameters Type Name Description object expected Returns Type Description LessThanOrEqualConstraint View Source Attribute(Type) Returns a new AttributeConstraint checking for the presence of a particular attribute on an object. Declaration public ResolvableConstraintExpression Attribute(Type expectedType) Parameters Type Name Description Type expectedType Returns Type Description ResolvableConstraintExpression View Source Attribute<TExpected>() Returns a new AttributeConstraint checking for the presence of a particular attribute on an object. Declaration public ResolvableConstraintExpression Attribute<TExpected>() Returns Type Description ResolvableConstraintExpression Type Parameters Name Description TExpected View Source Contain(object?) Returns a new SomeItemsConstraint checking for the presence of a particular object in the collection. Declaration public SomeItemsConstraint Contain(object? expected) Parameters Type Name Description object expected Returns Type Description SomeItemsConstraint View Source Contain(string?) Returns a new ContainsConstraint. This constraint will, in turn, make use of the appropriate second-level constraint, depending on the type of the actual argument. This overload is only used if the item sought is a string, since any other type implies that we are looking for a collection member. Declaration public ContainsConstraint Contain(string? expected) Parameters Type Name Description string expected Returns Type Description ContainsConstraint View Source ContainKey(object) Returns a new DictionaryContainsKeyConstraint checking for the presence of a particular key in the Dictionary key collection. Declaration public DictionaryContainsKeyConstraint ContainKey(object expected) Parameters Type Name Description object expected The key to be matched in the Dictionary key collection Returns Type Description DictionaryContainsKeyConstraint View Source ContainValue(object?) Returns a new DictionaryContainsValueConstraint checking for the presence of a particular value in the Dictionary value collection. Declaration public DictionaryContainsValueConstraint ContainValue(object? expected) Parameters Type Name Description object expected The value to be matched in the Dictionary value collection Returns Type Description DictionaryContainsValueConstraint View Source Contain<T>(T?) Returns a new SomeItemsConstraint checking for the presence of a particular object in the collection. Declaration public SomeItemsConstraint<T> Contain<T>(T? expected) Parameters Type Name Description T expected Returns Type Description SomeItemsConstraint<T> Type Parameters Name Description T View Source Contains(object?) Returns a new SomeItemsConstraint checking for the presence of a particular object in the collection. To search for a substring instead of a collection element, use the Contains(string?) overload. Declaration public SomeItemsConstraint Contains(object? expected) Parameters Type Name Description object expected Returns Type Description SomeItemsConstraint View Source Contains(string?) Returns a new ContainsConstraint. This constraint will, in turn, make use of the appropriate second-level constraint, depending on the type of the actual argument. To search for a collection element instead of a substring, use the Contains(object?) overload. Declaration public ContainsConstraint Contains(string? expected) Parameters Type Name Description string expected Returns Type Description ContainsConstraint View Source Contains<T>(T?) Returns a new SomeItemsConstraint checking for the presence of a particular object in the collection. To search for a substring instead of a collection element, use the Contains(string?) overload. Declaration public SomeItemsConstraint<T> Contains<T>(T? expected) Parameters Type Name Description T expected Returns Type Description SomeItemsConstraint<T> Type Parameters Name Description T View Source EndWith(string) Returns a constraint that succeeds if the actual value ends with the substring supplied as an argument. Declaration public EndsWithConstraint EndWith(string expected) Parameters Type Name Description string expected Returns Type Description EndsWithConstraint View Source EndsWith(string) Returns a constraint that succeeds if the actual value ends with the substring supplied as an argument. Declaration public EndsWithConstraint EndsWith(string expected) Parameters Type Name Description string expected Returns Type Description EndsWithConstraint View Source EqualTo(byte) Returns a constraint that tests two numbers for equality Declaration public EqualNumericConstraint<byte> EqualTo(byte expected) Parameters Type Name Description byte expected Returns Type Description EqualNumericConstraint<byte> View Source EqualTo(DateTime) Returns a constraint that tests two date time instances for equality Declaration public EqualTimeBaseConstraint<DateTime> EqualTo(DateTime expected) Parameters Type Name Description DateTime expected Returns Type Description EqualTimeBaseConstraint<DateTime> View Source EqualTo(DateTimeOffset) Returns a constraint that tests two date time offset instances for equality Declaration public EqualDateTimeOffsetConstraint EqualTo(DateTimeOffset expected) Parameters Type Name Description DateTimeOffset expected Returns Type Description EqualDateTimeOffsetConstraint View Source EqualTo(decimal) Returns a constraint that tests two numbers for equality Declaration public EqualNumericConstraint<decimal> EqualTo(decimal expected) Parameters Type Name Description decimal expected Returns Type Description EqualNumericConstraint<decimal> View Source EqualTo(double) Returns a constraint that tests two numbers for equality Declaration public EqualNumericConstraint<double> EqualTo(double expected) Parameters Type Name Description double expected Returns Type Description EqualNumericConstraint<double> View Source EqualTo(short) Returns a constraint that tests two numbers for equality Declaration public EqualNumericConstraint<short> EqualTo(short expected) Parameters Type Name Description short expected Returns Type Description EqualNumericConstraint<short> View Source EqualTo(int) Returns a constraint that tests two numbers for equality Declaration public EqualNumericConstraint<int> EqualTo(int expected) Parameters Type Name Description int expected Returns Type Description EqualNumericConstraint<int> View Source EqualTo(long) Returns a constraint that tests two numbers for equality Declaration public EqualNumericConstraint<long> EqualTo(long expected) Parameters Type Name Description long expected Returns Type Description EqualNumericConstraint<long> View Source EqualTo(object?) Returns a constraint that tests two items for equality Declaration public EqualConstraint EqualTo(object? expected) Parameters Type Name Description object expected Returns Type Description EqualConstraint View Source EqualTo(sbyte) Returns a constraint that tests two numbers for equality Declaration public EqualNumericConstraint<sbyte> EqualTo(sbyte expected) Parameters Type Name Description sbyte expected Returns Type Description EqualNumericConstraint<sbyte> View Source EqualTo(float) Returns a constraint that tests two numbers for equality Declaration public EqualNumericConstraint<float> EqualTo(float expected) Parameters Type Name Description float expected Returns Type Description EqualNumericConstraint<float> View Source EqualTo(string?) Returns a constraint that tests two strings for equality Declaration public EqualStringConstraint EqualTo(string? expected) Parameters Type Name Description string expected Returns Type Description EqualStringConstraint View Source EqualTo(TimeSpan) Returns a constraint that tests two timespan instances for equality Declaration public EqualTimeBaseConstraint<TimeSpan> EqualTo(TimeSpan expected) Parameters Type Name Description TimeSpan expected Returns Type Description EqualTimeBaseConstraint<TimeSpan> View Source EqualTo(ushort) Returns a constraint that tests two numbers for equality Declaration public EqualNumericConstraint<ushort> EqualTo(ushort expected) Parameters Type Name Description ushort expected Returns Type Description EqualNumericConstraint<ushort> View Source EqualTo(uint) Returns a constraint that tests two numbers for equality Declaration public EqualNumericConstraint<uint> EqualTo(uint expected) Parameters Type Name Description uint expected Returns Type Description EqualNumericConstraint<uint> View Source EqualTo(ulong) Returns a constraint that tests two numbers for equality Declaration public EqualNumericConstraint<ulong> EqualTo(ulong expected) Parameters Type Name Description ulong expected Returns Type Description EqualNumericConstraint<ulong> View Source EqualTo<T>(T?) Returns a constraint that tests two items for equality Declaration public EqualConstraint<T> EqualTo<T>(T? expected) Parameters Type Name Description T expected Returns Type Description EqualConstraint<T> Type Parameters Name Description T View Source EquivalentTo(IEnumerable) Returns a constraint that tests whether the actual value is a collection containing the same elements as the collection supplied as an argument. Declaration public CollectionEquivalentConstraint EquivalentTo(IEnumerable expected) Parameters Type Name Description IEnumerable expected Returns Type Description CollectionEquivalentConstraint View Source Exactly(int) Returns a ConstraintExpression, which will apply the following constraint to all members of a collection, succeeding only if a specified number of them succeed. Declaration public ItemsConstraintExpression Exactly(int expectedCount) Parameters Type Name Description int expectedCount Returns Type Description ItemsConstraintExpression View Source GreaterThan(object) Returns a constraint that tests whether the actual value is greater than the supplied argument Declaration public GreaterThanConstraint GreaterThan(object expected) Parameters Type Name Description object expected Returns Type Description GreaterThanConstraint View Source GreaterThanOrEqualTo(object) Returns a constraint that tests whether the actual value is greater than or equal to the supplied argument Declaration public GreaterThanOrEqualConstraint GreaterThanOrEqualTo(object expected) Parameters Type Name Description object expected Returns Type Description GreaterThanOrEqualConstraint View Source InRange(object, object) Returns a constraint that tests whether the actual value falls inclusively within a specified range. Declaration public RangeConstraint InRange(object from, object to) Parameters Type Name Description object from Inclusive beginning of the range. object to Inclusive end of the range. Returns Type Description RangeConstraint View Source InstanceOf(Type) Returns a constraint that tests whether the actual value is of the type supplied as an argument or a derived type. Declaration public InstanceOfTypeConstraint InstanceOf(Type expectedType) Parameters Type Name Description Type expectedType Returns Type Description InstanceOfTypeConstraint View Source InstanceOf<TExpected>() Returns a constraint that tests whether the actual value is of the type supplied as an argument or a derived type. Declaration public InstanceOfTypeConstraint InstanceOf<TExpected>() Returns Type Description InstanceOfTypeConstraint Type Parameters Name Description TExpected View Source ItemAt(params object[]) Returns a new IndexerConstraintExpression, which will apply any following constraint to that indexer value. Declaration public ConstraintExpression ItemAt(params object[] indexArgs) Parameters Type Name Description object[] indexArgs Index accessor values. Returns Type Description ConstraintExpression View Source LessThan(object) Returns a constraint that tests whether the actual value is less than the supplied argument Declaration public LessThanConstraint LessThan(object expected) Parameters Type Name Description object expected Returns Type Description LessThanConstraint View Source LessThanOrEqualTo(object) Returns a constraint that tests whether the actual value is less than or equal to the supplied argument Declaration public LessThanOrEqualConstraint LessThanOrEqualTo(object expected) Parameters Type Name Description object expected Returns Type Description LessThanOrEqualConstraint View Source Match(string) Returns a constraint that succeeds if the actual value matches the regular expression supplied as an argument. Declaration public RegexConstraint Match(string pattern) Parameters Type Name Description string pattern Returns Type Description RegexConstraint View Source Match(Regex) Returns a constraint that succeeds if the actual value matches the regular expression supplied as an argument. Declaration public RegexConstraint Match(Regex regex) Parameters Type Name Description Regex regex Returns Type Description RegexConstraint View Source Matches(IResolveConstraint) Returns the constraint provided as an argument - used to allow custom custom constraints to easily participate in the syntax. Declaration public Constraint Matches(IResolveConstraint constraint) Parameters Type Name Description IResolveConstraint constraint Returns Type Description Constraint View Source Matches(string) Returns a constraint that succeeds if the actual value matches the regular expression supplied as an argument. Declaration public RegexConstraint Matches(string pattern) Parameters Type Name Description string pattern Returns Type Description RegexConstraint View Source Matches(Regex) Returns a constraint that succeeds if the actual value matches the regular expression supplied as an argument. Declaration public RegexConstraint Matches(Regex regex) Parameters Type Name Description Regex regex Returns Type Description RegexConstraint View Source Matches<TActual>(Predicate<TActual>) Returns the constraint provided as an argument - used to allow custom custom constraints to easily participate in the syntax. Declaration public Constraint Matches<TActual>(Predicate<TActual> predicate) Parameters Type Name Description Predicate<TActual> predicate Returns Type Description Constraint Type Parameters Name Description TActual View Source Member(object?) Returns a new SomeItemsConstraint checking for the presence of a particular object in the collection. Declaration public SomeItemsConstraint Member(object? expected) Parameters Type Name Description object expected Returns Type Description SomeItemsConstraint View Source Member<T>(T?) Returns a new SomeItemsConstraint checking for the presence of a particular object in the collection. Declaration public SomeItemsConstraint<T> Member<T>(T? expected) Parameters Type Name Description T expected Returns Type Description SomeItemsConstraint<T> Type Parameters Name Description T View Source MultipleOf(int) Returns a constraint that tests for a number to be a multiple of another. Declaration public MultipleOfConstraint MultipleOf(int multiple) Parameters Type Name Description int multiple Returns Type Description MultipleOfConstraint View Source Property(string) Returns a new PropertyConstraintExpression, which will either test for the existence of the named property on the object being tested or apply any following constraint to that property. Declaration public ResolvableConstraintExpression Property(string name) Parameters Type Name Description string name Returns Type Description ResolvableConstraintExpression View Source SameAs(object?) Returns a constraint that tests that two references are the same object Declaration public SameAsConstraint SameAs(object? expected) Parameters Type Name Description object expected Returns Type Description SameAsConstraint View Source SamePath(string) Returns a constraint that tests whether the path provided is the same as an expected path after canonicalization. Declaration public SamePathConstraint SamePath(string expected) Parameters Type Name Description string expected Returns Type Description SamePathConstraint View Source SamePathOrUnder(string) Returns a constraint that tests whether the path provided is the same path or under an expected path after canonicalization. Declaration public SamePathOrUnderConstraint SamePathOrUnder(string expected) Parameters Type Name Description string expected Returns Type Description SamePathOrUnderConstraint View Source StartWith(string) Returns a constraint that succeeds if the actual value starts with the substring supplied as an argument. Declaration public StartsWithConstraint StartWith(string expected) Parameters Type Name Description string expected Returns Type Description StartsWithConstraint View Source StartsWith(string) Returns a constraint that succeeds if the actual value starts with the substring supplied as an argument. Declaration public StartsWithConstraint StartsWith(string expected) Parameters Type Name Description string expected Returns Type Description StartsWithConstraint View Source SubPathOf(string) Returns a constraint that tests whether the path provided is the a subpath of the expected path after canonicalization. Declaration public SubPathConstraint SubPathOf(string expected) Parameters Type Name Description string expected Returns Type Description SubPathConstraint View Source SubsetOf(IEnumerable) Returns a constraint that tests whether the actual value is a subset of the collection supplied as an argument. Declaration public CollectionSubsetConstraint SubsetOf(IEnumerable expected) Parameters Type Name Description IEnumerable expected Returns Type Description CollectionSubsetConstraint View Source SupersetOf(IEnumerable) Returns a constraint that tests whether the actual value is a superset of the collection supplied as an argument. Declaration public CollectionSupersetConstraint SupersetOf(IEnumerable expected) Parameters Type Name Description IEnumerable expected Returns Type Description CollectionSupersetConstraint View Source ToString() Returns a string representation of the expression as it currently stands. This should only be used for testing, since it has the side-effect of resolving the expression. Declaration public override string ToString() Returns Type Description string Overrides object.ToString() View Source TypeOf(Type) Returns a constraint that tests whether the actual value is of the exact type supplied as an argument. Declaration public ExactTypeConstraint TypeOf(Type expectedType) Parameters Type Name Description Type expectedType Returns Type Description ExactTypeConstraint View Source TypeOf<TExpected>() Returns a constraint that tests whether the actual value is of the exact type supplied as an argument. Declaration public ExactTypeConstraint TypeOf<TExpected>() Returns Type Description ExactTypeConstraint Type Parameters Name Description TExpected"
  },
  "api/NUnit.Framework.Constraints.ConstraintOperator.html": {
    "href": "api/NUnit.Framework.Constraints.ConstraintOperator.html",
    "title": "Class ConstraintOperator | NUnit Docs",
    "summary": "Class ConstraintOperator The ConstraintOperator class is used internally by a ConstraintBuilder to represent an operator that modifies or combines constraints. Constraint operators use left and right precedence values to determine whether the top operator on the stack should be reduced before pushing a new operator. Inheritance object ConstraintOperator BinaryOperator PrefixOperator SelfResolvingOperator Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework.Constraints Assembly: nunit.framework.dll Syntax public abstract class ConstraintOperator Constructors View Source ConstraintOperator() Declaration protected ConstraintOperator() Fields View Source left_precedence The precedence value used when the operator is about to be pushed to the stack. Declaration protected int left_precedence Field Value Type Description int View Source right_precedence The precedence value used when the operator is on the top of the stack. Declaration protected int right_precedence Field Value Type Description int Properties View Source LeftContext The syntax element preceding this operator Declaration public object? LeftContext { get; set; } Property Value Type Description object View Source LeftPrecedence The precedence value used when the operator is about to be pushed to the stack. Declaration public virtual int LeftPrecedence { get; } Property Value Type Description int View Source RightContext The syntax element following this operator Declaration public object? RightContext { get; set; } Property Value Type Description object View Source RightPrecedence The precedence value used when the operator is on the top of the stack. Declaration public virtual int RightPrecedence { get; } Property Value Type Description int Methods View Source Reduce(ConstraintStack) Reduce produces a constraint from the operator and any arguments. It takes the arguments from the constraint stack and pushes the resulting constraint on it. Declaration public abstract void Reduce(ConstraintBuilder.ConstraintStack stack) Parameters Type Name Description ConstraintBuilder.ConstraintStack stack"
  },
  "api/NUnit.Framework.Constraints.ConstraintResult.html": {
    "href": "api/NUnit.Framework.Constraints.ConstraintResult.html",
    "title": "Class ConstraintResult | NUnit Docs",
    "summary": "Class ConstraintResult Contains the result of matching a Constraint against an actual value. Inheritance object ConstraintResult CollectionEquivalentConstraintResult EqualConstraintResult Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework.Constraints Assembly: nunit.framework.dll Syntax public class ConstraintResult Constructors View Source ConstraintResult(IConstraint, object?) Constructs a ConstraintResult for a particular Constraint. Declaration public ConstraintResult(IConstraint constraint, object? actualValue) Parameters Type Name Description IConstraint constraint The Constraint to which this result applies. object actualValue The actual value to which the Constraint was applied. View Source ConstraintResult(IConstraint, object?, ConstraintStatus) Constructs a ConstraintResult for a particular Constraint. Declaration public ConstraintResult(IConstraint constraint, object? actualValue, ConstraintStatus status) Parameters Type Name Description IConstraint constraint The Constraint to which this result applies. object actualValue The actual value to which the Constraint was applied. ConstraintStatus status The status of the new ConstraintResult. View Source ConstraintResult(IConstraint, object?, bool) Constructs a ConstraintResult for a particular Constraint. Declaration public ConstraintResult(IConstraint constraint, object? actualValue, bool isSuccess) Parameters Type Name Description IConstraint constraint The Constraint to which this result applies. object actualValue The actual value to which the Constraint was applied. bool isSuccess If true, applies a status of Success to the result, otherwise Failure. Properties View Source ActualValue The actual value that was passed to the ApplyTo<TActual>(TActual) method. Declaration public object? ActualValue { get; } Property Value Type Description object View Source Description Description of the constraint may be affected by the state the constraint had when ApplyTo<TActual>(TActual) was performed against the actual value. Declaration public string Description { get; } Property Value Type Description string View Source IsSuccess True if actual value meets the Constraint criteria otherwise false. Declaration public virtual bool IsSuccess { get; } Property Value Type Description bool View Source Name Display friendly name of the constraint. Declaration public string Name { get; } Property Value Type Description string View Source Status Gets and sets the ResultStatus for this result. Declaration public ConstraintStatus Status { get; set; } Property Value Type Description ConstraintStatus Methods View Source WriteActualValueTo(MessageWriter) Write the actual value for a failing constraint test to a MessageWriter. The default implementation simply writes the raw value of actual, leaving it to the writer to perform any formatting. Declaration public virtual void WriteActualValueTo(MessageWriter writer) Parameters Type Name Description MessageWriter writer The writer on which the actual value is displayed View Source WriteAdditionalLinesTo(MessageWriter) Write some additional failure message. Declaration public virtual void WriteAdditionalLinesTo(MessageWriter writer) Parameters Type Name Description MessageWriter writer The MessageWriter on which to display the message View Source WriteMessageTo(MessageWriter) Write the failure message to the MessageWriter provided as an argument. The default implementation simply passes the result and the actual value to the writer, which then displays the constraint description and the value. Constraints that need to provide additional details, such as where the error occurred, can override this. Declaration public virtual void WriteMessageTo(MessageWriter writer) Parameters Type Name Description MessageWriter writer The MessageWriter on which to display the message"
  },
  "api/NUnit.Framework.Constraints.ConstraintStatus.html": {
    "href": "api/NUnit.Framework.Constraints.ConstraintStatus.html",
    "title": "Enum ConstraintStatus | NUnit Docs",
    "summary": "Enum ConstraintStatus ConstraintStatus represents the status of a ConstraintResult returned by a Constraint being applied to an actual value. Namespace: NUnit.Framework.Constraints Assembly: nunit.framework.dll Syntax public enum ConstraintStatus Fields Name Description Error An error occurred in applying the constraint (reserved for future use) Failure The constraint failed Success The constraint succeeded Unknown The status has not yet been set"
  },
  "api/NUnit.Framework.Constraints.ContainsConstraint.html": {
    "href": "api/NUnit.Framework.Constraints.ContainsConstraint.html",
    "title": "Class ContainsConstraint | NUnit Docs",
    "summary": "Class ContainsConstraint ContainsConstraint tests a whether a string contains a substring or a collection contains an object. It postpones the decision of which test to use until the type of the actual argument is known. This allows testing whether a string is contained in a collection or as a substring of another string using the same syntax. Inheritance object Constraint ContainsConstraint Implements IConstraint IResolveConstraint Inherited Members Constraint.ApplyTo<TActual>(ActualValueDelegate<TActual>) Constraint.ApplyTo<TActual>(ref TActual) Constraint.ApplyToAsync<TActual>(Func<Task<TActual>>) Constraint.GetTestObject<TActual>(ActualValueDelegate<TActual>) Constraint.ToString() Constraint.GetStringRepresentation(IEnumerable) Constraint.GetStringRepresentation() Constraint.After(int) Constraint.After(int, int) Constraint.DisplayName Constraint.Arguments Constraint.Builder Constraint.And Constraint.With Constraint.Or object.GetType() object.MemberwiseClone() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework.Constraints Assembly: nunit.framework.dll Syntax public class ContainsConstraint : Constraint, IConstraint, IResolveConstraint Constructors View Source ContainsConstraint(object?) Initializes a new instance of the ContainsConstraint class. Declaration public ContainsConstraint(object? expected) Parameters Type Name Description object expected The expected value contained within the string/collection. Properties View Source Description The Description of what this constraint tests, for use in messages and in the ConstraintResult. Declaration public override string Description { get; } Property Value Type Description string Overrides Constraint.Description View Source IgnoreCase Flag the constraint to ignore case and return self. Declaration public ContainsConstraint IgnoreCase { get; } Property Value Type Description ContainsConstraint View Source IgnoreLineEndingFormat Flag the constraint to ignore line ending format (\\r vs. \\n vs. \\r\\n) and return self. Declaration public ContainsConstraint IgnoreLineEndingFormat { get; } Property Value Type Description ContainsConstraint View Source IgnoreWhiteSpace Flag the constraint to ignore white-space and return self. Declaration public ContainsConstraint IgnoreWhiteSpace { get; } Property Value Type Description ContainsConstraint Methods View Source ApplyTo<TActual>(TActual) Test whether the constraint is satisfied by a given value Declaration public override ConstraintResult ApplyTo<TActual>(TActual actual) Parameters Type Name Description TActual actual The value to be tested Returns Type Description ConstraintResult True for success, false for failure Type Parameters Name Description TActual Overrides Constraint.ApplyTo<TActual>(TActual) Implements IConstraint IResolveConstraint"
  },
  "api/NUnit.Framework.Constraints.CountZeroConstraint.html": {
    "href": "api/NUnit.Framework.Constraints.CountZeroConstraint.html",
    "title": "Class CountZeroConstraint | NUnit Docs",
    "summary": "Class CountZeroConstraint CountZeroConstraint tests whether an instance has a property .Count with value zero. Inheritance object Constraint CountZeroConstraint Implements IConstraint IResolveConstraint Inherited Members Constraint.ApplyTo<TActual>(ActualValueDelegate<TActual>) Constraint.ApplyTo<TActual>(ref TActual) Constraint.ApplyToAsync<TActual>(Func<Task<TActual>>) Constraint.GetTestObject<TActual>(ActualValueDelegate<TActual>) Constraint.ToString() Constraint.GetStringRepresentation(IEnumerable) Constraint.GetStringRepresentation() Constraint.After(int) Constraint.After(int, int) Constraint.DisplayName Constraint.Arguments Constraint.Builder Constraint.And Constraint.With Constraint.Or object.GetType() object.MemberwiseClone() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework.Constraints Assembly: nunit.framework.dll Syntax public class CountZeroConstraint : Constraint, IConstraint, IResolveConstraint Constructors View Source CountZeroConstraint() Declaration public CountZeroConstraint() Properties View Source Description The Description of what this constraint tests, for use in messages and in the ConstraintResult. Declaration public override string Description { get; } Property Value Type Description string Overrides Constraint.Description Methods View Source ApplyTo<TActual>(TActual) Test whether the constraint is satisfied by a given value Declaration public override ConstraintResult ApplyTo<TActual>(TActual actual) Parameters Type Name Description TActual actual The value to be tested Returns Type Description ConstraintResult True for success, false for failure Type Parameters Name Description TActual Overrides Constraint.ApplyTo<TActual>(TActual) View Source HasCountProperty(Type) Checks if the specified type has a int Count property. Declaration public static bool HasCountProperty(Type type) Parameters Type Name Description Type type Type to check. Returns Type Description bool true when type has a 'int Count' property, false otherwise. Implements IConstraint IResolveConstraint"
  },
  "api/NUnit.Framework.Constraints.DateTimes.html": {
    "href": "api/NUnit.Framework.Constraints.DateTimes.html",
    "title": "Class DateTimes | NUnit Docs",
    "summary": "Class DateTimes The DateTimes class contains common operations on Date and Time values. Inheritance object DateTimes Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework.Constraints Assembly: nunit.framework.dll Syntax public static class DateTimes"
  },
  "api/NUnit.Framework.Constraints.DefaultConstraint.html": {
    "href": "api/NUnit.Framework.Constraints.DefaultConstraint.html",
    "title": "Class DefaultConstraint | NUnit Docs",
    "summary": "Class DefaultConstraint Tests that the actual value is default value for type. Inheritance object Constraint DefaultConstraint Implements IConstraint IResolveConstraint Inherited Members Constraint.ApplyTo<TActual>(ActualValueDelegate<TActual>) Constraint.ApplyTo<TActual>(ref TActual) Constraint.ApplyToAsync<TActual>(Func<Task<TActual>>) Constraint.GetTestObject<TActual>(ActualValueDelegate<TActual>) Constraint.ToString() Constraint.GetStringRepresentation(IEnumerable) Constraint.GetStringRepresentation() Constraint.After(int) Constraint.After(int, int) Constraint.DisplayName Constraint.Arguments Constraint.Builder Constraint.And Constraint.With Constraint.Or object.GetType() object.MemberwiseClone() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework.Constraints Assembly: nunit.framework.dll Syntax public class DefaultConstraint : Constraint, IConstraint, IResolveConstraint Constructors View Source DefaultConstraint() Declaration public DefaultConstraint() Properties View Source Description The Description of what this constraint tests, for use in messages and in the ConstraintResult. Declaration public override string Description { get; } Property Value Type Description string Overrides Constraint.Description Methods View Source ApplyTo<TActual>(TActual) Applies the constraint to an actual value, returning a ConstraintResult. Declaration public override ConstraintResult ApplyTo<TActual>(TActual actual) Parameters Type Name Description TActual actual Returns Type Description ConstraintResult Type Parameters Name Description TActual Overrides Constraint.ApplyTo<TActual>(TActual) Implements IConstraint IResolveConstraint"
  },
  "api/NUnit.Framework.Constraints.DelayedConstraint.WithDimensionedDelayInterval.html": {
    "href": "api/NUnit.Framework.Constraints.DelayedConstraint.WithDimensionedDelayInterval.html",
    "title": "Class DelayedConstraint.WithDimensionedDelayInterval | NUnit Docs",
    "summary": "Class DelayedConstraint.WithDimensionedDelayInterval Allows only setting the polling interval of a DelayedConstraint Inheritance object Constraint PrefixConstraint DelayedConstraint DelayedConstraint.WithDimensionedDelayInterval Implements IConstraint IResolveConstraint Inherited Members DelayedConstraint.ApplyTo<TActual>(TActual) DelayedConstraint.ApplyTo<TActual>(ActualValueDelegate<TActual>) DelayedConstraint.ApplyToAsync<TActual>(Func<Task<TActual>>) DelayedConstraint.GetStringRepresentation() DelayedConstraint.DelayInterval DelayedConstraint.PollingInterval DelayedConstraint.Description PrefixConstraint.BaseConstraint PrefixConstraint.DescriptionPrefix Constraint.ApplyTo<TActual>(ref TActual) Constraint.GetTestObject<TActual>(ActualValueDelegate<TActual>) Constraint.ToString() Constraint.GetStringRepresentation(IEnumerable) Constraint.After(int) Constraint.After(int, int) Constraint.DisplayName Constraint.Arguments Constraint.Builder Constraint.And Constraint.With Constraint.Or object.GetType() object.MemberwiseClone() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework.Constraints Assembly: nunit.framework.dll Syntax public class DelayedConstraint.WithDimensionedDelayInterval : DelayedConstraint, IConstraint, IResolveConstraint Constructors View Source WithDimensionedDelayInterval(DelayedConstraint) Creates a new DelayedConstraint.WithDimensionedDelayInterval Declaration public WithDimensionedDelayInterval(DelayedConstraint parent) Parameters Type Name Description DelayedConstraint parent Parent DelayedConstraint on which polling interval is required to be set Methods View Source PollEvery(int) Set polling interval, in milliseconds Declaration public DelayedConstraint.WithRawPollingInterval PollEvery(int milliSeconds) Parameters Type Name Description int milliSeconds A time interval, in milliseconds Returns Type Description DelayedConstraint.WithRawPollingInterval Implements IConstraint IResolveConstraint"
  },
  "api/NUnit.Framework.Constraints.DelayedConstraint.WithRawDelayInterval.html": {
    "href": "api/NUnit.Framework.Constraints.DelayedConstraint.WithRawDelayInterval.html",
    "title": "Class DelayedConstraint.WithRawDelayInterval | NUnit Docs",
    "summary": "Class DelayedConstraint.WithRawDelayInterval Allows only changing the time dimension of delay interval and setting a polling interval of a DelayedConstraint Inheritance object Constraint PrefixConstraint DelayedConstraint DelayedConstraint.WithRawDelayInterval Implements IConstraint IResolveConstraint Inherited Members DelayedConstraint.ApplyTo<TActual>(TActual) DelayedConstraint.ApplyTo<TActual>(ActualValueDelegate<TActual>) DelayedConstraint.ApplyToAsync<TActual>(Func<Task<TActual>>) DelayedConstraint.GetStringRepresentation() DelayedConstraint.DelayInterval DelayedConstraint.PollingInterval DelayedConstraint.Description PrefixConstraint.BaseConstraint PrefixConstraint.DescriptionPrefix Constraint.ApplyTo<TActual>(ref TActual) Constraint.GetTestObject<TActual>(ActualValueDelegate<TActual>) Constraint.ToString() Constraint.GetStringRepresentation(IEnumerable) Constraint.After(int) Constraint.After(int, int) Constraint.DisplayName Constraint.Arguments Constraint.Builder Constraint.And Constraint.With Constraint.Or object.GetType() object.MemberwiseClone() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework.Constraints Assembly: nunit.framework.dll Syntax public class DelayedConstraint.WithRawDelayInterval : DelayedConstraint, IConstraint, IResolveConstraint Constructors View Source WithRawDelayInterval(DelayedConstraint) Creates a new DelayedConstraint.WithRawDelayInterval Declaration public WithRawDelayInterval(DelayedConstraint parent) Parameters Type Name Description DelayedConstraint parent Parent DelayedConstraint on which delay interval dimension is required to be set Properties View Source MilliSeconds Changes delay interval dimension to milliseconds Declaration public DelayedConstraint.WithDimensionedDelayInterval MilliSeconds { get; } Property Value Type Description DelayedConstraint.WithDimensionedDelayInterval View Source Minutes Changes delay interval dimension to minutes Declaration public DelayedConstraint.WithDimensionedDelayInterval Minutes { get; } Property Value Type Description DelayedConstraint.WithDimensionedDelayInterval View Source Seconds Changes delay interval dimension to seconds Declaration public DelayedConstraint.WithDimensionedDelayInterval Seconds { get; } Property Value Type Description DelayedConstraint.WithDimensionedDelayInterval Methods View Source PollEvery(int) Set polling interval, in milliseconds Declaration public DelayedConstraint.WithRawPollingInterval PollEvery(int milliSeconds) Parameters Type Name Description int milliSeconds A time interval, in milliseconds Returns Type Description DelayedConstraint.WithRawPollingInterval Implements IConstraint IResolveConstraint"
  },
  "api/NUnit.Framework.Constraints.DelayedConstraint.WithRawPollingInterval.html": {
    "href": "api/NUnit.Framework.Constraints.DelayedConstraint.WithRawPollingInterval.html",
    "title": "Class DelayedConstraint.WithRawPollingInterval | NUnit Docs",
    "summary": "Class DelayedConstraint.WithRawPollingInterval Allows only changing the time dimension of the polling interval of a DelayedConstraint Inheritance object Constraint PrefixConstraint DelayedConstraint DelayedConstraint.WithRawPollingInterval Implements IConstraint IResolveConstraint Inherited Members DelayedConstraint.ApplyTo<TActual>(TActual) DelayedConstraint.ApplyTo<TActual>(ActualValueDelegate<TActual>) DelayedConstraint.ApplyToAsync<TActual>(Func<Task<TActual>>) DelayedConstraint.GetStringRepresentation() DelayedConstraint.DelayInterval DelayedConstraint.PollingInterval DelayedConstraint.Description PrefixConstraint.BaseConstraint PrefixConstraint.DescriptionPrefix Constraint.ApplyTo<TActual>(ref TActual) Constraint.GetTestObject<TActual>(ActualValueDelegate<TActual>) Constraint.ToString() Constraint.GetStringRepresentation(IEnumerable) Constraint.After(int) Constraint.After(int, int) Constraint.DisplayName Constraint.Arguments Constraint.Builder Constraint.And Constraint.With Constraint.Or object.GetType() object.MemberwiseClone() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework.Constraints Assembly: nunit.framework.dll Syntax public class DelayedConstraint.WithRawPollingInterval : DelayedConstraint, IConstraint, IResolveConstraint Constructors View Source WithRawPollingInterval(DelayedConstraint) Creates a new DelayedConstraint.WithRawPollingInterval Declaration public WithRawPollingInterval(DelayedConstraint parent) Parameters Type Name Description DelayedConstraint parent Parent DelayedConstraint on which polling dimension is required to be set Properties View Source MilliSeconds Changes polling interval dimension to milliseconds Declaration public DelayedConstraint MilliSeconds { get; } Property Value Type Description DelayedConstraint View Source Minutes Changes polling interval dimension to minutes Declaration public DelayedConstraint Minutes { get; } Property Value Type Description DelayedConstraint View Source Seconds Changes polling interval dimension to seconds Declaration public DelayedConstraint Seconds { get; } Property Value Type Description DelayedConstraint Implements IConstraint IResolveConstraint"
  },
  "api/NUnit.Framework.Constraints.DelayedConstraint.html": {
    "href": "api/NUnit.Framework.Constraints.DelayedConstraint.html",
    "title": "Class DelayedConstraint | NUnit Docs",
    "summary": "Class DelayedConstraint Applies a delay to the match so that a match can be evaluated in the future. Inheritance object Constraint PrefixConstraint DelayedConstraint DelayedConstraint.WithDimensionedDelayInterval DelayedConstraint.WithRawDelayInterval DelayedConstraint.WithRawPollingInterval Implements IConstraint IResolveConstraint Inherited Members PrefixConstraint.BaseConstraint PrefixConstraint.DescriptionPrefix Constraint.ApplyTo<TActual>(ref TActual) Constraint.GetTestObject<TActual>(ActualValueDelegate<TActual>) Constraint.ToString() Constraint.GetStringRepresentation(IEnumerable) Constraint.After(int) Constraint.After(int, int) Constraint.DisplayName Constraint.Arguments Constraint.Builder Constraint.And Constraint.With Constraint.Or object.GetType() object.MemberwiseClone() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework.Constraints Assembly: nunit.framework.dll Syntax public class DelayedConstraint : PrefixConstraint, IConstraint, IResolveConstraint Constructors View Source DelayedConstraint(IConstraint, int) Creates a new DelayedConstraint Declaration public DelayedConstraint(IConstraint baseConstraint, int delayInMilliseconds) Parameters Type Name Description IConstraint baseConstraint The inner constraint to decorate int delayInMilliseconds The time interval after which the match is performed Exceptions Type Condition InvalidOperationException If the value of delayInMilliseconds is less than 0 View Source DelayedConstraint(IConstraint, int, int) Creates a new DelayedConstraint Declaration public DelayedConstraint(IConstraint baseConstraint, int delayInMilliseconds, int pollingIntervalInMilliseconds) Parameters Type Name Description IConstraint baseConstraint The inner constraint to decorate int delayInMilliseconds The time interval after which the match is performed, in milliseconds int pollingIntervalInMilliseconds The time interval used for polling, in milliseconds Exceptions Type Condition InvalidOperationException If the value of delayInMilliseconds is less than 0 Properties View Source DelayInterval Delay value store as an Interval object Declaration protected Interval DelayInterval { get; set; } Property Value Type Description Interval View Source Description Gets text describing a constraint Declaration public override string Description { get; } Property Value Type Description string Overrides PrefixConstraint.Description View Source PollingInterval Polling value stored as an Interval object Declaration protected Interval PollingInterval { get; set; } Property Value Type Description Interval Methods View Source ApplyToAsync<TActual>(Func<Task<TActual>>) Applies the constraint to a delegate that returns the task. The default implementation simply evaluates the delegate and awaits the task but derived classes may override it to provide for delayed processing. Declaration public override Task<ConstraintResult> ApplyToAsync<TActual>(Func<Task<TActual>> taskDel) Parameters Type Name Description Func<Task<TActual>> taskDel Returns Type Description Task<ConstraintResult> Type Parameters Name Description TActual Overrides Constraint.ApplyToAsync<TActual>(Func<Task<TActual>>) View Source ApplyTo<TActual>(ActualValueDelegate<TActual>) Test whether the constraint is satisfied by a delegate Declaration public override ConstraintResult ApplyTo<TActual>(ActualValueDelegate<TActual> del) Parameters Type Name Description ActualValueDelegate<TActual> del The delegate whose value is to be tested Returns Type Description ConstraintResult A ConstraintResult Type Parameters Name Description TActual Overrides Constraint.ApplyTo<TActual>(ActualValueDelegate<TActual>) View Source ApplyTo<TActual>(TActual) Test whether the constraint is satisfied by a given value Declaration public override ConstraintResult ApplyTo<TActual>(TActual actual) Parameters Type Name Description TActual actual The value to be tested Returns Type Description ConstraintResult True for if the base constraint fails, false if it succeeds Type Parameters Name Description TActual Overrides Constraint.ApplyTo<TActual>(TActual) View Source GetStringRepresentation() Returns the string representation of the constraint. Declaration protected override string GetStringRepresentation() Returns Type Description string Overrides Constraint.GetStringRepresentation() Implements IConstraint IResolveConstraint"
  },
  "api/NUnit.Framework.Constraints.DictionaryContainsKeyConstraint.html": {
    "href": "api/NUnit.Framework.Constraints.DictionaryContainsKeyConstraint.html",
    "title": "Class DictionaryContainsKeyConstraint | NUnit Docs",
    "summary": "Class DictionaryContainsKeyConstraint DictionaryContainsKeyConstraint is used to test whether a dictionary contains an expected object as a key. Inheritance object Constraint DictionaryContainsKeyConstraint Implements IConstraint IResolveConstraint Inherited Members Constraint.ApplyTo<TActual>(ActualValueDelegate<TActual>) Constraint.ApplyTo<TActual>(ref TActual) Constraint.ApplyToAsync<TActual>(Func<Task<TActual>>) Constraint.GetTestObject<TActual>(ActualValueDelegate<TActual>) Constraint.ToString() Constraint.GetStringRepresentation(IEnumerable) Constraint.GetStringRepresentation() Constraint.After(int) Constraint.After(int, int) Constraint.Arguments Constraint.Builder Constraint.And Constraint.With Constraint.Or object.GetType() object.MemberwiseClone() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework.Constraints Assembly: nunit.framework.dll Syntax public class DictionaryContainsKeyConstraint : Constraint, IConstraint, IResolveConstraint Constructors View Source DictionaryContainsKeyConstraint(object) Construct a DictionaryContainsKeyConstraint Declaration public DictionaryContainsKeyConstraint(object expected) Parameters Type Name Description object expected Properties View Source Description The Description of what this constraint tests, for use in messages and in the ConstraintResult. Declaration public override string Description { get; } Property Value Type Description string Overrides Constraint.Description View Source DisplayName The display name of this Constraint for use by ToString(). The default value is the name of the constraint with trailing \"Constraint\" removed. Derived classes may set this to another name in their constructors. Declaration public override string DisplayName { get; } Property Value Type Description string Overrides Constraint.DisplayName View Source Expected Gets the expected object Declaration protected object Expected { get; } Property Value Type Description object Methods View Source ApplyTo<TActual>(TActual) Test whether the constraint is satisfied by a given value Declaration public override ConstraintResult ApplyTo<TActual>(TActual actual) Parameters Type Name Description TActual actual The value to be tested Returns Type Description ConstraintResult Type Parameters Name Description TActual Overrides Constraint.ApplyTo<TActual>(TActual) View Source WithValue(object?) Returns a new DictionaryContainsKeyValuePairConstraint checking for the presence of a particular key-value-pair in the dictionary. Declaration public DictionaryContainsKeyValuePairConstraint WithValue(object? expectedValue) Parameters Type Name Description object expectedValue Returns Type Description DictionaryContainsKeyValuePairConstraint Implements IConstraint IResolveConstraint"
  },
  "api/NUnit.Framework.Constraints.DictionaryContainsKeyValuePairConstraint.html": {
    "href": "api/NUnit.Framework.Constraints.DictionaryContainsKeyValuePairConstraint.html",
    "title": "Class DictionaryContainsKeyValuePairConstraint | NUnit Docs",
    "summary": "Class DictionaryContainsKeyValuePairConstraint DictionaryContainsKeyValuePairConstraint is used to test whether a dictionary contains an expected object as a key-value-pair. Inheritance object Constraint CollectionConstraint CollectionItemsEqualConstraint DictionaryContainsKeyValuePairConstraint Implements IConstraint IResolveConstraint Inherited Members CollectionItemsEqualConstraint.Using(IComparer) CollectionItemsEqualConstraint.Using<T>(IComparer<T>) CollectionItemsEqualConstraint.Using<T>(Comparison<T>) CollectionItemsEqualConstraint.Using(IEqualityComparer) CollectionItemsEqualConstraint.Using<T>(IEqualityComparer<T>) CollectionItemsEqualConstraint.Using<T>(Func<T, T, bool>) CollectionItemsEqualConstraint.UsingPropertiesComparer() CollectionItemsEqualConstraint.UsingPropertiesComparer(Func<PropertiesComparerConfigurationUntyped, PropertiesComparerConfigurationUntyped>) CollectionItemsEqualConstraint.IgnoreCase CollectionItemsEqualConstraint.IgnoreWhiteSpace CollectionItemsEqualConstraint.IgnoreLineEndingFormat Constraint.ApplyTo<TActual>(ActualValueDelegate<TActual>) Constraint.ApplyTo<TActual>(ref TActual) Constraint.ApplyToAsync<TActual>(Func<Task<TActual>>) Constraint.ToString() Constraint.After(int) Constraint.After(int, int) Constraint.Arguments Constraint.Builder Constraint.And Constraint.With Constraint.Or object.GetType() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework.Constraints Assembly: nunit.framework.dll Syntax public sealed class DictionaryContainsKeyValuePairConstraint : CollectionItemsEqualConstraint, IConstraint, IResolveConstraint Constructors View Source DictionaryContainsKeyValuePairConstraint(object, object?) Construct a DictionaryContainsKeyValuePairConstraint Declaration public DictionaryContainsKeyValuePairConstraint(object key, object? value) Parameters Type Name Description object key object value Properties View Source Description The Description of what this constraint tests, for use in messages and in the ConstraintResult. Declaration public override string Description { get; } Property Value Type Description string Overrides Constraint.Description View Source DisplayName The display name of this Constraint for use by ToString(). The default value is the name of the constraint with trailing \"Constraint\" removed. Derived classes may set this to another name in their constructors. Declaration public override string DisplayName { get; } Property Value Type Description string Overrides Constraint.DisplayName Methods View Source ApplyTo<TActual>(TActual) Test whether the constraint is satisfied by a given value Declaration public override ConstraintResult ApplyTo<TActual>(TActual actual) Parameters Type Name Description TActual actual The value to be tested Returns Type Description ConstraintResult Type Parameters Name Description TActual Overrides CollectionConstraint.ApplyTo<TActual>(TActual) View Source Matches(IEnumerable) Test whether the expected key is contained in the dictionary Declaration protected override bool Matches(IEnumerable collection) Parameters Type Name Description IEnumerable collection Returns Type Description bool Overrides CollectionConstraint.Matches(IEnumerable) Implements IConstraint IResolveConstraint"
  },
  "api/NUnit.Framework.Constraints.DictionaryContainsValueConstraint.html": {
    "href": "api/NUnit.Framework.Constraints.DictionaryContainsValueConstraint.html",
    "title": "Class DictionaryContainsValueConstraint | NUnit Docs",
    "summary": "Class DictionaryContainsValueConstraint DictionaryContainsValueConstraint is used to test whether a dictionary contains an expected object as a value. Inheritance object Constraint CollectionConstraint CollectionItemsEqualConstraint DictionaryContainsValueConstraint Implements IConstraint IResolveConstraint Inherited Members CollectionItemsEqualConstraint.Using(IComparer) CollectionItemsEqualConstraint.Using<T>(IComparer<T>) CollectionItemsEqualConstraint.Using<T>(Comparison<T>) CollectionItemsEqualConstraint.Using(IEqualityComparer) CollectionItemsEqualConstraint.Using<T>(IEqualityComparer<T>) CollectionItemsEqualConstraint.Using<T>(Func<T, T, bool>) CollectionItemsEqualConstraint.UsingPropertiesComparer() CollectionItemsEqualConstraint.UsingPropertiesComparer(Func<PropertiesComparerConfigurationUntyped, PropertiesComparerConfigurationUntyped>) CollectionItemsEqualConstraint.ItemsEqual(object, object) CollectionItemsEqualConstraint.Tally(IEnumerable) CollectionItemsEqualConstraint.IgnoringCase CollectionItemsEqualConstraint.IgnoringWhiteSpace CollectionItemsEqualConstraint.IgnoringLineEndingFormat CollectionItemsEqualConstraint.UsingExternalComparer CollectionItemsEqualConstraint.IgnoreCase CollectionItemsEqualConstraint.IgnoreWhiteSpace CollectionItemsEqualConstraint.IgnoreLineEndingFormat CollectionConstraint.IsEmpty(IEnumerable) CollectionConstraint.ApplyTo<TActual>(TActual) Constraint.ApplyTo<TActual>(ActualValueDelegate<TActual>) Constraint.ApplyTo<TActual>(ref TActual) Constraint.ApplyToAsync<TActual>(Func<Task<TActual>>) Constraint.GetTestObject<TActual>(ActualValueDelegate<TActual>) Constraint.ToString() Constraint.GetStringRepresentation(IEnumerable) Constraint.GetStringRepresentation() Constraint.After(int) Constraint.After(int, int) Constraint.Arguments Constraint.Builder Constraint.And Constraint.With Constraint.Or object.GetType() object.MemberwiseClone() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework.Constraints Assembly: nunit.framework.dll Syntax public class DictionaryContainsValueConstraint : CollectionItemsEqualConstraint, IConstraint, IResolveConstraint Constructors View Source DictionaryContainsValueConstraint(object?) Construct a DictionaryContainsValueConstraint Declaration public DictionaryContainsValueConstraint(object? expected) Parameters Type Name Description object expected Properties View Source Description The Description of what this constraint tests, for use in messages and in the ConstraintResult. Declaration public override string Description { get; } Property Value Type Description string Overrides Constraint.Description View Source DisplayName The display name of this Constraint for use by ToString(). The default value is the name of the constraint with trailing \"Constraint\" removed. Derived classes may set this to another name in their constructors. Declaration public override string DisplayName { get; } Property Value Type Description string Overrides Constraint.DisplayName View Source Expected Gets the expected object Declaration protected object? Expected { get; } Property Value Type Description object Methods View Source Matches(IEnumerable) Test whether the expected value is contained in the dictionary Declaration protected override bool Matches(IEnumerable actual) Parameters Type Name Description IEnumerable actual Returns Type Description bool Overrides CollectionConstraint.Matches(IEnumerable) View Source Using<TActualValueElement, TExpected>(Func<TActualValueElement, TExpected, bool>) Flag the constraint to use the supplied predicate function Declaration public DictionaryContainsValueConstraint Using<TActualValueElement, TExpected>(Func<TActualValueElement, TExpected, bool> comparison) Parameters Type Name Description Func<TActualValueElement, TExpected, bool> comparison The comparison function to use. Returns Type Description DictionaryContainsValueConstraint Self. Type Parameters Name Description TActualValueElement The type of the dictionary's TValue. TExpected The type of the expected value. Implements IConstraint IResolveConstraint"
  },
  "api/NUnit.Framework.Constraints.EmptyCollectionConstraint.html": {
    "href": "api/NUnit.Framework.Constraints.EmptyCollectionConstraint.html",
    "title": "Class EmptyCollectionConstraint | NUnit Docs",
    "summary": "Class EmptyCollectionConstraint EmptyCollectionConstraint tests whether a collection is empty. Inheritance object Constraint CollectionConstraint EmptyCollectionConstraint Implements IConstraint IResolveConstraint Inherited Members CollectionConstraint.IsEmpty(IEnumerable) CollectionConstraint.ApplyTo<TActual>(TActual) Constraint.ApplyTo<TActual>(ActualValueDelegate<TActual>) Constraint.ApplyTo<TActual>(ref TActual) Constraint.ApplyToAsync<TActual>(Func<Task<TActual>>) Constraint.GetTestObject<TActual>(ActualValueDelegate<TActual>) Constraint.ToString() Constraint.GetStringRepresentation(IEnumerable) Constraint.GetStringRepresentation() Constraint.After(int) Constraint.After(int, int) Constraint.DisplayName Constraint.Arguments Constraint.Builder Constraint.And Constraint.With Constraint.Or object.GetType() object.MemberwiseClone() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework.Constraints Assembly: nunit.framework.dll Syntax public class EmptyCollectionConstraint : CollectionConstraint, IConstraint, IResolveConstraint Constructors View Source EmptyCollectionConstraint() Declaration public EmptyCollectionConstraint() Properties View Source Description The Description of what this constraint tests, for use in messages and in the ConstraintResult. Declaration public override string Description { get; } Property Value Type Description string Overrides Constraint.Description Methods View Source Matches(IEnumerable) Check that the collection is empty Declaration protected override bool Matches(IEnumerable collection) Parameters Type Name Description IEnumerable collection Returns Type Description bool Overrides CollectionConstraint.Matches(IEnumerable) Implements IConstraint IResolveConstraint"
  },
  "api/NUnit.Framework.Constraints.EmptyConstraint.html": {
    "href": "api/NUnit.Framework.Constraints.EmptyConstraint.html",
    "title": "Class EmptyConstraint | NUnit Docs",
    "summary": "Class EmptyConstraint EmptyConstraint tests a whether a string or collection is empty, postponing the decision about which test is applied until the type of the actual argument is known. Inheritance object Constraint EmptyConstraint Implements IConstraint IResolveConstraint Inherited Members Constraint.ApplyTo<TActual>(ActualValueDelegate<TActual>) Constraint.ApplyTo<TActual>(ref TActual) Constraint.ApplyToAsync<TActual>(Func<Task<TActual>>) Constraint.GetTestObject<TActual>(ActualValueDelegate<TActual>) Constraint.ToString() Constraint.GetStringRepresentation(IEnumerable) Constraint.GetStringRepresentation() Constraint.After(int) Constraint.After(int, int) Constraint.DisplayName Constraint.Arguments Constraint.Builder Constraint.And Constraint.With Constraint.Or object.GetType() object.MemberwiseClone() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework.Constraints Assembly: nunit.framework.dll Syntax public class EmptyConstraint : Constraint, IConstraint, IResolveConstraint Constructors View Source EmptyConstraint() Declaration public EmptyConstraint() Properties View Source Description The Description of what this constraint tests, for use in messages and in the ConstraintResult. Declaration public override string Description { get; } Property Value Type Description string Overrides Constraint.Description Methods View Source ApplyTo<TActual>(TActual) Test whether the constraint is satisfied by a given value Declaration public override ConstraintResult ApplyTo<TActual>(TActual actual) Parameters Type Name Description TActual actual The value to be tested Returns Type Description ConstraintResult True for success, false for failure Type Parameters Name Description TActual Overrides Constraint.ApplyTo<TActual>(TActual) Implements IConstraint IResolveConstraint"
  },
  "api/NUnit.Framework.Constraints.EmptyDirectoryConstraint.html": {
    "href": "api/NUnit.Framework.Constraints.EmptyDirectoryConstraint.html",
    "title": "Class EmptyDirectoryConstraint | NUnit Docs",
    "summary": "Class EmptyDirectoryConstraint EmptyDirectoryConstraint is used to test that a directory is empty Inheritance object Constraint EmptyDirectoryConstraint Implements IConstraint IResolveConstraint Inherited Members Constraint.ApplyTo<TActual>(ActualValueDelegate<TActual>) Constraint.ApplyTo<TActual>(ref TActual) Constraint.ApplyToAsync<TActual>(Func<Task<TActual>>) Constraint.GetTestObject<TActual>(ActualValueDelegate<TActual>) Constraint.ToString() Constraint.GetStringRepresentation(IEnumerable) Constraint.GetStringRepresentation() Constraint.After(int) Constraint.After(int, int) Constraint.DisplayName Constraint.Arguments Constraint.Builder Constraint.And Constraint.With Constraint.Or object.GetType() object.MemberwiseClone() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework.Constraints Assembly: nunit.framework.dll Syntax public class EmptyDirectoryConstraint : Constraint, IConstraint, IResolveConstraint Constructors View Source EmptyDirectoryConstraint() Declaration public EmptyDirectoryConstraint() Properties View Source Description The Description of what this constraint tests, for use in messages and in the ConstraintResult. Declaration public override string Description { get; } Property Value Type Description string Overrides Constraint.Description Methods View Source ApplyTo<TActual>(TActual) Test whether the constraint is satisfied by a given value Declaration public override ConstraintResult ApplyTo<TActual>(TActual actual) Parameters Type Name Description TActual actual The value to be tested Returns Type Description ConstraintResult True for success, false for failure Type Parameters Name Description TActual Overrides Constraint.ApplyTo<TActual>(TActual) Implements IConstraint IResolveConstraint"
  },
  "api/NUnit.Framework.Constraints.EmptyGuidConstraint.html": {
    "href": "api/NUnit.Framework.Constraints.EmptyGuidConstraint.html",
    "title": "Class EmptyGuidConstraint | NUnit Docs",
    "summary": "Class EmptyGuidConstraint EmptyGuidConstraint tests whether a Guid is empty. Inheritance object Constraint EmptyGuidConstraint Implements IConstraint IResolveConstraint Inherited Members Constraint.ApplyTo<TActual>(ActualValueDelegate<TActual>) Constraint.ApplyTo<TActual>(ref TActual) Constraint.ApplyToAsync<TActual>(Func<Task<TActual>>) Constraint.GetTestObject<TActual>(ActualValueDelegate<TActual>) Constraint.ToString() Constraint.GetStringRepresentation(IEnumerable) Constraint.GetStringRepresentation() Constraint.After(int) Constraint.After(int, int) Constraint.DisplayName Constraint.Arguments Constraint.Builder Constraint.And Constraint.With Constraint.Or object.GetType() object.MemberwiseClone() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework.Constraints Assembly: nunit.framework.dll Syntax public class EmptyGuidConstraint : Constraint, IConstraint, IResolveConstraint Constructors View Source EmptyGuidConstraint() Declaration public EmptyGuidConstraint() Properties View Source Description The Description of what this constraint tests, for use in messages and in the ConstraintResult. Declaration public override string Description { get; } Property Value Type Description string Overrides Constraint.Description Methods View Source ApplyTo<TActual>(TActual) Test whether the constraint is satisfied by a given value Declaration public override ConstraintResult ApplyTo<TActual>(TActual actual) Parameters Type Name Description TActual actual The value to be tested Returns Type Description ConstraintResult True for success, false for failure Type Parameters Name Description TActual Overrides Constraint.ApplyTo<TActual>(TActual) Implements IConstraint IResolveConstraint"
  },
  "api/NUnit.Framework.Constraints.EmptyStringConstraint.html": {
    "href": "api/NUnit.Framework.Constraints.EmptyStringConstraint.html",
    "title": "Class EmptyStringConstraint | NUnit Docs",
    "summary": "Class EmptyStringConstraint EmptyStringConstraint tests whether a string is empty. Inheritance object Constraint StringConstraint EmptyStringConstraint Implements IConstraint IResolveConstraint Inherited Members StringConstraint.expected StringConstraint.caseInsensitive StringConstraint.descriptionText StringConstraint.ApplyTo<TActual>(TActual) StringConstraint.IgnoreCase Constraint.ApplyTo<TActual>(ActualValueDelegate<TActual>) Constraint.ApplyTo<TActual>(ref TActual) Constraint.ApplyToAsync<TActual>(Func<Task<TActual>>) Constraint.GetTestObject<TActual>(ActualValueDelegate<TActual>) Constraint.ToString() Constraint.GetStringRepresentation(IEnumerable) Constraint.GetStringRepresentation() Constraint.After(int) Constraint.After(int, int) Constraint.DisplayName Constraint.Arguments Constraint.Builder Constraint.And Constraint.With Constraint.Or object.GetType() object.MemberwiseClone() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework.Constraints Assembly: nunit.framework.dll Syntax public class EmptyStringConstraint : StringConstraint, IConstraint, IResolveConstraint Constructors View Source EmptyStringConstraint() Declaration public EmptyStringConstraint() Properties View Source Description The Description of what this constraint tests, for use in messages and in the ConstraintResult. Declaration public override string Description { get; } Property Value Type Description string Overrides StringConstraint.Description Methods View Source Matches(string?) Test whether the constraint is satisfied by a given value Declaration protected override bool Matches(string? actual) Parameters Type Name Description string actual The value to be tested Returns Type Description bool True for success, false for failure Overrides StringConstraint.Matches(string?) Implements IConstraint IResolveConstraint"
  },
  "api/NUnit.Framework.Constraints.EndsWithConstraint.html": {
    "href": "api/NUnit.Framework.Constraints.EndsWithConstraint.html",
    "title": "Class EndsWithConstraint | NUnit Docs",
    "summary": "Class EndsWithConstraint EndsWithConstraint can test whether a string ends with an expected substring. Inheritance object Constraint StringConstraint EndsWithConstraint Implements IConstraint IResolveConstraint Inherited Members StringConstraint.expected StringConstraint.caseInsensitive StringConstraint.descriptionText StringConstraint.ApplyTo<TActual>(TActual) StringConstraint.Description StringConstraint.IgnoreCase Constraint.ApplyTo<TActual>(ActualValueDelegate<TActual>) Constraint.ApplyTo<TActual>(ref TActual) Constraint.ApplyToAsync<TActual>(Func<Task<TActual>>) Constraint.GetTestObject<TActual>(ActualValueDelegate<TActual>) Constraint.ToString() Constraint.GetStringRepresentation(IEnumerable) Constraint.GetStringRepresentation() Constraint.After(int) Constraint.After(int, int) Constraint.DisplayName Constraint.Arguments Constraint.Builder Constraint.And Constraint.With Constraint.Or object.GetType() object.MemberwiseClone() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework.Constraints Assembly: nunit.framework.dll Syntax public class EndsWithConstraint : StringConstraint, IConstraint, IResolveConstraint Constructors View Source EndsWithConstraint(string) Initializes a new instance of the EndsWithConstraint class. Declaration public EndsWithConstraint(string expected) Parameters Type Name Description string expected The expected string Methods View Source Matches(string?) Test whether the constraint is matched by the actual value. This is a template method, which calls the IsMatch method of the derived class. Declaration protected override bool Matches(string? actual) Parameters Type Name Description string actual Returns Type Description bool Overrides StringConstraint.Matches(string?) Implements IConstraint IResolveConstraint"
  },
  "api/NUnit.Framework.Constraints.EqualConstraint-1.html": {
    "href": "api/NUnit.Framework.Constraints.EqualConstraint-1.html",
    "title": "Class EqualConstraint<T> | NUnit Docs",
    "summary": "Class EqualConstraint<T> EqualConstraint is able to compare an actual value with the expected value provided in its constructor. Two objects are considered equal if both are null, or if both have the same value. NUnit has special semantics for some object types. Inheritance object Constraint EqualConstraint EqualConstraint<T> Implements IConstraint IResolveConstraint Inherited Members EqualConstraint.Within(object) EqualConstraint.Using(IComparer) EqualConstraint.Using<T>(IComparer<T>) EqualConstraint.Using<T>(Func<T, T, bool>) EqualConstraint.Using<T>(Comparison<T>) EqualConstraint.Using(IEqualityComparer) EqualConstraint.Using<T>(IEqualityComparer<T>) EqualConstraint.Using<TActual, TExpected>(Func<TActual, TExpected, bool>) EqualConstraint.UsingPropertiesComparer() EqualConstraint.UsingPropertiesComparer(Func<PropertiesComparerConfigurationUntyped, PropertiesComparerConfigurationUntyped>) EqualConstraint.ApplyTo<TActual>(TActual) EqualConstraint.Comparer EqualConstraint.Tolerance EqualConstraint.CaseInsensitive EqualConstraint.IgnoringWhiteSpace EqualConstraint.IgnoringLineEndingFormat EqualConstraint.ComparingProperties EqualConstraint.ClipStrings EqualConstraint.HasFailurePoints EqualConstraint.FailurePoints EqualConstraint.IgnoreCase EqualConstraint.IgnoreWhiteSpace EqualConstraint.IgnoreLineEndingFormat EqualConstraint.NoClip EqualConstraint.AsCollection EqualConstraint.WithSameOffset EqualConstraint.Ulps EqualConstraint.Percent EqualConstraint.Days EqualConstraint.Hours EqualConstraint.Minutes EqualConstraint.Seconds EqualConstraint.Milliseconds EqualConstraint.Ticks EqualConstraint.Description Constraint.ApplyTo<TActual>(ActualValueDelegate<TActual>) Constraint.ApplyTo<TActual>(ref TActual) Constraint.ApplyToAsync<TActual>(Func<Task<TActual>>) Constraint.GetTestObject<TActual>(ActualValueDelegate<TActual>) Constraint.ToString() Constraint.GetStringRepresentation(IEnumerable) Constraint.GetStringRepresentation() Constraint.After(int) Constraint.After(int, int) Constraint.DisplayName Constraint.Arguments Constraint.Builder Constraint.And Constraint.With Constraint.Or object.GetType() object.MemberwiseClone() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework.Constraints Assembly: nunit.framework.dll Syntax public class EqualConstraint<T> : EqualConstraint, IConstraint, IResolveConstraint Type Parameters Name Description T Constructors View Source EqualConstraint(object?) Initializes a new instance of the EqualConstraint class. Declaration public EqualConstraint(object? expected) Parameters Type Name Description object expected The expected value. Methods View Source UsingPropertiesComparer(Func<PropertiesComparerConfiguration<T>, PropertiesComparerConfiguration<T>>) Enables comparing a subset of instance properties. Declaration public EqualConstraint UsingPropertiesComparer(Func<PropertiesComparerConfiguration<T>, PropertiesComparerConfiguration<T>> configure) Parameters Type Name Description Func<PropertiesComparerConfiguration<T>, PropertiesComparerConfiguration<T>> configure Function to configure the PropertiesComparerConfiguration Returns Type Description EqualConstraint Remarks This allows comparing classes that don't implement IEquatable<T> without having to compare each property separately in own code. Implements IConstraint IResolveConstraint"
  },
  "api/NUnit.Framework.Constraints.EqualConstraint.html": {
    "href": "api/NUnit.Framework.Constraints.EqualConstraint.html",
    "title": "Class EqualConstraint | NUnit Docs",
    "summary": "Class EqualConstraint EqualConstraint is able to compare an actual value with the expected value provided in its constructor. Two objects are considered equal if both are null, or if both have the same value. NUnit has special semantics for some object types. Inheritance object Constraint EqualConstraint EqualConstraint<T> Implements IConstraint IResolveConstraint Inherited Members Constraint.ApplyTo<TActual>(ActualValueDelegate<TActual>) Constraint.ApplyTo<TActual>(ref TActual) Constraint.ApplyToAsync<TActual>(Func<Task<TActual>>) Constraint.GetTestObject<TActual>(ActualValueDelegate<TActual>) Constraint.ToString() Constraint.GetStringRepresentation(IEnumerable) Constraint.GetStringRepresentation() Constraint.After(int) Constraint.After(int, int) Constraint.DisplayName Constraint.Arguments Constraint.Builder Constraint.And Constraint.With Constraint.Or object.GetType() object.MemberwiseClone() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework.Constraints Assembly: nunit.framework.dll Syntax public class EqualConstraint : Constraint, IConstraint, IResolveConstraint Constructors View Source EqualConstraint(object?) Initializes a new instance of the EqualConstraint class. Declaration public EqualConstraint(object? expected) Parameters Type Name Description object expected The expected value. Properties View Source AsCollection Flag the constraint to compare arrays as collections and return self. Declaration public EqualConstraint AsCollection { get; } Property Value Type Description EqualConstraint View Source CaseInsensitive Gets a value indicating whether to compare case insensitive. Declaration public bool CaseInsensitive { get; } Property Value Type Description bool true if comparing case insensitive; otherwise, false. View Source ClipStrings Gets a value indicating whether or not to clip strings. Declaration public bool ClipStrings { get; } Property Value Type Description bool true if set to clip strings otherwise, false. View Source Comparer The underlying comparer used. Declaration protected NUnitEqualityComparer Comparer { get; } Property Value Type Description NUnitEqualityComparer View Source ComparingProperties Gets a value indicating whether to compare separate properties. Declaration public bool ComparingProperties { get; } Property Value Type Description bool true if comparing separate properties; otherwise, false. View Source Days Causes the tolerance to be interpreted as a TimeSpan in days. Declaration public EqualConstraint Days { get; } Property Value Type Description EqualConstraint Self View Source Description The Description of what this constraint tests, for use in messages and in the ConstraintResult. Declaration public override string Description { get; } Property Value Type Description string Overrides Constraint.Description View Source FailurePoints Gets the failure points. Declaration public IList<NUnitEqualityComparer.FailurePoint> FailurePoints { get; } Property Value Type Description IList<NUnitEqualityComparer.FailurePoint> The failure points. View Source HasFailurePoints Gets a value indicating whether there is any additional Failure Information. Declaration public bool HasFailurePoints { get; } Property Value Type Description bool View Source Hours Causes the tolerance to be interpreted as a TimeSpan in hours. Declaration public EqualConstraint Hours { get; } Property Value Type Description EqualConstraint Self View Source IgnoreCase Flag the constraint to ignore case and return self. Declaration public EqualConstraint IgnoreCase { get; } Property Value Type Description EqualConstraint View Source IgnoreLineEndingFormat Flag the constraint to ignore line ending format (\\r vs. \\n vs. \\r\\n) and return self. Declaration public EqualConstraint IgnoreLineEndingFormat { get; } Property Value Type Description EqualConstraint View Source IgnoreWhiteSpace Flag the constraint to ignore white space and return self. Declaration public EqualConstraint IgnoreWhiteSpace { get; } Property Value Type Description EqualConstraint View Source IgnoringLineEndingFormat Gets a value indicating whether to compare ignoring line ending format (\\r vs. \\n vs. \\r\\n). Declaration public bool IgnoringLineEndingFormat { get; } Property Value Type Description bool true if comparing ignoring line ending format (\\r vs. \\n vs. \\r\\n); otherwise, false. View Source IgnoringWhiteSpace Gets a value indicating whether to compare ignoring white space. Declaration public bool IgnoringWhiteSpace { get; } Property Value Type Description bool true if comparing ignoring white space; otherwise, false. View Source Milliseconds Causes the tolerance to be interpreted as a TimeSpan in milliseconds. Declaration public EqualConstraint Milliseconds { get; } Property Value Type Description EqualConstraint Self View Source Minutes Causes the tolerance to be interpreted as a TimeSpan in minutes. Declaration public EqualConstraint Minutes { get; } Property Value Type Description EqualConstraint Self View Source NoClip Flag the constraint to suppress string clipping and return self. Declaration public EqualConstraint NoClip { get; } Property Value Type Description EqualConstraint View Source Percent Switches the .Within() modifier to interpret its tolerance as a percentage that the actual values is allowed to deviate from the expected value. Declaration public EqualConstraint Percent { get; } Property Value Type Description EqualConstraint Self View Source Seconds Causes the tolerance to be interpreted as a TimeSpan in seconds. Declaration public EqualConstraint Seconds { get; } Property Value Type Description EqualConstraint Self View Source Ticks Causes the tolerance to be interpreted as a TimeSpan in clock ticks. Declaration public EqualConstraint Ticks { get; } Property Value Type Description EqualConstraint Self View Source Tolerance Gets the tolerance for this comparison. Declaration public Tolerance Tolerance { get; } Property Value Type Description Tolerance The tolerance. View Source Ulps Switches the .Within() modifier to interpret its tolerance as a distance in representable values (see remarks). Declaration public EqualConstraint Ulps { get; } Property Value Type Description EqualConstraint Self. Remarks Ulp stands for \"unit in the last place\" and describes the minimum amount a given value can change. For any integers, an ulp is 1 whole digit. For floating point values, the accuracy of which is better for smaller numbers and worse for larger numbers, an ulp depends on the size of the number. Using ulps for comparison of floating point results instead of fixed tolerances is safer because it will automatically compensate for the added inaccuracy of larger numbers. View Source WithSameOffset Flags the constraint to include Offset property in comparison of two DateTimeOffset values. Declaration public EqualConstraint WithSameOffset { get; } Property Value Type Description EqualConstraint Remarks Using this modifier does not allow to use the Within(object) constraint modifier. Methods View Source ApplyTo<TActual>(TActual) Test whether the constraint is satisfied by a given value Declaration public override ConstraintResult ApplyTo<TActual>(TActual actual) Parameters Type Name Description TActual actual The value to be tested Returns Type Description ConstraintResult True for success, false for failure Type Parameters Name Description TActual Overrides Constraint.ApplyTo<TActual>(TActual) View Source Using(IComparer) Flag the constraint to use the supplied IComparer object. Declaration public EqualConstraint Using(IComparer comparer) Parameters Type Name Description IComparer comparer The IComparer object to use. Returns Type Description EqualConstraint Self. View Source Using(IEqualityComparer) Flag the constraint to use the supplied IEqualityComparer object. Declaration public EqualConstraint Using(IEqualityComparer comparer) Parameters Type Name Description IEqualityComparer comparer The IComparer object to use. Returns Type Description EqualConstraint Self. View Source UsingPropertiesComparer() Enables comparing of instance properties. Declaration public EqualConstraint UsingPropertiesComparer() Returns Type Description EqualConstraint Remarks This allows comparing classes that don't implement IEquatable<T> without having to compare each property separately in own code. View Source UsingPropertiesComparer(Func<PropertiesComparerConfigurationUntyped, PropertiesComparerConfigurationUntyped>) Enables comparing of instance properties. Declaration public EqualConstraint UsingPropertiesComparer(Func<PropertiesComparerConfigurationUntyped, PropertiesComparerConfigurationUntyped> configure) Parameters Type Name Description Func<PropertiesComparerConfigurationUntyped, PropertiesComparerConfigurationUntyped> configure Function to configure the PropertiesComparerConfiguration Returns Type Description EqualConstraint Remarks This allows comparing classes that don't implement IEquatable<T> without having to compare each property separately in own code. View Source Using<T>(IComparer<T>) Flag the constraint to use the supplied IComparer object. Declaration public EqualConstraint Using<T>(IComparer<T> comparer) Parameters Type Name Description IComparer<T> comparer The IComparer object to use. Returns Type Description EqualConstraint Self. Type Parameters Name Description T View Source Using<T>(IEqualityComparer<T>) Flag the constraint to use the supplied IEqualityComparer object. Declaration public EqualConstraint Using<T>(IEqualityComparer<T> comparer) Parameters Type Name Description IEqualityComparer<T> comparer The IComparer object to use. Returns Type Description EqualConstraint Self. Type Parameters Name Description T View Source Using<T>(Comparison<T>) Flag the constraint to use the supplied Comparison object. Declaration public EqualConstraint Using<T>(Comparison<T> comparer) Parameters Type Name Description Comparison<T> comparer The IComparer object to use. Returns Type Description EqualConstraint Self. Type Parameters Name Description T View Source Using<T>(Func<T, T, bool>) Flag the constraint to use the supplied boolean-returning delegate. Declaration public EqualConstraint Using<T>(Func<T, T, bool> comparer) Parameters Type Name Description Func<T, T, bool> comparer The boolean-returning delegate to use. Returns Type Description EqualConstraint Self. Type Parameters Name Description T View Source Using<TActual, TExpected>(Func<TActual, TExpected, bool>) Flag the constraint to use the supplied predicate function Declaration public EqualConstraint Using<TActual, TExpected>(Func<TActual, TExpected, bool> comparison) Parameters Type Name Description Func<TActual, TExpected, bool> comparison The comparison function to use. Returns Type Description EqualConstraint Self. Type Parameters Name Description TActual The type of the actual value. Note for collection comparisons this is the element type. TExpected The type of the expected value. Note for collection comparisons this is the element type. View Source Within(object) Flag the constraint to use a tolerance when determining equality. Declaration public EqualConstraint Within(object amount) Parameters Type Name Description object amount Tolerance value to be used Returns Type Description EqualConstraint Self. Implements IConstraint IResolveConstraint"
  },
  "api/NUnit.Framework.Constraints.EqualConstraintResult.html": {
    "href": "api/NUnit.Framework.Constraints.EqualConstraintResult.html",
    "title": "Class EqualConstraintResult | NUnit Docs",
    "summary": "Class EqualConstraintResult The EqualConstraintResult class is tailored for formatting and displaying the result of an EqualConstraint. Inheritance object ConstraintResult EqualConstraintResult Inherited Members ConstraintResult.WriteAdditionalLinesTo(MessageWriter) ConstraintResult.WriteActualValueTo(MessageWriter) ConstraintResult.ActualValue ConstraintResult.Status ConstraintResult.IsSuccess ConstraintResult.Name ConstraintResult.Description object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework.Constraints Assembly: nunit.framework.dll Syntax public class EqualConstraintResult : ConstraintResult Constructors View Source EqualConstraintResult(Constraint, object?, Tolerance, bool) Construct an EqualConstraintResult Declaration public EqualConstraintResult(Constraint constraint, object? actual, Tolerance tolerance, bool hasSucceeded) Parameters Type Name Description Constraint constraint object actual Tolerance tolerance bool hasSucceeded View Source EqualConstraintResult(Constraint, object?, bool) Construct an EqualConstraintResult Declaration public EqualConstraintResult(Constraint constraint, object? actual, bool hasSucceeded) Parameters Type Name Description Constraint constraint object actual bool hasSucceeded View Source EqualConstraintResult(EqualConstraint, object?, bool) Construct an EqualConstraintResult Declaration public EqualConstraintResult(EqualConstraint constraint, object? actual, bool hasSucceeded) Parameters Type Name Description EqualConstraint constraint object actual bool hasSucceeded View Source EqualConstraintResult(EqualStringWithoutUsingConstraint, object?, bool, bool, bool, bool) Construct an EqualConstraintResult Declaration public EqualConstraintResult(EqualStringWithoutUsingConstraint constraint, object? actual, bool caseInsensitive, bool ignoringWhiteSpace, bool clipStrings, bool hasSucceeded) Parameters Type Name Description EqualStringWithoutUsingConstraint constraint object actual bool caseInsensitive bool ignoringWhiteSpace bool clipStrings bool hasSucceeded View Source EqualConstraintResult(EqualStringWithoutUsingConstraint, object?, bool, bool, bool, bool, bool) Construct an EqualConstraintResult Declaration public EqualConstraintResult(EqualStringWithoutUsingConstraint constraint, object? actual, bool caseInsensitive, bool ignoringWhiteSpace, bool ignoringLineEndingFormat, bool clipStrings, bool hasSucceeded) Parameters Type Name Description EqualStringWithoutUsingConstraint constraint object actual bool caseInsensitive bool ignoringWhiteSpace bool ignoringLineEndingFormat bool clipStrings bool hasSucceeded Methods View Source WriteMessageTo(MessageWriter) Write a failure message. Overridden to provide custom failure messages for EqualConstraint. Declaration public override void WriteMessageTo(MessageWriter writer) Parameters Type Name Description MessageWriter writer The MessageWriter to write to Overrides ConstraintResult.WriteMessageTo(MessageWriter)"
  },
  "api/NUnit.Framework.Constraints.EqualDateTimeOffsetConstraint.html": {
    "href": "api/NUnit.Framework.Constraints.EqualDateTimeOffsetConstraint.html",
    "title": "Class EqualDateTimeOffsetConstraint | NUnit Docs",
    "summary": "Class EqualDateTimeOffsetConstraint EqualConstraint is able to compare an actual value with the expected value provided in its constructor. Two objects are considered equal if both are null, or if both have the same value. NUnit has special semantics for some object types. Inheritance object Constraint EqualTimeBaseConstraint<DateTimeOffset> EqualDateTimeOffsetConstraint Implements IConstraint IResolveConstraint Inherited Members EqualTimeBaseConstraint<DateTimeOffset>.Within(TimeSpan) EqualTimeBaseConstraint<DateTimeOffset>.Within(double) EqualTimeBaseConstraint<DateTimeOffset>.ApplyTo(DateTimeOffset) EqualTimeBaseConstraint<DateTimeOffset>.ApplyTo<TActual>(TActual) EqualTimeBaseConstraint<DateTimeOffset>.Expected EqualTimeBaseConstraint<DateTimeOffset>.Description Constraint.ApplyTo<TActual>(ActualValueDelegate<TActual>) Constraint.ApplyTo<TActual>(ref TActual) Constraint.ApplyToAsync<TActual>(Func<Task<TActual>>) Constraint.GetTestObject<TActual>(ActualValueDelegate<TActual>) Constraint.ToString() Constraint.GetStringRepresentation(IEnumerable) Constraint.GetStringRepresentation() Constraint.After(int) Constraint.After(int, int) Constraint.DisplayName Constraint.Arguments Constraint.Builder Constraint.And Constraint.With Constraint.Or object.GetType() object.MemberwiseClone() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework.Constraints Assembly: nunit.framework.dll Syntax public class EqualDateTimeOffsetConstraint : EqualTimeBaseConstraint<DateTimeOffset>, IConstraint, IResolveConstraint Constructors View Source EqualDateTimeOffsetConstraint(DateTimeOffset) Initializes a new instance of the EqualConstraint class. Declaration public EqualDateTimeOffsetConstraint(DateTimeOffset expected) Parameters Type Name Description DateTimeOffset expected The expected value. Properties View Source WithSameOffset Flags the constraint to include Offset property in comparison of two DateTimeOffset values. Declaration public EqualDateTimeOffsetConstraintWithSameOffset WithSameOffset { get; } Property Value Type Description EqualDateTimeOffsetConstraintWithSameOffset Remarks Using this modifier does not allow to use the Within(object) constraint modifier. Implements IConstraint IResolveConstraint"
  },
  "api/NUnit.Framework.Constraints.EqualDateTimeOffsetConstraintWithSameOffset.html": {
    "href": "api/NUnit.Framework.Constraints.EqualDateTimeOffsetConstraintWithSameOffset.html",
    "title": "Class EqualDateTimeOffsetConstraintWithSameOffset | NUnit Docs",
    "summary": "Class EqualDateTimeOffsetConstraintWithSameOffset EqualConstraint is able to compare an actual value with the expected value provided in its constructor. Two objects are considered equal if both are null, or if both have the same value. NUnit has special semantics for some object types. Inheritance object Constraint EqualDateTimeOffsetConstraintWithSameOffset Implements IConstraint IResolveConstraint Inherited Members Constraint.ApplyTo<TActual>(ActualValueDelegate<TActual>) Constraint.ApplyTo<TActual>(ref TActual) Constraint.ApplyToAsync<TActual>(Func<Task<TActual>>) Constraint.GetTestObject<TActual>(ActualValueDelegate<TActual>) Constraint.ToString() Constraint.GetStringRepresentation(IEnumerable) Constraint.GetStringRepresentation() Constraint.After(int) Constraint.After(int, int) Constraint.DisplayName Constraint.Arguments Constraint.Builder Constraint.And Constraint.With Constraint.Or object.GetType() object.MemberwiseClone() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework.Constraints Assembly: nunit.framework.dll Syntax public class EqualDateTimeOffsetConstraintWithSameOffset : Constraint, IConstraint, IResolveConstraint Constructors View Source EqualDateTimeOffsetConstraintWithSameOffset(DateTimeOffset) Initializes a new instance of the EqualConstraint class. Declaration public EqualDateTimeOffsetConstraintWithSameOffset(DateTimeOffset expected) Parameters Type Name Description DateTimeOffset expected The expected value. Properties View Source Description The Description of what this constraint tests, for use in messages and in the ConstraintResult. Declaration public override string Description { get; } Property Value Type Description string Overrides Constraint.Description Methods View Source ApplyTo(DateTimeOffset) Test whether the constraint is satisfied by a given value Declaration public ConstraintResult ApplyTo(DateTimeOffset actual) Parameters Type Name Description DateTimeOffset actual The value to be tested Returns Type Description ConstraintResult True for success, false for failure View Source ApplyTo<TActual>(TActual) Test whether the constraint is satisfied by a given value Declaration public override ConstraintResult ApplyTo<TActual>(TActual actual) Parameters Type Name Description TActual actual The value to be tested Returns Type Description ConstraintResult True for success, false for failure Type Parameters Name Description TActual Overrides Constraint.ApplyTo<TActual>(TActual) Implements IConstraint IResolveConstraint"
  },
  "api/NUnit.Framework.Constraints.EqualNumericConstraint-1.html": {
    "href": "api/NUnit.Framework.Constraints.EqualNumericConstraint-1.html",
    "title": "Class EqualNumericConstraint<T> | NUnit Docs",
    "summary": "Class EqualNumericConstraint<T> EqualNumericConstraint is able to compare an actual value with the expected value provided in its constructor. Two objects are considered equal if both are null, or if both have the same value. NUnit has special semantics for some object types. Inheritance object Constraint EqualNumericWithoutUsingConstraint<T> EqualNumericConstraint<T> Implements IConstraint IResolveConstraint IEqualWithUsingConstraint<T> Inherited Members EqualNumericWithoutUsingConstraint<T>.Within(T) EqualNumericWithoutUsingConstraint<T>.ApplyTo(T) EqualNumericWithoutUsingConstraint<T>.ApplyTo<TActual>(TActual) EqualNumericWithoutUsingConstraint<T>.DisplayName EqualNumericWithoutUsingConstraint<T>.Expected EqualNumericWithoutUsingConstraint<T>.Tolerance EqualNumericWithoutUsingConstraint<T>.Ulps EqualNumericWithoutUsingConstraint<T>.Percent EqualNumericWithoutUsingConstraint<T>.Description Constraint.ApplyTo<TActual>(ActualValueDelegate<TActual>) Constraint.ApplyTo<TActual>(ref TActual) Constraint.ApplyToAsync<TActual>(Func<Task<TActual>>) Constraint.GetTestObject<TActual>(ActualValueDelegate<TActual>) Constraint.ToString() Constraint.GetStringRepresentation(IEnumerable) Constraint.GetStringRepresentation() Constraint.After(int) Constraint.After(int, int) Constraint.Arguments Constraint.Builder Constraint.And Constraint.With Constraint.Or object.GetType() object.MemberwiseClone() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework.Constraints Assembly: nunit.framework.dll Syntax public class EqualNumericConstraint<T> : EqualNumericWithoutUsingConstraint<T>, IConstraint, IResolveConstraint, IEqualWithUsingConstraint<T> where T : unmanaged, IConvertible Type Parameters Name Description T Constructors View Source EqualNumericConstraint(T) Initializes a new instance of the EqualConstraint class. Declaration public EqualNumericConstraint(T expected) Parameters Type Name Description T expected The expected value. Remarks Marked internal to prevent external instantiation with non-supported types. Implements IConstraint IResolveConstraint IEqualWithUsingConstraint<T> Extension Methods IEqualWithUsingConstraintExtensions.Using<TExpected>(IEqualWithUsingConstraint<TExpected>, IComparer<TExpected>) IEqualWithUsingConstraintExtensions.Using<TExpected>(IEqualWithUsingConstraint<TExpected>, IEqualityComparer<TExpected>) IEqualWithUsingConstraintExtensions.Using<TExpected>(IEqualWithUsingConstraint<TExpected>, IComparer) IEqualWithUsingConstraintExtensions.Using<TExpected>(IEqualWithUsingConstraint<TExpected>, IEqualityComparer) IEqualWithUsingConstraintExtensions.Using<TExpected>(IEqualWithUsingConstraint<TExpected>, Comparison<TExpected>) IEqualWithUsingConstraintExtensions.Using<TExpected>(IEqualWithUsingConstraint<TExpected>, Func<TExpected, TExpected, bool>) IEqualWithUsingConstraintExtensions.Using<TActual, TExpected>(IEqualWithUsingConstraint<TExpected>, IComparer<TActual>) IEqualWithUsingConstraintExtensions.Using<TActual, TExpected>(IEqualWithUsingConstraint<TExpected>, Func<TActual, TExpected, bool>)"
  },
  "api/NUnit.Framework.Constraints.EqualNumericWithoutUsingConstraint-1.html": {
    "href": "api/NUnit.Framework.Constraints.EqualNumericWithoutUsingConstraint-1.html",
    "title": "Class EqualNumericWithoutUsingConstraint<T> | NUnit Docs",
    "summary": "Class EqualNumericWithoutUsingConstraint<T> EqualNumericConstraint is able to compare an actual value with the expected value provided in its constructor. Two objects are considered equal if both are null, or if both have the same value. NUnit has special semantics for some object types. Inheritance object Constraint EqualNumericWithoutUsingConstraint<T> EqualNumericConstraint<T> Implements IConstraint IResolveConstraint Inherited Members Constraint.ApplyTo<TActual>(ActualValueDelegate<TActual>) Constraint.ApplyTo<TActual>(ref TActual) Constraint.ApplyToAsync<TActual>(Func<Task<TActual>>) Constraint.GetTestObject<TActual>(ActualValueDelegate<TActual>) Constraint.ToString() Constraint.GetStringRepresentation(IEnumerable) Constraint.GetStringRepresentation() Constraint.After(int) Constraint.After(int, int) Constraint.Arguments Constraint.Builder Constraint.And Constraint.With Constraint.Or object.GetType() object.MemberwiseClone() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework.Constraints Assembly: nunit.framework.dll Syntax public class EqualNumericWithoutUsingConstraint<T> : Constraint, IConstraint, IResolveConstraint where T : unmanaged, IConvertible Type Parameters Name Description T Constructors View Source EqualNumericWithoutUsingConstraint(T) Initializes a new instance of the EqualConstraint class. Declaration public EqualNumericWithoutUsingConstraint(T expected) Parameters Type Name Description T expected The expected value. Remarks Marked internal to prevent external instantiation with non-supported types. Properties View Source Description The Description of what this constraint tests, for use in messages and in the ConstraintResult. Declaration public override string Description { get; } Property Value Type Description string Overrides Constraint.Description View Source DisplayName The display name of this Constraint for use by ToString(). The default value is the name of the constraint with trailing \"Constraint\" removed. Derived classes may set this to another name in their constructors. Declaration public override string DisplayName { get; } Property Value Type Description string Overrides Constraint.DisplayName View Source Expected The expected value. Declaration public T Expected { get; } Property Value Type Description T View Source Percent Switches the .Within() modifier to interpret its tolerance as a percentage that the actual values is allowed to deviate from the expected value. Declaration public EqualNumericWithoutUsingConstraint<T> Percent { get; } Property Value Type Description EqualNumericWithoutUsingConstraint<T> Self View Source Tolerance Gets the tolerance for this comparison. Declaration public Tolerance Tolerance { get; } Property Value Type Description Tolerance The tolerance. View Source Ulps Switches the .Within() modifier to interpret its tolerance as a distance in representable values (see remarks). Declaration public EqualNumericWithoutUsingConstraint<T> Ulps { get; } Property Value Type Description EqualNumericWithoutUsingConstraint<T> Self. Remarks Ulp stands for \"unit in the last place\" and describes the minimum amount a given value can change. For any integers, an ulp is 1 whole digit. For floating point values, the accuracy of which is better for smaller numbers and worse for larger numbers, an ulp depends on the size of the number. Using ulps for comparison of floating point results instead of fixed tolerances is safer because it will automatically compensate for the added inaccuracy of larger numbers. Methods View Source ApplyTo(T) Test whether the constraint is satisfied by a given value Declaration public ConstraintResult ApplyTo(T actual) Parameters Type Name Description T actual The value to be tested Returns Type Description ConstraintResult True for success, false for failure View Source ApplyTo<TActual>(TActual) Test whether the constraint is satisfied by a given value Declaration public override ConstraintResult ApplyTo<TActual>(TActual actual) Parameters Type Name Description TActual actual The value to be tested Returns Type Description ConstraintResult True for success, false for failure Type Parameters Name Description TActual Overrides Constraint.ApplyTo<TActual>(TActual) View Source Within(T) Flag the constraint to use a tolerance when determining equality. Declaration public EqualNumericWithoutUsingConstraint<T> Within(T amount) Parameters Type Name Description T amount Tolerance value to be used Returns Type Description EqualNumericWithoutUsingConstraint<T> Self. Implements IConstraint IResolveConstraint"
  },
  "api/NUnit.Framework.Constraints.EqualStringConstraint.html": {
    "href": "api/NUnit.Framework.Constraints.EqualStringConstraint.html",
    "title": "Class EqualStringConstraint | NUnit Docs",
    "summary": "Class EqualStringConstraint EqualConstraint is able to compare an actual value with the expected value provided in its constructor. Two objects are considered equal if both are null, or if both have the same value. NUnit has special semantics for some object types. Inheritance object Constraint EqualStringWithoutUsingConstraint EqualStringConstraint Implements IConstraint IResolveConstraint IEqualWithUsingConstraint<string> Inherited Members EqualStringWithoutUsingConstraint.ApplyTo(string) EqualStringWithoutUsingConstraint.ApplyTo<TActual>(TActual) EqualStringWithoutUsingConstraint.Expected EqualStringWithoutUsingConstraint.IgnoreCase EqualStringWithoutUsingConstraint.IgnoreWhiteSpace EqualStringWithoutUsingConstraint.IgnoreLineEndingFormat EqualStringWithoutUsingConstraint.NoClip EqualStringWithoutUsingConstraint.Description Constraint.ApplyTo<TActual>(ActualValueDelegate<TActual>) Constraint.ApplyTo<TActual>(ref TActual) Constraint.ApplyToAsync<TActual>(Func<Task<TActual>>) Constraint.GetTestObject<TActual>(ActualValueDelegate<TActual>) Constraint.ToString() Constraint.GetStringRepresentation(IEnumerable) Constraint.GetStringRepresentation() Constraint.After(int) Constraint.After(int, int) Constraint.DisplayName Constraint.Arguments Constraint.Builder Constraint.And Constraint.With Constraint.Or object.GetType() object.MemberwiseClone() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework.Constraints Assembly: nunit.framework.dll Syntax public class EqualStringConstraint : EqualStringWithoutUsingConstraint, IConstraint, IResolveConstraint, IEqualWithUsingConstraint<string?> Constructors View Source EqualStringConstraint(string?) Initializes a new instance of the EqualConstraint class. Declaration public EqualStringConstraint(string? expected) Parameters Type Name Description string expected The expected value. Methods View Source Using(StringComparer) Sets the StringComparer to be used in the comparison. Declaration public EqualUsingConstraint<string> Using(StringComparer comparer) Parameters Type Name Description StringComparer comparer comparer to use for comparing strings. Returns Type Description EqualUsingConstraint<string> Equal constraint comparing Expected with an actual value using the user supplied comparer. Implements IConstraint IResolveConstraint IEqualWithUsingConstraint<T> Extension Methods IEqualWithUsingConstraintExtensions.Using<TExpected>(IEqualWithUsingConstraint<TExpected>, IComparer<TExpected>) IEqualWithUsingConstraintExtensions.Using<TExpected>(IEqualWithUsingConstraint<TExpected>, IEqualityComparer<TExpected>) IEqualWithUsingConstraintExtensions.Using<TExpected>(IEqualWithUsingConstraint<TExpected>, IComparer) IEqualWithUsingConstraintExtensions.Using<TExpected>(IEqualWithUsingConstraint<TExpected>, IEqualityComparer) IEqualWithUsingConstraintExtensions.Using<TExpected>(IEqualWithUsingConstraint<TExpected>, Comparison<TExpected>) IEqualWithUsingConstraintExtensions.Using<TExpected>(IEqualWithUsingConstraint<TExpected>, Func<TExpected, TExpected, bool>) IEqualWithUsingConstraintExtensions.Using<TActual, TExpected>(IEqualWithUsingConstraint<TExpected>, IComparer<TActual>) IEqualWithUsingConstraintExtensions.Using<TActual, TExpected>(IEqualWithUsingConstraint<TExpected>, Func<TActual, TExpected, bool>)"
  },
  "api/NUnit.Framework.Constraints.EqualStringWithoutUsingConstraint.html": {
    "href": "api/NUnit.Framework.Constraints.EqualStringWithoutUsingConstraint.html",
    "title": "Class EqualStringWithoutUsingConstraint | NUnit Docs",
    "summary": "Class EqualStringWithoutUsingConstraint EqualConstraint is able to compare an actual value with the expected value provided in its constructor. Two objects are considered equal if both are null, or if both have the same value. NUnit has special semantics for some object types. Inheritance object Constraint EqualStringWithoutUsingConstraint EqualStringConstraint Implements IConstraint IResolveConstraint Inherited Members Constraint.ApplyTo<TActual>(ActualValueDelegate<TActual>) Constraint.ApplyTo<TActual>(ref TActual) Constraint.ApplyToAsync<TActual>(Func<Task<TActual>>) Constraint.GetTestObject<TActual>(ActualValueDelegate<TActual>) Constraint.ToString() Constraint.GetStringRepresentation(IEnumerable) Constraint.GetStringRepresentation() Constraint.After(int) Constraint.After(int, int) Constraint.DisplayName Constraint.Arguments Constraint.Builder Constraint.And Constraint.With Constraint.Or object.GetType() object.MemberwiseClone() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework.Constraints Assembly: nunit.framework.dll Syntax public class EqualStringWithoutUsingConstraint : Constraint, IConstraint, IResolveConstraint Constructors View Source EqualStringWithoutUsingConstraint(string?) Initializes a new instance of the EqualConstraint class. Declaration public EqualStringWithoutUsingConstraint(string? expected) Parameters Type Name Description string expected The expected value. Properties View Source Description The Description of what this constraint tests, for use in messages and in the ConstraintResult. Declaration public override string Description { get; } Property Value Type Description string Overrides Constraint.Description View Source Expected Gets the expected value. Declaration public string? Expected { get; } Property Value Type Description string View Source IgnoreCase Flag the constraint to ignore case and return self. Declaration public EqualStringWithoutUsingConstraint IgnoreCase { get; } Property Value Type Description EqualStringWithoutUsingConstraint View Source IgnoreLineEndingFormat Flag the constraint to ignore line ending format (\\r vs. \\n vs. \\r\\n) and return self. Declaration public EqualStringWithoutUsingConstraint IgnoreLineEndingFormat { get; } Property Value Type Description EqualStringWithoutUsingConstraint View Source IgnoreWhiteSpace Flag the constraint to ignore white space and return self. Declaration public EqualStringWithoutUsingConstraint IgnoreWhiteSpace { get; } Property Value Type Description EqualStringWithoutUsingConstraint View Source NoClip Flag the constraint to suppress string clipping and return self. Declaration public EqualStringWithoutUsingConstraint NoClip { get; } Property Value Type Description EqualStringWithoutUsingConstraint Methods View Source ApplyTo(string?) Test whether the constraint is satisfied by a given value Declaration public ConstraintResult ApplyTo(string? actual) Parameters Type Name Description string actual The value to be tested Returns Type Description ConstraintResult True for success, false for failure View Source ApplyTo<TActual>(TActual) Applies the constraint to an actual value, returning a ConstraintResult. Declaration public override sealed ConstraintResult ApplyTo<TActual>(TActual actual) Parameters Type Name Description TActual actual The value to be tested Returns Type Description ConstraintResult A ConstraintResult Type Parameters Name Description TActual Overrides Constraint.ApplyTo<TActual>(TActual) Remarks I wish we could hide this method, but it is public in the base class. Implements IConstraint IResolveConstraint"
  },
  "api/NUnit.Framework.Constraints.EqualTimeBaseConstraint-1.html": {
    "href": "api/NUnit.Framework.Constraints.EqualTimeBaseConstraint-1.html",
    "title": "Class EqualTimeBaseConstraint<T> | NUnit Docs",
    "summary": "Class EqualTimeBaseConstraint<T> EqualConstraint is able to compare an actual value with the expected value provided in its constructor. Two objects are considered equal if both are null, or if both have the same value. NUnit has special semantics for some object types. Inheritance object Constraint EqualTimeBaseConstraint<T> EqualDateTimeOffsetConstraint Implements IConstraint IResolveConstraint Inherited Members Constraint.ApplyTo<TActual>(ActualValueDelegate<TActual>) Constraint.ApplyTo<TActual>(ref TActual) Constraint.ApplyToAsync<TActual>(Func<Task<TActual>>) Constraint.GetTestObject<TActual>(ActualValueDelegate<TActual>) Constraint.ToString() Constraint.GetStringRepresentation(IEnumerable) Constraint.GetStringRepresentation() Constraint.After(int) Constraint.After(int, int) Constraint.DisplayName Constraint.Arguments Constraint.Builder Constraint.And Constraint.With Constraint.Or object.GetType() object.MemberwiseClone() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework.Constraints Assembly: nunit.framework.dll Syntax public class EqualTimeBaseConstraint<T> : Constraint, IConstraint, IResolveConstraint where T : struct, IEquatable<T>, IComparable<T> Type Parameters Name Description T Constructors View Source EqualTimeBaseConstraint(T, Func<T, long>) Initializes a new instance of the EqualConstraint class. Declaration public EqualTimeBaseConstraint(T expected, Func<T, long> getTicks) Parameters Type Name Description T expected The expected value. Func<T, long> getTicks Method to extract the Ticks from an instance of T. Properties View Source Description The Description of what this constraint tests, for use in messages and in the ConstraintResult. Declaration public override string Description { get; } Property Value Type Description string Overrides Constraint.Description View Source Expected Gets the expected value. Declaration public T Expected { get; } Property Value Type Description T Methods View Source ApplyTo(T) Test whether the constraint is satisfied by a given value Declaration public virtual ConstraintResult ApplyTo(T actual) Parameters Type Name Description T actual The value to be tested Returns Type Description ConstraintResult True for success, false for failure View Source ApplyTo<TActual>(TActual) Test whether the constraint is satisfied by a given value Declaration public override ConstraintResult ApplyTo<TActual>(TActual actual) Parameters Type Name Description TActual actual The value to be tested Returns Type Description ConstraintResult True for success, false for failure Type Parameters Name Description TActual Overrides Constraint.ApplyTo<TActual>(TActual) View Source Within(double) Flag the constraint to use a tolerance when determining equality. Declaration public EqualTimeBasedConstraintWithNumericTolerance<T> Within(double amount) Parameters Type Name Description double amount Tolerance value to be used Returns Type Description EqualTimeBasedConstraintWithNumericTolerance<T> Self. View Source Within(TimeSpan) Flag the constraint to use a tolerance when determining equality. Declaration public EqualTimeBasedConstraintWithTimeSpanTolerance<T> Within(TimeSpan amount) Parameters Type Name Description TimeSpan amount Tolerance value to be used Returns Type Description EqualTimeBasedConstraintWithTimeSpanTolerance<T> Self. Implements IConstraint IResolveConstraint"
  },
  "api/NUnit.Framework.Constraints.EqualTimeBasedConstraintWithNumericTolerance-1.html": {
    "href": "api/NUnit.Framework.Constraints.EqualTimeBasedConstraintWithNumericTolerance-1.html",
    "title": "Class EqualTimeBasedConstraintWithNumericTolerance<T> | NUnit Docs",
    "summary": "Class EqualTimeBasedConstraintWithNumericTolerance<T> EqualConstraint is able to compare an actual value with the expected value provided in its constructor. Two objects are considered equal if both are null, or if both have the same value. NUnit has special semantics for some object types. Inheritance object EqualTimeBasedConstraintWithNumericTolerance<T> Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework.Constraints Assembly: nunit.framework.dll Syntax public class EqualTimeBasedConstraintWithNumericTolerance<T> where T : notnull, IEquatable<T>, IComparable<T> Type Parameters Name Description T Constructors View Source EqualTimeBasedConstraintWithNumericTolerance(T, Func<T, long>, double) Initializes a new instance of the EqualConstraint class. Declaration public EqualTimeBasedConstraintWithNumericTolerance(T expected, Func<T, long> getTicks, double tolerance) Parameters Type Name Description T expected The expected value. Func<T, long> getTicks Method to extract the Ticks from an instance of T. double tolerance The tolerance to apply when qualified with a unit. Properties View Source Builder The ConstraintBuilder holding this constraint Declaration public ConstraintBuilder? Builder { get; set; } Property Value Type Description ConstraintBuilder View Source Days Causes the tolerance to be interpreted as a TimeSpan in days. Declaration public EqualTimeBasedConstraintWithTimeSpanTolerance<T> Days { get; } Property Value Type Description EqualTimeBasedConstraintWithTimeSpanTolerance<T> Self View Source Hours Causes the tolerance to be interpreted as a TimeSpan in hours. Declaration public EqualTimeBasedConstraintWithTimeSpanTolerance<T> Hours { get; } Property Value Type Description EqualTimeBasedConstraintWithTimeSpanTolerance<T> Self View Source Milliseconds Causes the tolerance to be interpreted as a TimeSpan in milliseconds. Declaration public EqualTimeBasedConstraintWithTimeSpanTolerance<T> Milliseconds { get; } Property Value Type Description EqualTimeBasedConstraintWithTimeSpanTolerance<T> Self View Source Minutes Causes the tolerance to be interpreted as a TimeSpan in minutes. Declaration public EqualTimeBasedConstraintWithTimeSpanTolerance<T> Minutes { get; } Property Value Type Description EqualTimeBasedConstraintWithTimeSpanTolerance<T> Self View Source Seconds Causes the tolerance to be interpreted as a TimeSpan in seconds. Declaration public EqualTimeBasedConstraintWithTimeSpanTolerance<T> Seconds { get; } Property Value Type Description EqualTimeBasedConstraintWithTimeSpanTolerance<T> Self View Source Ticks Causes the tolerance to be interpreted as a TimeSpan in clock ticks. Declaration public EqualTimeBasedConstraintWithTimeSpanTolerance<T> Ticks { get; } Property Value Type Description EqualTimeBasedConstraintWithTimeSpanTolerance<T> Self"
  },
  "api/NUnit.Framework.Constraints.EqualTimeBasedConstraintWithTimeSpanTolerance-1.html": {
    "href": "api/NUnit.Framework.Constraints.EqualTimeBasedConstraintWithTimeSpanTolerance-1.html",
    "title": "Class EqualTimeBasedConstraintWithTimeSpanTolerance<T> | NUnit Docs",
    "summary": "Class EqualTimeBasedConstraintWithTimeSpanTolerance<T> EqualConstraint is able to compare an actual value with the expected value provided in its constructor. Two objects are considered equal if both are null, or if both have the same value. NUnit has special semantics for some object types. Inheritance object Constraint EqualTimeBasedConstraintWithTimeSpanTolerance<T> Implements IConstraint IResolveConstraint Inherited Members Constraint.ApplyTo<TActual>(ActualValueDelegate<TActual>) Constraint.ApplyTo<TActual>(ref TActual) Constraint.ApplyToAsync<TActual>(Func<Task<TActual>>) Constraint.GetTestObject<TActual>(ActualValueDelegate<TActual>) Constraint.ToString() Constraint.GetStringRepresentation(IEnumerable) Constraint.GetStringRepresentation() Constraint.After(int) Constraint.After(int, int) Constraint.DisplayName Constraint.Arguments Constraint.Builder Constraint.And Constraint.With Constraint.Or object.GetType() object.MemberwiseClone() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework.Constraints Assembly: nunit.framework.dll Syntax public class EqualTimeBasedConstraintWithTimeSpanTolerance<T> : Constraint, IConstraint, IResolveConstraint where T : notnull, IEquatable<T>, IComparable<T> Type Parameters Name Description T Constructors View Source EqualTimeBasedConstraintWithTimeSpanTolerance(T, Func<T, long>, TimeSpan) Initializes a new instance of the EqualConstraint class. Declaration public EqualTimeBasedConstraintWithTimeSpanTolerance(T expected, Func<T, long> getTicks, TimeSpan tolerance) Parameters Type Name Description T expected The expected value. Func<T, long> getTicks Method to extract the Ticks from an instance of T. TimeSpan tolerance The tolerance to apply when comparing for equality. Properties View Source Description The Description of what this constraint tests, for use in messages and in the ConstraintResult. Declaration public override string Description { get; } Property Value Type Description string Overrides Constraint.Description Methods View Source ApplyTo(T) Test whether the constraint is satisfied by a given value Declaration public ConstraintResult ApplyTo(T actual) Parameters Type Name Description T actual The value to be tested Returns Type Description ConstraintResult True for success, false for failure View Source ApplyTo<TActual>(TActual) Test whether the constraint is satisfied by a given value Declaration public override ConstraintResult ApplyTo<TActual>(TActual actual) Parameters Type Name Description TActual actual The value to be tested Returns Type Description ConstraintResult True for success, false for failure Type Parameters Name Description TActual Overrides Constraint.ApplyTo<TActual>(TActual) Implements IConstraint IResolveConstraint"
  },
  "api/NUnit.Framework.Constraints.EqualUsingConstraint-1.html": {
    "href": "api/NUnit.Framework.Constraints.EqualUsingConstraint-1.html",
    "title": "Class EqualUsingConstraint<T> | NUnit Docs",
    "summary": "Class EqualUsingConstraint<T> EqualUsingConstraint where the comparison is done by a user supplied comparer. Inheritance object Constraint EqualUsingConstraint<T> Implements IConstraint IResolveConstraint Inherited Members Constraint.ApplyTo<TActual>(ActualValueDelegate<TActual>) Constraint.ApplyTo<TActual>(ref TActual) Constraint.ApplyToAsync<TActual>(Func<Task<TActual>>) Constraint.GetTestObject<TActual>(ActualValueDelegate<TActual>) Constraint.ToString() Constraint.GetStringRepresentation(IEnumerable) Constraint.GetStringRepresentation() Constraint.After(int) Constraint.After(int, int) Constraint.DisplayName Constraint.Arguments Constraint.Builder Constraint.And Constraint.With Constraint.Or object.GetType() object.MemberwiseClone() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework.Constraints Assembly: nunit.framework.dll Syntax public class EqualUsingConstraint<T> : Constraint, IConstraint, IResolveConstraint Type Parameters Name Description T Constructors View Source EqualUsingConstraint(T?, IComparer<T>) Initializes a new instance of the EqualConstraint class. Declaration public EqualUsingConstraint(T? expected, IComparer<T> comparer) Parameters Type Name Description T expected The expected value. IComparer<T> comparer The comparer to use. View Source EqualUsingConstraint(T?, IEqualityComparer<T>) Initializes a new instance of the EqualConstraint class. Declaration public EqualUsingConstraint(T? expected, IEqualityComparer<T> comparer) Parameters Type Name Description T expected The expected value. IEqualityComparer<T> comparer The comparer to use. View Source EqualUsingConstraint(T?, IComparer) Initializes a new instance of the EqualConstraint class. Declaration public EqualUsingConstraint(T? expected, IComparer comparer) Parameters Type Name Description T expected The expected value. IComparer comparer The comparer to use. View Source EqualUsingConstraint(T?, IEqualityComparer) Initializes a new instance of the EqualConstraint class. Declaration public EqualUsingConstraint(T? expected, IEqualityComparer comparer) Parameters Type Name Description T expected The expected value. IEqualityComparer comparer The comparer to use. View Source EqualUsingConstraint(T?, Comparison<T>) Initializes a new instance of the EqualConstraint class. Declaration public EqualUsingConstraint(T? expected, Comparison<T> comparer) Parameters Type Name Description T expected The expected value. Comparison<T> comparer The comparer to use. View Source EqualUsingConstraint(T?, Func<object, object, bool>) Initializes a new instance of the EqualConstraint class. Declaration public EqualUsingConstraint(T? expected, Func<object, object, bool> comparer) Parameters Type Name Description T expected The expected value. Func<object, object, bool> comparer The comparer to use. View Source EqualUsingConstraint(T?, Func<T, T, bool>) Initializes a new instance of the EqualConstraint class. Declaration public EqualUsingConstraint(T? expected, Func<T, T, bool> comparer) Parameters Type Name Description T expected The expected value. Func<T, T, bool> comparer The comparer to use. Properties View Source Description The Description of what this constraint tests, for use in messages and in the ConstraintResult. Declaration public override string Description { get; } Property Value Type Description string Overrides Constraint.Description Methods View Source ApplyTo(T?) Test whether the constraint is satisfied by a given value Declaration public virtual ConstraintResult ApplyTo(T? actual) Parameters Type Name Description T actual The value to be tested Returns Type Description ConstraintResult True for success, false for failure View Source ApplyTo<TActual>(TActual) Applies the constraint to an actual value, returning a ConstraintResult. Declaration public override sealed ConstraintResult ApplyTo<TActual>(TActual actual) Parameters Type Name Description TActual actual The value to be tested Returns Type Description ConstraintResult A ConstraintResult Type Parameters Name Description TActual Overrides Constraint.ApplyTo<TActual>(TActual) Remarks I wish we could hide this method, but it is public in the base class. Implements IConstraint IResolveConstraint"
  },
  "api/NUnit.Framework.Constraints.EqualityAdapter.html": {
    "href": "api/NUnit.Framework.Constraints.EqualityAdapter.html",
    "title": "Class EqualityAdapter | NUnit Docs",
    "summary": "Class EqualityAdapter EqualityAdapter class handles all equality comparisons that use an IEqualityComparer, IEqualityComparer<T> or a ComparisonAdapter. Inheritance object EqualityAdapter Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework.Constraints Assembly: nunit.framework.dll Syntax public abstract class EqualityAdapter Constructors View Source EqualityAdapter() Declaration protected EqualityAdapter() Methods View Source AreEqual(object, object) Compares two objects, returning true if they are equal Declaration public abstract bool AreEqual(object x, object y) Parameters Type Name Description object x object y Returns Type Description bool View Source AreEqual(object, object, ref Tolerance) Compares two objects, within a tolerance returning true if they are equal Declaration public virtual bool AreEqual(object x, object y, ref Tolerance tolerance) Parameters Type Name Description object x object y Tolerance tolerance Returns Type Description bool View Source CanCompare(object, object) Returns true if the two objects can be compared by this adapter. The base adapter cannot handle IEnumerables except for strings. Declaration public virtual bool CanCompare(object x, object y) Parameters Type Name Description object x object y Returns Type Description bool View Source For(IComparer) Returns an EqualityAdapter that wraps an IComparer. Declaration public static EqualityAdapter For(IComparer comparer) Parameters Type Name Description IComparer comparer Returns Type Description EqualityAdapter View Source For(IEqualityComparer) Returns an EqualityAdapter that wraps an IEqualityComparer. Declaration public static EqualityAdapter For(IEqualityComparer comparer) Parameters Type Name Description IEqualityComparer comparer Returns Type Description EqualityAdapter View Source For<T>(IComparer<T>) Returns an EqualityAdapter that wraps an IComparer<T>. Declaration public static EqualityAdapter For<T>(IComparer<T> comparer) Parameters Type Name Description IComparer<T> comparer Returns Type Description EqualityAdapter Type Parameters Name Description T View Source For<T>(IEqualityComparer<T>) Returns an EqualityAdapter that wraps an IEqualityComparer<T>. Declaration public static EqualityAdapter For<T>(IEqualityComparer<T> comparer) Parameters Type Name Description IEqualityComparer<T> comparer Returns Type Description EqualityAdapter Type Parameters Name Description T View Source For<T>(Comparison<T>) Returns an EqualityAdapter that wraps a Comparison<T>. Declaration public static EqualityAdapter For<T>(Comparison<T> comparer) Parameters Type Name Description Comparison<T> comparer Returns Type Description EqualityAdapter Type Parameters Name Description T View Source For<TExpected, TActual>(Func<TExpected, TActual, bool>) Returns an EqualityAdapter that uses a predicate function for items comparison. Declaration public static EqualityAdapter For<TExpected, TActual>(Func<TExpected, TActual, bool> comparison) Parameters Type Name Description Func<TExpected, TActual, bool> comparison Returns Type Description EqualityAdapter Type Parameters Name Description TExpected TActual"
  },
  "api/NUnit.Framework.Constraints.ExactCountConstraint.html": {
    "href": "api/NUnit.Framework.Constraints.ExactCountConstraint.html",
    "title": "Class ExactCountConstraint | NUnit Docs",
    "summary": "Class ExactCountConstraint ExactCountConstraint applies another constraint to each item in a collection, succeeding only if a specified number of items succeed. Inheritance object Constraint ExactCountConstraint Implements IConstraint IResolveConstraint Inherited Members Constraint.ApplyTo<TActual>(ActualValueDelegate<TActual>) Constraint.ApplyTo<TActual>(ref TActual) Constraint.ApplyToAsync<TActual>(Func<Task<TActual>>) Constraint.GetTestObject<TActual>(ActualValueDelegate<TActual>) Constraint.ToString() Constraint.GetStringRepresentation(IEnumerable) Constraint.GetStringRepresentation() Constraint.After(int) Constraint.After(int, int) Constraint.DisplayName Constraint.Arguments Constraint.Builder Constraint.And Constraint.With Constraint.Or object.GetType() object.MemberwiseClone() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework.Constraints Assembly: nunit.framework.dll Syntax public class ExactCountConstraint : Constraint, IConstraint, IResolveConstraint Constructors View Source ExactCountConstraint(int) Construct a standalone ExactCountConstraint Declaration public ExactCountConstraint(int expectedCount) Parameters Type Name Description int expectedCount View Source ExactCountConstraint(int, IConstraint) Construct an ExactCountConstraint on top of an existing constraint Declaration public ExactCountConstraint(int expectedCount, IConstraint itemConstraint) Parameters Type Name Description int expectedCount IConstraint itemConstraint Properties View Source Description The Description of what this constraint tests, for use in messages and in the ConstraintResult. Declaration public override string Description { get; } Property Value Type Description string Overrides Constraint.Description Methods View Source ApplyTo<TActual>(TActual) Apply the item constraint to each item in the collection, succeeding only if the expected number of items pass. Declaration public override ConstraintResult ApplyTo<TActual>(TActual actual) Parameters Type Name Description TActual actual The value to be tested Returns Type Description ConstraintResult A ConstraintResult Type Parameters Name Description TActual Overrides Constraint.ApplyTo<TActual>(TActual) Implements IConstraint IResolveConstraint"
  },
  "api/NUnit.Framework.Constraints.ExactCountOperator.html": {
    "href": "api/NUnit.Framework.Constraints.ExactCountOperator.html",
    "title": "Class ExactCountOperator | NUnit Docs",
    "summary": "Class ExactCountOperator Represents a constraint that succeeds if the specified count of members of a collection match a base constraint. Inheritance object ConstraintOperator SelfResolvingOperator ExactCountOperator Inherited Members ConstraintOperator.left_precedence ConstraintOperator.right_precedence ConstraintOperator.LeftContext ConstraintOperator.RightContext ConstraintOperator.LeftPrecedence ConstraintOperator.RightPrecedence object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework.Constraints Assembly: nunit.framework.dll Syntax public class ExactCountOperator : SelfResolvingOperator Constructors View Source ExactCountOperator(int) Construct an ExactCountOperator for a specified count Declaration public ExactCountOperator(int expectedCount) Parameters Type Name Description int expectedCount The expected count Methods View Source Reduce(ConstraintStack) Reduce produces a constraint from the operator and any arguments. It takes the arguments from the constraint stack and pushes the resulting constraint on it. Declaration public override void Reduce(ConstraintBuilder.ConstraintStack stack) Parameters Type Name Description ConstraintBuilder.ConstraintStack stack Overrides ConstraintOperator.Reduce(ConstraintBuilder.ConstraintStack)"
  },
  "api/NUnit.Framework.Constraints.ExactTypeConstraint.html": {
    "href": "api/NUnit.Framework.Constraints.ExactTypeConstraint.html",
    "title": "Class ExactTypeConstraint | NUnit Docs",
    "summary": "Class ExactTypeConstraint ExactTypeConstraint is used to test that an object is of the exact type provided in the constructor Inheritance object Constraint TypeConstraint ExactTypeConstraint ExceptionTypeConstraint Implements IConstraint IResolveConstraint Inherited Members TypeConstraint.expectedType TypeConstraint.actualType TypeConstraint.ApplyTo<TActual>(TActual) TypeConstraint.Description Constraint.ApplyTo<TActual>(ActualValueDelegate<TActual>) Constraint.ApplyTo<TActual>(ref TActual) Constraint.ApplyToAsync<TActual>(Func<Task<TActual>>) Constraint.GetTestObject<TActual>(ActualValueDelegate<TActual>) Constraint.ToString() Constraint.GetStringRepresentation(IEnumerable) Constraint.GetStringRepresentation() Constraint.After(int) Constraint.After(int, int) Constraint.Arguments Constraint.Builder Constraint.And Constraint.With Constraint.Or object.GetType() object.MemberwiseClone() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework.Constraints Assembly: nunit.framework.dll Syntax public class ExactTypeConstraint : TypeConstraint, IConstraint, IResolveConstraint Constructors View Source ExactTypeConstraint(Type) Construct an ExactTypeConstraint for a given Type Declaration public ExactTypeConstraint(Type type) Parameters Type Name Description Type type The expected Type. Properties View Source DisplayName The display name of this Constraint for use by ToString(). The default value is the name of the constraint with trailing \"Constraint\" removed. Derived classes may set this to another name in their constructors. Declaration public override string DisplayName { get; } Property Value Type Description string Overrides Constraint.DisplayName Methods View Source Matches(object?) Apply the constraint to an actual value, returning true if it succeeds Declaration protected override bool Matches(object? actual) Parameters Type Name Description object actual The actual argument Returns Type Description bool True if the constraint succeeds, otherwise false. Overrides TypeConstraint.Matches(object?) Implements IConstraint IResolveConstraint"
  },
  "api/NUnit.Framework.Constraints.ExceptionTypeConstraint.html": {
    "href": "api/NUnit.Framework.Constraints.ExceptionTypeConstraint.html",
    "title": "Class ExceptionTypeConstraint | NUnit Docs",
    "summary": "Class ExceptionTypeConstraint ExceptionTypeConstraint is a special version of ExactTypeConstraint used to provided detailed info about the exception thrown in an error message. Inheritance object Constraint TypeConstraint ExactTypeConstraint ExceptionTypeConstraint Implements IConstraint IResolveConstraint Inherited Members ExactTypeConstraint.Matches(object) ExactTypeConstraint.DisplayName TypeConstraint.expectedType TypeConstraint.actualType TypeConstraint.Description Constraint.ApplyTo<TActual>(ActualValueDelegate<TActual>) Constraint.ApplyTo<TActual>(ref TActual) Constraint.ApplyToAsync<TActual>(Func<Task<TActual>>) Constraint.GetTestObject<TActual>(ActualValueDelegate<TActual>) Constraint.ToString() Constraint.GetStringRepresentation(IEnumerable) Constraint.GetStringRepresentation() Constraint.After(int) Constraint.After(int, int) Constraint.Arguments Constraint.Builder Constraint.And Constraint.With Constraint.Or object.GetType() object.MemberwiseClone() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework.Constraints Assembly: nunit.framework.dll Syntax public class ExceptionTypeConstraint : ExactTypeConstraint, IConstraint, IResolveConstraint Constructors View Source ExceptionTypeConstraint(Type) Constructs an ExceptionTypeConstraint Declaration public ExceptionTypeConstraint(Type type) Parameters Type Name Description Type type Methods View Source ApplyTo<TActual>(TActual) Applies the constraint to an actual value, returning a ConstraintResult. Declaration public override ConstraintResult ApplyTo<TActual>(TActual actual) Parameters Type Name Description TActual actual The value to be tested Returns Type Description ConstraintResult A ConstraintResult Type Parameters Name Description TActual Overrides TypeConstraint.ApplyTo<TActual>(TActual) Implements IConstraint IResolveConstraint"
  },
  "api/NUnit.Framework.Constraints.FalseConstraint.html": {
    "href": "api/NUnit.Framework.Constraints.FalseConstraint.html",
    "title": "Class FalseConstraint | NUnit Docs",
    "summary": "Class FalseConstraint FalseConstraint tests that the actual value is false Inheritance object Constraint FalseConstraint Implements IConstraint IResolveConstraint Inherited Members Constraint.ApplyTo<TActual>(ActualValueDelegate<TActual>) Constraint.ApplyTo<TActual>(ref TActual) Constraint.ApplyToAsync<TActual>(Func<Task<TActual>>) Constraint.GetTestObject<TActual>(ActualValueDelegate<TActual>) Constraint.ToString() Constraint.GetStringRepresentation(IEnumerable) Constraint.GetStringRepresentation() Constraint.After(int) Constraint.After(int, int) Constraint.DisplayName Constraint.Arguments Constraint.Builder Constraint.And Constraint.With Constraint.Or object.GetType() object.MemberwiseClone() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework.Constraints Assembly: nunit.framework.dll Syntax public class FalseConstraint : Constraint, IConstraint, IResolveConstraint Constructors View Source FalseConstraint() Declaration public FalseConstraint() Properties View Source Description The Description of what this constraint tests, for use in messages and in the ConstraintResult. Declaration public override string Description { get; } Property Value Type Description string Overrides Constraint.Description Methods View Source ApplyTo<TActual>(TActual) Test whether the constraint is satisfied by a given value Declaration public override ConstraintResult ApplyTo<TActual>(TActual actual) Parameters Type Name Description TActual actual The value to be tested Returns Type Description ConstraintResult True for success, false for failure Type Parameters Name Description TActual Overrides Constraint.ApplyTo<TActual>(TActual) Implements IConstraint IResolveConstraint"
  },
  "api/NUnit.Framework.Constraints.FileOrDirectoryExistsConstraint.html": {
    "href": "api/NUnit.Framework.Constraints.FileOrDirectoryExistsConstraint.html",
    "title": "Class FileOrDirectoryExistsConstraint | NUnit Docs",
    "summary": "Class FileOrDirectoryExistsConstraint FileOrDirectoryExistsConstraint is used to determine if a file or directory exists Inheritance object Constraint FileOrDirectoryExistsConstraint Implements IConstraint IResolveConstraint Inherited Members Constraint.ApplyTo<TActual>(ActualValueDelegate<TActual>) Constraint.ApplyTo<TActual>(ref TActual) Constraint.ApplyToAsync<TActual>(Func<Task<TActual>>) Constraint.GetTestObject<TActual>(ActualValueDelegate<TActual>) Constraint.ToString() Constraint.GetStringRepresentation(IEnumerable) Constraint.GetStringRepresentation() Constraint.After(int) Constraint.After(int, int) Constraint.DisplayName Constraint.Arguments Constraint.Builder Constraint.And Constraint.With Constraint.Or object.GetType() object.MemberwiseClone() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework.Constraints Assembly: nunit.framework.dll Syntax public class FileOrDirectoryExistsConstraint : Constraint, IConstraint, IResolveConstraint Constructors View Source FileOrDirectoryExistsConstraint() Initializes a new instance of the FileOrDirectoryExistsConstraint class that will check files and directories. Declaration public FileOrDirectoryExistsConstraint() View Source FileOrDirectoryExistsConstraint(bool) Initializes a new instance of the FileOrDirectoryExistsConstraint class that will only check files if ignoreDirectories is true. Declaration public FileOrDirectoryExistsConstraint(bool ignoreDirectories) Parameters Type Name Description bool ignoreDirectories if set to true [ignore directories]. Properties View Source Description The Description of what this constraint tests, for use in messages and in the ConstraintResult. Declaration public override string Description { get; } Property Value Type Description string Overrides Constraint.Description View Source IgnoreDirectories If true, the constraint will only check if files exist, not directories Declaration public FileOrDirectoryExistsConstraint IgnoreDirectories { get; } Property Value Type Description FileOrDirectoryExistsConstraint View Source IgnoreFiles If true, the constraint will only check if directories exist, not files Declaration public FileOrDirectoryExistsConstraint IgnoreFiles { get; } Property Value Type Description FileOrDirectoryExistsConstraint Methods View Source ApplyTo<TActual>(TActual) Applies the constraint to an actual value, returning a ConstraintResult. Declaration public override ConstraintResult ApplyTo<TActual>(TActual actual) Parameters Type Name Description TActual actual The value to be tested Returns Type Description ConstraintResult A ConstraintResult Type Parameters Name Description TActual Overrides Constraint.ApplyTo<TActual>(TActual) Implements IConstraint IResolveConstraint"
  },
  "api/NUnit.Framework.Constraints.GreaterThanConstraint.html": {
    "href": "api/NUnit.Framework.Constraints.GreaterThanConstraint.html",
    "title": "Class GreaterThanConstraint | NUnit Docs",
    "summary": "Class GreaterThanConstraint Tests whether a value is greater than the value supplied to its constructor Inheritance object Constraint ComparisonConstraint GreaterThanConstraint Implements IConstraint IResolveConstraint Inherited Members ComparisonConstraint.ApplyTo<TActual>(TActual) ComparisonConstraint.Using(IComparer) ComparisonConstraint.Using<T>(IComparer<T>) ComparisonConstraint.Using<T>(Comparison<T>) ComparisonConstraint.Within(object) ComparisonConstraint.Description ComparisonConstraint.Percent Constraint.ApplyTo<TActual>(ActualValueDelegate<TActual>) Constraint.ApplyTo<TActual>(ref TActual) Constraint.ApplyToAsync<TActual>(Func<Task<TActual>>) Constraint.GetTestObject<TActual>(ActualValueDelegate<TActual>) Constraint.ToString() Constraint.GetStringRepresentation(IEnumerable) Constraint.GetStringRepresentation() Constraint.After(int) Constraint.After(int, int) Constraint.DisplayName Constraint.Arguments Constraint.Builder Constraint.And Constraint.With Constraint.Or object.GetType() object.MemberwiseClone() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework.Constraints Assembly: nunit.framework.dll Syntax public class GreaterThanConstraint : ComparisonConstraint, IConstraint, IResolveConstraint Constructors View Source GreaterThanConstraint(object) Initializes a new instance of the GreaterThanConstraint class. Declaration public GreaterThanConstraint(object expected) Parameters Type Name Description object expected The expected value. Methods View Source PerformComparison(ComparisonAdapter, object, object, Tolerance) Perform the comparison Declaration protected override bool PerformComparison(ComparisonAdapter comparer, object actual, object expected, Tolerance tolerance) Parameters Type Name Description ComparisonAdapter comparer object actual object expected Tolerance tolerance Returns Type Description bool Overrides ComparisonConstraint.PerformComparison(ComparisonAdapter, object, object, Tolerance) Implements IConstraint IResolveConstraint"
  },
  "api/NUnit.Framework.Constraints.GreaterThanOrEqualConstraint.html": {
    "href": "api/NUnit.Framework.Constraints.GreaterThanOrEqualConstraint.html",
    "title": "Class GreaterThanOrEqualConstraint | NUnit Docs",
    "summary": "Class GreaterThanOrEqualConstraint Tests whether a value is greater than or equal to the value supplied to its constructor Inheritance object Constraint ComparisonConstraint GreaterThanOrEqualConstraint Implements IConstraint IResolveConstraint Inherited Members ComparisonConstraint.ApplyTo<TActual>(TActual) ComparisonConstraint.Using(IComparer) ComparisonConstraint.Using<T>(IComparer<T>) ComparisonConstraint.Using<T>(Comparison<T>) ComparisonConstraint.Within(object) ComparisonConstraint.Description ComparisonConstraint.Percent Constraint.ApplyTo<TActual>(ActualValueDelegate<TActual>) Constraint.ApplyTo<TActual>(ref TActual) Constraint.ApplyToAsync<TActual>(Func<Task<TActual>>) Constraint.GetTestObject<TActual>(ActualValueDelegate<TActual>) Constraint.ToString() Constraint.GetStringRepresentation(IEnumerable) Constraint.GetStringRepresentation() Constraint.After(int) Constraint.After(int, int) Constraint.DisplayName Constraint.Arguments Constraint.Builder Constraint.And Constraint.With Constraint.Or object.GetType() object.MemberwiseClone() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework.Constraints Assembly: nunit.framework.dll Syntax public class GreaterThanOrEqualConstraint : ComparisonConstraint, IConstraint, IResolveConstraint Constructors View Source GreaterThanOrEqualConstraint(object) Initializes a new instance of the GreaterThanOrEqualConstraint class. Declaration public GreaterThanOrEqualConstraint(object expected) Parameters Type Name Description object expected The expected value. Methods View Source PerformComparison(ComparisonAdapter, object, object, Tolerance) Perform the comparison Declaration protected override bool PerformComparison(ComparisonAdapter comparer, object actual, object expected, Tolerance tolerance) Parameters Type Name Description ComparisonAdapter comparer object actual object expected Tolerance tolerance Returns Type Description bool Overrides ComparisonConstraint.PerformComparison(ComparisonAdapter, object, object, Tolerance) Implements IConstraint IResolveConstraint"
  },
  "api/NUnit.Framework.Constraints.IConstraint.html": {
    "href": "api/NUnit.Framework.Constraints.IConstraint.html",
    "title": "Interface IConstraint | NUnit Docs",
    "summary": "Interface IConstraint Interface for all constraints Inherited Members IResolveConstraint.Resolve() Namespace: NUnit.Framework.Constraints Assembly: nunit.framework.dll Syntax public interface IConstraint : IResolveConstraint Properties View Source Arguments Arguments provided to this Constraint, for use in formatting the description. Declaration object?[] Arguments { get; } Property Value Type Description object[] View Source Builder The ConstraintBuilder holding this constraint Declaration ConstraintBuilder? Builder { get; set; } Property Value Type Description ConstraintBuilder View Source Description The Description of what this constraint tests, for use in messages and in the ConstraintResult. Declaration string Description { get; } Property Value Type Description string View Source DisplayName The display name of this Constraint for use by ToString(). Declaration string DisplayName { get; } Property Value Type Description string Methods View Source ApplyTo<TActual>(ActualValueDelegate<TActual>) Applies the constraint to an ActualValueDelegate that returns the value to be tested. The default implementation simply evaluates the delegate but derived classes may override it to provide for delayed processing. Declaration ConstraintResult ApplyTo<TActual>(ActualValueDelegate<TActual> del) Parameters Type Name Description ActualValueDelegate<TActual> del An ActualValueDelegate Returns Type Description ConstraintResult A ConstraintResult Type Parameters Name Description TActual View Source ApplyTo<TActual>(TActual) Applies the constraint to an actual value, returning a ConstraintResult. Declaration ConstraintResult ApplyTo<TActual>(TActual actual) Parameters Type Name Description TActual actual The value to be tested Returns Type Description ConstraintResult A ConstraintResult Type Parameters Name Description TActual View Source ApplyTo<TActual>(ref TActual) Test whether the constraint is satisfied by a given reference. The default implementation simply dereferences the value but derived classes may override it to provide for delayed processing. Declaration [Obsolete(\"This was never implemented and will be removed.\")] ConstraintResult ApplyTo<TActual>(ref TActual actual) Parameters Type Name Description TActual actual A reference to the value to be tested Returns Type Description ConstraintResult A ConstraintResult Type Parameters Name Description TActual"
  },
  "api/NUnit.Framework.Constraints.IResolveConstraint.html": {
    "href": "api/NUnit.Framework.Constraints.IResolveConstraint.html",
    "title": "Interface IResolveConstraint | NUnit Docs",
    "summary": "Interface IResolveConstraint The IResolveConstraint interface is implemented by all complete and resolvable constraints and expressions. Namespace: NUnit.Framework.Constraints Assembly: nunit.framework.dll Syntax public interface IResolveConstraint Methods View Source Resolve() Return the top-level constraint for this expression Declaration IConstraint Resolve() Returns Type Description IConstraint"
  },
  "api/NUnit.Framework.Constraints.IndexerConstraint.html": {
    "href": "api/NUnit.Framework.Constraints.IndexerConstraint.html",
    "title": "Class IndexerConstraint | NUnit Docs",
    "summary": "Class IndexerConstraint IndexerConstraint extracts a named property and uses its value as the actual value for a chained constraint. Inheritance object Constraint PrefixConstraint IndexerConstraint Implements IConstraint IResolveConstraint Inherited Members PrefixConstraint.BaseConstraint PrefixConstraint.DescriptionPrefix PrefixConstraint.Description Constraint.ApplyTo<TActual>(ActualValueDelegate<TActual>) Constraint.ApplyTo<TActual>(ref TActual) Constraint.ApplyToAsync<TActual>(Func<Task<TActual>>) Constraint.GetTestObject<TActual>(ActualValueDelegate<TActual>) Constraint.ToString() Constraint.GetStringRepresentation(IEnumerable) Constraint.After(int) Constraint.After(int, int) Constraint.DisplayName Constraint.Arguments Constraint.Builder Constraint.And Constraint.With Constraint.Or object.GetType() object.MemberwiseClone() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework.Constraints Assembly: nunit.framework.dll Syntax public class IndexerConstraint : PrefixConstraint, IConstraint, IResolveConstraint Constructors View Source IndexerConstraint(IEnumerable<object>, IConstraint) Initializes a new instance of the IndexerConstraint class. Declaration public IndexerConstraint(IEnumerable<object> indexerArguments, IConstraint baseConstraint) Parameters Type Name Description IEnumerable<object> indexerArguments The argument list for the indexer. IConstraint baseConstraint The constraint to apply to the indexer. View Source IndexerConstraint(object[], IConstraint) Initializes a new instance of the IndexerConstraint class. Declaration public IndexerConstraint(object[] indexerArguments, IConstraint baseConstraint) Parameters Type Name Description object[] indexerArguments The argument list for the indexer. IConstraint baseConstraint The constraint to apply to the indexer. Methods View Source ApplyTo<TActual>(TActual) Test whether the constraint is satisfied by a given value Declaration public override ConstraintResult ApplyTo<TActual>(TActual actual) Parameters Type Name Description TActual actual The value to be tested Returns Type Description ConstraintResult Type Parameters Name Description TActual Overrides Constraint.ApplyTo<TActual>(TActual) View Source GetStringRepresentation() Returns the string representation of the constraint. Declaration protected override string GetStringRepresentation() Returns Type Description string Overrides Constraint.GetStringRepresentation() Implements IConstraint IResolveConstraint"
  },
  "api/NUnit.Framework.Constraints.IndexerOperator.html": {
    "href": "api/NUnit.Framework.Constraints.IndexerOperator.html",
    "title": "Class IndexerOperator | NUnit Docs",
    "summary": "Class IndexerOperator Operator used to test for the presence of a Indexer on an object and optionally apply further tests to the value of that indexer. Inheritance object ConstraintOperator PrefixOperator IndexerOperator Inherited Members PrefixOperator.Reduce(ConstraintBuilder.ConstraintStack) ConstraintOperator.left_precedence ConstraintOperator.right_precedence ConstraintOperator.LeftContext ConstraintOperator.RightContext ConstraintOperator.LeftPrecedence ConstraintOperator.RightPrecedence object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework.Constraints Assembly: nunit.framework.dll Syntax public class IndexerOperator : PrefixOperator Constructors View Source IndexerOperator(params object[]) Constructs a IndexerOperator for a particular set of indexer parameters Declaration public IndexerOperator(params object[] indexArgs) Parameters Type Name Description object[] indexArgs Methods View Source ApplyPrefix(IConstraint) Returns a IndexerConstraint applied to its argument. Declaration public override IConstraint ApplyPrefix(IConstraint constraint) Parameters Type Name Description IConstraint constraint Returns Type Description IConstraint Overrides PrefixOperator.ApplyPrefix(IConstraint)"
  },
  "api/NUnit.Framework.Constraints.InstanceOfTypeConstraint.html": {
    "href": "api/NUnit.Framework.Constraints.InstanceOfTypeConstraint.html",
    "title": "Class InstanceOfTypeConstraint | NUnit Docs",
    "summary": "Class InstanceOfTypeConstraint InstanceOfTypeConstraint is used to test that an object is of the same type provided or derived from it. Inheritance object Constraint TypeConstraint InstanceOfTypeConstraint Implements IConstraint IResolveConstraint Inherited Members TypeConstraint.expectedType TypeConstraint.actualType TypeConstraint.ApplyTo<TActual>(TActual) TypeConstraint.Description Constraint.ApplyTo<TActual>(ActualValueDelegate<TActual>) Constraint.ApplyTo<TActual>(ref TActual) Constraint.ApplyToAsync<TActual>(Func<Task<TActual>>) Constraint.GetTestObject<TActual>(ActualValueDelegate<TActual>) Constraint.ToString() Constraint.GetStringRepresentation(IEnumerable) Constraint.GetStringRepresentation() Constraint.After(int) Constraint.After(int, int) Constraint.Arguments Constraint.Builder Constraint.And Constraint.With Constraint.Or object.GetType() object.MemberwiseClone() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework.Constraints Assembly: nunit.framework.dll Syntax public class InstanceOfTypeConstraint : TypeConstraint, IConstraint, IResolveConstraint Constructors View Source InstanceOfTypeConstraint(Type) Construct an InstanceOfTypeConstraint for the type provided Declaration public InstanceOfTypeConstraint(Type type) Parameters Type Name Description Type type The expected Type Properties View Source DisplayName The display name of this Constraint for use by ToString(). The default value is the name of the constraint with trailing \"Constraint\" removed. Derived classes may set this to another name in their constructors. Declaration public override string DisplayName { get; } Property Value Type Description string Overrides Constraint.DisplayName Methods View Source Matches(object?) Apply the constraint to an actual value, returning true if it succeeds Declaration protected override bool Matches(object? actual) Parameters Type Name Description object actual The actual argument Returns Type Description bool True if the constraint succeeds, otherwise false. Overrides TypeConstraint.Matches(object?) Implements IConstraint IResolveConstraint"
  },
  "api/NUnit.Framework.Constraints.InsteadOperator.html": {
    "href": "api/NUnit.Framework.Constraints.InsteadOperator.html",
    "title": "Class InsteadOperator | NUnit Docs",
    "summary": "Class InsteadOperator Operator that replaces the left constraint with the right constraint Inheritance object ConstraintOperator BinaryOperator InsteadOperator Inherited Members BinaryOperator.Reduce(ConstraintBuilder.ConstraintStack) BinaryOperator.LeftPrecedence BinaryOperator.RightPrecedence ConstraintOperator.left_precedence ConstraintOperator.right_precedence ConstraintOperator.LeftContext ConstraintOperator.RightContext object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework.Constraints Assembly: nunit.framework.dll Syntax public class InsteadOperator : BinaryOperator Constructors View Source InsteadOperator() Construct an InsteadOperator Declaration public InsteadOperator() Methods View Source ApplyOperator(IConstraint, IConstraint) Apply the operator to replace the left constraint Declaration public override IConstraint ApplyOperator(IConstraint left, IConstraint right) Parameters Type Name Description IConstraint left IConstraint right Returns Type Description IConstraint Overrides BinaryOperator.ApplyOperator(IConstraint, IConstraint)"
  },
  "api/NUnit.Framework.Constraints.Interval.html": {
    "href": "api/NUnit.Framework.Constraints.Interval.html",
    "title": "Class Interval | NUnit Docs",
    "summary": "Class Interval Keeps track of an interval time which can be represented in Minutes, Seconds or Milliseconds Inheritance object Interval Inherited Members object.GetType() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework.Constraints Assembly: nunit.framework.dll Syntax public sealed class Interval Constructors View Source Interval(int) Constructs a interval given an value in milliseconds Declaration public Interval(int value) Parameters Type Name Description int value Properties View Source AsTimeSpan Gets Interval value represented as a TimeSpan object Declaration public TimeSpan AsTimeSpan { get; } Property Value Type Description TimeSpan View Source InMilliseconds Returns the interval with the current value as a number of milliseconds. Declaration public Interval InMilliseconds { get; } Property Value Type Description Interval View Source InMinutes Returns the interval with the current value as a number of minutes. Declaration public Interval InMinutes { get; } Property Value Type Description Interval View Source InSeconds Returns the interval with the current value as a number of seconds. Declaration public Interval InSeconds { get; } Property Value Type Description Interval View Source IsNotZero Is true for intervals created with a non-zero value Declaration public bool IsNotZero { get; } Property Value Type Description bool Methods View Source ToString() Returns a string that represents the current object. Declaration public override string ToString() Returns Type Description string A string that represents the current object. Overrides object.ToString()"
  },
  "api/NUnit.Framework.Constraints.ItemsConstraintExpression.html": {
    "href": "api/NUnit.Framework.Constraints.ItemsConstraintExpression.html",
    "title": "Class ItemsConstraintExpression | NUnit Docs",
    "summary": "Class ItemsConstraintExpression An extension of ResolvableConstraintExpression that adds a no-op Items property for readability. Inheritance object ConstraintExpression ItemsConstraintExpression Inherited Members ConstraintExpression.ToString() ConstraintExpression.Append(ConstraintOperator) ConstraintExpression.Append(SelfResolvingOperator) ConstraintExpression.Append(Constraint) ConstraintExpression.Append<T>(T) ConstraintExpression.Exactly(int) ConstraintExpression.Property(string) ConstraintExpression.Attribute(Type) ConstraintExpression.Attribute<TExpected>() ConstraintExpression.Matches(IResolveConstraint) ConstraintExpression.Matches<TActual>(Predicate<TActual>) ConstraintExpression.MultipleOf(int) ConstraintExpression.EqualTo(object) ConstraintExpression.EqualTo<T>(T) ConstraintExpression.EqualTo(string) ConstraintExpression.EqualTo(DateTimeOffset) ConstraintExpression.EqualTo(DateTime) ConstraintExpression.EqualTo(TimeSpan) ConstraintExpression.EqualTo(double) ConstraintExpression.EqualTo(float) ConstraintExpression.EqualTo(decimal) ConstraintExpression.EqualTo(long) ConstraintExpression.EqualTo(int) ConstraintExpression.EqualTo(short) ConstraintExpression.EqualTo(byte) ConstraintExpression.EqualTo(ulong) ConstraintExpression.EqualTo(uint) ConstraintExpression.EqualTo(ushort) ConstraintExpression.EqualTo(sbyte) ConstraintExpression.SameAs(object) ConstraintExpression.GreaterThan(object) ConstraintExpression.GreaterThanOrEqualTo(object) ConstraintExpression.AtLeast(object) ConstraintExpression.LessThan(object) ConstraintExpression.LessThanOrEqualTo(object) ConstraintExpression.AtMost(object) ConstraintExpression.TypeOf(Type) ConstraintExpression.TypeOf<TExpected>() ConstraintExpression.InstanceOf(Type) ConstraintExpression.InstanceOf<TExpected>() ConstraintExpression.AssignableFrom(Type) ConstraintExpression.AssignableFrom<TExpected>() ConstraintExpression.AssignableTo(Type) ConstraintExpression.AssignableTo<TExpected>() ConstraintExpression.EquivalentTo(IEnumerable) ConstraintExpression.SubsetOf(IEnumerable) ConstraintExpression.SupersetOf(IEnumerable) ConstraintExpression.Member(object) ConstraintExpression.Member<T>(T) ConstraintExpression.Contains(object) ConstraintExpression.Contains<T>(T) ConstraintExpression.Contains(string) ConstraintExpression.Contain(object) ConstraintExpression.Contain<T>(T) ConstraintExpression.Contain(string) ConstraintExpression.ContainKey(object) ConstraintExpression.ContainValue(object) ConstraintExpression.StartWith(string) ConstraintExpression.StartsWith(string) ConstraintExpression.EndWith(string) ConstraintExpression.EndsWith(string) ConstraintExpression.Match(string) ConstraintExpression.Match(Regex) ConstraintExpression.Matches(string) ConstraintExpression.Matches(Regex) ConstraintExpression.SamePath(string) ConstraintExpression.SubPathOf(string) ConstraintExpression.SamePathOrUnder(string) ConstraintExpression.InRange(object, object) ConstraintExpression.AnyOf(params object[]) ConstraintExpression.AnyOf(ICollection) ConstraintExpression.ItemAt(params object[]) ConstraintExpression.Not ConstraintExpression.No ConstraintExpression.All ConstraintExpression.Some ConstraintExpression.None ConstraintExpression.One ConstraintExpression.Length ConstraintExpression.Count ConstraintExpression.Message ConstraintExpression.InnerException ConstraintExpression.With ConstraintExpression.Null ConstraintExpression.Default ConstraintExpression.True ConstraintExpression.False ConstraintExpression.Positive ConstraintExpression.Negative ConstraintExpression.Zero ConstraintExpression.NaN ConstraintExpression.Even ConstraintExpression.Odd ConstraintExpression.Empty ConstraintExpression.WhiteSpace ConstraintExpression.Unique ConstraintExpression.XmlSerializable ConstraintExpression.Ordered ConstraintExpression.Exist object.GetType() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework.Constraints Assembly: nunit.framework.dll Syntax public sealed class ItemsConstraintExpression : ConstraintExpression Constructors View Source ItemsConstraintExpression() Create a new instance of ItemsConstraintExpression Declaration public ItemsConstraintExpression() View Source ItemsConstraintExpression(ConstraintBuilder) Create a new instance of ResolvableConstraintExpression, passing in a pre-populated ConstraintBuilder. Declaration public ItemsConstraintExpression(ConstraintBuilder builder) Parameters Type Name Description ConstraintBuilder builder Properties View Source Items No-op property for readability. Declaration public ResolvableConstraintExpression Items { get; } Property Value Type Description ResolvableConstraintExpression"
  },
  "api/NUnit.Framework.Constraints.LessThanConstraint.html": {
    "href": "api/NUnit.Framework.Constraints.LessThanConstraint.html",
    "title": "Class LessThanConstraint | NUnit Docs",
    "summary": "Class LessThanConstraint Tests whether a value is less than the value supplied to its constructor Inheritance object Constraint ComparisonConstraint LessThanConstraint Implements IConstraint IResolveConstraint Inherited Members ComparisonConstraint.ApplyTo<TActual>(TActual) ComparisonConstraint.Using(IComparer) ComparisonConstraint.Using<T>(IComparer<T>) ComparisonConstraint.Using<T>(Comparison<T>) ComparisonConstraint.Within(object) ComparisonConstraint.Description ComparisonConstraint.Percent Constraint.ApplyTo<TActual>(ActualValueDelegate<TActual>) Constraint.ApplyTo<TActual>(ref TActual) Constraint.ApplyToAsync<TActual>(Func<Task<TActual>>) Constraint.GetTestObject<TActual>(ActualValueDelegate<TActual>) Constraint.ToString() Constraint.GetStringRepresentation(IEnumerable) Constraint.GetStringRepresentation() Constraint.After(int) Constraint.After(int, int) Constraint.DisplayName Constraint.Arguments Constraint.Builder Constraint.And Constraint.With Constraint.Or object.GetType() object.MemberwiseClone() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework.Constraints Assembly: nunit.framework.dll Syntax public class LessThanConstraint : ComparisonConstraint, IConstraint, IResolveConstraint Constructors View Source LessThanConstraint(object) Initializes a new instance of the LessThanConstraint class. Declaration public LessThanConstraint(object expected) Parameters Type Name Description object expected The expected value. Methods View Source PerformComparison(ComparisonAdapter, object, object, Tolerance) Perform the comparison Declaration protected override bool PerformComparison(ComparisonAdapter comparer, object actual, object expected, Tolerance tolerance) Parameters Type Name Description ComparisonAdapter comparer object actual object expected Tolerance tolerance Returns Type Description bool Overrides ComparisonConstraint.PerformComparison(ComparisonAdapter, object, object, Tolerance) Implements IConstraint IResolveConstraint"
  },
  "api/NUnit.Framework.Constraints.LessThanOrEqualConstraint.html": {
    "href": "api/NUnit.Framework.Constraints.LessThanOrEqualConstraint.html",
    "title": "Class LessThanOrEqualConstraint | NUnit Docs",
    "summary": "Class LessThanOrEqualConstraint Tests whether a value is less than or equal to the value supplied to its constructor Inheritance object Constraint ComparisonConstraint LessThanOrEqualConstraint Implements IConstraint IResolveConstraint Inherited Members ComparisonConstraint.ApplyTo<TActual>(TActual) ComparisonConstraint.Using(IComparer) ComparisonConstraint.Using<T>(IComparer<T>) ComparisonConstraint.Using<T>(Comparison<T>) ComparisonConstraint.Within(object) ComparisonConstraint.Description ComparisonConstraint.Percent Constraint.ApplyTo<TActual>(ActualValueDelegate<TActual>) Constraint.ApplyTo<TActual>(ref TActual) Constraint.ApplyToAsync<TActual>(Func<Task<TActual>>) Constraint.GetTestObject<TActual>(ActualValueDelegate<TActual>) Constraint.ToString() Constraint.GetStringRepresentation(IEnumerable) Constraint.GetStringRepresentation() Constraint.After(int) Constraint.After(int, int) Constraint.DisplayName Constraint.Arguments Constraint.Builder Constraint.And Constraint.With Constraint.Or object.GetType() object.MemberwiseClone() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework.Constraints Assembly: nunit.framework.dll Syntax public class LessThanOrEqualConstraint : ComparisonConstraint, IConstraint, IResolveConstraint Constructors View Source LessThanOrEqualConstraint(object) Initializes a new instance of the LessThanOrEqualConstraint class. Declaration public LessThanOrEqualConstraint(object expected) Parameters Type Name Description object expected The expected value. Methods View Source PerformComparison(ComparisonAdapter, object, object, Tolerance) Perform the comparison Declaration protected override bool PerformComparison(ComparisonAdapter comparer, object actual, object expected, Tolerance tolerance) Parameters Type Name Description ComparisonAdapter comparer object actual object expected Tolerance tolerance Returns Type Description bool Overrides ComparisonConstraint.PerformComparison(ComparisonAdapter, object, object, Tolerance) Implements IConstraint IResolveConstraint"
  },
  "api/NUnit.Framework.Constraints.MessageWriter.html": {
    "href": "api/NUnit.Framework.Constraints.MessageWriter.html",
    "title": "Class MessageWriter | NUnit Docs",
    "summary": "Class MessageWriter MessageWriter is the abstract base for classes that write constraint descriptions and messages in some form. The class has separate methods for writing various components of a message, allowing implementations to tailor the presentation as needed. Inheritance object MarshalByRefObject TextWriter StringWriter MessageWriter Implements IDisposable IAsyncDisposable Inherited Members StringWriter.Close() StringWriter.Dispose(bool) StringWriter.GetStringBuilder() StringWriter.Write(char) StringWriter.Write(char[], int, int) StringWriter.Write(ReadOnlySpan<char>) StringWriter.Write(string) StringWriter.Write(StringBuilder) StringWriter.WriteLine(ReadOnlySpan<char>) StringWriter.WriteLine(StringBuilder) StringWriter.WriteAsync(char) StringWriter.WriteAsync(string) StringWriter.WriteAsync(char[], int, int) StringWriter.WriteAsync(ReadOnlyMemory<char>, CancellationToken) StringWriter.WriteAsync(StringBuilder, CancellationToken) StringWriter.WriteLineAsync(char) StringWriter.WriteLineAsync(string) StringWriter.WriteLineAsync(StringBuilder, CancellationToken) StringWriter.WriteLineAsync(char[], int, int) StringWriter.WriteLineAsync(ReadOnlyMemory<char>, CancellationToken) StringWriter.FlushAsync() StringWriter.ToString() StringWriter.Encoding TextWriter.Null TextWriter.CoreNewLine TextWriter.Dispose() TextWriter.DisposeAsync() TextWriter.Flush() TextWriter.Write(char[]) TextWriter.Write(bool) TextWriter.Write(int) TextWriter.Write(uint) TextWriter.Write(long) TextWriter.Write(ulong) TextWriter.Write(float) TextWriter.Write(double) TextWriter.Write(decimal) TextWriter.Write(object) TextWriter.Write(string, object) TextWriter.Write(string, object, object) TextWriter.Write(string, object, object, object) TextWriter.Write(string, params object[]) TextWriter.Write(string, params ReadOnlySpan<object>) TextWriter.WriteLine() TextWriter.WriteLine(char) TextWriter.WriteLine(char[]) TextWriter.WriteLine(char[], int, int) TextWriter.WriteLine(bool) TextWriter.WriteLine(int) TextWriter.WriteLine(uint) TextWriter.WriteLine(long) TextWriter.WriteLine(ulong) TextWriter.WriteLine(float) TextWriter.WriteLine(double) TextWriter.WriteLine(decimal) TextWriter.WriteLine(string) TextWriter.WriteLine(object) TextWriter.WriteLine(string, object) TextWriter.WriteLine(string, object, object) TextWriter.WriteLine(string, object, object, object) TextWriter.WriteLine(string, params object[]) TextWriter.WriteLine(string, params ReadOnlySpan<object>) TextWriter.WriteAsync(char[]) TextWriter.WriteLineAsync(char[]) TextWriter.WriteLineAsync() TextWriter.FlushAsync(CancellationToken) TextWriter.Synchronized(TextWriter) TextWriter.CreateBroadcasting(params TextWriter[]) TextWriter.FormatProvider TextWriter.NewLine MarshalByRefObject.GetLifetimeService() MarshalByRefObject.InitializeLifetimeService() MarshalByRefObject.MemberwiseClone(bool) object.GetType() object.MemberwiseClone() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework.Constraints Assembly: nunit.framework.dll Syntax public abstract class MessageWriter : StringWriter, IDisposable, IAsyncDisposable Constructors View Source MessageWriter() Construct a MessageWriter given a culture Declaration protected MessageWriter() Properties View Source MaxLineLength Abstract method to get the max line length Declaration public abstract int MaxLineLength { get; set; } Property Value Type Description int Methods View Source DisplayDifferences(ConstraintResult) Display Expected and Actual lines for a constraint. This is called by MessageWriter's default implementation of WriteMessageTo and provides the generic two-line display. Declaration public abstract void DisplayDifferences(ConstraintResult result) Parameters Type Name Description ConstraintResult result The failing constraint result View Source DisplayDifferences(object?, object?) Display Expected and Actual lines for given values. This method may be called by constraints that need more control over the display of actual and expected values than is provided by the default implementation. Declaration public abstract void DisplayDifferences(object? expected, object? actual) Parameters Type Name Description object expected The expected value object actual The actual value causing the failure View Source DisplayDifferences(object?, object?, Tolerance?) Display Expected and Actual lines for given values, including a tolerance value on the Expected line. Declaration public abstract void DisplayDifferences(object? expected, object? actual, Tolerance? tolerance) Parameters Type Name Description object expected The expected value object actual The actual value causing the failure Tolerance tolerance The tolerance within which the test was made View Source DisplayStringDifferences(string, string, int, bool, bool) Display the expected and actual string values on separate lines. If the mismatch parameter is >=0, an additional line is displayed line containing a caret that points to the mismatch point. Declaration public abstract void DisplayStringDifferences(string expected, string actual, int mismatch, bool ignoreCase, bool clipping) Parameters Type Name Description string expected The expected string value string actual The actual string value int mismatch The point in expected at which the strings don't match or -1 bool ignoreCase If true, case is ignored in locating the point where the strings differ bool clipping If true, the strings should be clipped to fit the line View Source DisplayStringDifferences(string, string, int, int, bool, bool, bool) Display the expected and actual string values on separate lines. If the mismatch parameter is >=0, an additional line is displayed line containing a caret that points to the mismatch point. Declaration public virtual void DisplayStringDifferences(string expected, string actual, int mismatchExpected, int mismatchActual, bool ignoreCase, bool ignoreWhiteSpace, bool clipping) Parameters Type Name Description string expected The expected string value string actual The actual string value int mismatchExpected The point in expected at which the strings don't match or -1 int mismatchActual The point in actual at which the strings don't match or -1 bool ignoreCase If true, case is ignored in locating the point where the strings differ bool ignoreWhiteSpace If true, white space is ignored in locating the point where the strings differ bool clipping If true, the strings should be clipped to fit the line View Source WriteActualValue(object?) Writes the text for an actual value. Declaration public abstract void WriteActualValue(object? actual) Parameters Type Name Description object actual The actual value. View Source WriteCollectionElements(IEnumerable, long, int) Writes the text for a collection value, starting at a particular point, to a max length Declaration public abstract void WriteCollectionElements(IEnumerable collection, long start, int max) Parameters Type Name Description IEnumerable collection The collection containing elements to write. long start The starting point of the elements to write int max The maximum number of elements to write View Source WriteMessageLine(int, string, params object?[]?) Method to write single line message with optional args, usually written to precede the general failure message, at a given indentation level. Declaration public abstract void WriteMessageLine(int level, string message, params object?[]? args) Parameters Type Name Description int level The indentation level of the message string message The message to be written object[] args Any arguments used in formatting the message View Source WriteMessageLine(string, params object?[]?) Method to write single line message with optional args, usually written to precede the general failure message. Declaration public void WriteMessageLine(string message, params object?[]? args) Parameters Type Name Description string message The message to be written object[] args Any arguments used in formatting the message View Source WriteValue(object?) Writes the text for a generalized value. Declaration public abstract void WriteValue(object? val) Parameters Type Name Description object val The value. Implements IDisposable IAsyncDisposable"
  },
  "api/NUnit.Framework.Constraints.MultipleOfConstraint.html": {
    "href": "api/NUnit.Framework.Constraints.MultipleOfConstraint.html",
    "title": "Class MultipleOfConstraint | NUnit Docs",
    "summary": "Class MultipleOfConstraint MultipleOfConstraint tests that the actual value is a multiple of a specified integer. Inheritance object Constraint MultipleOfConstraint Implements IConstraint IResolveConstraint Inherited Members Constraint.ApplyTo<TActual>(ActualValueDelegate<TActual>) Constraint.ApplyTo<TActual>(ref TActual) Constraint.ApplyToAsync<TActual>(Func<Task<TActual>>) Constraint.GetTestObject<TActual>(ActualValueDelegate<TActual>) Constraint.ToString() Constraint.GetStringRepresentation(IEnumerable) Constraint.GetStringRepresentation() Constraint.After(int) Constraint.After(int, int) Constraint.DisplayName Constraint.Arguments Constraint.Builder Constraint.And Constraint.With Constraint.Or object.GetType() object.MemberwiseClone() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework.Constraints Assembly: nunit.framework.dll Syntax public class MultipleOfConstraint : Constraint, IConstraint, IResolveConstraint Constructors View Source MultipleOfConstraint(int) Initializes an instance of the MultipleOfConstraint. Declaration public MultipleOfConstraint(int multiple) Parameters Type Name Description int multiple An integer value greater than zero Properties View Source Description The Description of what this constraint tests, for use in messages and in the ConstraintResult. Declaration public override string Description { get; } Property Value Type Description string Overrides Constraint.Description Methods View Source ApplyTo<TActual>(TActual) Test whether the constraint is satisfied by a given value Declaration public override ConstraintResult ApplyTo<TActual>(TActual actual) Parameters Type Name Description TActual actual The value to be tested Returns Type Description ConstraintResult True for success, false for failure Type Parameters Name Description TActual Overrides Constraint.ApplyTo<TActual>(TActual) Implements IConstraint IResolveConstraint"
  },
  "api/NUnit.Framework.Constraints.NUnitComparer.html": {
    "href": "api/NUnit.Framework.Constraints.NUnitComparer.html",
    "title": "Class NUnitComparer | NUnit Docs",
    "summary": "Class NUnitComparer NUnitComparer encapsulates NUnit's default behavior in comparing two objects. Inheritance object NUnitComparer Implements IComparer Inherited Members object.GetType() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework.Constraints Assembly: nunit.framework.dll Syntax public sealed class NUnitComparer : IComparer Constructors View Source NUnitComparer() Declaration public NUnitComparer() Properties View Source Default Returns the default NUnitComparer. Declaration public static NUnitComparer Default { get; } Property Value Type Description NUnitComparer Methods View Source Compare(object?, object?) Compares two objects Declaration public int Compare(object? x, object? y) Parameters Type Name Description object x object y Returns Type Description int Implements IComparer"
  },
  "api/NUnit.Framework.Constraints.NUnitEqualityComparer.FailurePoint.html": {
    "href": "api/NUnit.Framework.Constraints.NUnitEqualityComparer.FailurePoint.html",
    "title": "Class NUnitEqualityComparer.FailurePoint | NUnit Docs",
    "summary": "Class NUnitEqualityComparer.FailurePoint FailurePoint class represents one point of failure in an equality test. Inheritance object NUnitEqualityComparer.FailurePoint Inherited Members object.GetType() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework.Constraints Assembly: nunit.framework.dll Syntax public sealed class NUnitEqualityComparer.FailurePoint Constructors View Source FailurePoint() Declaration public FailurePoint() Fields View Source ActualHasData Indicates whether the actual value is valid Declaration public bool ActualHasData Field Value Type Description bool View Source ActualValue The actual value Declaration public object? ActualValue Field Value Type Description object View Source ExpectedHasData Indicates whether the expected value is valid Declaration public bool ExpectedHasData Field Value Type Description bool View Source ExpectedValue The expected value Declaration public object? ExpectedValue Field Value Type Description object View Source Position The location of the failure Declaration public long Position Field Value Type Description long View Source PropertyName The name of the property. Declaration public string? PropertyName Field Value Type Description string"
  },
  "api/NUnit.Framework.Constraints.NUnitEqualityComparer.html": {
    "href": "api/NUnit.Framework.Constraints.NUnitEqualityComparer.html",
    "title": "Class NUnitEqualityComparer | NUnit Docs",
    "summary": "Class NUnitEqualityComparer NUnitEqualityComparer encapsulates NUnit's handling of equality tests between objects. Inheritance object NUnitEqualityComparer Inherited Members object.GetType() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework.Constraints Assembly: nunit.framework.dll Syntax public sealed class NUnitEqualityComparer Constructors View Source NUnitEqualityComparer() Initializes a new instance of the NUnitEqualityComparer class. Declaration public NUnitEqualityComparer() Properties View Source CompareAsCollection Gets and sets a flag indicating that arrays should be compared as collections, without regard to their shape. Declaration public bool CompareAsCollection { get; set; } Property Value Type Description bool View Source CompareProperties Gets and sets a flag indicating whether an instance properties should be compared when determining equality. Declaration public bool CompareProperties { get; set; } Property Value Type Description bool View Source ComparePropertiesConfiguration Gets and sets the names of properties to exclude from comparison. Declaration public PropertiesComparerConfiguration? ComparePropertiesConfiguration { get; set; } Property Value Type Description PropertiesComparerConfiguration View Source ExternalComparers Gets the list of external comparers to be used to test for equality. They are applied to members of collections, in place of NUnit's own logic. Declaration public IList<EqualityAdapter> ExternalComparers { get; } Property Value Type Description IList<EqualityAdapter> View Source FailurePoints Gets the list of failure points for the last Match performed. The list consists of objects to be interpreted by the caller. This generally means that the caller may only make use of objects it has placed on the list at a particular depth. Declaration public IList<NUnitEqualityComparer.FailurePoint> FailurePoints { get; } Property Value Type Description IList<NUnitEqualityComparer.FailurePoint> View Source HasFailurePoints Gets a value indicating whether there is any additional Failure Information. Declaration public bool HasFailurePoints { get; } Property Value Type Description bool View Source IgnoreCase Gets and sets a flag indicating whether case should be ignored in determining equality. Declaration public bool IgnoreCase { get; set; } Property Value Type Description bool View Source IgnoreLineEndingFormat Gets and sets a flag indicating whether line ending format (\\r vs. \\n vs. \\r\\n) should be ignored in determining equality. Declaration public bool IgnoreLineEndingFormat { get; set; } Property Value Type Description bool View Source IgnoreWhiteSpace Gets and sets a flag indicating whether white space should be ignored in determining equality. Declaration public bool IgnoreWhiteSpace { get; set; } Property Value Type Description bool View Source WithSameOffset Flags the comparer to include Offset property in comparison of two DateTimeOffset values. Declaration public bool WithSameOffset { get; set; } Property Value Type Description bool Remarks Using this modifier does not allow to use the Tolerance modifier. Methods View Source AreEqual(object?, object?, ref Tolerance) Compares two objects for equality within a tolerance. Declaration public bool AreEqual(object? x, object? y, ref Tolerance tolerance) Parameters Type Name Description object x object y Tolerance tolerance Returns Type Description bool"
  },
  "api/NUnit.Framework.Constraints.NaNConstraint.html": {
    "href": "api/NUnit.Framework.Constraints.NaNConstraint.html",
    "title": "Class NaNConstraint | NUnit Docs",
    "summary": "Class NaNConstraint NaNConstraint tests that the actual value is a double or float NaN Inheritance object Constraint NaNConstraint Implements IConstraint IResolveConstraint Inherited Members Constraint.ApplyTo<TActual>(ActualValueDelegate<TActual>) Constraint.ApplyTo<TActual>(ref TActual) Constraint.ApplyToAsync<TActual>(Func<Task<TActual>>) Constraint.GetTestObject<TActual>(ActualValueDelegate<TActual>) Constraint.ToString() Constraint.GetStringRepresentation(IEnumerable) Constraint.GetStringRepresentation() Constraint.After(int) Constraint.After(int, int) Constraint.DisplayName Constraint.Arguments Constraint.Builder Constraint.And Constraint.With Constraint.Or object.GetType() object.MemberwiseClone() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework.Constraints Assembly: nunit.framework.dll Syntax public class NaNConstraint : Constraint, IConstraint, IResolveConstraint Constructors View Source NaNConstraint() Declaration public NaNConstraint() Properties View Source Description The Description of what this constraint tests, for use in messages and in the ConstraintResult. Declaration public override string Description { get; } Property Value Type Description string Overrides Constraint.Description Methods View Source ApplyTo<TActual>(TActual) Test that the actual value is an NaN Declaration public override ConstraintResult ApplyTo<TActual>(TActual actual) Parameters Type Name Description TActual actual Returns Type Description ConstraintResult Type Parameters Name Description TActual Overrides Constraint.ApplyTo<TActual>(TActual) Implements IConstraint IResolveConstraint"
  },
  "api/NUnit.Framework.Constraints.NoItemConstraint.html": {
    "href": "api/NUnit.Framework.Constraints.NoItemConstraint.html",
    "title": "Class NoItemConstraint | NUnit Docs",
    "summary": "Class NoItemConstraint NoItemConstraint applies another constraint to each item in a collection, failing if any of them succeeds. Inheritance object Constraint PrefixConstraint NoItemConstraint Implements IConstraint IResolveConstraint Inherited Members PrefixConstraint.BaseConstraint PrefixConstraint.DescriptionPrefix PrefixConstraint.Description Constraint.ApplyTo<TActual>(ActualValueDelegate<TActual>) Constraint.ApplyTo<TActual>(ref TActual) Constraint.ApplyToAsync<TActual>(Func<Task<TActual>>) Constraint.GetTestObject<TActual>(ActualValueDelegate<TActual>) Constraint.ToString() Constraint.GetStringRepresentation(IEnumerable) Constraint.GetStringRepresentation() Constraint.After(int) Constraint.After(int, int) Constraint.Arguments Constraint.Builder Constraint.And Constraint.With Constraint.Or object.GetType() object.MemberwiseClone() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework.Constraints Assembly: nunit.framework.dll Syntax public class NoItemConstraint : PrefixConstraint, IConstraint, IResolveConstraint Constructors View Source NoItemConstraint(IConstraint) Construct a SomeItemsConstraint on top of an existing constraint Declaration public NoItemConstraint(IConstraint itemConstraint) Parameters Type Name Description IConstraint itemConstraint Properties View Source DisplayName The display name of this Constraint for use by ToString(). The default value is the name of the constraint with trailing \"Constraint\" removed. Derived classes may set this to another name in their constructors. Declaration public override string DisplayName { get; } Property Value Type Description string Overrides Constraint.DisplayName Methods View Source ApplyTo<TActual>(TActual) Apply the item constraint to each item in the collection, failing if any item fails. Declaration public override ConstraintResult ApplyTo<TActual>(TActual actual) Parameters Type Name Description TActual actual Returns Type Description ConstraintResult Type Parameters Name Description TActual Overrides Constraint.ApplyTo<TActual>(TActual) Implements IConstraint IResolveConstraint"
  },
  "api/NUnit.Framework.Constraints.NoneOperator.html": {
    "href": "api/NUnit.Framework.Constraints.NoneOperator.html",
    "title": "Class NoneOperator | NUnit Docs",
    "summary": "Class NoneOperator Represents a constraint that succeeds if none of the members of a collection match a base constraint. Inheritance object ConstraintOperator PrefixOperator CollectionOperator NoneOperator Inherited Members PrefixOperator.Reduce(ConstraintBuilder.ConstraintStack) ConstraintOperator.left_precedence ConstraintOperator.right_precedence ConstraintOperator.LeftContext ConstraintOperator.RightContext ConstraintOperator.LeftPrecedence ConstraintOperator.RightPrecedence object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework.Constraints Assembly: nunit.framework.dll Syntax public class NoneOperator : CollectionOperator Constructors View Source NoneOperator() Declaration public NoneOperator() Methods View Source ApplyPrefix(IConstraint) Returns a constraint that will apply the argument to the members of a collection, succeeding if none of them succeed. Declaration public override IConstraint ApplyPrefix(IConstraint constraint) Parameters Type Name Description IConstraint constraint Returns Type Description IConstraint Overrides PrefixOperator.ApplyPrefix(IConstraint)"
  },
  "api/NUnit.Framework.Constraints.NotConstraint.html": {
    "href": "api/NUnit.Framework.Constraints.NotConstraint.html",
    "title": "Class NotConstraint | NUnit Docs",
    "summary": "Class NotConstraint NotConstraint negates the effect of some other constraint Inheritance object Constraint PrefixConstraint NotConstraint Implements IConstraint IResolveConstraint Inherited Members PrefixConstraint.BaseConstraint PrefixConstraint.DescriptionPrefix PrefixConstraint.Description Constraint.ApplyTo<TActual>(ActualValueDelegate<TActual>) Constraint.ApplyTo<TActual>(ref TActual) Constraint.ApplyToAsync<TActual>(Func<Task<TActual>>) Constraint.GetTestObject<TActual>(ActualValueDelegate<TActual>) Constraint.ToString() Constraint.GetStringRepresentation(IEnumerable) Constraint.GetStringRepresentation() Constraint.After(int) Constraint.After(int, int) Constraint.DisplayName Constraint.Arguments Constraint.Builder Constraint.And Constraint.With Constraint.Or object.GetType() object.MemberwiseClone() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework.Constraints Assembly: nunit.framework.dll Syntax public class NotConstraint : PrefixConstraint, IConstraint, IResolveConstraint Constructors View Source NotConstraint(IConstraint) Initializes a new instance of the NotConstraint class. Declaration public NotConstraint(IConstraint baseConstraint) Parameters Type Name Description IConstraint baseConstraint The base constraint to be negated. Methods View Source ApplyTo<TActual>(TActual) Test whether the constraint is satisfied by a given value Declaration public override ConstraintResult ApplyTo<TActual>(TActual actual) Parameters Type Name Description TActual actual The value to be tested Returns Type Description ConstraintResult True for if the base constraint fails, false if it succeeds Type Parameters Name Description TActual Overrides Constraint.ApplyTo<TActual>(TActual) Implements IConstraint IResolveConstraint"
  },
  "api/NUnit.Framework.Constraints.NotOperator.html": {
    "href": "api/NUnit.Framework.Constraints.NotOperator.html",
    "title": "Class NotOperator | NUnit Docs",
    "summary": "Class NotOperator Negates the test of the constraint it wraps. Inheritance object ConstraintOperator PrefixOperator NotOperator Inherited Members PrefixOperator.Reduce(ConstraintBuilder.ConstraintStack) ConstraintOperator.left_precedence ConstraintOperator.right_precedence ConstraintOperator.LeftContext ConstraintOperator.RightContext ConstraintOperator.LeftPrecedence ConstraintOperator.RightPrecedence object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework.Constraints Assembly: nunit.framework.dll Syntax public class NotOperator : PrefixOperator Constructors View Source NotOperator() Constructs a new NotOperator Declaration public NotOperator() Methods View Source ApplyPrefix(IConstraint) Returns a NotConstraint applied to its argument. Declaration public override IConstraint ApplyPrefix(IConstraint constraint) Parameters Type Name Description IConstraint constraint Returns Type Description IConstraint Overrides PrefixOperator.ApplyPrefix(IConstraint)"
  },
  "api/NUnit.Framework.Constraints.NullConstraint.html": {
    "href": "api/NUnit.Framework.Constraints.NullConstraint.html",
    "title": "Class NullConstraint | NUnit Docs",
    "summary": "Class NullConstraint NullConstraint tests that the actual value is null Inheritance object Constraint NullConstraint Implements IConstraint IResolveConstraint Inherited Members Constraint.ApplyTo<TActual>(ActualValueDelegate<TActual>) Constraint.ApplyTo<TActual>(ref TActual) Constraint.ApplyToAsync<TActual>(Func<Task<TActual>>) Constraint.GetTestObject<TActual>(ActualValueDelegate<TActual>) Constraint.ToString() Constraint.GetStringRepresentation(IEnumerable) Constraint.GetStringRepresentation() Constraint.After(int) Constraint.After(int, int) Constraint.DisplayName Constraint.Arguments Constraint.Builder Constraint.And Constraint.With Constraint.Or object.GetType() object.MemberwiseClone() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework.Constraints Assembly: nunit.framework.dll Syntax public class NullConstraint : Constraint, IConstraint, IResolveConstraint Constructors View Source NullConstraint() Declaration public NullConstraint() Properties View Source Description The Description of what this constraint tests, for use in messages and in the ConstraintResult. Declaration public override string Description { get; } Property Value Type Description string Overrides Constraint.Description Methods View Source ApplyTo<TActual>(TActual) Applies the constraint to an actual value, returning a ConstraintResult. Declaration public override ConstraintResult ApplyTo<TActual>(TActual actual) Parameters Type Name Description TActual actual The value to be tested Returns Type Description ConstraintResult A ConstraintResult Type Parameters Name Description TActual Overrides Constraint.ApplyTo<TActual>(TActual) Implements IConstraint IResolveConstraint"
  },
  "api/NUnit.Framework.Constraints.OrConstraint.html": {
    "href": "api/NUnit.Framework.Constraints.OrConstraint.html",
    "title": "Class OrConstraint | NUnit Docs",
    "summary": "Class OrConstraint OrConstraint succeeds if either member succeeds Inheritance object Constraint BinaryConstraint OrConstraint Implements IConstraint IResolveConstraint Inherited Members BinaryConstraint.Left BinaryConstraint.Right Constraint.ApplyTo<TActual>(ActualValueDelegate<TActual>) Constraint.ApplyTo<TActual>(ref TActual) Constraint.ApplyToAsync<TActual>(Func<Task<TActual>>) Constraint.GetTestObject<TActual>(ActualValueDelegate<TActual>) Constraint.ToString() Constraint.GetStringRepresentation(IEnumerable) Constraint.GetStringRepresentation() Constraint.After(int) Constraint.After(int, int) Constraint.DisplayName Constraint.Arguments Constraint.Builder Constraint.And Constraint.With Constraint.Or object.GetType() object.MemberwiseClone() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework.Constraints Assembly: nunit.framework.dll Syntax public class OrConstraint : BinaryConstraint, IConstraint, IResolveConstraint Constructors View Source OrConstraint(IConstraint, IConstraint) Create an OrConstraint from two other constraints Declaration public OrConstraint(IConstraint left, IConstraint right) Parameters Type Name Description IConstraint left The first constraint IConstraint right The second constraint Properties View Source Description Gets text describing a constraint Declaration public override string Description { get; } Property Value Type Description string Overrides Constraint.Description Methods View Source ApplyTo<TActual>(TActual) Apply the member constraints to an actual value, succeeding succeeding as soon as one of them succeeds. Declaration public override ConstraintResult ApplyTo<TActual>(TActual actual) Parameters Type Name Description TActual actual The actual value Returns Type Description ConstraintResult True if either constraint succeeded Type Parameters Name Description TActual Overrides Constraint.ApplyTo<TActual>(TActual) Implements IConstraint IResolveConstraint"
  },
  "api/NUnit.Framework.Constraints.OrOperator.html": {
    "href": "api/NUnit.Framework.Constraints.OrOperator.html",
    "title": "Class OrOperator | NUnit Docs",
    "summary": "Class OrOperator Operator that requires at least one of its arguments to succeed Inheritance object ConstraintOperator BinaryOperator OrOperator Inherited Members BinaryOperator.Reduce(ConstraintBuilder.ConstraintStack) BinaryOperator.LeftPrecedence BinaryOperator.RightPrecedence ConstraintOperator.left_precedence ConstraintOperator.right_precedence ConstraintOperator.LeftContext ConstraintOperator.RightContext object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework.Constraints Assembly: nunit.framework.dll Syntax public class OrOperator : BinaryOperator Constructors View Source OrOperator() Construct an OrOperator Declaration public OrOperator() Methods View Source ApplyOperator(IConstraint, IConstraint) Apply the operator to produce an OrConstraint Declaration public override IConstraint ApplyOperator(IConstraint left, IConstraint right) Parameters Type Name Description IConstraint left IConstraint right Returns Type Description IConstraint Overrides BinaryOperator.ApplyOperator(IConstraint, IConstraint)"
  },
  "api/NUnit.Framework.Constraints.PathConstraint.html": {
    "href": "api/NUnit.Framework.Constraints.PathConstraint.html",
    "title": "Class PathConstraint | NUnit Docs",
    "summary": "Class PathConstraint PathConstraint serves as the abstract base of constraints that operate on paths and provides several helper methods. Inheritance object Constraint StringConstraint PathConstraint SamePathConstraint SamePathOrUnderConstraint SubPathConstraint Implements IConstraint IResolveConstraint Inherited Members StringConstraint.expected StringConstraint.caseInsensitive StringConstraint.descriptionText StringConstraint.ApplyTo<TActual>(TActual) StringConstraint.Matches(string) StringConstraint.Description StringConstraint.IgnoreCase Constraint.ApplyTo<TActual>(ActualValueDelegate<TActual>) Constraint.ApplyTo<TActual>(ref TActual) Constraint.ApplyToAsync<TActual>(Func<Task<TActual>>) Constraint.GetTestObject<TActual>(ActualValueDelegate<TActual>) Constraint.ToString() Constraint.GetStringRepresentation(IEnumerable) Constraint.After(int) Constraint.After(int, int) Constraint.DisplayName Constraint.Arguments Constraint.Builder Constraint.And Constraint.With Constraint.Or object.GetType() object.MemberwiseClone() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework.Constraints Assembly: nunit.framework.dll Syntax public abstract class PathConstraint : StringConstraint, IConstraint, IResolveConstraint Constructors View Source PathConstraint(string) Construct a PathConstraint for a give expected path Declaration protected PathConstraint(string expected) Parameters Type Name Description string expected The expected path Properties View Source RespectCase Modifies the current instance to be case-sensitive and returns it. Declaration public PathConstraint RespectCase { get; } Property Value Type Description PathConstraint Methods View Source Canonicalize(string) Canonicalize the provided path Declaration protected string Canonicalize(string path) Parameters Type Name Description string path Returns Type Description string The path in standardized form View Source DetermineComparisonType() Determines the StringComparison value based on the caseInsensitive field. If caseInsensitive is true, it returns OrdinalIgnoreCase; otherwise, it returns Ordinal. Declaration protected StringComparison DetermineComparisonType() Returns Type Description StringComparison View Source GetStringRepresentation() Returns the string representation of this constraint Declaration protected override string GetStringRepresentation() Returns Type Description string Overrides Constraint.GetStringRepresentation() View Source IsSubPath(string, string) Test whether one path in canonical form is a subpath of another path Declaration protected bool IsSubPath(string path1, string path2) Parameters Type Name Description string path1 The first path - supposed to be the parent path string path2 The second path - supposed to be the child path Returns Type Description bool Implements IConstraint IResolveConstraint"
  },
  "api/NUnit.Framework.Constraints.PredicateConstraint-1.html": {
    "href": "api/NUnit.Framework.Constraints.PredicateConstraint-1.html",
    "title": "Class PredicateConstraint<T> | NUnit Docs",
    "summary": "Class PredicateConstraint<T> Predicate constraint wraps a Predicate in a constraint, returning success if the predicate is true. Inheritance object Constraint PredicateConstraint<T> Implements IConstraint IResolveConstraint Inherited Members Constraint.ApplyTo<TActual>(ActualValueDelegate<TActual>) Constraint.ApplyTo<TActual>(ref TActual) Constraint.ApplyToAsync<TActual>(Func<Task<TActual>>) Constraint.GetTestObject<TActual>(ActualValueDelegate<TActual>) Constraint.ToString() Constraint.GetStringRepresentation(IEnumerable) Constraint.GetStringRepresentation() Constraint.After(int) Constraint.After(int, int) Constraint.DisplayName Constraint.Arguments Constraint.Builder Constraint.And Constraint.With Constraint.Or object.GetType() object.MemberwiseClone() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework.Constraints Assembly: nunit.framework.dll Syntax public class PredicateConstraint<T> : Constraint, IConstraint, IResolveConstraint Type Parameters Name Description T Constructors View Source PredicateConstraint(Predicate<T>) Construct a PredicateConstraint from a predicate Declaration public PredicateConstraint(Predicate<T> predicate) Parameters Type Name Description Predicate<T> predicate Properties View Source Description Gets text describing a constraint Declaration public override string Description { get; } Property Value Type Description string Overrides Constraint.Description Methods View Source ApplyTo<TActual>(TActual) Determines whether the predicate succeeds when applied to the actual value. Declaration public override ConstraintResult ApplyTo<TActual>(TActual actual) Parameters Type Name Description TActual actual Returns Type Description ConstraintResult Type Parameters Name Description TActual Overrides Constraint.ApplyTo<TActual>(TActual) Implements IConstraint IResolveConstraint"
  },
  "api/NUnit.Framework.Constraints.PrefixConstraint.html": {
    "href": "api/NUnit.Framework.Constraints.PrefixConstraint.html",
    "title": "Class PrefixConstraint | NUnit Docs",
    "summary": "Class PrefixConstraint Abstract base class used for prefixes Inheritance object Constraint PrefixConstraint AllItemsConstraint AttributeConstraint DelayedConstraint IndexerConstraint NoItemConstraint NotConstraint PropertyConstraint SomeItemsConstraint ThrowsConstraint Implements IConstraint IResolveConstraint Inherited Members Constraint.ApplyTo<TActual>(TActual) Constraint.ApplyTo<TActual>(ActualValueDelegate<TActual>) Constraint.ApplyTo<TActual>(ref TActual) Constraint.ApplyToAsync<TActual>(Func<Task<TActual>>) Constraint.GetTestObject<TActual>(ActualValueDelegate<TActual>) Constraint.ToString() Constraint.GetStringRepresentation(IEnumerable) Constraint.GetStringRepresentation() Constraint.After(int) Constraint.After(int, int) Constraint.DisplayName Constraint.Arguments Constraint.Builder Constraint.And Constraint.With Constraint.Or object.GetType() object.MemberwiseClone() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework.Constraints Assembly: nunit.framework.dll Syntax public abstract class PrefixConstraint : Constraint, IConstraint, IResolveConstraint Constructors View Source PrefixConstraint(IResolveConstraint, string) Construct given a base constraint Declaration protected PrefixConstraint(IResolveConstraint baseConstraint, string descriptionPrefix) Parameters Type Name Description IResolveConstraint baseConstraint string descriptionPrefix Prefix used in forming the constraint description Properties View Source BaseConstraint The base constraint Declaration protected IConstraint BaseConstraint { get; } Property Value Type Description IConstraint View Source Description The Description of what this constraint tests, for use in messages and in the ConstraintResult. Declaration public override string Description { get; } Property Value Type Description string Overrides Constraint.Description View Source DescriptionPrefix Prefix used in forming the constraint description Declaration protected string DescriptionPrefix { get; } Property Value Type Description string Implements IConstraint IResolveConstraint"
  },
  "api/NUnit.Framework.Constraints.PrefixOperator.html": {
    "href": "api/NUnit.Framework.Constraints.PrefixOperator.html",
    "title": "Class PrefixOperator | NUnit Docs",
    "summary": "Class PrefixOperator PrefixOperator takes a single constraint and modifies its action in some way. Inheritance object ConstraintOperator PrefixOperator CollectionOperator IndexerOperator NotOperator WithOperator Inherited Members ConstraintOperator.left_precedence ConstraintOperator.right_precedence ConstraintOperator.LeftContext ConstraintOperator.RightContext ConstraintOperator.LeftPrecedence ConstraintOperator.RightPrecedence object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework.Constraints Assembly: nunit.framework.dll Syntax public abstract class PrefixOperator : ConstraintOperator Constructors View Source PrefixOperator() Declaration protected PrefixOperator() Methods View Source ApplyPrefix(IConstraint) Returns the constraint created by applying this prefix to another constraint. Declaration public abstract IConstraint ApplyPrefix(IConstraint constraint) Parameters Type Name Description IConstraint constraint Returns Type Description IConstraint View Source Reduce(ConstraintStack) Reduce produces a constraint from the operator and any arguments. It takes the arguments from the constraint stack and pushes the resulting constraint on it. Declaration public override void Reduce(ConstraintBuilder.ConstraintStack stack) Parameters Type Name Description ConstraintBuilder.ConstraintStack stack Overrides ConstraintOperator.Reduce(ConstraintBuilder.ConstraintStack)"
  },
  "api/NUnit.Framework.Constraints.PropOperator.html": {
    "href": "api/NUnit.Framework.Constraints.PropOperator.html",
    "title": "Class PropOperator | NUnit Docs",
    "summary": "Class PropOperator Operator used to test for the presence of a named Property on an object and optionally apply further tests to the value of that property. Inheritance object ConstraintOperator SelfResolvingOperator PropOperator Inherited Members ConstraintOperator.left_precedence ConstraintOperator.right_precedence ConstraintOperator.LeftContext ConstraintOperator.RightContext ConstraintOperator.LeftPrecedence ConstraintOperator.RightPrecedence object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework.Constraints Assembly: nunit.framework.dll Syntax public class PropOperator : SelfResolvingOperator Constructors View Source PropOperator(string) Constructs a PropOperator for a particular named property Declaration public PropOperator(string name) Parameters Type Name Description string name Properties View Source Name Gets the name of the property to which the operator applies Declaration public string Name { get; } Property Value Type Description string Methods View Source Reduce(ConstraintStack) Reduce produces a constraint from the operator and any arguments. It takes the arguments from the constraint stack and pushes the resulting constraint on it. Declaration public override void Reduce(ConstraintBuilder.ConstraintStack stack) Parameters Type Name Description ConstraintBuilder.ConstraintStack stack Overrides ConstraintOperator.Reduce(ConstraintBuilder.ConstraintStack)"
  },
  "api/NUnit.Framework.Constraints.PropertiesComparerConfiguration-1.html": {
    "href": "api/NUnit.Framework.Constraints.PropertiesComparerConfiguration-1.html",
    "title": "Class PropertiesComparerConfiguration<T> | NUnit Docs",
    "summary": "Class PropertiesComparerConfiguration<T> Generic version of PropertiesComparerConfiguration to allow specifiying properties using expression syntax instead of strings. Inheritance object PropertiesComparerConfiguration PropertiesComparerConfiguration<T> Inherited Members PropertiesComparerConfiguration.SetTolerance(object) object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework.Constraints Assembly: nunit.framework.dll Syntax public class PropertiesComparerConfiguration<T> : PropertiesComparerConfiguration Type Parameters Name Description T Constructors View Source PropertiesComparerConfiguration() Declaration public PropertiesComparerConfiguration() Methods View Source AllowDifferentTypes() Set the NUnit.Framework.Constraints.PropertiesComparerConfiguration.AllowComparingDifferentTypes property. Declaration public PropertiesComparerConfiguration<T> AllowDifferentTypes() Returns Type Description PropertiesComparerConfiguration<T> Self. View Source CompareOnlyCommonProperties() Set the NUnit.Framework.Constraints.PropertiesComparerConfiguration.OnlyCompareCommonProperties property. Declaration public PropertiesComparerConfiguration<T> CompareOnlyCommonProperties() Returns Type Description PropertiesComparerConfiguration<T> Self. Remarks Implies AllowDifferentTypes() View Source Excluding(params Expression<Func<T, object?>>[]) Set the NUnit.Framework.Constraints.PropertiesComparerConfiguration.PropertyNamesToExclude property. Declaration public PropertiesComparerConfiguration<T> Excluding(params Expression<Func<T, object?>>[] properties) Parameters Type Name Description Expression<Func<T, object>>[] properties List of properties to use for comparison. Returns Type Description PropertiesComparerConfiguration<T> Self. View Source Excluding<TFrom>(params Expression<Func<TFrom, object?>>[]) Set the NUnit.Framework.Constraints.PropertiesComparerConfiguration.PropertyNamesToExclude property. Declaration public PropertiesComparerConfiguration<T> Excluding<TFrom>(params Expression<Func<TFrom, object?>>[] properties) Parameters Type Name Description Expression<Func<TFrom, object>>[] properties List of properties to use for comparison. Returns Type Description PropertiesComparerConfiguration<T> Self. Type Parameters Name Description TFrom View Source Map<TTo>(Expression<Func<T, object?>>, Expression<Func<TTo, object?>>) Updates the NUnit.Framework.Constraints.PropertiesComparerConfiguration.PropertyNameMapForType property. Declaration public PropertiesComparerConfiguration<T> Map<TTo>(Expression<Func<T, object?>> from, Expression<Func<TTo, object?>> to) Parameters Type Name Description Expression<Func<T, object>> from The name to map from. Expression<Func<TTo, object>> to The name to map to. Returns Type Description PropertiesComparerConfiguration<T> Self. Type Parameters Name Description TTo Remarks Implies AllowDifferentTypes() View Source Map<TFrom>(Expression<Func<TFrom, object?>>, object?) Updates the NUnit.Framework.Constraints.PropertiesComparerConfiguration.PropertyNameToValueMapForType property. Declaration public PropertiesComparerConfiguration<T> Map<TFrom>(Expression<Func<TFrom, object?>> from, object? value) Parameters Type Name Description Expression<Func<TFrom, object>> from The name to map from. object value The value to use for a propery with name from. Returns Type Description PropertiesComparerConfiguration<T> Self. Type Parameters Name Description TFrom Remarks Implies AllowDifferentTypes() View Source Map<TTo>(params (Expression<Func<T, object?>> From, Expression<Func<TTo, object?>> To)[]) Set the NUnit.Framework.Constraints.PropertiesComparerConfiguration.PropertyNameMapForType property. Declaration public PropertiesComparerConfiguration<T> Map<TTo>(params (Expression<Func<T, object?>> From, Expression<Func<TTo, object?>> To)[] properties) Parameters Type Name Description (Expression<Func<T, object>> From, Expression<Func<TTo, object>> To)[] properties List of properties to map for comparison. Returns Type Description PropertiesComparerConfiguration<T> Self. Type Parameters Name Description TTo Remarks Implies AllowDifferentTypes() View Source Map<TFrom, TTo>(Expression<Func<TFrom, object?>>, Expression<Func<TTo, object?>>) Updates the NUnit.Framework.Constraints.PropertiesComparerConfiguration.PropertyNameMapForType property. Declaration public PropertiesComparerConfiguration<T> Map<TFrom, TTo>(Expression<Func<TFrom, object?>> from, Expression<Func<TTo, object?>> to) Parameters Type Name Description Expression<Func<TFrom, object>> from The name to map from. Expression<Func<TTo, object>> to The name to map to. Returns Type Description PropertiesComparerConfiguration<T> Self. Type Parameters Name Description TFrom TTo Remarks Implies AllowDifferentTypes() View Source Map<TFrom, TTo>(params (Expression<Func<TFrom, object?>> From, Expression<Func<TTo, object?>> To)[]) Set the NUnit.Framework.Constraints.PropertiesComparerConfiguration.PropertyNameMapForType property. Declaration public PropertiesComparerConfiguration<T> Map<TFrom, TTo>(params (Expression<Func<TFrom, object?>> From, Expression<Func<TTo, object?>> To)[] properties) Parameters Type Name Description (Expression<Func<TFrom, object>> From, Expression<Func<TTo, object>> To)[] properties List of properties to map for comparison. Returns Type Description PropertiesComparerConfiguration<T> Self. Type Parameters Name Description TFrom TTo Remarks Implies AllowDifferentTypes() View Source Using(params Expression<Func<T, object?>>[]) Set the NUnit.Framework.Constraints.PropertiesComparerConfiguration.PropertyNamesToUseForType property. Declaration public PropertiesComparerConfiguration<T> Using(params Expression<Func<T, object?>>[] properties) Parameters Type Name Description Expression<Func<T, object>>[] properties List of properties to use for comparison. Returns Type Description PropertiesComparerConfiguration<T> Self. View Source Using<TFrom>(params Expression<Func<TFrom, object?>>[]) Set the NUnit.Framework.Constraints.PropertiesComparerConfiguration.PropertyNamesToUseForType property. Declaration public PropertiesComparerConfiguration<T> Using<TFrom>(params Expression<Func<TFrom, object?>>[] properties) Parameters Type Name Description Expression<Func<TFrom, object>>[] properties List of properties to use for comparison. Returns Type Description PropertiesComparerConfiguration<T> Self. Type Parameters Name Description TFrom View Source Within(object) Specify a tolerance for all numeric comparisons. Declaration public PropertiesComparerConfiguration<T> Within(object amount) Parameters Type Name Description object amount The tolerance to apply. Returns Type Description PropertiesComparerConfiguration<T> Self."
  },
  "api/NUnit.Framework.Constraints.PropertiesComparerConfiguration.html": {
    "href": "api/NUnit.Framework.Constraints.PropertiesComparerConfiguration.html",
    "title": "Class PropertiesComparerConfiguration | NUnit Docs",
    "summary": "Class PropertiesComparerConfiguration Class to configure how to compare properties Inheritance object PropertiesComparerConfiguration PropertiesComparerConfigurationUntyped PropertiesComparerConfiguration<T> Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework.Constraints Assembly: nunit.framework.dll Syntax public class PropertiesComparerConfiguration Constructors View Source PropertiesComparerConfiguration() Declaration public PropertiesComparerConfiguration() Methods View Source SetTolerance(object) Set the tolerance to apply based upon the type of the tolerance. Declaration protected void SetTolerance(object amount) Parameters Type Name Description object amount Remarks This method accepts a TimeSpan, a numeric value or a Tolerance instance."
  },
  "api/NUnit.Framework.Constraints.PropertiesComparerConfigurationUntyped.html": {
    "href": "api/NUnit.Framework.Constraints.PropertiesComparerConfigurationUntyped.html",
    "title": "Class PropertiesComparerConfigurationUntyped | NUnit Docs",
    "summary": "Class PropertiesComparerConfigurationUntyped Class to configure how to compare properties. Non-generic untyped version. Inheritance object PropertiesComparerConfiguration PropertiesComparerConfigurationUntyped Inherited Members PropertiesComparerConfiguration.SetTolerance(object) object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework.Constraints Assembly: nunit.framework.dll Syntax public class PropertiesComparerConfigurationUntyped : PropertiesComparerConfiguration Constructors View Source PropertiesComparerConfigurationUntyped() Declaration public PropertiesComparerConfigurationUntyped() Methods View Source AllowDifferentTypes() Set the NUnit.Framework.Constraints.PropertiesComparerConfiguration.AllowComparingDifferentTypes property. Declaration public PropertiesComparerConfigurationUntyped AllowDifferentTypes() Returns Type Description PropertiesComparerConfigurationUntyped Self. View Source CompareOnlyCommonProperties() Set the NUnit.Framework.Constraints.PropertiesComparerConfiguration.OnlyCompareCommonProperties property. Declaration public PropertiesComparerConfigurationUntyped CompareOnlyCommonProperties() Returns Type Description PropertiesComparerConfigurationUntyped Self. Remarks Implies AllowDifferentTypes() View Source Excluding(params string[]) Set the NUnit.Framework.Constraints.PropertiesComparerConfiguration.PropertyNamesToExclude property. Declaration public PropertiesComparerConfigurationUntyped Excluding(params string[] properties) Parameters Type Name Description string[] properties List of properties to use for comparison. Returns Type Description PropertiesComparerConfigurationUntyped Self. View Source Map(string, string) Updates the NUnit.Framework.Constraints.PropertiesComparerConfiguration.PropertyNameMap property. Declaration public PropertiesComparerConfigurationUntyped Map(string from, string to) Parameters Type Name Description string from The name to map from. string to The name to map to. Returns Type Description PropertiesComparerConfigurationUntyped Self. Remarks Implies AllowDifferentTypes() View Source Map(params (string From, string To)[]) Set the NUnit.Framework.Constraints.PropertiesComparerConfiguration.PropertyNameMap property. Declaration public PropertiesComparerConfigurationUntyped Map(params (string From, string To)[] properties) Parameters Type Name Description (string From, string To)[] properties List of properties to map for comparison. Returns Type Description PropertiesComparerConfigurationUntyped Self. Remarks Implies AllowDifferentTypes() View Source Using(params string[]) Set the NUnit.Framework.Constraints.PropertiesComparerConfiguration.PropertyNamesToUse property. Declaration public PropertiesComparerConfigurationUntyped Using(params string[] properties) Parameters Type Name Description string[] properties List of properties to use for comparison. Returns Type Description PropertiesComparerConfigurationUntyped Self. Remarks The names are not related to one type, but common across all nested compared types. This could be used to only compare id of types instead of each property. View Source Within(object) Specify a tolerance for all numeric comparisons. Declaration public PropertiesComparerConfigurationUntyped Within(object amount) Parameters Type Name Description object amount The tolerance to apply. Returns Type Description PropertiesComparerConfigurationUntyped Self."
  },
  "api/NUnit.Framework.Constraints.PropertyConstraint.html": {
    "href": "api/NUnit.Framework.Constraints.PropertyConstraint.html",
    "title": "Class PropertyConstraint | NUnit Docs",
    "summary": "Class PropertyConstraint PropertyConstraint extracts a named property and uses its value as the actual value for a chained constraint. Inheritance object Constraint PrefixConstraint PropertyConstraint Implements IConstraint IResolveConstraint Inherited Members PrefixConstraint.BaseConstraint PrefixConstraint.DescriptionPrefix PrefixConstraint.Description Constraint.ApplyTo<TActual>(ActualValueDelegate<TActual>) Constraint.ApplyTo<TActual>(ref TActual) Constraint.ApplyToAsync<TActual>(Func<Task<TActual>>) Constraint.GetTestObject<TActual>(ActualValueDelegate<TActual>) Constraint.ToString() Constraint.GetStringRepresentation(IEnumerable) Constraint.After(int) Constraint.After(int, int) Constraint.DisplayName Constraint.Arguments Constraint.Builder Constraint.And Constraint.With Constraint.Or object.GetType() object.MemberwiseClone() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework.Constraints Assembly: nunit.framework.dll Syntax public class PropertyConstraint : PrefixConstraint, IConstraint, IResolveConstraint Constructors View Source PropertyConstraint(string, IConstraint) Initializes a new instance of the PropertyConstraint class. Declaration public PropertyConstraint(string name, IConstraint baseConstraint) Parameters Type Name Description string name The name. IConstraint baseConstraint The constraint to apply to the property. Methods View Source ApplyTo<TActual>(TActual) Test whether the constraint is satisfied by a given value Declaration public override ConstraintResult ApplyTo<TActual>(TActual actual) Parameters Type Name Description TActual actual The value to be tested Returns Type Description ConstraintResult Type Parameters Name Description TActual Overrides Constraint.ApplyTo<TActual>(TActual) View Source GetStringRepresentation() Returns the string representation of the constraint. Declaration protected override string GetStringRepresentation() Returns Type Description string Overrides Constraint.GetStringRepresentation() Implements IConstraint IResolveConstraint"
  },
  "api/NUnit.Framework.Constraints.PropertyExistsConstraint.html": {
    "href": "api/NUnit.Framework.Constraints.PropertyExistsConstraint.html",
    "title": "Class PropertyExistsConstraint | NUnit Docs",
    "summary": "Class PropertyExistsConstraint PropertyExistsConstraint tests that a named property exists on the object provided through Match. Originally, PropertyConstraint provided this feature in addition to making optional tests on the value of the property. The two constraints are now separate. Inheritance object Constraint PropertyExistsConstraint Implements IConstraint IResolveConstraint Inherited Members Constraint.ApplyTo<TActual>(ActualValueDelegate<TActual>) Constraint.ApplyTo<TActual>(ref TActual) Constraint.ApplyToAsync<TActual>(Func<Task<TActual>>) Constraint.GetTestObject<TActual>(ActualValueDelegate<TActual>) Constraint.ToString() Constraint.GetStringRepresentation(IEnumerable) Constraint.After(int) Constraint.After(int, int) Constraint.DisplayName Constraint.Arguments Constraint.Builder Constraint.And Constraint.With Constraint.Or object.GetType() object.MemberwiseClone() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework.Constraints Assembly: nunit.framework.dll Syntax public class PropertyExistsConstraint : Constraint, IConstraint, IResolveConstraint Constructors View Source PropertyExistsConstraint(string) Initializes a new instance of the PropertyExistsConstraint class. Declaration public PropertyExistsConstraint(string name) Parameters Type Name Description string name The name of the property. Properties View Source Description The Description of what this constraint tests, for use in messages and in the ConstraintResult. Declaration public override string Description { get; } Property Value Type Description string Overrides Constraint.Description Methods View Source ApplyTo<TActual>(TActual) Test whether the property exists for a given object Declaration public override ConstraintResult ApplyTo<TActual>(TActual actual) Parameters Type Name Description TActual actual The object to be tested Returns Type Description ConstraintResult True for success, false for failure Type Parameters Name Description TActual Overrides Constraint.ApplyTo<TActual>(TActual) View Source GetStringRepresentation() Returns the string representation of the constraint. Declaration protected override string GetStringRepresentation() Returns Type Description string Overrides Constraint.GetStringRepresentation() Implements IConstraint IResolveConstraint"
  },
  "api/NUnit.Framework.Constraints.RangeConstraint.html": {
    "href": "api/NUnit.Framework.Constraints.RangeConstraint.html",
    "title": "Class RangeConstraint | NUnit Docs",
    "summary": "Class RangeConstraint RangeConstraint tests whether two values are within a specified range. Inheritance object Constraint RangeConstraint Implements IConstraint IResolveConstraint Inherited Members Constraint.ApplyTo<TActual>(ActualValueDelegate<TActual>) Constraint.ApplyTo<TActual>(ref TActual) Constraint.ApplyToAsync<TActual>(Func<Task<TActual>>) Constraint.GetTestObject<TActual>(ActualValueDelegate<TActual>) Constraint.ToString() Constraint.GetStringRepresentation(IEnumerable) Constraint.GetStringRepresentation() Constraint.After(int) Constraint.After(int, int) Constraint.DisplayName Constraint.Arguments Constraint.Builder Constraint.And Constraint.With Constraint.Or object.GetType() object.MemberwiseClone() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework.Constraints Assembly: nunit.framework.dll Syntax public class RangeConstraint : Constraint, IConstraint, IResolveConstraint Constructors View Source RangeConstraint(object, object) Initializes a new instance of the RangeConstraint class. Declaration public RangeConstraint(object from, object to) Parameters Type Name Description object from Inclusive beginning of the range. object to Inclusive end of the range. Properties View Source Description Gets text describing a constraint Declaration public override string Description { get; } Property Value Type Description string Overrides Constraint.Description Methods View Source ApplyTo<TActual>(TActual) Test whether the constraint is satisfied by a given value Declaration public override ConstraintResult ApplyTo<TActual>(TActual actual) Parameters Type Name Description TActual actual The value to be tested Returns Type Description ConstraintResult True for success, false for failure Type Parameters Name Description TActual Overrides Constraint.ApplyTo<TActual>(TActual) View Source Using(IComparer) Modifies the constraint to use an IComparer and returns self. Declaration public RangeConstraint Using(IComparer comparer) Parameters Type Name Description IComparer comparer Returns Type Description RangeConstraint View Source Using<T>(IComparer<T>) Modifies the constraint to use an IComparer<T> and returns self. Declaration public RangeConstraint Using<T>(IComparer<T> comparer) Parameters Type Name Description IComparer<T> comparer Returns Type Description RangeConstraint Type Parameters Name Description T View Source Using<T>(Comparison<T>) Modifies the constraint to use a Comparison<T> and returns self. Declaration public RangeConstraint Using<T>(Comparison<T> comparer) Parameters Type Name Description Comparison<T> comparer Returns Type Description RangeConstraint Type Parameters Name Description T Implements IConstraint IResolveConstraint"
  },
  "api/NUnit.Framework.Constraints.RegexConstraint.html": {
    "href": "api/NUnit.Framework.Constraints.RegexConstraint.html",
    "title": "Class RegexConstraint | NUnit Docs",
    "summary": "Class RegexConstraint RegexConstraint can test whether a string matches the pattern provided. Inheritance object Constraint RegexConstraint Implements IConstraint IResolveConstraint Inherited Members Constraint.ApplyTo<TActual>(ActualValueDelegate<TActual>) Constraint.ApplyTo<TActual>(ref TActual) Constraint.ApplyToAsync<TActual>(Func<Task<TActual>>) Constraint.GetTestObject<TActual>(ActualValueDelegate<TActual>) Constraint.ToString() Constraint.GetStringRepresentation(IEnumerable) Constraint.GetStringRepresentation() Constraint.After(int) Constraint.After(int, int) Constraint.DisplayName Constraint.Arguments Constraint.Builder Constraint.And Constraint.With Constraint.Or object.GetType() object.MemberwiseClone() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework.Constraints Assembly: nunit.framework.dll Syntax public class RegexConstraint : Constraint, IConstraint, IResolveConstraint Constructors View Source RegexConstraint(string) Initializes a new instance of the RegexConstraint class. Declaration public RegexConstraint(string pattern) Parameters Type Name Description string pattern The pattern. View Source RegexConstraint(Regex) Initializes a new instance of the RegexConstraint class. Declaration public RegexConstraint(Regex regex) Parameters Type Name Description Regex regex The Regex pattern object. Properties View Source Description The Description of what this constraint tests, for use in messages and in the ConstraintResult. Declaration public override string Description { get; } Property Value Type Description string Overrides Constraint.Description View Source IgnoreCase Modify the constraint to ignore case in matching. Declaration public RegexConstraint IgnoreCase { get; } Property Value Type Description RegexConstraint Methods View Source ApplyTo<TActual>(TActual) Applies the regex constraint to an actual value, returning a ConstraintResult. Declaration public override ConstraintResult ApplyTo<TActual>(TActual actual) Parameters Type Name Description TActual actual The string to be tested. Returns Type Description ConstraintResult True for success, false for failure. Type Parameters Name Description TActual Overrides Constraint.ApplyTo<TActual>(TActual) Implements IConstraint IResolveConstraint"
  },
  "api/NUnit.Framework.Constraints.ResolvableConstraintExpression.html": {
    "href": "api/NUnit.Framework.Constraints.ResolvableConstraintExpression.html",
    "title": "Class ResolvableConstraintExpression | NUnit Docs",
    "summary": "Class ResolvableConstraintExpression ResolvableConstraintExpression is used to represent a compound constraint being constructed at a point where the last operator may either terminate the expression or may have additional qualifying constraints added to it. It is used, for example, for a Property element or for an Exception element, either of which may be optionally followed by constraints that apply to the property or exception. Inheritance object ConstraintExpression ResolvableConstraintExpression Implements IResolveConstraint Inherited Members ConstraintExpression.builder ConstraintExpression.ToString() ConstraintExpression.Append(ConstraintOperator) ConstraintExpression.Append(SelfResolvingOperator) ConstraintExpression.Append(Constraint) ConstraintExpression.Append<T>(T) ConstraintExpression.Exactly(int) ConstraintExpression.Property(string) ConstraintExpression.Attribute(Type) ConstraintExpression.Attribute<TExpected>() ConstraintExpression.Matches(IResolveConstraint) ConstraintExpression.Matches<TActual>(Predicate<TActual>) ConstraintExpression.MultipleOf(int) ConstraintExpression.EqualTo(object) ConstraintExpression.EqualTo<T>(T) ConstraintExpression.EqualTo(string) ConstraintExpression.EqualTo(DateTimeOffset) ConstraintExpression.EqualTo(DateTime) ConstraintExpression.EqualTo(TimeSpan) ConstraintExpression.EqualTo(double) ConstraintExpression.EqualTo(float) ConstraintExpression.EqualTo(decimal) ConstraintExpression.EqualTo(long) ConstraintExpression.EqualTo(int) ConstraintExpression.EqualTo(short) ConstraintExpression.EqualTo(byte) ConstraintExpression.EqualTo(ulong) ConstraintExpression.EqualTo(uint) ConstraintExpression.EqualTo(ushort) ConstraintExpression.EqualTo(sbyte) ConstraintExpression.SameAs(object) ConstraintExpression.GreaterThan(object) ConstraintExpression.GreaterThanOrEqualTo(object) ConstraintExpression.AtLeast(object) ConstraintExpression.LessThan(object) ConstraintExpression.LessThanOrEqualTo(object) ConstraintExpression.AtMost(object) ConstraintExpression.TypeOf(Type) ConstraintExpression.TypeOf<TExpected>() ConstraintExpression.InstanceOf(Type) ConstraintExpression.InstanceOf<TExpected>() ConstraintExpression.AssignableFrom(Type) ConstraintExpression.AssignableFrom<TExpected>() ConstraintExpression.AssignableTo(Type) ConstraintExpression.AssignableTo<TExpected>() ConstraintExpression.EquivalentTo(IEnumerable) ConstraintExpression.SubsetOf(IEnumerable) ConstraintExpression.SupersetOf(IEnumerable) ConstraintExpression.Member(object) ConstraintExpression.Member<T>(T) ConstraintExpression.Contains(object) ConstraintExpression.Contains<T>(T) ConstraintExpression.Contains(string) ConstraintExpression.Contain(object) ConstraintExpression.Contain<T>(T) ConstraintExpression.Contain(string) ConstraintExpression.ContainKey(object) ConstraintExpression.ContainValue(object) ConstraintExpression.StartWith(string) ConstraintExpression.StartsWith(string) ConstraintExpression.EndWith(string) ConstraintExpression.EndsWith(string) ConstraintExpression.Match(string) ConstraintExpression.Match(Regex) ConstraintExpression.Matches(string) ConstraintExpression.Matches(Regex) ConstraintExpression.SamePath(string) ConstraintExpression.SubPathOf(string) ConstraintExpression.SamePathOrUnder(string) ConstraintExpression.InRange(object, object) ConstraintExpression.AnyOf(params object[]) ConstraintExpression.AnyOf(ICollection) ConstraintExpression.ItemAt(params object[]) ConstraintExpression.Not ConstraintExpression.No ConstraintExpression.All ConstraintExpression.Some ConstraintExpression.None ConstraintExpression.One ConstraintExpression.Length ConstraintExpression.Count ConstraintExpression.Message ConstraintExpression.InnerException ConstraintExpression.With ConstraintExpression.Null ConstraintExpression.Default ConstraintExpression.True ConstraintExpression.False ConstraintExpression.Positive ConstraintExpression.Negative ConstraintExpression.Zero ConstraintExpression.NaN ConstraintExpression.Even ConstraintExpression.Odd ConstraintExpression.Empty ConstraintExpression.WhiteSpace ConstraintExpression.Unique ConstraintExpression.XmlSerializable ConstraintExpression.Ordered ConstraintExpression.Exist object.GetType() object.MemberwiseClone() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework.Constraints Assembly: nunit.framework.dll Syntax public class ResolvableConstraintExpression : ConstraintExpression, IResolveConstraint Constructors View Source ResolvableConstraintExpression() Create a new instance of ResolvableConstraintExpression Declaration public ResolvableConstraintExpression() View Source ResolvableConstraintExpression(ConstraintBuilder) Create a new instance of ResolvableConstraintExpression, passing in a pre-populated ConstraintBuilder. Declaration public ResolvableConstraintExpression(ConstraintBuilder builder) Parameters Type Name Description ConstraintBuilder builder Properties View Source And Appends an And Operator to the expression Declaration public ConstraintExpression And { get; } Property Value Type Description ConstraintExpression View Source Or Appends an Or operator to the expression. Declaration public ConstraintExpression Or { get; } Property Value Type Description ConstraintExpression Implements IResolveConstraint"
  },
  "api/NUnit.Framework.Constraints.ReusableConstraint.html": {
    "href": "api/NUnit.Framework.Constraints.ReusableConstraint.html",
    "title": "Class ReusableConstraint | NUnit Docs",
    "summary": "Class ReusableConstraint ReusableConstraint wraps a constraint expression after resolving it so that it can be reused consistently. Inheritance object ReusableConstraint Implements IResolveConstraint Inherited Members object.GetType() object.MemberwiseClone() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework.Constraints Assembly: nunit.framework.dll Syntax public class ReusableConstraint : IResolveConstraint Constructors View Source ReusableConstraint(IResolveConstraint) Construct a ReusableConstraint from a constraint expression Declaration public ReusableConstraint(IResolveConstraint c) Parameters Type Name Description IResolveConstraint c The expression to be resolved and reused Methods View Source Resolve() Return the top-level constraint for this expression Declaration public IConstraint Resolve() Returns Type Description IConstraint View Source ToString() Returns a string that represents this instance. Declaration public override string ToString() Returns Type Description string A string that represents this instance. Overrides object.ToString() Operators View Source implicit operator ReusableConstraint(Constraint) Converts a constraint to a ReusableConstraint Declaration public static implicit operator ReusableConstraint(Constraint c) Parameters Type Name Description Constraint c The constraint to be converted Returns Type Description ReusableConstraint A ReusableConstraint Implements IResolveConstraint"
  },
  "api/NUnit.Framework.Constraints.SameAsConstraint.html": {
    "href": "api/NUnit.Framework.Constraints.SameAsConstraint.html",
    "title": "Class SameAsConstraint | NUnit Docs",
    "summary": "Class SameAsConstraint SameAsConstraint tests whether an object is identical to the object passed to its constructor Inheritance object Constraint SameAsConstraint Implements IConstraint IResolveConstraint Inherited Members Constraint.ApplyTo<TActual>(ActualValueDelegate<TActual>) Constraint.ApplyTo<TActual>(ref TActual) Constraint.ApplyToAsync<TActual>(Func<Task<TActual>>) Constraint.GetTestObject<TActual>(ActualValueDelegate<TActual>) Constraint.ToString() Constraint.GetStringRepresentation(IEnumerable) Constraint.GetStringRepresentation() Constraint.After(int) Constraint.After(int, int) Constraint.DisplayName Constraint.Arguments Constraint.Builder Constraint.And Constraint.With Constraint.Or object.GetType() object.MemberwiseClone() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework.Constraints Assembly: nunit.framework.dll Syntax public class SameAsConstraint : Constraint, IConstraint, IResolveConstraint Constructors View Source SameAsConstraint(object?) Initializes a new instance of the SameAsConstraint class. Declaration public SameAsConstraint(object? expected) Parameters Type Name Description object expected The expected object. Properties View Source Description The Description of what this constraint tests, for use in messages and in the ConstraintResult. Declaration public override string Description { get; } Property Value Type Description string Overrides Constraint.Description Methods View Source ApplyTo<TActual>(TActual) Test whether the constraint is satisfied by a given value Declaration public override ConstraintResult ApplyTo<TActual>(TActual actual) Parameters Type Name Description TActual actual The value to be tested Returns Type Description ConstraintResult True for success, false for failure Type Parameters Name Description TActual Overrides Constraint.ApplyTo<TActual>(TActual) Implements IConstraint IResolveConstraint"
  },
  "api/NUnit.Framework.Constraints.SamePathConstraint.html": {
    "href": "api/NUnit.Framework.Constraints.SamePathConstraint.html",
    "title": "Class SamePathConstraint | NUnit Docs",
    "summary": "Class SamePathConstraint Summary description for SamePathConstraint. Inheritance object Constraint StringConstraint PathConstraint SamePathConstraint Implements IConstraint IResolveConstraint Inherited Members PathConstraint.GetStringRepresentation() PathConstraint.Canonicalize(string) PathConstraint.DetermineComparisonType() PathConstraint.IsSubPath(string, string) PathConstraint.RespectCase StringConstraint.expected StringConstraint.caseInsensitive StringConstraint.descriptionText StringConstraint.ApplyTo<TActual>(TActual) StringConstraint.IgnoreCase Constraint.ApplyTo<TActual>(ActualValueDelegate<TActual>) Constraint.ApplyTo<TActual>(ref TActual) Constraint.ApplyToAsync<TActual>(Func<Task<TActual>>) Constraint.GetTestObject<TActual>(ActualValueDelegate<TActual>) Constraint.ToString() Constraint.GetStringRepresentation(IEnumerable) Constraint.After(int) Constraint.After(int, int) Constraint.DisplayName Constraint.Arguments Constraint.Builder Constraint.And Constraint.With Constraint.Or object.GetType() object.MemberwiseClone() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework.Constraints Assembly: nunit.framework.dll Syntax public class SamePathConstraint : PathConstraint, IConstraint, IResolveConstraint Constructors View Source SamePathConstraint(string) Initializes a new instance of the SamePathConstraint class. Declaration public SamePathConstraint(string expected) Parameters Type Name Description string expected The expected path Properties View Source Description The Description of what this constraint tests, for use in messages and in the ConstraintResult. Declaration public override string Description { get; } Property Value Type Description string Overrides StringConstraint.Description Methods View Source Matches(string?) Test whether the constraint is satisfied by a given value Declaration protected override bool Matches(string? actual) Parameters Type Name Description string actual The value to be tested Returns Type Description bool True for success, false for failure Overrides StringConstraint.Matches(string?) Implements IConstraint IResolveConstraint"
  },
  "api/NUnit.Framework.Constraints.SamePathOrUnderConstraint.html": {
    "href": "api/NUnit.Framework.Constraints.SamePathOrUnderConstraint.html",
    "title": "Class SamePathOrUnderConstraint | NUnit Docs",
    "summary": "Class SamePathOrUnderConstraint SamePathOrUnderConstraint tests that one path is under another Inheritance object Constraint StringConstraint PathConstraint SamePathOrUnderConstraint Implements IConstraint IResolveConstraint Inherited Members PathConstraint.GetStringRepresentation() PathConstraint.Canonicalize(string) PathConstraint.DetermineComparisonType() PathConstraint.IsSubPath(string, string) PathConstraint.RespectCase StringConstraint.expected StringConstraint.caseInsensitive StringConstraint.descriptionText StringConstraint.ApplyTo<TActual>(TActual) StringConstraint.IgnoreCase Constraint.ApplyTo<TActual>(ActualValueDelegate<TActual>) Constraint.ApplyTo<TActual>(ref TActual) Constraint.ApplyToAsync<TActual>(Func<Task<TActual>>) Constraint.GetTestObject<TActual>(ActualValueDelegate<TActual>) Constraint.ToString() Constraint.GetStringRepresentation(IEnumerable) Constraint.After(int) Constraint.After(int, int) Constraint.DisplayName Constraint.Arguments Constraint.Builder Constraint.And Constraint.With Constraint.Or object.GetType() object.MemberwiseClone() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework.Constraints Assembly: nunit.framework.dll Syntax public class SamePathOrUnderConstraint : PathConstraint, IConstraint, IResolveConstraint Constructors View Source SamePathOrUnderConstraint(string) Initializes a new instance of the SamePathOrUnderConstraint class. Declaration public SamePathOrUnderConstraint(string expected) Parameters Type Name Description string expected The expected path Properties View Source Description The Description of what this constraint tests, for use in messages and in the ConstraintResult. Declaration public override string Description { get; } Property Value Type Description string Overrides StringConstraint.Description Methods View Source Matches(string?) Test whether the constraint is satisfied by a given value Declaration protected override bool Matches(string? actual) Parameters Type Name Description string actual The value to be tested Returns Type Description bool True for success, false for failure Overrides StringConstraint.Matches(string?) Implements IConstraint IResolveConstraint"
  },
  "api/NUnit.Framework.Constraints.SelfResolvingOperator.html": {
    "href": "api/NUnit.Framework.Constraints.SelfResolvingOperator.html",
    "title": "Class SelfResolvingOperator | NUnit Docs",
    "summary": "Class SelfResolvingOperator Abstract base class for operators that are able to reduce to a constraint whether or not another syntactic element follows. Inheritance object ConstraintOperator SelfResolvingOperator AttributeOperator ExactCountOperator PropOperator ThrowsOperator Inherited Members ConstraintOperator.left_precedence ConstraintOperator.right_precedence ConstraintOperator.Reduce(ConstraintBuilder.ConstraintStack) ConstraintOperator.LeftContext ConstraintOperator.RightContext ConstraintOperator.LeftPrecedence ConstraintOperator.RightPrecedence object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework.Constraints Assembly: nunit.framework.dll Syntax public abstract class SelfResolvingOperator : ConstraintOperator Constructors View Source SelfResolvingOperator() Declaration protected SelfResolvingOperator()"
  },
  "api/NUnit.Framework.Constraints.SomeItemsConstraint-1.html": {
    "href": "api/NUnit.Framework.Constraints.SomeItemsConstraint-1.html",
    "title": "Class SomeItemsConstraint<T> | NUnit Docs",
    "summary": "Class SomeItemsConstraint<T> SomeItemsConstraint applies another constraint to each item in a collection, succeeding if any of them succeeds. Inheritance object Constraint PrefixConstraint SomeItemsConstraint SomeItemsConstraint<T> Implements IConstraint IResolveConstraint Inherited Members SomeItemsConstraint.ApplyTo<TActual>(TActual) SomeItemsConstraint.Using<TActualCollectionElement, TExpected>(Func<TActualCollectionElement, TExpected, bool>) SomeItemsConstraint.Using(IComparer) SomeItemsConstraint.Using<T>(IComparer<T>) SomeItemsConstraint.Using<T>(Comparison<T>) SomeItemsConstraint.Using(IEqualityComparer) SomeItemsConstraint.Using<T>(IEqualityComparer<T>) SomeItemsConstraint.UsingPropertiesComparer() SomeItemsConstraint.UsingPropertiesComparer(Func<PropertiesComparerConfigurationUntyped, PropertiesComparerConfigurationUntyped>) SomeItemsConstraint.DisplayName PrefixConstraint.BaseConstraint PrefixConstraint.DescriptionPrefix PrefixConstraint.Description Constraint.ApplyTo<TActual>(ActualValueDelegate<TActual>) Constraint.ApplyTo<TActual>(ref TActual) Constraint.ApplyToAsync<TActual>(Func<Task<TActual>>) Constraint.GetTestObject<TActual>(ActualValueDelegate<TActual>) Constraint.ToString() Constraint.GetStringRepresentation(IEnumerable) Constraint.GetStringRepresentation() Constraint.After(int) Constraint.After(int, int) Constraint.Arguments Constraint.Builder Constraint.And Constraint.With Constraint.Or object.GetType() object.MemberwiseClone() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework.Constraints Assembly: nunit.framework.dll Syntax public class SomeItemsConstraint<T> : SomeItemsConstraint, IConstraint, IResolveConstraint Type Parameters Name Description T Constructors View Source SomeItemsConstraint(EqualConstraint<T>) Construct a SomeItemsConstraint on top of an existing constraint Declaration public SomeItemsConstraint(EqualConstraint<T> itemConstraint) Parameters Type Name Description EqualConstraint<T> itemConstraint Methods View Source UsingPropertiesComparer(Func<PropertiesComparerConfiguration<T>, PropertiesComparerConfiguration<T>>) Enables comparing a subset of instance properties. Declaration public SomeItemsConstraint UsingPropertiesComparer(Func<PropertiesComparerConfiguration<T>, PropertiesComparerConfiguration<T>> configure) Parameters Type Name Description Func<PropertiesComparerConfiguration<T>, PropertiesComparerConfiguration<T>> configure Function to configure the PropertiesComparerConfiguration Returns Type Description SomeItemsConstraint Remarks This allows comparing classes that don't implement IEquatable<T> without having to compare each property separately in own code. Implements IConstraint IResolveConstraint"
  },
  "api/NUnit.Framework.Constraints.SomeItemsConstraint.html": {
    "href": "api/NUnit.Framework.Constraints.SomeItemsConstraint.html",
    "title": "Class SomeItemsConstraint | NUnit Docs",
    "summary": "Class SomeItemsConstraint SomeItemsConstraint applies another constraint to each item in a collection, succeeding if any of them succeeds. Inheritance object Constraint PrefixConstraint SomeItemsConstraint SomeItemsConstraint<T> Implements IConstraint IResolveConstraint Inherited Members PrefixConstraint.BaseConstraint PrefixConstraint.DescriptionPrefix PrefixConstraint.Description Constraint.ApplyTo<TActual>(ActualValueDelegate<TActual>) Constraint.ApplyTo<TActual>(ref TActual) Constraint.ApplyToAsync<TActual>(Func<Task<TActual>>) Constraint.GetTestObject<TActual>(ActualValueDelegate<TActual>) Constraint.ToString() Constraint.GetStringRepresentation(IEnumerable) Constraint.GetStringRepresentation() Constraint.After(int) Constraint.After(int, int) Constraint.Arguments Constraint.Builder Constraint.And Constraint.With Constraint.Or object.GetType() object.MemberwiseClone() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework.Constraints Assembly: nunit.framework.dll Syntax public class SomeItemsConstraint : PrefixConstraint, IConstraint, IResolveConstraint Constructors View Source SomeItemsConstraint(IConstraint) Construct a SomeItemsConstraint on top of an existing constraint Declaration public SomeItemsConstraint(IConstraint itemConstraint) Parameters Type Name Description IConstraint itemConstraint Properties View Source DisplayName The display name of this Constraint for use by ToString(). The default value is the name of the constraint with trailing \"Constraint\" removed. Derived classes may set this to another name in their constructors. Declaration public override string DisplayName { get; } Property Value Type Description string Overrides Constraint.DisplayName Methods View Source ApplyTo<TActual>(TActual) Apply the item constraint to each item in the collection, succeeding if any item succeeds. Declaration public override ConstraintResult ApplyTo<TActual>(TActual actual) Parameters Type Name Description TActual actual Returns Type Description ConstraintResult Type Parameters Name Description TActual Overrides Constraint.ApplyTo<TActual>(TActual) View Source Using(IComparer) Flag the constraint to use the supplied IComparer object. Declaration public SomeItemsConstraint Using(IComparer comparer) Parameters Type Name Description IComparer comparer The IComparer object to use. Returns Type Description SomeItemsConstraint Self. View Source Using(IEqualityComparer) Flag the constraint to use the supplied IEqualityComparer object. Declaration public SomeItemsConstraint Using(IEqualityComparer comparer) Parameters Type Name Description IEqualityComparer comparer The IComparer object to use. Returns Type Description SomeItemsConstraint Self. View Source UsingPropertiesComparer() Enables comparing of instance properties. Declaration public SomeItemsConstraint UsingPropertiesComparer() Returns Type Description SomeItemsConstraint Remarks This allows comparing classes that don't implement IEquatable<T> without having to compare each property separately in own code. View Source UsingPropertiesComparer(Func<PropertiesComparerConfigurationUntyped, PropertiesComparerConfigurationUntyped>) Enables comparing of instance properties. Declaration public SomeItemsConstraint UsingPropertiesComparer(Func<PropertiesComparerConfigurationUntyped, PropertiesComparerConfigurationUntyped> configure) Parameters Type Name Description Func<PropertiesComparerConfigurationUntyped, PropertiesComparerConfigurationUntyped> configure Returns Type Description SomeItemsConstraint Remarks This allows comparing classes that don't implement IEquatable<T> without having to compare each property separately in own code. View Source Using<T>(IComparer<T>) Flag the constraint to use the supplied IComparer<T> object. Declaration public SomeItemsConstraint Using<T>(IComparer<T> comparer) Parameters Type Name Description IComparer<T> comparer The IComparer object to use. Returns Type Description SomeItemsConstraint Self. Type Parameters Name Description T View Source Using<T>(IEqualityComparer<T>) Flag the constraint to use the supplied IEqualityComparer<T> object. Declaration public SomeItemsConstraint Using<T>(IEqualityComparer<T> comparer) Parameters Type Name Description IEqualityComparer<T> comparer The IComparer object to use. Returns Type Description SomeItemsConstraint Self. Type Parameters Name Description T View Source Using<T>(Comparison<T>) Flag the constraint to use the supplied Comparison<T> object. Declaration public SomeItemsConstraint Using<T>(Comparison<T> comparer) Parameters Type Name Description Comparison<T> comparer The IComparer object to use. Returns Type Description SomeItemsConstraint Self. Type Parameters Name Description T View Source Using<TActualCollectionElement, TExpected>(Func<TActualCollectionElement, TExpected, bool>) Flag the constraint to use the supplied Func<T1, T2, TResult> object. Declaration public SomeItemsConstraint Using<TActualCollectionElement, TExpected>(Func<TActualCollectionElement, TExpected, bool> comparison) Parameters Type Name Description Func<TActualCollectionElement, TExpected, bool> comparison The comparison function to use. Returns Type Description SomeItemsConstraint Self. Type Parameters Name Description TActualCollectionElement The type of the elements in the collection. TExpected The type of the expected value. Implements IConstraint IResolveConstraint"
  },
  "api/NUnit.Framework.Constraints.SomeOperator.html": {
    "href": "api/NUnit.Framework.Constraints.SomeOperator.html",
    "title": "Class SomeOperator | NUnit Docs",
    "summary": "Class SomeOperator Represents a constraint that succeeds if any of the members of a collection match a base constraint. Inheritance object ConstraintOperator PrefixOperator CollectionOperator SomeOperator Inherited Members PrefixOperator.Reduce(ConstraintBuilder.ConstraintStack) ConstraintOperator.left_precedence ConstraintOperator.right_precedence ConstraintOperator.LeftContext ConstraintOperator.RightContext ConstraintOperator.LeftPrecedence ConstraintOperator.RightPrecedence object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework.Constraints Assembly: nunit.framework.dll Syntax public class SomeOperator : CollectionOperator Constructors View Source SomeOperator() Declaration public SomeOperator() Methods View Source ApplyPrefix(IConstraint) Returns a constraint that will apply the argument to the members of a collection, succeeding if any of them succeed. Declaration public override IConstraint ApplyPrefix(IConstraint constraint) Parameters Type Name Description IConstraint constraint Returns Type Description IConstraint Overrides PrefixOperator.ApplyPrefix(IConstraint)"
  },
  "api/NUnit.Framework.Constraints.StartsWithConstraint.html": {
    "href": "api/NUnit.Framework.Constraints.StartsWithConstraint.html",
    "title": "Class StartsWithConstraint | NUnit Docs",
    "summary": "Class StartsWithConstraint StartsWithConstraint can test whether a string starts with an expected substring. Inheritance object Constraint StringConstraint StartsWithConstraint Implements IConstraint IResolveConstraint Inherited Members StringConstraint.expected StringConstraint.caseInsensitive StringConstraint.descriptionText StringConstraint.ApplyTo<TActual>(TActual) StringConstraint.Description StringConstraint.IgnoreCase Constraint.ApplyTo<TActual>(ActualValueDelegate<TActual>) Constraint.ApplyTo<TActual>(ref TActual) Constraint.ApplyToAsync<TActual>(Func<Task<TActual>>) Constraint.GetTestObject<TActual>(ActualValueDelegate<TActual>) Constraint.ToString() Constraint.GetStringRepresentation(IEnumerable) Constraint.GetStringRepresentation() Constraint.After(int) Constraint.After(int, int) Constraint.DisplayName Constraint.Arguments Constraint.Builder Constraint.And Constraint.With Constraint.Or object.GetType() object.MemberwiseClone() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework.Constraints Assembly: nunit.framework.dll Syntax public class StartsWithConstraint : StringConstraint, IConstraint, IResolveConstraint Constructors View Source StartsWithConstraint(string) Initializes a new instance of the StartsWithConstraint class. Declaration public StartsWithConstraint(string expected) Parameters Type Name Description string expected The expected string Methods View Source Matches(string?) Test whether the constraint is matched by the actual value. This is a template method, which calls the IsMatch method of the derived class. Declaration protected override bool Matches(string? actual) Parameters Type Name Description string actual Returns Type Description bool Overrides StringConstraint.Matches(string?) Implements IConstraint IResolveConstraint"
  },
  "api/NUnit.Framework.Constraints.StringConstraint.html": {
    "href": "api/NUnit.Framework.Constraints.StringConstraint.html",
    "title": "Class StringConstraint | NUnit Docs",
    "summary": "Class StringConstraint StringConstraint is the abstract base for constraints that operate on strings. It supports the IgnoreCase modifier for string operations. Inheritance object Constraint StringConstraint EmptyStringConstraint EndsWithConstraint PathConstraint StartsWithConstraint SubstringConstraint WhiteSpaceConstraint Implements IConstraint IResolveConstraint Inherited Members Constraint.ApplyTo<TActual>(ActualValueDelegate<TActual>) Constraint.ApplyTo<TActual>(ref TActual) Constraint.ApplyToAsync<TActual>(Func<Task<TActual>>) Constraint.GetTestObject<TActual>(ActualValueDelegate<TActual>) Constraint.ToString() Constraint.GetStringRepresentation(IEnumerable) Constraint.GetStringRepresentation() Constraint.After(int) Constraint.After(int, int) Constraint.DisplayName Constraint.Arguments Constraint.Builder Constraint.And Constraint.With Constraint.Or object.GetType() object.MemberwiseClone() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework.Constraints Assembly: nunit.framework.dll Syntax public abstract class StringConstraint : Constraint, IConstraint, IResolveConstraint Constructors View Source StringConstraint() Constructs a StringConstraint without an expected value Declaration protected StringConstraint() View Source StringConstraint(string) Constructs a StringConstraint given an expected value Declaration protected StringConstraint(string expected) Parameters Type Name Description string expected The expected value Fields View Source caseInsensitive Indicates whether tests should be case-insensitive Declaration protected bool caseInsensitive Field Value Type Description bool View Source descriptionText Description of this constraint Declaration protected string descriptionText Field Value Type Description string View Source expected The expected value Declaration protected readonly string expected Field Value Type Description string Properties View Source Description The Description of what this constraint tests, for use in messages and in the ConstraintResult. Declaration public override string Description { get; } Property Value Type Description string Overrides Constraint.Description View Source IgnoreCase Modify the constraint to ignore case in matching. Declaration public virtual StringConstraint IgnoreCase { get; } Property Value Type Description StringConstraint Methods View Source ApplyTo<TActual>(TActual) Test whether the constraint is satisfied by a given value Declaration public override ConstraintResult ApplyTo<TActual>(TActual actual) Parameters Type Name Description TActual actual The value to be tested Returns Type Description ConstraintResult True for success, false for failure Type Parameters Name Description TActual Overrides Constraint.ApplyTo<TActual>(TActual) View Source Matches(string?) Test whether the constraint is satisfied by a given string Declaration protected abstract bool Matches(string? actual) Parameters Type Name Description string actual The string to be tested Returns Type Description bool True for success, false for failure Implements IConstraint IResolveConstraint"
  },
  "api/NUnit.Framework.Constraints.SubPathConstraint.html": {
    "href": "api/NUnit.Framework.Constraints.SubPathConstraint.html",
    "title": "Class SubPathConstraint | NUnit Docs",
    "summary": "Class SubPathConstraint SubPathConstraint tests that the actual path is under the expected path Inheritance object Constraint StringConstraint PathConstraint SubPathConstraint Implements IConstraint IResolveConstraint Inherited Members PathConstraint.GetStringRepresentation() PathConstraint.Canonicalize(string) PathConstraint.DetermineComparisonType() PathConstraint.IsSubPath(string, string) PathConstraint.RespectCase StringConstraint.expected StringConstraint.caseInsensitive StringConstraint.descriptionText StringConstraint.ApplyTo<TActual>(TActual) StringConstraint.IgnoreCase Constraint.ApplyTo<TActual>(ActualValueDelegate<TActual>) Constraint.ApplyTo<TActual>(ref TActual) Constraint.ApplyToAsync<TActual>(Func<Task<TActual>>) Constraint.GetTestObject<TActual>(ActualValueDelegate<TActual>) Constraint.ToString() Constraint.GetStringRepresentation(IEnumerable) Constraint.After(int) Constraint.After(int, int) Constraint.DisplayName Constraint.Arguments Constraint.Builder Constraint.And Constraint.With Constraint.Or object.GetType() object.MemberwiseClone() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework.Constraints Assembly: nunit.framework.dll Syntax public class SubPathConstraint : PathConstraint, IConstraint, IResolveConstraint Constructors View Source SubPathConstraint(string) Initializes a new instance of the SubPathConstraint class. Declaration public SubPathConstraint(string expected) Parameters Type Name Description string expected The expected path Properties View Source Description The Description of what this constraint tests, for use in messages and in the ConstraintResult. Declaration public override string Description { get; } Property Value Type Description string Overrides StringConstraint.Description Methods View Source Matches(string?) Test whether the constraint is satisfied by a given value Declaration protected override bool Matches(string? actual) Parameters Type Name Description string actual The value to be tested Returns Type Description bool True for success, false for failure Overrides StringConstraint.Matches(string?) Implements IConstraint IResolveConstraint"
  },
  "api/NUnit.Framework.Constraints.SubstringConstraint.html": {
    "href": "api/NUnit.Framework.Constraints.SubstringConstraint.html",
    "title": "Class SubstringConstraint | NUnit Docs",
    "summary": "Class SubstringConstraint SubstringConstraint can test whether a string contains the expected substring. Inheritance object Constraint StringConstraint SubstringConstraint Implements IConstraint IResolveConstraint Inherited Members StringConstraint.expected StringConstraint.caseInsensitive StringConstraint.descriptionText StringConstraint.ApplyTo<TActual>(TActual) StringConstraint.Description Constraint.ApplyTo<TActual>(ActualValueDelegate<TActual>) Constraint.ApplyTo<TActual>(ref TActual) Constraint.ApplyToAsync<TActual>(Func<Task<TActual>>) Constraint.GetTestObject<TActual>(ActualValueDelegate<TActual>) Constraint.ToString() Constraint.GetStringRepresentation(IEnumerable) Constraint.GetStringRepresentation() Constraint.After(int) Constraint.After(int, int) Constraint.DisplayName Constraint.Arguments Constraint.Builder Constraint.And Constraint.With Constraint.Or object.GetType() object.MemberwiseClone() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework.Constraints Assembly: nunit.framework.dll Syntax public class SubstringConstraint : StringConstraint, IConstraint, IResolveConstraint Constructors View Source SubstringConstraint(string) Initializes a new instance of the SubstringConstraint class. Declaration public SubstringConstraint(string expected) Parameters Type Name Description string expected The expected. Properties View Source IgnoreCase Modify the constraint to ignore case in matching. This will call Using(StringComparison.CurrentCultureIgnoreCase). Declaration public override StringConstraint IgnoreCase { get; } Property Value Type Description StringConstraint Overrides StringConstraint.IgnoreCase Exceptions Type Condition InvalidOperationException Thrown when a comparison type different than CurrentCultureIgnoreCase was already set. Methods View Source Matches(string?) Test whether the constraint is satisfied by a given value Declaration protected override bool Matches(string? actual) Parameters Type Name Description string actual The value to be tested Returns Type Description bool True for success, false for failure Overrides StringConstraint.Matches(string?) View Source Using(StringComparison) Modify the constraint to the specified comparison. Declaration public SubstringConstraint Using(StringComparison comparisonType) Parameters Type Name Description StringComparison comparisonType Returns Type Description SubstringConstraint Exceptions Type Condition InvalidOperationException Thrown when a comparison type different than comparisonType was already set. Implements IConstraint IResolveConstraint"
  },
  "api/NUnit.Framework.Constraints.ThrowsConstraint.html": {
    "href": "api/NUnit.Framework.Constraints.ThrowsConstraint.html",
    "title": "Class ThrowsConstraint | NUnit Docs",
    "summary": "Class ThrowsConstraint ThrowsConstraint is used to test the exception thrown by a delegate by applying a constraint to it. Inheritance object Constraint PrefixConstraint ThrowsConstraint Implements IConstraint IResolveConstraint Inherited Members PrefixConstraint.BaseConstraint PrefixConstraint.DescriptionPrefix Constraint.ApplyTo<TActual>(ref TActual) Constraint.GetTestObject<TActual>(ActualValueDelegate<TActual>) Constraint.ToString() Constraint.GetStringRepresentation(IEnumerable) Constraint.GetStringRepresentation() Constraint.After(int) Constraint.After(int, int) Constraint.DisplayName Constraint.Arguments Constraint.Builder Constraint.And Constraint.With Constraint.Or object.GetType() object.MemberwiseClone() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework.Constraints Assembly: nunit.framework.dll Syntax public class ThrowsConstraint : PrefixConstraint, IConstraint, IResolveConstraint Constructors View Source ThrowsConstraint(IConstraint) Initializes a new instance of the ThrowsConstraint class, using a constraint to be applied to the exception. Declaration public ThrowsConstraint(IConstraint baseConstraint) Parameters Type Name Description IConstraint baseConstraint A constraint to apply to the caught exception. Properties View Source ActualException Get the actual exception thrown - used by Assert.Throws. Declaration public Exception? ActualException { get; } Property Value Type Description Exception View Source Description Gets text describing a constraint Declaration public override string Description { get; } Property Value Type Description string Overrides PrefixConstraint.Description Methods View Source ApplyToAsync<TActual>(Func<Task<TActual>>) Applies the constraint to a delegate that returns the task. The default implementation simply evaluates the delegate and awaits the task but derived classes may override it to provide for delayed processing. Declaration public override Task<ConstraintResult> ApplyToAsync<TActual>(Func<Task<TActual>> actual) Parameters Type Name Description Func<Task<TActual>> actual Returns Type Description Task<ConstraintResult> Type Parameters Name Description TActual Overrides Constraint.ApplyToAsync<TActual>(Func<Task<TActual>>) View Source ApplyTo<TActual>(ActualValueDelegate<TActual>) Converts an ActualValueDelegate to a TestDelegate before calling the primary overload. Declaration public override ConstraintResult ApplyTo<TActual>(ActualValueDelegate<TActual> del) Parameters Type Name Description ActualValueDelegate<TActual> del Returns Type Description ConstraintResult Type Parameters Name Description TActual Overrides Constraint.ApplyTo<TActual>(ActualValueDelegate<TActual>) View Source ApplyTo<TActual>(TActual) Executes the code of the delegate and captures any exception. If a non-null base constraint was provided, it applies that constraint to the exception. Declaration public override ConstraintResult ApplyTo<TActual>(TActual actual) Parameters Type Name Description TActual actual A delegate representing the code to be tested Returns Type Description ConstraintResult True if an exception is thrown and the constraint succeeds, otherwise false Type Parameters Name Description TActual Overrides Constraint.ApplyTo<TActual>(TActual) Implements IConstraint IResolveConstraint"
  },
  "api/NUnit.Framework.Constraints.ThrowsExceptionConstraint.html": {
    "href": "api/NUnit.Framework.Constraints.ThrowsExceptionConstraint.html",
    "title": "Class ThrowsExceptionConstraint | NUnit Docs",
    "summary": "Class ThrowsExceptionConstraint ThrowsExceptionConstraint tests that an exception has been thrown, without any further tests. Inheritance object Constraint ThrowsExceptionConstraint Implements IConstraint IResolveConstraint Inherited Members Constraint.ApplyTo<TActual>(ref TActual) Constraint.GetTestObject<TActual>(ActualValueDelegate<TActual>) Constraint.ToString() Constraint.GetStringRepresentation(IEnumerable) Constraint.GetStringRepresentation() Constraint.After(int) Constraint.After(int, int) Constraint.DisplayName Constraint.Arguments Constraint.Builder Constraint.And Constraint.With Constraint.Or object.GetType() object.MemberwiseClone() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework.Constraints Assembly: nunit.framework.dll Syntax public class ThrowsExceptionConstraint : Constraint, IConstraint, IResolveConstraint Constructors View Source ThrowsExceptionConstraint() Declaration public ThrowsExceptionConstraint() Properties View Source Description The Description of what this constraint tests, for use in messages and in the ConstraintResult. Declaration public override string Description { get; } Property Value Type Description string Overrides Constraint.Description Methods View Source ApplyToAsync<TActual>(Func<Task<TActual>>) Applies the constraint to a delegate that returns the task. The default implementation simply evaluates the delegate and awaits the task but derived classes may override it to provide for delayed processing. Declaration public override Task<ConstraintResult> ApplyToAsync<TActual>(Func<Task<TActual>> actual) Parameters Type Name Description Func<Task<TActual>> actual Returns Type Description Task<ConstraintResult> Type Parameters Name Description TActual Overrides Constraint.ApplyToAsync<TActual>(Func<Task<TActual>>) View Source ApplyTo<TActual>(ActualValueDelegate<TActual>) Applies the constraint to an ActualValueDelegate that returns the value to be tested. The default implementation simply evaluates the delegate but derived classes may override it to provide for delayed processing. Declaration public override ConstraintResult ApplyTo<TActual>(ActualValueDelegate<TActual> del) Parameters Type Name Description ActualValueDelegate<TActual> del Returns Type Description ConstraintResult Type Parameters Name Description TActual Overrides Constraint.ApplyTo<TActual>(ActualValueDelegate<TActual>) View Source ApplyTo<TActual>(TActual) Executes the code and returns success if an exception is thrown. Declaration public override ConstraintResult ApplyTo<TActual>(TActual actual) Parameters Type Name Description TActual actual A delegate representing the code to be tested Returns Type Description ConstraintResult True if an exception is thrown, otherwise false Type Parameters Name Description TActual Overrides Constraint.ApplyTo<TActual>(TActual) Implements IConstraint IResolveConstraint"
  },
  "api/NUnit.Framework.Constraints.ThrowsNothingConstraint.html": {
    "href": "api/NUnit.Framework.Constraints.ThrowsNothingConstraint.html",
    "title": "Class ThrowsNothingConstraint | NUnit Docs",
    "summary": "Class ThrowsNothingConstraint ThrowsNothingConstraint tests that a delegate does not throw an exception. Inheritance object Constraint ThrowsNothingConstraint Implements IConstraint IResolveConstraint Inherited Members Constraint.ApplyTo<TActual>(ref TActual) Constraint.GetTestObject<TActual>(ActualValueDelegate<TActual>) Constraint.ToString() Constraint.GetStringRepresentation(IEnumerable) Constraint.GetStringRepresentation() Constraint.After(int) Constraint.After(int, int) Constraint.DisplayName Constraint.Arguments Constraint.Builder Constraint.And Constraint.With Constraint.Or object.GetType() object.MemberwiseClone() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework.Constraints Assembly: nunit.framework.dll Syntax public class ThrowsNothingConstraint : Constraint, IConstraint, IResolveConstraint Constructors View Source ThrowsNothingConstraint() Declaration public ThrowsNothingConstraint() Properties View Source Description Gets text describing a constraint Declaration public override string Description { get; } Property Value Type Description string Overrides Constraint.Description Methods View Source ApplyToAsync<TActual>(Func<Task<TActual>>) Applies the constraint to a delegate that returns the task. The default implementation simply evaluates the delegate and awaits the task but derived classes may override it to provide for delayed processing. Declaration public override Task<ConstraintResult> ApplyToAsync<TActual>(Func<Task<TActual>> taskDel) Parameters Type Name Description Func<Task<TActual>> taskDel Returns Type Description Task<ConstraintResult> Type Parameters Name Description TActual Overrides Constraint.ApplyToAsync<TActual>(Func<Task<TActual>>) View Source ApplyTo<TActual>(ActualValueDelegate<TActual>) Applies the constraint to an ActualValueDelegate that returns the value to be tested. The default implementation simply evaluates the delegate but derived classes may override it to provide for delayed processing. Declaration public override ConstraintResult ApplyTo<TActual>(ActualValueDelegate<TActual> del) Parameters Type Name Description ActualValueDelegate<TActual> del An ActualValueDelegate Returns Type Description ConstraintResult A ConstraintResult Type Parameters Name Description TActual Overrides Constraint.ApplyTo<TActual>(ActualValueDelegate<TActual>) View Source ApplyTo<TActual>(TActual) Test whether the constraint is satisfied by a given value Declaration public override ConstraintResult ApplyTo<TActual>(TActual actual) Parameters Type Name Description TActual actual The value to be tested Returns Type Description ConstraintResult True if no exception is thrown, otherwise false Type Parameters Name Description TActual Overrides Constraint.ApplyTo<TActual>(TActual) Implements IConstraint IResolveConstraint"
  },
  "api/NUnit.Framework.Constraints.ThrowsOperator.html": {
    "href": "api/NUnit.Framework.Constraints.ThrowsOperator.html",
    "title": "Class ThrowsOperator | NUnit Docs",
    "summary": "Class ThrowsOperator Operator that tests that an exception is thrown and optionally applies further tests to the exception. Inheritance object ConstraintOperator SelfResolvingOperator ThrowsOperator Inherited Members ConstraintOperator.left_precedence ConstraintOperator.right_precedence ConstraintOperator.LeftContext ConstraintOperator.RightContext ConstraintOperator.LeftPrecedence ConstraintOperator.RightPrecedence object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework.Constraints Assembly: nunit.framework.dll Syntax public class ThrowsOperator : SelfResolvingOperator Constructors View Source ThrowsOperator() Construct a ThrowsOperator Declaration public ThrowsOperator() Methods View Source Reduce(ConstraintStack) Reduce produces a constraint from the operator and any arguments. It takes the arguments from the constraint stack and pushes the resulting constraint on it. Declaration public override void Reduce(ConstraintBuilder.ConstraintStack stack) Parameters Type Name Description ConstraintBuilder.ConstraintStack stack Overrides ConstraintOperator.Reduce(ConstraintBuilder.ConstraintStack)"
  },
  "api/NUnit.Framework.Constraints.Tolerance.Range.html": {
    "href": "api/NUnit.Framework.Constraints.Tolerance.Range.html",
    "title": "Struct Tolerance.Range | NUnit Docs",
    "summary": "Struct Tolerance.Range Tolerance.Range represents the range of values that match a specific tolerance, when applied to a specific value. Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.GetType() object.Equals(object, object) object.ReferenceEquals(object, object) Namespace: NUnit.Framework.Constraints Assembly: nunit.framework.dll Syntax public readonly struct Tolerance.Range Constructors View Source Range(object, object) Constructs a range Declaration public Range(object lowerBound, object upperBound) Parameters Type Name Description object lowerBound object upperBound Fields View Source LowerBound The lower bound of the range Declaration public readonly object LowerBound Field Value Type Description object View Source UpperBound The upper bound of the range Declaration public readonly object UpperBound Field Value Type Description object"
  },
  "api/NUnit.Framework.Constraints.Tolerance.html": {
    "href": "api/NUnit.Framework.Constraints.Tolerance.html",
    "title": "Class Tolerance | NUnit Docs",
    "summary": "Class Tolerance The Tolerance class generalizes the notion of a tolerance within which an equality test succeeds. Normally, it is used with numeric types, but it can be used with any type that supports taking a difference between two objects and comparing that difference to a value. Inheritance object Tolerance Inherited Members object.GetType() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework.Constraints Assembly: nunit.framework.dll Syntax public sealed class Tolerance Constructors View Source Tolerance(object) Constructs a linear tolerance of a specified amount Declaration public Tolerance(object amount) Parameters Type Name Description object amount Fields View Source Default Returns a default Tolerance object, equivalent to a default matching rules. Declaration public static readonly Tolerance Default Field Value Type Description Tolerance View Source Exact Returns an empty Tolerance object, equivalent to an exact match. Declaration public static readonly Tolerance Exact Field Value Type Description Tolerance Properties View Source Amount Gets the magnitude of the current Tolerance instance. Declaration public object Amount { get; } Property Value Type Description object View Source Days Returns a new tolerance with a TimeSpan as the amount, using the current amount as a number of days. Declaration public Tolerance Days { get; } Property Value Type Description Tolerance View Source HasVariance Returns true if the current tolerance varies from exact and default. Indicating tolerance needs processing. Declaration public bool HasVariance { get; } Property Value Type Description bool View Source Hours Returns a new tolerance with a TimeSpan as the amount, using the current amount as a number of hours. Declaration public Tolerance Hours { get; } Property Value Type Description Tolerance View Source IsUnsetOrDefault Returns true if the current tolerance has not been set or is using the default. Declaration public bool IsUnsetOrDefault { get; } Property Value Type Description bool View Source Milliseconds Returns a new tolerance with a TimeSpan as the amount, using the current amount as a number of milliseconds. Declaration public Tolerance Milliseconds { get; } Property Value Type Description Tolerance View Source Minutes Returns a new tolerance with a TimeSpan as the amount, using the current amount as a number of minutes. Declaration public Tolerance Minutes { get; } Property Value Type Description Tolerance View Source Mode Gets the ToleranceMode for the current Tolerance Declaration public ToleranceMode Mode { get; } Property Value Type Description ToleranceMode View Source Percent Returns a new tolerance, using the current amount as a percentage. Declaration public Tolerance Percent { get; } Property Value Type Description Tolerance View Source Seconds Returns a new tolerance with a TimeSpan as the amount, using the current amount as a number of seconds. Declaration public Tolerance Seconds { get; } Property Value Type Description Tolerance View Source Ticks Returns a new tolerance with a TimeSpan as the amount, using the current amount as a number of clock ticks. Declaration public Tolerance Ticks { get; } Property Value Type Description Tolerance View Source Ulps Returns a new tolerance, using the current amount in Ulps Declaration public Tolerance Ulps { get; } Property Value Type Description Tolerance Methods View Source ApplyToValue(object) Apply the tolerance to an expected value and return a Tolerance.Range that represents the acceptable values. Declaration public Tolerance.Range ApplyToValue(object value) Parameters Type Name Description object value Returns Type Description Tolerance.Range View Source ToString() Returns a string that represents the current object. Declaration public override string? ToString() Returns Type Description string A string that represents the current object. Overrides object.ToString()"
  },
  "api/NUnit.Framework.Constraints.ToleranceMode.html": {
    "href": "api/NUnit.Framework.Constraints.ToleranceMode.html",
    "title": "Enum ToleranceMode | NUnit Docs",
    "summary": "Enum ToleranceMode Modes in which the tolerance value for a comparison can be interpreted. Namespace: NUnit.Framework.Constraints Assembly: nunit.framework.dll Syntax public enum ToleranceMode Fields Name Description Linear The tolerance is used as a numeric range within which two compared values are considered to be equal. Percent Interprets the tolerance as the percentage by which the two compared values my deviate from each other. Ulps Compares two values based in their distance in representable numbers. Unset The tolerance was created with a value, without specifying how the value would be used. This is used to prevent setting the mode more than once and is generally changed to Linear upon execution of the test."
  },
  "api/NUnit.Framework.Constraints.TrueConstraint.html": {
    "href": "api/NUnit.Framework.Constraints.TrueConstraint.html",
    "title": "Class TrueConstraint | NUnit Docs",
    "summary": "Class TrueConstraint TrueConstraint tests that the actual value is true Inheritance object Constraint TrueConstraint Implements IConstraint IResolveConstraint Inherited Members Constraint.ApplyTo<TActual>(ActualValueDelegate<TActual>) Constraint.ApplyTo<TActual>(ref TActual) Constraint.ApplyToAsync<TActual>(Func<Task<TActual>>) Constraint.GetTestObject<TActual>(ActualValueDelegate<TActual>) Constraint.ToString() Constraint.GetStringRepresentation(IEnumerable) Constraint.GetStringRepresentation() Constraint.After(int) Constraint.After(int, int) Constraint.DisplayName Constraint.Arguments Constraint.Builder Constraint.And Constraint.With Constraint.Or object.GetType() object.MemberwiseClone() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework.Constraints Assembly: nunit.framework.dll Syntax public class TrueConstraint : Constraint, IConstraint, IResolveConstraint Constructors View Source TrueConstraint() Declaration public TrueConstraint() Properties View Source Description The Description of what this constraint tests, for use in messages and in the ConstraintResult. Declaration public override string Description { get; } Property Value Type Description string Overrides Constraint.Description Methods View Source ApplyTo<TActual>(TActual) Test whether the constraint is satisfied by a given value Declaration public override ConstraintResult ApplyTo<TActual>(TActual actual) Parameters Type Name Description TActual actual The value to be tested Returns Type Description ConstraintResult True for success, false for failure Type Parameters Name Description TActual Overrides Constraint.ApplyTo<TActual>(TActual) Implements IConstraint IResolveConstraint"
  },
  "api/NUnit.Framework.Constraints.TypeConstraint.html": {
    "href": "api/NUnit.Framework.Constraints.TypeConstraint.html",
    "title": "Class TypeConstraint | NUnit Docs",
    "summary": "Class TypeConstraint TypeConstraint is the abstract base for constraints that take a Type as their expected value. Inheritance object Constraint TypeConstraint AssignableFromConstraint AssignableToConstraint ExactTypeConstraint InstanceOfTypeConstraint Implements IConstraint IResolveConstraint Inherited Members Constraint.ApplyTo<TActual>(ActualValueDelegate<TActual>) Constraint.ApplyTo<TActual>(ref TActual) Constraint.ApplyToAsync<TActual>(Func<Task<TActual>>) Constraint.GetTestObject<TActual>(ActualValueDelegate<TActual>) Constraint.ToString() Constraint.GetStringRepresentation(IEnumerable) Constraint.GetStringRepresentation() Constraint.After(int) Constraint.After(int, int) Constraint.DisplayName Constraint.Arguments Constraint.Builder Constraint.And Constraint.With Constraint.Or object.GetType() object.MemberwiseClone() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework.Constraints Assembly: nunit.framework.dll Syntax public abstract class TypeConstraint : Constraint, IConstraint, IResolveConstraint Constructors View Source TypeConstraint(Type, string) Construct a TypeConstraint for a given Type Declaration protected TypeConstraint(Type type, string descriptionPrefix) Parameters Type Name Description Type type The expected type for the constraint string descriptionPrefix Prefix used in forming the constraint description Fields View Source actualType The type of the actual argument to which the constraint was applied Declaration protected Type? actualType Field Value Type Description Type View Source expectedType The expected Type used by the constraint Declaration protected Type expectedType Field Value Type Description Type Properties View Source Description The Description of what this constraint tests, for use in messages and in the ConstraintResult. Declaration public override string Description { get; } Property Value Type Description string Overrides Constraint.Description Methods View Source ApplyTo<TActual>(TActual) Applies the constraint to an actual value, returning a ConstraintResult. Declaration public override ConstraintResult ApplyTo<TActual>(TActual actual) Parameters Type Name Description TActual actual The value to be tested Returns Type Description ConstraintResult A ConstraintResult Type Parameters Name Description TActual Overrides Constraint.ApplyTo<TActual>(TActual) View Source Matches(object?) Apply the constraint to an actual value, returning true if it succeeds Declaration protected abstract bool Matches(object? actual) Parameters Type Name Description object actual The actual argument Returns Type Description bool True if the constraint succeeds, otherwise false. Implements IConstraint IResolveConstraint"
  },
  "api/NUnit.Framework.Constraints.UniqueItemsConstraint.html": {
    "href": "api/NUnit.Framework.Constraints.UniqueItemsConstraint.html",
    "title": "Class UniqueItemsConstraint | NUnit Docs",
    "summary": "Class UniqueItemsConstraint UniqueItemsConstraint tests whether all the items in a collection are unique. Inheritance object Constraint CollectionConstraint CollectionItemsEqualConstraint UniqueItemsConstraint Implements IConstraint IResolveConstraint Inherited Members CollectionItemsEqualConstraint.Using(IComparer) CollectionItemsEqualConstraint.Using<T>(IComparer<T>) CollectionItemsEqualConstraint.Using<T>(Comparison<T>) CollectionItemsEqualConstraint.Using(IEqualityComparer) CollectionItemsEqualConstraint.Using<T>(IEqualityComparer<T>) CollectionItemsEqualConstraint.Using<T>(Func<T, T, bool>) CollectionItemsEqualConstraint.UsingPropertiesComparer() CollectionItemsEqualConstraint.UsingPropertiesComparer(Func<PropertiesComparerConfigurationUntyped, PropertiesComparerConfigurationUntyped>) CollectionItemsEqualConstraint.ItemsEqual(object, object) CollectionItemsEqualConstraint.Tally(IEnumerable) CollectionItemsEqualConstraint.IgnoringCase CollectionItemsEqualConstraint.IgnoringWhiteSpace CollectionItemsEqualConstraint.IgnoringLineEndingFormat CollectionItemsEqualConstraint.UsingExternalComparer CollectionItemsEqualConstraint.IgnoreCase CollectionItemsEqualConstraint.IgnoreWhiteSpace CollectionItemsEqualConstraint.IgnoreLineEndingFormat CollectionConstraint.IsEmpty(IEnumerable) Constraint.ApplyTo<TActual>(ActualValueDelegate<TActual>) Constraint.ApplyTo<TActual>(ref TActual) Constraint.ApplyToAsync<TActual>(Func<Task<TActual>>) Constraint.GetTestObject<TActual>(ActualValueDelegate<TActual>) Constraint.ToString() Constraint.GetStringRepresentation(IEnumerable) Constraint.GetStringRepresentation() Constraint.After(int) Constraint.After(int, int) Constraint.DisplayName Constraint.Arguments Constraint.Builder Constraint.And Constraint.With Constraint.Or object.GetType() object.MemberwiseClone() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework.Constraints Assembly: nunit.framework.dll Syntax public class UniqueItemsConstraint : CollectionItemsEqualConstraint, IConstraint, IResolveConstraint Constructors View Source UniqueItemsConstraint() Declaration public UniqueItemsConstraint() Properties View Source Description The Description of what this constraint tests, for use in messages and in the ConstraintResult. Declaration public override string Description { get; } Property Value Type Description string Overrides Constraint.Description Methods View Source ApplyTo<TActual>(TActual) Test whether the constraint is satisfied by a given value Declaration public override ConstraintResult ApplyTo<TActual>(TActual actual) Parameters Type Name Description TActual actual The value to be tested Returns Type Description ConstraintResult True for success, false for failure Type Parameters Name Description TActual Overrides CollectionConstraint.ApplyTo<TActual>(TActual) View Source Matches(IEnumerable) Check that all items are unique. Declaration protected override bool Matches(IEnumerable actual) Parameters Type Name Description IEnumerable actual Returns Type Description bool Overrides CollectionConstraint.Matches(IEnumerable) Implements IConstraint IResolveConstraint"
  },
  "api/NUnit.Framework.Constraints.ValueFormatter.html": {
    "href": "api/NUnit.Framework.Constraints.ValueFormatter.html",
    "title": "Delegate ValueFormatter | NUnit Docs",
    "summary": "Delegate ValueFormatter Custom value formatter function Namespace: NUnit.Framework.Constraints Assembly: nunit.framework.dll Syntax public delegate string ValueFormatter(object val) Parameters Type Name Description object val The value Returns Type Description string Constructors View Source ValueFormatter(object, nint) Declaration public ValueFormatter(object @object, nint method) Parameters Type Name Description object object nint method Methods View Source BeginInvoke(object, AsyncCallback, object) Declaration public virtual IAsyncResult BeginInvoke(object val, AsyncCallback callback, object @object) Parameters Type Name Description object val AsyncCallback callback object object Returns Type Description IAsyncResult View Source EndInvoke(IAsyncResult) Declaration public virtual string EndInvoke(IAsyncResult result) Parameters Type Name Description IAsyncResult result Returns Type Description string View Source Invoke(object) Declaration public virtual string Invoke(object val) Parameters Type Name Description object val Returns Type Description string"
  },
  "api/NUnit.Framework.Constraints.ValueFormatterFactory.html": {
    "href": "api/NUnit.Framework.Constraints.ValueFormatterFactory.html",
    "title": "Delegate ValueFormatterFactory | NUnit Docs",
    "summary": "Delegate ValueFormatterFactory Custom value formatter factory function Namespace: NUnit.Framework.Constraints Assembly: nunit.framework.dll Syntax public delegate ValueFormatter ValueFormatterFactory(ValueFormatter next) Parameters Type Name Description ValueFormatter next The next formatter function Returns Type Description ValueFormatter ValueFormatter Remarks If the given formatter is unable to handle a certain format, it must call the next formatter in the chain Constructors View Source ValueFormatterFactory(object, nint) Declaration public ValueFormatterFactory(object @object, nint method) Parameters Type Name Description object object nint method Methods View Source BeginInvoke(ValueFormatter, AsyncCallback, object) Declaration public virtual IAsyncResult BeginInvoke(ValueFormatter next, AsyncCallback callback, object @object) Parameters Type Name Description ValueFormatter next AsyncCallback callback object object Returns Type Description IAsyncResult View Source EndInvoke(IAsyncResult) Declaration public virtual ValueFormatter EndInvoke(IAsyncResult result) Parameters Type Name Description IAsyncResult result Returns Type Description ValueFormatter View Source Invoke(ValueFormatter) Declaration public virtual ValueFormatter Invoke(ValueFormatter next) Parameters Type Name Description ValueFormatter next Returns Type Description ValueFormatter"
  },
  "api/NUnit.Framework.Constraints.WhiteSpaceConstraint.html": {
    "href": "api/NUnit.Framework.Constraints.WhiteSpaceConstraint.html",
    "title": "Class WhiteSpaceConstraint | NUnit Docs",
    "summary": "Class WhiteSpaceConstraint WhiteSpaceConstraint tests whether a string contains white space. Inheritance object Constraint StringConstraint WhiteSpaceConstraint Implements IConstraint IResolveConstraint Inherited Members StringConstraint.expected StringConstraint.caseInsensitive StringConstraint.descriptionText StringConstraint.ApplyTo<TActual>(TActual) StringConstraint.IgnoreCase Constraint.ApplyTo<TActual>(ActualValueDelegate<TActual>) Constraint.ApplyTo<TActual>(ref TActual) Constraint.ApplyToAsync<TActual>(Func<Task<TActual>>) Constraint.GetTestObject<TActual>(ActualValueDelegate<TActual>) Constraint.ToString() Constraint.GetStringRepresentation(IEnumerable) Constraint.GetStringRepresentation() Constraint.After(int) Constraint.After(int, int) Constraint.Arguments Constraint.Builder Constraint.And Constraint.With Constraint.Or object.GetType() object.MemberwiseClone() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework.Constraints Assembly: nunit.framework.dll Syntax public class WhiteSpaceConstraint : StringConstraint, IConstraint, IResolveConstraint Constructors View Source WhiteSpaceConstraint() Declaration public WhiteSpaceConstraint() Properties View Source Description The Description of what this constraint tests, for use in messages and in the ConstraintResult. Declaration public override string Description { get; } Property Value Type Description string Overrides StringConstraint.Description View Source DisplayName The display name of this Constraint for use by ToString(). The default value is the name of the constraint with trailing \"Constraint\" removed. Derived classes may set this to another name in their constructors. Declaration public override string DisplayName { get; } Property Value Type Description string Overrides Constraint.DisplayName Methods View Source Matches(string?) Test whether the constraint is satisfied by a given value Declaration protected override bool Matches(string? actual) Parameters Type Name Description string actual The value to be tested Returns Type Description bool True for success, false for failure Overrides StringConstraint.Matches(string?) Implements IConstraint IResolveConstraint"
  },
  "api/NUnit.Framework.Constraints.WithOperator.html": {
    "href": "api/NUnit.Framework.Constraints.WithOperator.html",
    "title": "Class WithOperator | NUnit Docs",
    "summary": "Class WithOperator Represents a constraint that simply wraps the constraint provided as an argument, without any further functionality, but which modifies the order of evaluation because of its precedence. Inheritance object ConstraintOperator PrefixOperator WithOperator Inherited Members PrefixOperator.Reduce(ConstraintBuilder.ConstraintStack) ConstraintOperator.left_precedence ConstraintOperator.right_precedence ConstraintOperator.LeftContext ConstraintOperator.RightContext ConstraintOperator.LeftPrecedence ConstraintOperator.RightPrecedence object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework.Constraints Assembly: nunit.framework.dll Syntax public class WithOperator : PrefixOperator Constructors View Source WithOperator() Constructor for the WithOperator Declaration public WithOperator() Methods View Source ApplyPrefix(IConstraint) Returns a constraint that wraps its argument Declaration public override IConstraint ApplyPrefix(IConstraint constraint) Parameters Type Name Description IConstraint constraint Returns Type Description IConstraint Overrides PrefixOperator.ApplyPrefix(IConstraint)"
  },
  "api/NUnit.Framework.Constraints.XmlSerializableConstraint.html": {
    "href": "api/NUnit.Framework.Constraints.XmlSerializableConstraint.html",
    "title": "Class XmlSerializableConstraint | NUnit Docs",
    "summary": "Class XmlSerializableConstraint XmlSerializableConstraint tests whether an object is serializable in XML format. Inheritance object Constraint XmlSerializableConstraint Implements IConstraint IResolveConstraint Inherited Members Constraint.ApplyTo<TActual>(ActualValueDelegate<TActual>) Constraint.ApplyTo<TActual>(ref TActual) Constraint.ApplyToAsync<TActual>(Func<Task<TActual>>) Constraint.GetTestObject<TActual>(ActualValueDelegate<TActual>) Constraint.ToString() Constraint.GetStringRepresentation(IEnumerable) Constraint.After(int) Constraint.After(int, int) Constraint.DisplayName Constraint.Arguments Constraint.Builder Constraint.And Constraint.With Constraint.Or object.GetType() object.MemberwiseClone() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework.Constraints Assembly: nunit.framework.dll Syntax public class XmlSerializableConstraint : Constraint, IConstraint, IResolveConstraint Constructors View Source XmlSerializableConstraint() Declaration public XmlSerializableConstraint() Properties View Source Description Gets text describing a constraint Declaration public override string Description { get; } Property Value Type Description string Overrides Constraint.Description Methods View Source ApplyTo<TActual>(TActual) Test whether the constraint is satisfied by a given value Declaration public override ConstraintResult ApplyTo<TActual>(TActual actual) Parameters Type Name Description TActual actual The value to be tested Returns Type Description ConstraintResult True for success, false for failure Type Parameters Name Description TActual Overrides Constraint.ApplyTo<TActual>(TActual) View Source GetStringRepresentation() Returns the string representation of this constraint Declaration protected override string GetStringRepresentation() Returns Type Description string Overrides Constraint.GetStringRepresentation() Implements IConstraint IResolveConstraint"
  },
  "api/NUnit.Framework.Constraints.html": {
    "href": "api/NUnit.Framework.Constraints.html",
    "title": "Namespace NUnit.Framework.Constraints | NUnit Docs",
    "summary": "Namespace NUnit.Framework.Constraints Classes AllItemsConstraint AllItemsConstraint applies another constraint to each item in a collection, succeeding if they all succeed. AllOperator Represents a constraint that succeeds if all the members of a collection match a base constraint. AndConstraint AndConstraint succeeds only if both members succeed. AndOperator Operator that requires both its arguments to succeed AnyOfConstraint AnyOfConstraint is used to determine whether the value is equal to any of the expected values. AssignableFromConstraint AssignableFromConstraint is used to test that an object can be assigned from a given Type. AssignableToConstraint AssignableToConstraint is used to test that an object can be assigned to a given Type. AttributeConstraint AttributeConstraint tests that a specified attribute is present on a Type or other provider and that the value of the attribute satisfies some other constraint. AttributeExistsConstraint AttributeExistsConstraint tests for the presence of a specified attribute on a Type. AttributeOperator Operator that tests for the presence of a particular attribute on a type and optionally applies further tests to the attribute. BinaryConstraint BinaryConstraint is the abstract base of all constraints that combine two other constraints in some fashion. BinaryOperator Abstract base class for all binary operators CollectionConstraint CollectionConstraint is the abstract base class for constraints that operate on collections. CollectionEquivalentConstraint CollectionEquivalentConstraint is used to determine whether two collections are equivalent. CollectionEquivalentConstraintResult Provides a ConstraintResult for the CollectionEquivalentConstraint. CollectionItemsEqualConstraint CollectionItemsEqualConstraint is the abstract base class for all collection constraints that apply some notion of item equality as a part of their operation. CollectionOperator Abstract base for operators that indicate how to apply a constraint to items in a collection. CollectionOrderedConstraint CollectionOrderedConstraint is used to test whether a collection is ordered. CollectionSubsetConstraint CollectionSubsetConstraint is used to determine whether one collection is a subset of another CollectionSupersetConstraint CollectionSupersetConstraint is used to determine whether one collection is a superset of another CollectionTally CollectionTally counts (tallies) the number of occurrences of each object in one or more enumerations. CollectionTally.CollectionTallyResult The result of a CollectionTally. ComparisonAdapter ComparisonAdapter class centralizes all comparisons of values in NUnit, adapting to the use of any provided IComparer, IComparer<T> or Comparison<T>. ComparisonConstraint Abstract base class for constraints that compare values to determine if one is greater than, equal to or less than the other. Constraint The Constraint class is the base of all built-in constraints within NUnit. It provides the operator overloads used to combine constraints. ConstraintBuilder ConstraintBuilder maintains the stacks that are used in processing a ConstraintExpression. An OperatorStack is used to hold operators that are waiting for their operands to be reorganized. a ConstraintStack holds input constraints as well as the results of each operator applied. ConstraintBuilder.ConstraintStack ConstraintStack is a type-safe stack for holding Constraints ConstraintExpression ConstraintExpression represents a compound constraint in the process of being constructed from a series of syntactic elements. Individual elements are appended to the expression as they are reorganized. When a constraint is appended, it is returned as the value of the operation so that modifiers may be applied. However, any partially built expression is attached to the constraint for later resolution. When an operator is appended, the partial expression is returned. If it's a self-resolving operator, then a ResolvableConstraintExpression is returned. ConstraintOperator The ConstraintOperator class is used internally by a ConstraintBuilder to represent an operator that modifies or combines constraints. Constraint operators use left and right precedence values to determine whether the top operator on the stack should be reduced before pushing a new operator. ConstraintResult Contains the result of matching a Constraint against an actual value. ContainsConstraint ContainsConstraint tests a whether a string contains a substring or a collection contains an object. It postpones the decision of which test to use until the type of the actual argument is known. This allows testing whether a string is contained in a collection or as a substring of another string using the same syntax. CountZeroConstraint CountZeroConstraint tests whether an instance has a property .Count with value zero. DateTimes The DateTimes class contains common operations on Date and Time values. DefaultConstraint Tests that the actual value is default value for type. DelayedConstraint Applies a delay to the match so that a match can be evaluated in the future. DelayedConstraint.WithDimensionedDelayInterval Allows only setting the polling interval of a DelayedConstraint DelayedConstraint.WithRawDelayInterval Allows only changing the time dimension of delay interval and setting a polling interval of a DelayedConstraint DelayedConstraint.WithRawPollingInterval Allows only changing the time dimension of the polling interval of a DelayedConstraint DictionaryContainsKeyConstraint DictionaryContainsKeyConstraint is used to test whether a dictionary contains an expected object as a key. DictionaryContainsKeyValuePairConstraint DictionaryContainsKeyValuePairConstraint is used to test whether a dictionary contains an expected object as a key-value-pair. DictionaryContainsValueConstraint DictionaryContainsValueConstraint is used to test whether a dictionary contains an expected object as a value. EmptyCollectionConstraint EmptyCollectionConstraint tests whether a collection is empty. EmptyConstraint EmptyConstraint tests a whether a string or collection is empty, postponing the decision about which test is applied until the type of the actual argument is known. EmptyDirectoryConstraint EmptyDirectoryConstraint is used to test that a directory is empty EmptyGuidConstraint EmptyGuidConstraint tests whether a Guid is empty. EmptyStringConstraint EmptyStringConstraint tests whether a string is empty. EndsWithConstraint EndsWithConstraint can test whether a string ends with an expected substring. EqualConstraint EqualConstraint is able to compare an actual value with the expected value provided in its constructor. Two objects are considered equal if both are null, or if both have the same value. NUnit has special semantics for some object types. EqualConstraintResult The EqualConstraintResult class is tailored for formatting and displaying the result of an EqualConstraint. EqualConstraint<T> EqualConstraint is able to compare an actual value with the expected value provided in its constructor. Two objects are considered equal if both are null, or if both have the same value. NUnit has special semantics for some object types. EqualDateTimeOffsetConstraint EqualConstraint is able to compare an actual value with the expected value provided in its constructor. Two objects are considered equal if both are null, or if both have the same value. NUnit has special semantics for some object types. EqualDateTimeOffsetConstraintWithSameOffset EqualConstraint is able to compare an actual value with the expected value provided in its constructor. Two objects are considered equal if both are null, or if both have the same value. NUnit has special semantics for some object types. EqualNumericConstraint<T> EqualNumericConstraint is able to compare an actual value with the expected value provided in its constructor. Two objects are considered equal if both are null, or if both have the same value. NUnit has special semantics for some object types. EqualNumericWithoutUsingConstraint<T> EqualNumericConstraint is able to compare an actual value with the expected value provided in its constructor. Two objects are considered equal if both are null, or if both have the same value. NUnit has special semantics for some object types. EqualStringConstraint EqualConstraint is able to compare an actual value with the expected value provided in its constructor. Two objects are considered equal if both are null, or if both have the same value. NUnit has special semantics for some object types. EqualStringWithoutUsingConstraint EqualConstraint is able to compare an actual value with the expected value provided in its constructor. Two objects are considered equal if both are null, or if both have the same value. NUnit has special semantics for some object types. EqualTimeBaseConstraint<T> EqualConstraint is able to compare an actual value with the expected value provided in its constructor. Two objects are considered equal if both are null, or if both have the same value. NUnit has special semantics for some object types. EqualTimeBasedConstraintWithNumericTolerance<T> EqualConstraint is able to compare an actual value with the expected value provided in its constructor. Two objects are considered equal if both are null, or if both have the same value. NUnit has special semantics for some object types. EqualTimeBasedConstraintWithTimeSpanTolerance<T> EqualConstraint is able to compare an actual value with the expected value provided in its constructor. Two objects are considered equal if both are null, or if both have the same value. NUnit has special semantics for some object types. EqualUsingConstraint<T> EqualUsingConstraint where the comparison is done by a user supplied comparer. EqualityAdapter EqualityAdapter class handles all equality comparisons that use an IEqualityComparer, IEqualityComparer<T> or a ComparisonAdapter. ExactCountConstraint ExactCountConstraint applies another constraint to each item in a collection, succeeding only if a specified number of items succeed. ExactCountOperator Represents a constraint that succeeds if the specified count of members of a collection match a base constraint. ExactTypeConstraint ExactTypeConstraint is used to test that an object is of the exact type provided in the constructor ExceptionTypeConstraint ExceptionTypeConstraint is a special version of ExactTypeConstraint used to provided detailed info about the exception thrown in an error message. FalseConstraint FalseConstraint tests that the actual value is false FileOrDirectoryExistsConstraint FileOrDirectoryExistsConstraint is used to determine if a file or directory exists GreaterThanConstraint Tests whether a value is greater than the value supplied to its constructor GreaterThanOrEqualConstraint Tests whether a value is greater than or equal to the value supplied to its constructor IndexerConstraint IndexerConstraint extracts a named property and uses its value as the actual value for a chained constraint. IndexerOperator Operator used to test for the presence of a Indexer on an object and optionally apply further tests to the value of that indexer. InstanceOfTypeConstraint InstanceOfTypeConstraint is used to test that an object is of the same type provided or derived from it. InsteadOperator Operator that replaces the left constraint with the right constraint Interval Keeps track of an interval time which can be represented in Minutes, Seconds or Milliseconds ItemsConstraintExpression An extension of ResolvableConstraintExpression that adds a no-op Items property for readability. LessThanConstraint Tests whether a value is less than the value supplied to its constructor LessThanOrEqualConstraint Tests whether a value is less than or equal to the value supplied to its constructor MessageWriter MessageWriter is the abstract base for classes that write constraint descriptions and messages in some form. The class has separate methods for writing various components of a message, allowing implementations to tailor the presentation as needed. MultipleOfConstraint MultipleOfConstraint tests that the actual value is a multiple of a specified integer. NUnitComparer NUnitComparer encapsulates NUnit's default behavior in comparing two objects. NUnitEqualityComparer NUnitEqualityComparer encapsulates NUnit's handling of equality tests between objects. NUnitEqualityComparer.FailurePoint FailurePoint class represents one point of failure in an equality test. NaNConstraint NaNConstraint tests that the actual value is a double or float NaN NoItemConstraint NoItemConstraint applies another constraint to each item in a collection, failing if any of them succeeds. NoneOperator Represents a constraint that succeeds if none of the members of a collection match a base constraint. NotConstraint NotConstraint negates the effect of some other constraint NotOperator Negates the test of the constraint it wraps. NullConstraint NullConstraint tests that the actual value is null OrConstraint OrConstraint succeeds if either member succeeds OrOperator Operator that requires at least one of its arguments to succeed PathConstraint PathConstraint serves as the abstract base of constraints that operate on paths and provides several helper methods. PredicateConstraint<T> Predicate constraint wraps a Predicate in a constraint, returning success if the predicate is true. PrefixConstraint Abstract base class used for prefixes PrefixOperator PrefixOperator takes a single constraint and modifies its action in some way. PropOperator Operator used to test for the presence of a named Property on an object and optionally apply further tests to the value of that property. PropertiesComparerConfiguration Class to configure how to compare properties PropertiesComparerConfigurationUntyped Class to configure how to compare properties. Non-generic untyped version. PropertiesComparerConfiguration<T> Generic version of PropertiesComparerConfiguration to allow specifiying properties using expression syntax instead of strings. PropertyConstraint PropertyConstraint extracts a named property and uses its value as the actual value for a chained constraint. PropertyExistsConstraint PropertyExistsConstraint tests that a named property exists on the object provided through Match. Originally, PropertyConstraint provided this feature in addition to making optional tests on the value of the property. The two constraints are now separate. RangeConstraint RangeConstraint tests whether two values are within a specified range. RegexConstraint RegexConstraint can test whether a string matches the pattern provided. ResolvableConstraintExpression ResolvableConstraintExpression is used to represent a compound constraint being constructed at a point where the last operator may either terminate the expression or may have additional qualifying constraints added to it. It is used, for example, for a Property element or for an Exception element, either of which may be optionally followed by constraints that apply to the property or exception. ReusableConstraint ReusableConstraint wraps a constraint expression after resolving it so that it can be reused consistently. SameAsConstraint SameAsConstraint tests whether an object is identical to the object passed to its constructor SamePathConstraint Summary description for SamePathConstraint. SamePathOrUnderConstraint SamePathOrUnderConstraint tests that one path is under another SelfResolvingOperator Abstract base class for operators that are able to reduce to a constraint whether or not another syntactic element follows. SomeItemsConstraint SomeItemsConstraint applies another constraint to each item in a collection, succeeding if any of them succeeds. SomeItemsConstraint<T> SomeItemsConstraint applies another constraint to each item in a collection, succeeding if any of them succeeds. SomeOperator Represents a constraint that succeeds if any of the members of a collection match a base constraint. StartsWithConstraint StartsWithConstraint can test whether a string starts with an expected substring. StringConstraint StringConstraint is the abstract base for constraints that operate on strings. It supports the IgnoreCase modifier for string operations. SubPathConstraint SubPathConstraint tests that the actual path is under the expected path SubstringConstraint SubstringConstraint can test whether a string contains the expected substring. ThrowsConstraint ThrowsConstraint is used to test the exception thrown by a delegate by applying a constraint to it. ThrowsExceptionConstraint ThrowsExceptionConstraint tests that an exception has been thrown, without any further tests. ThrowsNothingConstraint ThrowsNothingConstraint tests that a delegate does not throw an exception. ThrowsOperator Operator that tests that an exception is thrown and optionally applies further tests to the exception. Tolerance The Tolerance class generalizes the notion of a tolerance within which an equality test succeeds. Normally, it is used with numeric types, but it can be used with any type that supports taking a difference between two objects and comparing that difference to a value. TrueConstraint TrueConstraint tests that the actual value is true TypeConstraint TypeConstraint is the abstract base for constraints that take a Type as their expected value. UniqueItemsConstraint UniqueItemsConstraint tests whether all the items in a collection are unique. WhiteSpaceConstraint WhiteSpaceConstraint tests whether a string contains white space. WithOperator Represents a constraint that simply wraps the constraint provided as an argument, without any further functionality, but which modifies the order of evaluation because of its precedence. XmlSerializableConstraint XmlSerializableConstraint tests whether an object is serializable in XML format. Structs Tolerance.Range Tolerance.Range represents the range of values that match a specific tolerance, when applied to a specific value. Interfaces IConstraint Interface for all constraints IResolveConstraint The IResolveConstraint interface is implemented by all complete and resolvable constraints and expressions. Enums ConstraintStatus ConstraintStatus represents the status of a ConstraintResult returned by a Constraint being applied to an actual value. ToleranceMode Modes in which the tolerance value for a comparison can be interpreted. Delegates ActualValueDelegate<TActual> Delegate used to delay evaluation of the actual value to be used in evaluating a constraint ValueFormatter Custom value formatter function ValueFormatterFactory Custom value formatter factory function"
  },
  "api/NUnit.Framework.Contains.html": {
    "href": "api/NUnit.Framework.Contains.html",
    "title": "Class Contains | NUnit Docs",
    "summary": "Class Contains Helper class with properties and methods that supply a number of constraints used in Asserts. Inheritance object Contains Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework Assembly: nunit.framework.dll Syntax public abstract class Contains Constructors View Source Contains() Declaration protected Contains() Methods View Source Item(object?) Returns a new SomeItemsConstraint checking for the presence of a particular object in the collection. Declaration public static SomeItemsConstraint Item(object? expected) Parameters Type Name Description object expected Returns Type Description SomeItemsConstraint View Source Item<T>(T?) Returns a new SomeItemsConstraint checking for the presence of a particular object in the collection. Declaration public static SomeItemsConstraint<T> Item<T>(T? expected) Parameters Type Name Description T expected Returns Type Description SomeItemsConstraint<T> Type Parameters Name Description T View Source Key(object) Returns a new DictionaryContainsKeyConstraint checking for the presence of a particular key in the dictionary. Declaration public static DictionaryContainsKeyConstraint Key(object expected) Parameters Type Name Description object expected Returns Type Description DictionaryContainsKeyConstraint View Source Substring(string) Returns a constraint that succeeds if the actual value contains the substring supplied as an argument. Declaration public static SubstringConstraint Substring(string expected) Parameters Type Name Description string expected Returns Type Description SubstringConstraint View Source Value(object?) Returns a new DictionaryContainsValueConstraint checking for the presence of a particular value in the dictionary. Declaration public static DictionaryContainsValueConstraint Value(object? expected) Parameters Type Name Description object expected Returns Type Description DictionaryContainsValueConstraint"
  },
  "api/NUnit.Framework.CultureAttribute.html": {
    "href": "api/NUnit.Framework.CultureAttribute.html",
    "title": "Class CultureAttribute | NUnit Docs",
    "summary": "Class CultureAttribute Marks an assembly, test fixture or test method as applying to a specific Culture. Inheritance object Attribute NUnitAttribute IncludeExcludeAttribute CultureAttribute Implements IApplyToTest Inherited Members IncludeExcludeAttribute.Include IncludeExcludeAttribute.Exclude IncludeExcludeAttribute.Reason Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object, object) object.ReferenceEquals(object, object) Namespace: NUnit.Framework Assembly: nunit.framework.dll Syntax [AttributeUsage(AttributeTargets.Assembly|AttributeTargets.Class|AttributeTargets.Method, AllowMultiple = false, Inherited = false)] public class CultureAttribute : IncludeExcludeAttribute, IApplyToTest Constructors View Source CultureAttribute() Constructor with no cultures specified, for use with named property syntax. Declaration public CultureAttribute() View Source CultureAttribute(string?) Constructor taking one or more cultures Declaration public CultureAttribute(string? cultures) Parameters Type Name Description string cultures Comma-delimited list of cultures Methods View Source ApplyToTest(Test) Causes a test to be skipped if this CultureAttribute is not satisfied. Declaration public void ApplyToTest(Test test) Parameters Type Name Description Test test The test to modify View Source IsCultureSupported(string) Test to determine if the a particular culture or comma- delimited set of cultures is in use. Declaration public bool IsCultureSupported(string culture) Parameters Type Name Description string culture Name of the culture or comma-separated list of culture ids Returns Type Description bool True if the culture is in use on the system View Source IsCultureSupported(string[]) Test to determine if one of a collection of cultures is being used currently. Declaration public bool IsCultureSupported(string[] cultures) Parameters Type Name Description string[] cultures Returns Type Description bool Implements IApplyToTest"
  },
  "api/NUnit.Framework.DatapointAttribute.html": {
    "href": "api/NUnit.Framework.DatapointAttribute.html",
    "title": "Class DatapointAttribute | NUnit Docs",
    "summary": "Class DatapointAttribute Marks a field for use as a datapoint when executing a theory within the same fixture that requires an argument of the field's Type. Inheritance object Attribute NUnitAttribute DatapointAttribute Inherited Members Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object, object) object.ReferenceEquals(object, object) Namespace: NUnit.Framework Assembly: nunit.framework.dll Syntax [AttributeUsage(AttributeTargets.Field, AllowMultiple = false, Inherited = true)] public class DatapointAttribute : NUnitAttribute Constructors View Source DatapointAttribute() Declaration public DatapointAttribute()"
  },
  "api/NUnit.Framework.DatapointSourceAttribute.html": {
    "href": "api/NUnit.Framework.DatapointSourceAttribute.html",
    "title": "Class DatapointSourceAttribute | NUnit Docs",
    "summary": "Class DatapointSourceAttribute Marks a field, property or method as providing a set of datapoints for use in executing any theories within the same fixture that require an argument of the provided type. The data source may provide an array of the required Type or an IEnumerable<T>. Synonymous with DatapointsAttribute. Inheritance object Attribute NUnitAttribute DatapointSourceAttribute DatapointsAttribute Inherited Members Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object, object) object.ReferenceEquals(object, object) Namespace: NUnit.Framework Assembly: nunit.framework.dll Syntax [AttributeUsage(AttributeTargets.Method|AttributeTargets.Property|AttributeTargets.Field, AllowMultiple = false, Inherited = true)] public class DatapointSourceAttribute : NUnitAttribute Constructors View Source DatapointSourceAttribute() Declaration public DatapointSourceAttribute()"
  },
  "api/NUnit.Framework.DatapointsAttribute.html": {
    "href": "api/NUnit.Framework.DatapointsAttribute.html",
    "title": "Class DatapointsAttribute | NUnit Docs",
    "summary": "Class DatapointsAttribute Marks a field, property or method as providing a set of datapoints for use in executing any theories within the same fixture that require an argument of the provided Type. The data source may provide an array of the required Type or an IEnumerable<T>. Synonymous with DatapointSourceAttribute. Inheritance object Attribute NUnitAttribute DatapointSourceAttribute DatapointsAttribute Inherited Members Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object, object) object.ReferenceEquals(object, object) Namespace: NUnit.Framework Assembly: nunit.framework.dll Syntax [AttributeUsage(AttributeTargets.Method|AttributeTargets.Property|AttributeTargets.Field, AllowMultiple = false, Inherited = true)] public class DatapointsAttribute : DatapointSourceAttribute Constructors View Source DatapointsAttribute() Declaration public DatapointsAttribute()"
  },
  "api/NUnit.Framework.DefaultFloatingPointToleranceAttribute.html": {
    "href": "api/NUnit.Framework.DefaultFloatingPointToleranceAttribute.html",
    "title": "Class DefaultFloatingPointToleranceAttribute | NUnit Docs",
    "summary": "Class DefaultFloatingPointToleranceAttribute Sets the tolerance used by default when checking the equality of floating point values within the test assembly, fixture or method. Inheritance object Attribute NUnitAttribute DefaultFloatingPointToleranceAttribute Implements IApplyToContext Inherited Members Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object, object) object.ReferenceEquals(object, object) Namespace: NUnit.Framework Assembly: nunit.framework.dll Syntax [AttributeUsage(AttributeTargets.Assembly|AttributeTargets.Class|AttributeTargets.Method, AllowMultiple = false, Inherited = true)] public class DefaultFloatingPointToleranceAttribute : NUnitAttribute, IApplyToContext Constructors View Source DefaultFloatingPointToleranceAttribute(double) Construct specifying an amount Declaration public DefaultFloatingPointToleranceAttribute(double amount) Parameters Type Name Description double amount Methods View Source ApplyToContext(TestExecutionContext) Apply changes to the TestExecutionContext Declaration public void ApplyToContext(TestExecutionContext context) Parameters Type Name Description TestExecutionContext context The TestExecutionContext Implements IApplyToContext"
  },
  "api/NUnit.Framework.DescriptionAttribute.html": {
    "href": "api/NUnit.Framework.DescriptionAttribute.html",
    "title": "Class DescriptionAttribute | NUnit Docs",
    "summary": "Class DescriptionAttribute Provides the descriptive text relating to the assembly, test fixture or test method. Inheritance object Attribute NUnitAttribute PropertyAttribute DescriptionAttribute Implements IApplyToTest Inherited Members PropertyAttribute.ApplyToTest(Test) PropertyAttribute.Properties Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId object.GetType() object.ToString() object.Equals(object, object) object.ReferenceEquals(object, object) Namespace: NUnit.Framework Assembly: nunit.framework.dll Syntax [AttributeUsage(AttributeTargets.Assembly|AttributeTargets.Class|AttributeTargets.Method, AllowMultiple = false, Inherited = false)] public sealed class DescriptionAttribute : PropertyAttribute, IApplyToTest Constructors View Source DescriptionAttribute(string) Construct a description Attribute Declaration public DescriptionAttribute(string description) Parameters Type Name Description string description The text of the description Implements IApplyToTest"
  },
  "api/NUnit.Framework.Diagnostics.ProgressTraceListener.html": {
    "href": "api/NUnit.Framework.Diagnostics.ProgressTraceListener.html",
    "title": "Class ProgressTraceListener | NUnit Docs",
    "summary": "Class ProgressTraceListener The ProgressTraceListener class allows directing tracing or debugging output to Progress. To activate, place the following snippet into the one-time set-up method of either a test's fixture or the set-up fixture of a project: System.Trace.Listeners.Add(new ProgressTraceListener()); Make sure to only add a listener once, e.g.: if (!System.Trace.Listeners.OfType<ProgressTraceListener>().Any()) System.Trace.Listeners.Add(new ProgressTraceListener()); Alternatively, add it in the one-time set-up and again remove it in the one-time tear-down, e.g.: _progressTraceListener = new ProgressTraceListener(); System.Trace.Listeners.Add(_progressTraceListener); System.Trace.Listeners.Remove(_progressTraceListener); _progressTraceListener.Close(); Inheritance object MarshalByRefObject TraceListener TextWriterTraceListener ProgressTraceListener Implements IDisposable Inherited Members TextWriterTraceListener.Close() TextWriterTraceListener.Dispose(bool) TextWriterTraceListener.Flush() TextWriterTraceListener.Write(string) TextWriterTraceListener.WriteLine(string) TextWriterTraceListener.Writer TraceListener.Dispose() TraceListener.GetSupportedAttributes() TraceListener.TraceTransfer(TraceEventCache, string, int, string, Guid) TraceListener.Fail(string) TraceListener.Fail(string, string) TraceListener.Write(object) TraceListener.Write(string, string) TraceListener.Write(object, string) TraceListener.WriteIndent() TraceListener.WriteLine(object) TraceListener.WriteLine(string, string) TraceListener.WriteLine(object, string) TraceListener.TraceData(TraceEventCache, string, TraceEventType, int, object) TraceListener.TraceData(TraceEventCache, string, TraceEventType, int, params object[]) TraceListener.TraceEvent(TraceEventCache, string, TraceEventType, int) TraceListener.TraceEvent(TraceEventCache, string, TraceEventType, int, string) TraceListener.TraceEvent(TraceEventCache, string, TraceEventType, int, string, params object[]) TraceListener.Attributes TraceListener.Name TraceListener.IsThreadSafe TraceListener.IndentLevel TraceListener.IndentSize TraceListener.Filter TraceListener.NeedIndent TraceListener.TraceOutputOptions MarshalByRefObject.GetLifetimeService() MarshalByRefObject.InitializeLifetimeService() MarshalByRefObject.MemberwiseClone(bool) object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework.Diagnostics Assembly: nunit.framework.dll Syntax public class ProgressTraceListener : TextWriterTraceListener, IDisposable Remarks Although named \"Trace\", TextWriterTraceListener \"directs tracing or debugging output\". This listener is provided by NUnit (i.e. the origin of Progress) same as the ConsoleTraceListener is provided by .NET (the origin of Console). Constructors View Source ProgressTraceListener() Construct a ProgressTraceListener with trace output written to Progress Declaration public ProgressTraceListener() Implements IDisposable"
  },
  "api/NUnit.Framework.Diagnostics.html": {
    "href": "api/NUnit.Framework.Diagnostics.html",
    "title": "Namespace NUnit.Framework.Diagnostics | NUnit Docs",
    "summary": "Namespace NUnit.Framework.Diagnostics Classes ProgressTraceListener The ProgressTraceListener class allows directing tracing or debugging output to Progress. To activate, place the following snippet into the one-time set-up method of either a test's fixture or the set-up fixture of a project: System.Trace.Listeners.Add(new ProgressTraceListener()); Make sure to only add a listener once, e.g.: if (!System.Trace.Listeners.OfType<ProgressTraceListener>().Any()) System.Trace.Listeners.Add(new ProgressTraceListener()); Alternatively, add it in the one-time set-up and again remove it in the one-time tear-down, e.g.: _progressTraceListener = new ProgressTraceListener(); System.Trace.Listeners.Add(_progressTraceListener); System.Trace.Listeners.Remove(_progressTraceListener); _progressTraceListener.Close();"
  },
  "api/NUnit.Framework.Does.html": {
    "href": "api/NUnit.Framework.Does.html",
    "title": "Class Does | NUnit Docs",
    "summary": "Class Does Helper class with properties and methods that supply a number of constraints used in Asserts. Inheritance object Does Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework Assembly: nunit.framework.dll Syntax public abstract class Does Constructors View Source Does() Declaration protected Does() Properties View Source Exist Returns a constraint that succeeds if the value is a file or directory and it exists. Declaration public static FileOrDirectoryExistsConstraint Exist { get; } Property Value Type Description FileOrDirectoryExistsConstraint View Source Not Returns a ConstraintExpression that negates any following constraint. Declaration public static ConstraintExpression Not { get; } Property Value Type Description ConstraintExpression Methods View Source Contain(object?) Returns a new SomeItemsConstraint checking for the presence of a particular object in the collection. Declaration public static SomeItemsConstraint Contain(object? expected) Parameters Type Name Description object expected Returns Type Description SomeItemsConstraint View Source Contain(string?) Returns a new ContainsConstraint. This constraint will, in turn, make use of the appropriate second-level constraint, depending on the type of the actual argument. This overload is only used if the item sought is a string, since any other type implies that we are looking for a collection member. Declaration public static ContainsConstraint Contain(string? expected) Parameters Type Name Description string expected Returns Type Description ContainsConstraint View Source ContainKey(object) Returns a new DictionaryContainsKeyConstraint checking for the presence of a particular key in the Dictionary key collection. Declaration public static DictionaryContainsKeyConstraint ContainKey(object expected) Parameters Type Name Description object expected The key to be matched in the Dictionary key collection Returns Type Description DictionaryContainsKeyConstraint View Source ContainValue(object?) Returns a new DictionaryContainsValueConstraint checking for the presence of a particular value in the Dictionary value collection. Declaration public static DictionaryContainsValueConstraint ContainValue(object? expected) Parameters Type Name Description object expected The value to be matched in the Dictionary value collection Returns Type Description DictionaryContainsValueConstraint View Source Contain<T>(T?) Returns a new SomeItemsConstraint checking for the presence of a particular object in the collection. Declaration public static SomeItemsConstraint<T> Contain<T>(T? expected) Parameters Type Name Description T expected Returns Type Description SomeItemsConstraint<T> Type Parameters Name Description T View Source EndWith(string) Returns a constraint that succeeds if the actual value ends with the substring supplied as an argument. Declaration public static EndsWithConstraint EndWith(string expected) Parameters Type Name Description string expected Returns Type Description EndsWithConstraint View Source Match(string) Returns a constraint that succeeds if the actual value matches the regular expression supplied as an argument. Declaration public static RegexConstraint Match(string pattern) Parameters Type Name Description string pattern Returns Type Description RegexConstraint View Source Match(Regex) Returns a constraint that succeeds if the actual value matches the regular expression supplied as an argument. Declaration public static RegexConstraint Match(Regex regex) Parameters Type Name Description Regex regex Returns Type Description RegexConstraint View Source StartWith(string) Returns a constraint that succeeds if the actual value starts with the substring supplied as an argument. Declaration public static StartsWithConstraint StartWith(string expected) Parameters Type Name Description string expected Returns Type Description StartsWithConstraint"
  },
  "api/NUnit.Framework.EqualNumericWithoutUsingConstraintExtensions.html": {
    "href": "api/NUnit.Framework.EqualNumericWithoutUsingConstraintExtensions.html",
    "title": "Class EqualNumericWithoutUsingConstraintExtensions | NUnit Docs",
    "summary": "Class EqualNumericWithoutUsingConstraintExtensions Extension methods for EqualNumericWithoutUsingConstraint<T>. Inheritance object EqualNumericWithoutUsingConstraintExtensions Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework Assembly: nunit.framework.dll Syntax public static class EqualNumericWithoutUsingConstraintExtensions Methods View Source Within(EqualNumericWithoutUsingConstraint<int>, double) Flag the constraint to use a tolerance when determining equality. Declaration public static EqualNumericWithoutUsingConstraint<double> Within(this EqualNumericWithoutUsingConstraint<int> constraint, double amount) Parameters Type Name Description EqualNumericWithoutUsingConstraint<int> constraint The original constraint. double amount Tolerance value to be used Returns Type Description EqualNumericWithoutUsingConstraint<double> Original constraint promoted to double. View Source Within(EqualNumericWithoutUsingConstraint<float>, double) Flag the constraint to use a tolerance when determining equality. Declaration public static EqualNumericWithoutUsingConstraint<double> Within(this EqualNumericWithoutUsingConstraint<float> constraint, double amount) Parameters Type Name Description EqualNumericWithoutUsingConstraint<float> constraint The original constraint. double amount Tolerance value to be used Returns Type Description EqualNumericWithoutUsingConstraint<double> Original constraint promoted to double."
  },
  "api/NUnit.Framework.ExplicitAttribute.html": {
    "href": "api/NUnit.Framework.ExplicitAttribute.html",
    "title": "Class ExplicitAttribute | NUnit Docs",
    "summary": "Class ExplicitAttribute Marks an assembly, test fixture or test method such that it will only run if explicitly executed from the GUI, command line or included within a test filter. The test will not be run simply because an enclosing suite is run. Inheritance object Attribute NUnitAttribute ExplicitAttribute Implements IApplyToTest Inherited Members Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object, object) object.ReferenceEquals(object, object) Namespace: NUnit.Framework Assembly: nunit.framework.dll Syntax [AttributeUsage(AttributeTargets.Assembly|AttributeTargets.Class|AttributeTargets.Method, AllowMultiple = false, Inherited = false)] public class ExplicitAttribute : NUnitAttribute, IApplyToTest Constructors View Source ExplicitAttribute() Default constructor Declaration public ExplicitAttribute() View Source ExplicitAttribute(string?) Constructor with a reason Declaration public ExplicitAttribute(string? reason) Parameters Type Name Description string reason The reason test is marked explicit Methods View Source ApplyToTest(Test) Modifies a test by marking it as explicit. Declaration public void ApplyToTest(Test test) Parameters Type Name Description Test test The test to modify Implements IApplyToTest"
  },
  "api/NUnit.Framework.FixtureLifeCycleAttribute.html": {
    "href": "api/NUnit.Framework.FixtureLifeCycleAttribute.html",
    "title": "Class FixtureLifeCycleAttribute | NUnit Docs",
    "summary": "Class FixtureLifeCycleAttribute Specify the life cycle of a Fixture Inheritance object Attribute NUnitAttribute FixtureLifeCycleAttribute Implements IApplyToTest Inherited Members Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId object.GetType() object.ToString() object.Equals(object, object) object.ReferenceEquals(object, object) Namespace: NUnit.Framework Assembly: nunit.framework.dll Syntax [AttributeUsage(AttributeTargets.Assembly|AttributeTargets.Class, AllowMultiple = false, Inherited = true)] public sealed class FixtureLifeCycleAttribute : NUnitAttribute, IApplyToTest Constructors View Source FixtureLifeCycleAttribute(LifeCycle) Construct a FixtureLifeCycleAttribute with a specified LifeCycle. Declaration public FixtureLifeCycleAttribute(LifeCycle lifeCycle) Parameters Type Name Description LifeCycle lifeCycle Properties View Source LifeCycle Defines the life cycle for this test fixture or assembly. Declaration public LifeCycle LifeCycle { get; } Property Value Type Description LifeCycle Methods View Source ApplyToTest(Test) Overridden to set a TestFixture's LifeCycle. Declaration public void ApplyToTest(Test test) Parameters Type Name Description Test test Implements IApplyToTest"
  },
  "api/NUnit.Framework.Has.html": {
    "href": "api/NUnit.Framework.Has.html",
    "title": "Class Has | NUnit Docs",
    "summary": "Class Has Helper class with properties and methods that supply a number of constraints used in Asserts. Inheritance object Has Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework Assembly: nunit.framework.dll Syntax public abstract class Has Constructors View Source Has() Declaration protected Has() Properties View Source All Returns a ConstraintExpression, which will apply the following constraint to all members of a collection, succeeding if all of them succeed. Declaration public static ConstraintExpression All { get; } Property Value Type Description ConstraintExpression View Source Count Returns a new ConstraintExpression, which will apply the following constraint to the Count property of the object being tested. Declaration public static ResolvableConstraintExpression Count { get; } Property Value Type Description ResolvableConstraintExpression View Source InnerException Returns a new ConstraintExpression, which will apply the following constraint to the InnerException property of the object being tested. Declaration public static ResolvableConstraintExpression InnerException { get; } Property Value Type Description ResolvableConstraintExpression View Source Length Returns a new ConstraintExpression, which will apply the following constraint to the Length property of the object being tested. Declaration public static ResolvableConstraintExpression Length { get; } Property Value Type Description ResolvableConstraintExpression View Source Message Returns a new ConstraintExpression, which will apply the following constraint to the Message property of the object being tested. Declaration public static ResolvableConstraintExpression Message { get; } Property Value Type Description ResolvableConstraintExpression View Source No Returns a ConstraintExpression that negates any following constraint. Declaration public static ConstraintExpression No { get; } Property Value Type Description ConstraintExpression View Source None Returns a ConstraintExpression, which will apply the following constraint to all members of a collection, succeeding if all of them fail. Declaration public static ConstraintExpression None { get; } Property Value Type Description ConstraintExpression View Source One Returns a ItemsConstraintExpression which will apply the following constraint to only one member of the collection, and fail if none or more than one match occurs. Declaration public static ItemsConstraintExpression One { get; } Property Value Type Description ItemsConstraintExpression View Source Some Returns a ConstraintExpression, which will apply the following constraint to all members of a collection, succeeding if at least one of them succeeds. Declaration public static ConstraintExpression Some { get; } Property Value Type Description ConstraintExpression Methods View Source Attribute(Type) Returns a new AttributeConstraint checking for the presence of a particular attribute on an object. Declaration public static ResolvableConstraintExpression Attribute(Type expectedType) Parameters Type Name Description Type expectedType Returns Type Description ResolvableConstraintExpression View Source Attribute<T>() Returns a new AttributeConstraint checking for the presence of a particular attribute on an object. Declaration public static ResolvableConstraintExpression Attribute<T>() Returns Type Description ResolvableConstraintExpression Type Parameters Name Description T View Source Exactly(int) Returns a ConstraintExpression, which will apply the following constraint to all members of a collection, succeeding only if a specified number of them succeed. Declaration public static ItemsConstraintExpression Exactly(int expectedCount) Parameters Type Name Description int expectedCount Returns Type Description ItemsConstraintExpression View Source ItemAt(params object[]) Returns a new IndexerConstraintExpression, which will apply any following constraint to that indexer value. Declaration public static ConstraintExpression ItemAt(params object[] indexArgs) Parameters Type Name Description object[] indexArgs Index accessor values. Returns Type Description ConstraintExpression View Source Member(object?) Returns a new SomeItemsConstraint checking for the presence of a particular object in the collection. Declaration public static SomeItemsConstraint Member(object? expected) Parameters Type Name Description object expected Returns Type Description SomeItemsConstraint View Source Member<T>(T?) Returns a new SomeItemsConstraint checking for the presence of a particular object in the collection. Declaration public static SomeItemsConstraint<T> Member<T>(T? expected) Parameters Type Name Description T expected Returns Type Description SomeItemsConstraint<T> Type Parameters Name Description T View Source Property(string) Returns a new PropertyConstraintExpression, which will either test for the existence of the named property on the object being tested or apply any following constraint to that property. Declaration public static ResolvableConstraintExpression Property(string name) Parameters Type Name Description string name Returns Type Description ResolvableConstraintExpression"
  },
  "api/NUnit.Framework.IEqualWithUsingConstraint-1.html": {
    "href": "api/NUnit.Framework.IEqualWithUsingConstraint-1.html",
    "title": "Interface IEqualWithUsingConstraint<T> | NUnit Docs",
    "summary": "Interface IEqualWithUsingConstraint<T> Interface for equal constraints which support user comparisons. Namespace: NUnit.Framework Assembly: nunit.framework.dll Syntax public interface IEqualWithUsingConstraint<T> Type Parameters Name Description T Properties View Source Builder The ConstraintBuilder holding this constraint Declaration ConstraintBuilder? Builder { get; set; } Property Value Type Description ConstraintBuilder View Source Expected The expected value. Declaration T Expected { get; } Property Value Type Description T Extension Methods IEqualWithUsingConstraintExtensions.Using<TExpected>(IEqualWithUsingConstraint<TExpected>, IComparer<TExpected>) IEqualWithUsingConstraintExtensions.Using<TExpected>(IEqualWithUsingConstraint<TExpected>, IEqualityComparer<TExpected>) IEqualWithUsingConstraintExtensions.Using<TExpected>(IEqualWithUsingConstraint<TExpected>, IComparer) IEqualWithUsingConstraintExtensions.Using<TExpected>(IEqualWithUsingConstraint<TExpected>, IEqualityComparer) IEqualWithUsingConstraintExtensions.Using<TExpected>(IEqualWithUsingConstraint<TExpected>, Comparison<TExpected>) IEqualWithUsingConstraintExtensions.Using<TExpected>(IEqualWithUsingConstraint<TExpected>, Func<TExpected, TExpected, bool>) IEqualWithUsingConstraintExtensions.Using<TActual, TExpected>(IEqualWithUsingConstraint<TExpected>, IComparer<TActual>) IEqualWithUsingConstraintExtensions.Using<TActual, TExpected>(IEqualWithUsingConstraint<TExpected>, Func<TActual, TExpected, bool>)"
  },
  "api/NUnit.Framework.IEqualWithUsingConstraintExtensions.html": {
    "href": "api/NUnit.Framework.IEqualWithUsingConstraintExtensions.html",
    "title": "Class IEqualWithUsingConstraintExtensions | NUnit Docs",
    "summary": "Class IEqualWithUsingConstraintExtensions Allows specifying a custom comparer for the EqualConstraint. Inheritance object IEqualWithUsingConstraintExtensions Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework Assembly: nunit.framework.dll Syntax public static class IEqualWithUsingConstraintExtensions Methods View Source Using<TExpected>(IEqualWithUsingConstraint<TExpected>, IComparer<TExpected>) Flag the constraint to use the supplied IComparer object. Declaration public static EqualUsingConstraint<TExpected> Using<TExpected>(this IEqualWithUsingConstraint<TExpected> constraint, IComparer<TExpected> comparer) Parameters Type Name Description IEqualWithUsingConstraint<TExpected> constraint The constraint to add a user comparer to. IComparer<TExpected> comparer The comparer to use. Returns Type Description EqualUsingConstraint<TExpected> Equal constraint comparing Expected with an actual value using the user supplied comparer. Type Parameters Name Description TExpected The type of the expected value. View Source Using<TExpected>(IEqualWithUsingConstraint<TExpected>, IEqualityComparer<TExpected>) Flag the constraint to use the supplied IEqualityComparer object. Declaration public static EqualUsingConstraint<TExpected> Using<TExpected>(this IEqualWithUsingConstraint<TExpected> constraint, IEqualityComparer<TExpected> comparer) Parameters Type Name Description IEqualWithUsingConstraint<TExpected> constraint The constraint to add a user comparer to. IEqualityComparer<TExpected> comparer The comparer to use. Returns Type Description EqualUsingConstraint<TExpected> Equal constraint comparing Expected with an actual value using the user supplied comparer. Type Parameters Name Description TExpected The type of the expected value. View Source Using<TExpected>(IEqualWithUsingConstraint<TExpected>, IComparer) Flag the constraint to use the supplied IComparer object. Declaration public static EqualUsingConstraint<TExpected> Using<TExpected>(this IEqualWithUsingConstraint<TExpected> constraint, IComparer comparer) Parameters Type Name Description IEqualWithUsingConstraint<TExpected> constraint The constraint to add a user comparer to. IComparer comparer The comparer to use. Returns Type Description EqualUsingConstraint<TExpected> Equal constraint comparing Expected with an actual value using the user supplied comparer. Type Parameters Name Description TExpected The type of the expected value. View Source Using<TExpected>(IEqualWithUsingConstraint<TExpected>, IEqualityComparer) Flag the constraint to use the supplied IEqualityComparer object. Declaration public static EqualUsingConstraint<TExpected> Using<TExpected>(this IEqualWithUsingConstraint<TExpected> constraint, IEqualityComparer comparer) Parameters Type Name Description IEqualWithUsingConstraint<TExpected> constraint The constraint to add a user comparer to. IEqualityComparer comparer The comparer object to use. Returns Type Description EqualUsingConstraint<TExpected> Equal constraint comparing Expected with an actual value using the user supplied comparer. Type Parameters Name Description TExpected The type of the expected value. View Source Using<TExpected>(IEqualWithUsingConstraint<TExpected>, Comparison<TExpected>) Flag the constraint to use the supplied Comparison object. Declaration public static EqualUsingConstraint<TExpected> Using<TExpected>(this IEqualWithUsingConstraint<TExpected> constraint, Comparison<TExpected> comparer) Parameters Type Name Description IEqualWithUsingConstraint<TExpected> constraint The constraint to add a user comparer to. Comparison<TExpected> comparer The comparer to use. Returns Type Description EqualUsingConstraint<TExpected> Equal constraint comparing Expected with an actual value using the user supplied comparer. Type Parameters Name Description TExpected The type of the expected value. View Source Using<TExpected>(IEqualWithUsingConstraint<TExpected>, Func<TExpected, TExpected, bool>) Flag the constraint to use the supplied boolean-returning delegate. Declaration public static EqualUsingConstraint<TExpected> Using<TExpected>(this IEqualWithUsingConstraint<TExpected> constraint, Func<TExpected, TExpected, bool> comparer) Parameters Type Name Description IEqualWithUsingConstraint<TExpected> constraint The constraint to add a user comparer to. Func<TExpected, TExpected, bool> comparer The boolean-returning delegate to use. Returns Type Description EqualUsingConstraint<TExpected> Equal constraint comparing Expected with an actual value using the user supplied comparer. Type Parameters Name Description TExpected The type of the expected value. View Source Using<TActual, TExpected>(IEqualWithUsingConstraint<TExpected>, IComparer<TActual>) Flag the constraint to use the supplied IComparer object. Declaration public static EqualUsingConstraint<TExpected> Using<TActual, TExpected>(this IEqualWithUsingConstraint<TExpected> constraint, IComparer<TActual> comparer) Parameters Type Name Description IEqualWithUsingConstraint<TExpected> constraint The constraint to add a user comparer to. IComparer<TActual> comparer The comparer to use. Returns Type Description EqualUsingConstraint<TExpected> Equal constraint comparing Expected with an actual value using the user supplied comparer. Type Parameters Name Description TActual The type of the actual value. TExpected The type of the expected value. View Source Using<TActual, TExpected>(IEqualWithUsingConstraint<TExpected>, Func<TActual, TExpected, bool>) Flag the constraint to use the supplied predicate function Declaration public static EqualUsingConstraint<TExpected> Using<TActual, TExpected>(this IEqualWithUsingConstraint<TExpected> constraint, Func<TActual, TExpected, bool> comparer) Parameters Type Name Description IEqualWithUsingConstraint<TExpected> constraint The constraint to add a user comparer to. Func<TActual, TExpected, bool> comparer The comparison function to use. Returns Type Description EqualUsingConstraint<TExpected> Equal constraint comparing Expected with an actual value using the user supplied comparer. Type Parameters Name Description TActual The type of the actual value. TExpected The type of the expected value."
  },
  "api/NUnit.Framework.ITestAction.html": {
    "href": "api/NUnit.Framework.ITestAction.html",
    "title": "Interface ITestAction | NUnit Docs",
    "summary": "Interface ITestAction When implemented by an attribute, this interface implemented to provide actions to execute before and after tests. Namespace: NUnit.Framework Assembly: nunit.framework.dll Syntax public interface ITestAction Properties View Source Targets Provides the target for the action attribute Declaration ActionTargets Targets { get; } Property Value Type Description ActionTargets The target for the action attribute Methods View Source AfterTest(ITest) Executed after each test is run Declaration void AfterTest(ITest test) Parameters Type Name Description ITest test The test that has just been run. View Source BeforeTest(ITest) Executed before each test is run Declaration void BeforeTest(ITest test) Parameters Type Name Description ITest test The test that is going to be run."
  },
  "api/NUnit.Framework.IgnoreAttribute.html": {
    "href": "api/NUnit.Framework.IgnoreAttribute.html",
    "title": "Class IgnoreAttribute | NUnit Docs",
    "summary": "Class IgnoreAttribute Marks an assembly, test fixture or test method as being ignored. Ignored tests result in a warning message when the tests are run. Inheritance object Attribute NUnitAttribute IgnoreAttribute Implements IApplyToTest Inherited Members Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object, object) object.ReferenceEquals(object, object) Namespace: NUnit.Framework Assembly: nunit.framework.dll Syntax [AttributeUsage(AttributeTargets.Assembly|AttributeTargets.Class|AttributeTargets.Method, AllowMultiple = false, Inherited = false)] public class IgnoreAttribute : NUnitAttribute, IApplyToTest Constructors View Source IgnoreAttribute(string) Constructs the attribute giving a reason for ignoring the test. Declaration public IgnoreAttribute(string reason) Parameters Type Name Description string reason The reason for ignoring the test. Exceptions Type Condition ArgumentNullException If reason is null. Properties View Source Reason Gets the reason for ignoring the test. Declaration public string Reason { get; } Property Value Type Description string View Source Until The date in the future to stop ignoring the test as a string in UTC time. For example for a date and time, \"2014-12-25 08:10:00Z\" or for just a date, \"2014-12-25\". If just a date is given, the Ignore will expire at midnight UTC. Declaration public string? Until { get; set; } Property Value Type Description string Remarks Once the ignore until date has passed, the test will be marked as runnable. Tests with an ignore until date will have an IgnoreUntilDate property set which will appear in the test results. Exceptions Type Condition FormatException The string does not contain a valid string representation of a date and time. Methods View Source ApplyToTest(Test) Modifies a test by marking it as Ignored. Declaration public void ApplyToTest(Test test) Parameters Type Name Description Test test The test to modify Implements IApplyToTest"
  },
  "api/NUnit.Framework.IgnoreException.html": {
    "href": "api/NUnit.Framework.IgnoreException.html",
    "title": "Class IgnoreException | NUnit Docs",
    "summary": "Class IgnoreException Thrown when an assertion failed. Inheritance object Exception ResultStateException IgnoreException Implements ISerializable Inherited Members Exception.GetBaseException() Exception.ToString() Exception.GetType() Exception.TargetSite Exception.Message Exception.Data Exception.InnerException Exception.HelpLink Exception.Source Exception.HResult Exception.StackTrace Exception.SerializeObjectState object.MemberwiseClone() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework Assembly: nunit.framework.dll Syntax public class IgnoreException : ResultStateException, ISerializable Constructors View Source IgnoreException(string) Declaration public IgnoreException(string message) Parameters Type Name Description string message View Source IgnoreException(string, Exception?) Declaration public IgnoreException(string message, Exception? inner) Parameters Type Name Description string message The error message that explains the reason for the exception Exception inner The exception that caused the current exception Properties View Source ResultState Gets the ResultState provided by this exception Declaration public override ResultState ResultState { get; } Property Value Type Description ResultState Overrides ResultStateException.ResultState Implements ISerializable"
  },
  "api/NUnit.Framework.IncludeExcludeAttribute.html": {
    "href": "api/NUnit.Framework.IncludeExcludeAttribute.html",
    "title": "Class IncludeExcludeAttribute | NUnit Docs",
    "summary": "Class IncludeExcludeAttribute Abstract base for attributes that are used to include tests in the test run based on environmental settings. Inheritance object Attribute NUnitAttribute IncludeExcludeAttribute CultureAttribute NetPlatformAttribute PlatformAttribute Inherited Members Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object, object) object.ReferenceEquals(object, object) Namespace: NUnit.Framework Assembly: nunit.framework.dll Syntax public abstract class IncludeExcludeAttribute : NUnitAttribute Constructors View Source IncludeExcludeAttribute() Constructor with no included items specified, for use with named property syntax. Declaration public IncludeExcludeAttribute() View Source IncludeExcludeAttribute(string?) Constructor taking one or more included items Declaration public IncludeExcludeAttribute(string? include) Parameters Type Name Description string include Comma-delimited list of included items Properties View Source Exclude Name of the item to be excluded. Multiple items may be given, separated by a comma. Declaration public string? Exclude { get; set; } Property Value Type Description string View Source Include Name of the item that is needed in order for a test to run. Multiple items may be given, separated by a comma. Declaration public string? Include { get; set; } Property Value Type Description string View Source Reason The reason for including or excluding the test Declaration public string? Reason { get; set; } Property Value Type Description string"
  },
  "api/NUnit.Framework.InconclusiveException.html": {
    "href": "api/NUnit.Framework.InconclusiveException.html",
    "title": "Class InconclusiveException | NUnit Docs",
    "summary": "Class InconclusiveException Thrown when a test executes inconclusively. Inheritance object Exception ResultStateException InconclusiveException Implements ISerializable Inherited Members Exception.GetBaseException() Exception.ToString() Exception.GetType() Exception.TargetSite Exception.Message Exception.Data Exception.InnerException Exception.HelpLink Exception.Source Exception.HResult Exception.StackTrace Exception.SerializeObjectState object.MemberwiseClone() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework Assembly: nunit.framework.dll Syntax public class InconclusiveException : ResultStateException, ISerializable Constructors View Source InconclusiveException(string) Declaration public InconclusiveException(string message) Parameters Type Name Description string message The error message that explains the reason for the exception View Source InconclusiveException(string, Exception?) Declaration public InconclusiveException(string message, Exception? inner) Parameters Type Name Description string message The error message that explains the reason for the exception Exception inner The exception that caused the current exception Properties View Source ResultState Gets the ResultState provided by this exception Declaration public override ResultState ResultState { get; } Property Value Type Description ResultState Overrides ResultStateException.ResultState Implements ISerializable"
  },
  "api/NUnit.Framework.Interfaces.AssertionResult.html": {
    "href": "api/NUnit.Framework.Interfaces.AssertionResult.html",
    "title": "Class AssertionResult | NUnit Docs",
    "summary": "Class AssertionResult The AssertionResult class represents the result of a single assertion. Inheritance object AssertionResult Implements IEquatable<AssertionResult> Inherited Members object.GetType() object.MemberwiseClone() object.Equals(object, object) object.ReferenceEquals(object, object) Namespace: NUnit.Framework.Interfaces Assembly: nunit.framework.dll Syntax public class AssertionResult : IEquatable<AssertionResult> Constructors View Source AssertionResult(AssertionStatus, string, string?) Construct an AssertionResult Declaration public AssertionResult(AssertionStatus status, string message, string? stackTrace) Parameters Type Name Description AssertionStatus status string message string stackTrace View Source AssertionResult(FailureSite, AssertionStatus, string, string?) Construct an AssertionResult Declaration public AssertionResult(FailureSite site, AssertionStatus status, string message, string? stackTrace) Parameters Type Name Description FailureSite site AssertionStatus status string message string stackTrace Properties View Source Message The message produced by the assertion, or null Declaration public string Message { get; } Property Value Type Description string View Source Site Where did the failure occur. Declaration public FailureSite Site { get; } Property Value Type Description FailureSite View Source StackTrace The stack trace associated with the assertion, or null Declaration public string? StackTrace { get; } Property Value Type Description string View Source Status The pass/fail status of the assertion Declaration public AssertionStatus Status { get; } Property Value Type Description AssertionStatus Methods View Source Equals(AssertionResult?) Indicates whether the current object is equal to another object of the same type. Declaration public bool Equals(AssertionResult? other) Parameters Type Name Description AssertionResult other An object to compare with this object. Returns Type Description bool View Source Equals(object?) Determines whether the specified object is equal to the current object. Declaration public override bool Equals(object? obj) Parameters Type Name Description object obj The object to compare with the current object. Returns Type Description bool Overrides object.Equals(object) View Source GetHashCode() Serves as the default hash function. Declaration public override int GetHashCode() Returns Type Description int Overrides object.GetHashCode() View Source ToString() ToString Override Declaration public override string ToString() Returns Type Description string Overrides object.ToString() Implements IEquatable<T>"
  },
  "api/NUnit.Framework.Interfaces.AssertionStatus.html": {
    "href": "api/NUnit.Framework.Interfaces.AssertionStatus.html",
    "title": "Enum AssertionStatus | NUnit Docs",
    "summary": "Enum AssertionStatus AssertionStatus enumeration represents the possible outcomes of an assertion. The order of definition is significant, higher level values override lower ones in determining the overall result of a test. Namespace: NUnit.Framework.Interfaces Assembly: nunit.framework.dll Syntax public enum AssertionStatus Fields Name Description Error An unexpected exception was thrown Failed The assertion failed Inconclusive An assumption failed Passed The assertion succeeded Warning A warning message was issued"
  },
  "api/NUnit.Framework.Interfaces.FailureSite.html": {
    "href": "api/NUnit.Framework.Interfaces.FailureSite.html",
    "title": "Enum FailureSite | NUnit Docs",
    "summary": "Enum FailureSite The FailureSite enum indicates the stage of a test in which an error or failure occurred. Namespace: NUnit.Framework.Interfaces Assembly: nunit.framework.dll Syntax public enum FailureSite Fields Name Description Child Failure of a child test Parent Failure of a parent test SetUp Failure in the SetUp method TearDown Failure in the TearDown method Test Failure in the test itself"
  },
  "api/NUnit.Framework.Interfaces.IApplyToContext.html": {
    "href": "api/NUnit.Framework.Interfaces.IApplyToContext.html",
    "title": "Interface IApplyToContext | NUnit Docs",
    "summary": "Interface IApplyToContext The IApplyToContext interface is implemented by attributes that want to make changes to the execution context before a test is run. Namespace: NUnit.Framework.Interfaces Assembly: nunit.framework.dll Syntax public interface IApplyToContext Methods View Source ApplyToContext(TestExecutionContext) Apply changes to the execution context Declaration void ApplyToContext(TestExecutionContext context) Parameters Type Name Description TestExecutionContext context The execution context"
  },
  "api/NUnit.Framework.Interfaces.IApplyToTest.html": {
    "href": "api/NUnit.Framework.Interfaces.IApplyToTest.html",
    "title": "Interface IApplyToTest | NUnit Docs",
    "summary": "Interface IApplyToTest The IApplyToTest interface is implemented by self-applying attributes that modify the state of a test in some way. Namespace: NUnit.Framework.Interfaces Assembly: nunit.framework.dll Syntax public interface IApplyToTest Methods View Source ApplyToTest(Test) Modifies a test as defined for the specific attribute. Declaration void ApplyToTest(Test test) Parameters Type Name Description Test test The test to modify"
  },
  "api/NUnit.Framework.Interfaces.IApplyToTestSuite.html": {
    "href": "api/NUnit.Framework.Interfaces.IApplyToTestSuite.html",
    "title": "Interface IApplyToTestSuite | NUnit Docs",
    "summary": "Interface IApplyToTestSuite The IApplyToTestSuite interface is implemented by self-applying attributes that modify the state of a test suite in some way. Namespace: NUnit.Framework.Interfaces Assembly: nunit.framework.dll Syntax public interface IApplyToTestSuite Methods View Source ApplyToTestSuite(TestSuite) Modifies a test suite as defined for the specific attribute. Declaration void ApplyToTestSuite(TestSuite testSuite) Parameters Type Name Description TestSuite testSuite The test to modify"
  },
  "api/NUnit.Framework.Interfaces.ICombiningStrategy.html": {
    "href": "api/NUnit.Framework.Interfaces.ICombiningStrategy.html",
    "title": "Interface ICombiningStrategy | NUnit Docs",
    "summary": "Interface ICombiningStrategy CombiningStrategy is the abstract base for classes that know how to combine values provided for individual test parameters to create a set of test cases. Namespace: NUnit.Framework.Interfaces Assembly: nunit.framework.dll Syntax public interface ICombiningStrategy Methods View Source GetTestCases(IEnumerable[]) Gets the test cases generated by the CombiningStrategy. Declaration IEnumerable<ITestCaseData> GetTestCases(IEnumerable[] sources) Parameters Type Name Description IEnumerable[] sources Returns Type Description IEnumerable<ITestCaseData> The test cases."
  },
  "api/NUnit.Framework.Interfaces.ICommandWrapper.html": {
    "href": "api/NUnit.Framework.Interfaces.ICommandWrapper.html",
    "title": "Interface ICommandWrapper | NUnit Docs",
    "summary": "Interface ICommandWrapper ICommandWrapper is implemented by attributes and other objects able to wrap a TestCommand with another command. Namespace: NUnit.Framework.Interfaces Assembly: nunit.framework.dll Syntax public interface ICommandWrapper Remarks Attributes or other objects should implement one of the derived interfaces, rather than this one, since they indicate in which part of the command chain the wrapper should be applied. Methods View Source Wrap(TestCommand) Wrap a command and return the result. Declaration TestCommand Wrap(TestCommand command) Parameters Type Name Description TestCommand command The command to be wrapped Returns Type Description TestCommand The wrapped command"
  },
  "api/NUnit.Framework.Interfaces.IFixtureBuilder.html": {
    "href": "api/NUnit.Framework.Interfaces.IFixtureBuilder.html",
    "title": "Interface IFixtureBuilder | NUnit Docs",
    "summary": "Interface IFixtureBuilder The IFixtureBuilder interface is exposed by a class that knows how to build test fixtures from a specified type. In general, it is exposed by an attribute, but it may be implemented in a helper class used by the attribute in some cases. Namespace: NUnit.Framework.Interfaces Assembly: nunit.framework.dll Syntax public interface IFixtureBuilder Methods View Source BuildFrom(ITypeInfo) Builds any number of test fixtures from the specified type. Declaration IEnumerable<TestSuite> BuildFrom(ITypeInfo typeInfo) Parameters Type Name Description ITypeInfo typeInfo The type info of the fixture to be used. Returns Type Description IEnumerable<TestSuite>"
  },
  "api/NUnit.Framework.Interfaces.IFixtureBuilder2.html": {
    "href": "api/NUnit.Framework.Interfaces.IFixtureBuilder2.html",
    "title": "Interface IFixtureBuilder2 | NUnit Docs",
    "summary": "Interface IFixtureBuilder2 The IFixtureBuilder2 interface extends IFixtureBuilder by allowing use of a PreFilter, which is used to select methods as test cases. Inherited Members IFixtureBuilder.BuildFrom(ITypeInfo) Namespace: NUnit.Framework.Interfaces Assembly: nunit.framework.dll Syntax public interface IFixtureBuilder2 : IFixtureBuilder Methods View Source BuildFrom(ITypeInfo, IPreFilter) Builds any number of test fixtures from the specified type. Declaration IEnumerable<TestSuite> BuildFrom(ITypeInfo typeInfo, IPreFilter filter) Parameters Type Name Description ITypeInfo typeInfo The type info of the fixture to be used. IPreFilter filter PreFilter to be used to select methods. Returns Type Description IEnumerable<TestSuite>"
  },
  "api/NUnit.Framework.Interfaces.IImplyFixture.html": {
    "href": "api/NUnit.Framework.Interfaces.IImplyFixture.html",
    "title": "Interface IImplyFixture | NUnit Docs",
    "summary": "Interface IImplyFixture IImplyFixture is an empty marker interface used by attributes like TestAttribute that cause the class where they are used to be treated as a TestFixture even without a TestFixtureAttribute. Marker interfaces are not usually considered a good practice, but we use it here to avoid cluttering the attribute hierarchy with classes that don't contain any extra implementation. Namespace: NUnit.Framework.Interfaces Assembly: nunit.framework.dll Syntax public interface IImplyFixture"
  },
  "api/NUnit.Framework.Interfaces.IMethodInfo.html": {
    "href": "api/NUnit.Framework.Interfaces.IMethodInfo.html",
    "title": "Interface IMethodInfo | NUnit Docs",
    "summary": "Interface IMethodInfo The IMethodInfo class is used to encapsulate information about a method in a platform-independent manner. Inherited Members IReflectionInfo.GetCustomAttributes<T>(bool) IReflectionInfo.IsDefined<T>(bool) Namespace: NUnit.Framework.Interfaces Assembly: nunit.framework.dll Syntax public interface IMethodInfo : IReflectionInfo Properties View Source ContainsGenericParameters Gets a value indicating whether the method contains unassigned generic type parameters. Declaration bool ContainsGenericParameters { get; } Property Value Type Description bool View Source IsAbstract Gets a value indicating whether the method is abstract. Declaration bool IsAbstract { get; } Property Value Type Description bool View Source IsGenericMethod Gets a value indicating whether the method is a generic method. Declaration bool IsGenericMethod { get; } Property Value Type Description bool View Source IsGenericMethodDefinition Gets a value indicating whether the MethodInfo represents the definition of a generic method. Declaration bool IsGenericMethodDefinition { get; } Property Value Type Description bool View Source IsPublic Gets a value indicating whether the method is public. Declaration bool IsPublic { get; } Property Value Type Description bool View Source IsStatic Gets a value indicating whether the method is static. Declaration bool IsStatic { get; } Property Value Type Description bool View Source MethodInfo Gets the MethodInfo for this method. Declaration MethodInfo MethodInfo { get; } Property Value Type Description MethodInfo View Source Name Gets the name of the method. Declaration string Name { get; } Property Value Type Description string View Source ReturnType Gets the return Type of the method. Declaration ITypeInfo ReturnType { get; } Property Value Type Description ITypeInfo View Source TypeInfo Gets the Type from which this method was reflected. Declaration ITypeInfo TypeInfo { get; } Property Value Type Description ITypeInfo Methods View Source GetGenericArguments() Returns the Type arguments of a generic method or the Type parameters of a generic method definition. Declaration Type[] GetGenericArguments() Returns Type Description Type[] View Source GetParameters() Gets the parameters of the method. Declaration IParameterInfo[] GetParameters() Returns Type Description IParameterInfo[] View Source Invoke(object?, params object?[]?) Invokes the method, converting any TargetInvocationException to an NUnitException. Declaration object? Invoke(object? fixture, params object?[]? args) Parameters Type Name Description object fixture The object on which to invoke the method object[] args The argument list for the method Returns Type Description object The return value from the invoked method View Source MakeGenericMethod(params Type[]) Replaces the type parameters of the method with the array of types provided and returns a new IMethodInfo. Declaration IMethodInfo MakeGenericMethod(params Type[] typeArguments) Parameters Type Name Description Type[] typeArguments The type arguments to be used Returns Type Description IMethodInfo A new IMethodInfo with the type arguments replaced"
  },
  "api/NUnit.Framework.Interfaces.IParameterDataProvider.html": {
    "href": "api/NUnit.Framework.Interfaces.IParameterDataProvider.html",
    "title": "Interface IParameterDataProvider | NUnit Docs",
    "summary": "Interface IParameterDataProvider Provides data for a single test parameter. Namespace: NUnit.Framework.Interfaces Assembly: nunit.framework.dll Syntax public interface IParameterDataProvider Methods View Source GetDataFor(IParameterInfo) Retrieves a list of arguments which can be passed to the specified parameter. Declaration IEnumerable GetDataFor(IParameterInfo parameter) Parameters Type Name Description IParameterInfo parameter The parameter of a parameterized test. Returns Type Description IEnumerable View Source HasDataFor(IParameterInfo) Determines whether any data is available for a parameter. Declaration bool HasDataFor(IParameterInfo parameter) Parameters Type Name Description IParameterInfo parameter The parameter of a parameterized test. Returns Type Description bool"
  },
  "api/NUnit.Framework.Interfaces.IParameterDataSource.html": {
    "href": "api/NUnit.Framework.Interfaces.IParameterDataSource.html",
    "title": "Interface IParameterDataSource | NUnit Docs",
    "summary": "Interface IParameterDataSource Provides data for a single test parameter. Namespace: NUnit.Framework.Interfaces Assembly: nunit.framework.dll Syntax public interface IParameterDataSource Methods View Source GetData(IParameterInfo) Retrieves a list of arguments which can be passed to the specified parameter. Declaration IEnumerable GetData(IParameterInfo parameter) Parameters Type Name Description IParameterInfo parameter The parameter of a parameterized test. Returns Type Description IEnumerable"
  },
  "api/NUnit.Framework.Interfaces.IParameterInfo.html": {
    "href": "api/NUnit.Framework.Interfaces.IParameterInfo.html",
    "title": "Interface IParameterInfo | NUnit Docs",
    "summary": "Interface IParameterInfo The IParameterInfo interface is an abstraction of a .NET parameter. Inherited Members IReflectionInfo.GetCustomAttributes<T>(bool) IReflectionInfo.IsDefined<T>(bool) Namespace: NUnit.Framework.Interfaces Assembly: nunit.framework.dll Syntax public interface IParameterInfo : IReflectionInfo Properties View Source IsOptional Gets a value indicating whether the parameter is optional Declaration bool IsOptional { get; } Property Value Type Description bool View Source Method Gets an IMethodInfo representing the method for which this is a parameter Declaration IMethodInfo Method { get; } Property Value Type Description IMethodInfo View Source ParameterInfo Gets the underlying .NET ParameterInfo Declaration ParameterInfo ParameterInfo { get; } Property Value Type Description ParameterInfo View Source ParameterType Gets the Type of the parameter Declaration Type ParameterType { get; } Property Value Type Description Type"
  },
  "api/NUnit.Framework.Interfaces.IPreFilter.html": {
    "href": "api/NUnit.Framework.Interfaces.IPreFilter.html",
    "title": "Interface IPreFilter | NUnit Docs",
    "summary": "Interface IPreFilter Implemented by filters for use in deciding which Types and Methods should be used to generate tests. Namespace: NUnit.Framework.Interfaces Assembly: nunit.framework.dll Syntax public interface IPreFilter Methods View Source IsMatch(Type) Use the filter on a Type, returning true if the type matches the filter and should therefore be included in the discovery process. Declaration bool IsMatch(Type type) Parameters Type Name Description Type type Returns Type Description bool View Source IsMatch(Type, MethodInfo) Use the filter on a Type, returning true if the type matches the filter and should therefore be included in the discovery process. Declaration bool IsMatch(Type type, MethodInfo method) Parameters Type Name Description Type type MethodInfo method Returns Type Description bool"
  },
  "api/NUnit.Framework.Interfaces.IPropertyBag.html": {
    "href": "api/NUnit.Framework.Interfaces.IPropertyBag.html",
    "title": "Interface IPropertyBag | NUnit Docs",
    "summary": "Interface IPropertyBag A PropertyBag represents a collection of name/value pairs that allows duplicate entries with the same key. Methods are provided for adding a new pair as well as for setting a key to a single value. All keys are strings but values may be of any type. Null values are not permitted, since a null entry represents the absence of the key. The entries in a PropertyBag are of two kinds: those that take a single value and those that take multiple values. However, the PropertyBag has no knowledge of which entries fall into each category and the distinction is entirely up to the code using the PropertyBag. When working with multi-valued properties, client code should use the Add method to add name/value pairs and indexing to retrieve a list of all values for a given key. For example: bag.Add(\"Tag\", \"one\"); bag.Add(\"Tag\", \"two\"); Assert.That(bag[\"Tag\"], Is.EqualTo(new string[] { \"one\", \"two\" })); When working with single-valued properties, client code should use the Set method to set the value and Get to retrieve the value. The GetSetting methods may also be used to retrieve the value in a type-safe manner while also providing default. For example: bag.Set(\"Priority\", \"low\"); bag.Set(\"Priority\", \"high\"); // replaces value Assert.That(bag.Get(\"Priority\"), Is.EqualTo(\"high\")); Assert.That(bag.GetSetting(\"Priority\", \"low\"), Is.EqualTo(\"high\")); Inherited Members IXmlNodeBuilder.ToXml(bool) IXmlNodeBuilder.AddToXml(TNode, bool) Namespace: NUnit.Framework.Interfaces Assembly: nunit.framework.dll Syntax public interface IPropertyBag : IXmlNodeBuilder Properties View Source this[string] Gets or sets the list of values for a particular key, initializes new list behind the key if not found. Declaration IList this[string key] { get; set; } Parameters Type Name Description string key The key for which the values are to be retrieved or set Property Value Type Description IList View Source Keys Gets a collection containing all the keys in the property set Declaration ICollection<string> Keys { get; } Property Value Type Description ICollection<string> Methods View Source Add(string, object) Adds a key/value pair to the property bag Declaration void Add(string key, object value) Parameters Type Name Description string key The key object value The value View Source ContainsKey(string) Gets a flag indicating whether the specified key has any entries in the property set. Declaration bool ContainsKey(string key) Parameters Type Name Description string key The key to be checked Returns Type Description bool True if their are values present, otherwise false View Source Get(string) Gets a single value for a key, using the first one if multiple values are present and returning null if the value is not found. Declaration object? Get(string key) Parameters Type Name Description string key Returns Type Description object View Source Set(string, object) Sets the value for a key, removing any other values that are already in the property set. Declaration void Set(string key, object value) Parameters Type Name Description string key object value View Source TryGet(string, out IList?) Tries to retrieve list of values. Declaration bool TryGet(string key, out IList? values) Parameters Type Name Description string key The key for which the values are to be retrieved IList values Values, if found Returns Type Description bool true if found"
  },
  "api/NUnit.Framework.Interfaces.IReflectionInfo.html": {
    "href": "api/NUnit.Framework.Interfaces.IReflectionInfo.html",
    "title": "Interface IReflectionInfo | NUnit Docs",
    "summary": "Interface IReflectionInfo The IReflectionInfo interface is implemented by NUnit wrapper objects that perform reflection. Namespace: NUnit.Framework.Interfaces Assembly: nunit.framework.dll Syntax public interface IReflectionInfo Methods View Source GetCustomAttributes<T>(bool) Returns an array of custom attributes of the specified type applied to this object Declaration T[] GetCustomAttributes<T>(bool inherit) where T : class Parameters Type Name Description bool inherit Returns Type Description T[] Type Parameters Name Description T View Source IsDefined<T>(bool) Returns a value indicating whether an attribute of the specified type is defined on this object. Declaration bool IsDefined<T>(bool inherit) where T : class Parameters Type Name Description bool inherit Returns Type Description bool Type Parameters Name Description T"
  },
  "api/NUnit.Framework.Interfaces.IRepeatTest.html": {
    "href": "api/NUnit.Framework.Interfaces.IRepeatTest.html",
    "title": "Interface IRepeatTest | NUnit Docs",
    "summary": "Interface IRepeatTest Objects implementing this interface are used to wrap tests that can repeat. The implementing command is run once, invoking the chained commands any number of times. Inherited Members ICommandWrapper.Wrap(TestCommand) Namespace: NUnit.Framework.Interfaces Assembly: nunit.framework.dll Syntax public interface IRepeatTest : ICommandWrapper"
  },
  "api/NUnit.Framework.Interfaces.ISimpleTestBuilder.html": {
    "href": "api/NUnit.Framework.Interfaces.ISimpleTestBuilder.html",
    "title": "Interface ISimpleTestBuilder | NUnit Docs",
    "summary": "Interface ISimpleTestBuilder The ISimpleTestBuilder interface is exposed by a class that knows how to build a single tests from a specified method. In general, it is exposed by an attribute, but it may be implemented in a helper class used by the attribute in some cases. Namespace: NUnit.Framework.Interfaces Assembly: nunit.framework.dll Syntax public interface ISimpleTestBuilder Methods View Source BuildFrom(IMethodInfo, Test?) Builds a single test from the specified method and context. Declaration TestMethod BuildFrom(IMethodInfo method, Test? suite) Parameters Type Name Description IMethodInfo method The method to be used as a test Test suite The TestSuite to which the method will be added Returns Type Description TestMethod"
  },
  "api/NUnit.Framework.Interfaces.ISuiteBuilder.html": {
    "href": "api/NUnit.Framework.Interfaces.ISuiteBuilder.html",
    "title": "Interface ISuiteBuilder | NUnit Docs",
    "summary": "Interface ISuiteBuilder The ISuiteBuilder interface is exposed by a class that knows how to build a single test suite from a specified type. Namespace: NUnit.Framework.Interfaces Assembly: nunit.framework.dll Syntax public interface ISuiteBuilder Methods View Source BuildFrom(ITypeInfo) Builds a single test suite from the specified type. Declaration TestSuite BuildFrom(ITypeInfo typeInfo) Parameters Type Name Description ITypeInfo typeInfo The type of the fixture to be used Returns Type Description TestSuite View Source BuildFrom(ITypeInfo, IPreFilter) Builds a single test suite from the specified type, subject to a filter that decides which methods are included. Declaration TestSuite BuildFrom(ITypeInfo typeInfo, IPreFilter filter) Parameters Type Name Description ITypeInfo typeInfo The type of the fixture to be used IPreFilter filter A PreFilter for selecting methods. Returns Type Description TestSuite View Source CanBuildFrom(ITypeInfo) Examine the type and determine if it is suitable for this builder to use in building a TestSuite. Note that returning false will cause the type to be ignored in loading the tests. If it is desired to load the suite but label it as non-runnable, ignored, etc., then this method must return true. Declaration bool CanBuildFrom(ITypeInfo typeInfo) Parameters Type Name Description ITypeInfo typeInfo The type of the fixture to be used Returns Type Description bool"
  },
  "api/NUnit.Framework.Interfaces.ITest.html": {
    "href": "api/NUnit.Framework.Interfaces.ITest.html",
    "title": "Interface ITest | NUnit Docs",
    "summary": "Interface ITest Common interface supported by all representations of a test. Only includes informational fields. The Run method is specifically excluded to allow for data-only representations of a test. Inherited Members IXmlNodeBuilder.ToXml(bool) IXmlNodeBuilder.AddToXml(TNode, bool) Namespace: NUnit.Framework.Interfaces Assembly: nunit.framework.dll Syntax public interface ITest : IXmlNodeBuilder Properties View Source Arguments The arguments to use in creating the test or empty array if none are required. Declaration object?[] Arguments { get; } Property Value Type Description object[] View Source ClassName Gets the name of the class containing this test. Returns null if the test is not associated with a class. Declaration string? ClassName { get; } Property Value Type Description string View Source Fixture Gets a fixture object for running this test. Declaration object? Fixture { get; } Property Value Type Description object View Source FullName Gets the fully qualified name of the test Declaration string FullName { get; } Property Value Type Description string View Source HasChildren Gets a bool indicating whether the current test has any descendant tests. Declaration bool HasChildren { get; } Property Value Type Description bool View Source Id Gets the id of the test Declaration string Id { get; } Property Value Type Description string View Source IsSuite Returns true if this is a test suite Declaration bool IsSuite { get; } Property Value Type Description bool View Source Method Gets the method which declares the test, or null if no method is associated with this test. Declaration IMethodInfo? Method { get; } Property Value Type Description IMethodInfo View Source MethodName Gets the name of the method implementing this test. Returns null if the test is not implemented as a method. Declaration string? MethodName { get; } Property Value Type Description string View Source Name Gets the name of the test Declaration string Name { get; } Property Value Type Description string View Source Parent Gets the parent test, if any. Declaration ITest? Parent { get; } Property Value Type Description ITest The parent test or null if none exists. View Source Properties Gets the properties of the test Declaration IPropertyBag Properties { get; } Property Value Type Description IPropertyBag View Source RunState Gets the RunState of the test, indicating whether it can be run. Declaration RunState RunState { get; } Property Value Type Description RunState View Source TestCaseCount Count of the test cases ( 1 if this is a test case ) Declaration int TestCaseCount { get; } Property Value Type Description int View Source TestType Gets the type of the test Declaration string TestType { get; } Property Value Type Description string View Source Tests Gets this test's child tests Declaration IList<ITest> Tests { get; } Property Value Type Description IList<ITest> A list of child tests View Source TypeInfo Gets the Type of the test fixture, if applicable, or null if no fixture type is associated with this test. Declaration ITypeInfo? TypeInfo { get; } Property Value Type Description ITypeInfo"
  },
  "api/NUnit.Framework.Interfaces.ITestBuilder.html": {
    "href": "api/NUnit.Framework.Interfaces.ITestBuilder.html",
    "title": "Interface ITestBuilder | NUnit Docs",
    "summary": "Interface ITestBuilder The ITestBuilder interface is exposed by a class that knows how to build tests from a specified method. In general, it is exposed by an attribute which has additional information available to provide the necessary test parameters to distinguish the test cases built. Namespace: NUnit.Framework.Interfaces Assembly: nunit.framework.dll Syntax public interface ITestBuilder Methods View Source BuildFrom(IMethodInfo, Test?) Builds any number of tests from the specified method and context. Declaration IEnumerable<TestMethod> BuildFrom(IMethodInfo method, Test? suite) Parameters Type Name Description IMethodInfo method The method to be used as a test Test suite The TestSuite to which the method will be added Returns Type Description IEnumerable<TestMethod>"
  },
  "api/NUnit.Framework.Interfaces.ITestCaseBuilder.html": {
    "href": "api/NUnit.Framework.Interfaces.ITestCaseBuilder.html",
    "title": "Interface ITestCaseBuilder | NUnit Docs",
    "summary": "Interface ITestCaseBuilder The ITestCaseBuilder interface is exposed by a class that knows how to build a test from a specified method, possibly containing child test cases. Namespace: NUnit.Framework.Interfaces Assembly: nunit.framework.dll Syntax public interface ITestCaseBuilder Methods View Source BuildFrom(IMethodInfo, Test?) Builds a single test from the specified method and context, possibly containing child test cases. Declaration Test? BuildFrom(IMethodInfo method, Test? suite) Parameters Type Name Description IMethodInfo method The method to be used as a test case Test suite The test suite being populated, or null Returns Type Description Test View Source CanBuildFrom(IMethodInfo, Test?) Examine the method and determine if it is suitable for this builder to use in building a TestCase to be included in the suite being populated. Note that returning false will cause the method to be ignored in loading the tests. If it is desired to load the method but label it as non-runnable, ignored, etc., then this method must return true. Declaration bool CanBuildFrom(IMethodInfo method, Test? suite) Parameters Type Name Description IMethodInfo method The test method to examine Test suite The suite being populated Returns Type Description bool"
  },
  "api/NUnit.Framework.Interfaces.ITestCaseData.html": {
    "href": "api/NUnit.Framework.Interfaces.ITestCaseData.html",
    "title": "Interface ITestCaseData | NUnit Docs",
    "summary": "Interface ITestCaseData The ITestCaseData interface is implemented by a class that is able to return complete test cases for use by a parameterized test method. Inherited Members ITestData.TestName ITestData.RunState ITestData.Arguments ITestData.Properties Namespace: NUnit.Framework.Interfaces Assembly: nunit.framework.dll Syntax public interface ITestCaseData : ITestData Properties View Source ExpectedResult Gets the expected result of the test case Declaration object? ExpectedResult { get; } Property Value Type Description object View Source HasExpectedResult Returns true if an expected result has been set Declaration bool HasExpectedResult { get; } Property Value Type Description bool"
  },
  "api/NUnit.Framework.Interfaces.ITestData.html": {
    "href": "api/NUnit.Framework.Interfaces.ITestData.html",
    "title": "Interface ITestData | NUnit Docs",
    "summary": "Interface ITestData The ITestData interface is implemented by a class that represents a single instance of a parameterized test. Namespace: NUnit.Framework.Interfaces Assembly: nunit.framework.dll Syntax public interface ITestData Properties View Source Arguments Gets the argument list to be provided to the test Declaration object?[] Arguments { get; } Property Value Type Description object[] View Source Properties Gets the property dictionary for the test case Declaration IPropertyBag Properties { get; } Property Value Type Description IPropertyBag View Source RunState Gets the RunState for this test case. Declaration RunState RunState { get; } Property Value Type Description RunState View Source TestName Gets the name to be used for the test Declaration string? TestName { get; } Property Value Type Description string"
  },
  "api/NUnit.Framework.Interfaces.ITestFilter.html": {
    "href": "api/NUnit.Framework.Interfaces.ITestFilter.html",
    "title": "Interface ITestFilter | NUnit Docs",
    "summary": "Interface ITestFilter Interface to be implemented by filters applied to tests. The filter applies when running the test, after it has been loaded, since this is the only time an ITest exists. Inherited Members IXmlNodeBuilder.ToXml(bool) IXmlNodeBuilder.AddToXml(TNode, bool) Namespace: NUnit.Framework.Interfaces Assembly: nunit.framework.dll Syntax public interface ITestFilter : IXmlNodeBuilder Methods View Source IsExplicitMatch(ITest) Determine if a test matches the filter explicitly. That is, it must be a direct match of the test itself or one of its children. Declaration bool IsExplicitMatch(ITest test) Parameters Type Name Description ITest test The test to which the filter is applied Returns Type Description bool True if the test matches the filter explicitly, otherwise false View Source Pass(ITest) Determine if a particular test passes the filter criteria. Pass may examine the parents and/or descendants of a test, depending on the semantics of the particular filter Declaration bool Pass(ITest test) Parameters Type Name Description ITest test The test to which the filter is applied Returns Type Description bool True if the test passes the filter, otherwise false"
  },
  "api/NUnit.Framework.Interfaces.ITestFixtureData.html": {
    "href": "api/NUnit.Framework.Interfaces.ITestFixtureData.html",
    "title": "Interface ITestFixtureData | NUnit Docs",
    "summary": "Interface ITestFixtureData The ITestCaseData interface is implemented by a class that is able to return the data required to create an instance of a parameterized test fixture. Inherited Members ITestData.TestName ITestData.RunState ITestData.Arguments ITestData.Properties Namespace: NUnit.Framework.Interfaces Assembly: nunit.framework.dll Syntax public interface ITestFixtureData : ITestData Properties View Source TypeArgs Get the TypeArgs if separately set Declaration Type[]? TypeArgs { get; } Property Value Type Description Type[]"
  },
  "api/NUnit.Framework.Interfaces.ITestListener.html": {
    "href": "api/NUnit.Framework.Interfaces.ITestListener.html",
    "title": "Interface ITestListener | NUnit Docs",
    "summary": "Interface ITestListener The ITestListener interface is used internally to receive notifications of significant events while a test is being run. The events are propagated to clients by means of an AsyncCallback. NUnit extensions may also monitor these events. Namespace: NUnit.Framework.Interfaces Assembly: nunit.framework.dll Syntax public interface ITestListener Methods View Source SendMessage(TestMessage) Called when a test produces a message to be sent to listeners Declaration void SendMessage(TestMessage message) Parameters Type Name Description TestMessage message A TestMessage object containing the text to send View Source TestFinished(ITestResult) Called when a test has finished Declaration void TestFinished(ITestResult result) Parameters Type Name Description ITestResult result The result of the test View Source TestOutput(TestOutput) Called when a test produces output for immediate display Declaration void TestOutput(TestOutput output) Parameters Type Name Description TestOutput output A TestOutput object containing the text to display View Source TestStarted(ITest) Called when a test has just started Declaration void TestStarted(ITest test) Parameters Type Name Description ITest test The test that is starting"
  },
  "api/NUnit.Framework.Interfaces.ITestResult.html": {
    "href": "api/NUnit.Framework.Interfaces.ITestResult.html",
    "title": "Interface ITestResult | NUnit Docs",
    "summary": "Interface ITestResult The ITestResult interface represents the result of a test. Inherited Members IXmlNodeBuilder.ToXml(bool) IXmlNodeBuilder.AddToXml(TNode, bool) Namespace: NUnit.Framework.Interfaces Assembly: nunit.framework.dll Syntax public interface ITestResult : IXmlNodeBuilder Properties View Source AssertCount Gets the number of asserts executed when running the test and all its children. Declaration int AssertCount { get; } Property Value Type Description int View Source AssertionResults Gets a list of AssertionResults associated with the test Declaration IList<AssertionResult> AssertionResults { get; } Property Value Type Description IList<AssertionResult> View Source Children Gets the collection of child results. Declaration IEnumerable<ITestResult> Children { get; } Property Value Type Description IEnumerable<ITestResult> View Source Duration Gets the elapsed time for running the test in seconds Declaration double Duration { get; } Property Value Type Description double View Source EndTime Gets or sets the time the test finished running. Declaration DateTime EndTime { get; } Property Value Type Description DateTime View Source FailCount Gets the number of test cases that failed when running the test and all its children. Declaration int FailCount { get; } Property Value Type Description int View Source FullName Gets the full name of the test result Declaration string FullName { get; } Property Value Type Description string View Source HasChildren Indicates whether this result has any child results. Accessing HasChildren should not force creation of the Children collection in classes implementing this interface. Declaration bool HasChildren { get; } Property Value Type Description bool View Source InconclusiveCount Gets the number of test cases that were inconclusive when running the test and all its children. Declaration int InconclusiveCount { get; } Property Value Type Description int View Source Message Gets the message associated with a test failure or with not running the test Declaration string Message { get; } Property Value Type Description string View Source Name Gets the name of the test result Declaration string Name { get; } Property Value Type Description string View Source Output Gets any text output written to this result. Declaration string Output { get; } Property Value Type Description string View Source PassCount Gets the number of test cases that passed when running the test and all its children. Declaration int PassCount { get; } Property Value Type Description int View Source ResultState Gets the ResultState of the test result, which indicates the success or failure of the test. Declaration ResultState ResultState { get; } Property Value Type Description ResultState View Source SkipCount Gets the number of test cases that were skipped when running the test and all its children. Declaration int SkipCount { get; } Property Value Type Description int View Source StackTrace Gets any stack trace associated with an error or failure. Declaration string? StackTrace { get; } Property Value Type Description string View Source StartTime Gets or sets the time the test started running. Declaration DateTime StartTime { get; } Property Value Type Description DateTime View Source Test Gets the Test to which this result applies. Declaration ITest Test { get; } Property Value Type Description ITest View Source TestAttachments Gets the collection of files attached to the test Declaration ICollection<TestAttachment> TestAttachments { get; } Property Value Type Description ICollection<TestAttachment> View Source TotalCount Gets the total number of tests executed when running the test and all its children. Declaration int TotalCount { get; } Property Value Type Description int View Source WarningCount Gets the number of test cases that had warnings when running the test and all its children. Declaration int WarningCount { get; } Property Value Type Description int"
  },
  "api/NUnit.Framework.Interfaces.ITypeInfo.html": {
    "href": "api/NUnit.Framework.Interfaces.ITypeInfo.html",
    "title": "Interface ITypeInfo | NUnit Docs",
    "summary": "Interface ITypeInfo The ITypeInfo interface is an abstraction of a .NET Type Inherited Members IReflectionInfo.GetCustomAttributes<T>(bool) IReflectionInfo.IsDefined<T>(bool) Namespace: NUnit.Framework.Interfaces Assembly: nunit.framework.dll Syntax public interface ITypeInfo : IReflectionInfo Properties View Source Assembly Gets the assembly in which the type is declared Declaration Assembly Assembly { get; } Property Value Type Description Assembly View Source BaseType Gets the base type of this type as an ITypeInfo Declaration ITypeInfo? BaseType { get; } Property Value Type Description ITypeInfo View Source ContainsGenericParameters Gets a value indicating whether the Type has generic parameters that have not been replaced by specific Types. Declaration bool ContainsGenericParameters { get; } Property Value Type Description bool View Source FullName Gets the full name of the Type Declaration string FullName { get; } Property Value Type Description string View Source IsAbstract Gets a value indicating whether the type is abstract. Declaration bool IsAbstract { get; } Property Value Type Description bool View Source IsGenericType Gets a value indicating whether the Type is a generic Type Declaration bool IsGenericType { get; } Property Value Type Description bool View Source IsGenericTypeDefinition Gets a value indicating whether the Type is a generic Type definition Declaration bool IsGenericTypeDefinition { get; } Property Value Type Description bool View Source IsSealed Gets a value indicating whether the type is sealed. Declaration bool IsSealed { get; } Property Value Type Description bool View Source IsStaticClass Gets a value indicating whether this type is a static class. Declaration bool IsStaticClass { get; } Property Value Type Description bool View Source Name Gets the name of the Type Declaration string Name { get; } Property Value Type Description string View Source Namespace Gets the namespace of the Type Declaration string? Namespace { get; } Property Value Type Description string View Source Type Gets the underlying Type on which this ITypeInfo is based Declaration Type Type { get; } Property Value Type Description Type Methods View Source Construct(object?[]?) Construct an object of this Type, using the specified arguments. Declaration object Construct(object?[]? args) Parameters Type Name Description object[] args Returns Type Description object View Source GetConstructor(Type[]) Gets the public constructor taking the specified argument Types Declaration ConstructorInfo? GetConstructor(Type[] argTypes) Parameters Type Name Description Type[] argTypes Returns Type Description ConstructorInfo View Source GetDisplayName() Get the display name for this typeInfo. Declaration string GetDisplayName() Returns Type Description string View Source GetDisplayName(object?[]?) Get the display name for an object of this type, constructed with specific arguments Declaration string GetDisplayName(object?[]? args) Parameters Type Name Description object[] args Returns Type Description string View Source GetGenericTypeDefinition() Returns a Type representing a generic type definition from which this Type can be constructed. Declaration Type GetGenericTypeDefinition() Returns Type Description Type View Source GetMethods(BindingFlags) Returns an array of IMethodInfos for methods of this Type that match the specified flags. Declaration IMethodInfo[] GetMethods(BindingFlags flags) Parameters Type Name Description BindingFlags flags Returns Type Description IMethodInfo[] View Source GetMethodsWithAttribute<T>(bool) Returns all methods declared by this type that have the specified attribute, optionally including base classes. Methods from a base class are always returned before methods from a class that inherits from it. Declaration IMethodInfo[] GetMethodsWithAttribute<T>(bool inherit) where T : class Parameters Type Name Description bool inherit Specifies whether to search the fixture type inheritance chain. Returns Type Description IMethodInfo[] Type Parameters Name Description T View Source HasConstructor(Type[]) Returns a value indicating whether this Type has a public constructor taking the specified argument Types. Declaration bool HasConstructor(Type[] argTypes) Parameters Type Name Description Type[] argTypes Returns Type Description bool View Source HasMethodWithAttribute(Type) Returns a value indicating whether this type has a method with a specified public attribute Declaration bool HasMethodWithAttribute(Type attrType) Parameters Type Name Description Type attrType Returns Type Description bool View Source IsType(Type) Returns true if the Type wrapped is equal to the argument Declaration bool IsType(Type type) Parameters Type Name Description Type type Returns Type Description bool View Source MakeGenericType(Type[]) Returns a new ITypeInfo representing an instance of this generic Type using the supplied Type arguments Declaration ITypeInfo MakeGenericType(Type[] typeArgs) Parameters Type Name Description Type[] typeArgs Returns Type Description ITypeInfo"
  },
  "api/NUnit.Framework.Interfaces.IWrapSetUpTearDown.html": {
    "href": "api/NUnit.Framework.Interfaces.IWrapSetUpTearDown.html",
    "title": "Interface IWrapSetUpTearDown | NUnit Docs",
    "summary": "Interface IWrapSetUpTearDown Objects implementing this interface are used to wrap the entire test, including SetUp and TearDown. Inherited Members ICommandWrapper.Wrap(TestCommand) Namespace: NUnit.Framework.Interfaces Assembly: nunit.framework.dll Syntax public interface IWrapSetUpTearDown : ICommandWrapper"
  },
  "api/NUnit.Framework.Interfaces.IWrapTestMethod.html": {
    "href": "api/NUnit.Framework.Interfaces.IWrapTestMethod.html",
    "title": "Interface IWrapTestMethod | NUnit Docs",
    "summary": "Interface IWrapTestMethod Objects implementing this interface are used to wrap the TestMethodCommand itself. They apply after SetUp has been run and before TearDown. Inherited Members ICommandWrapper.Wrap(TestCommand) Namespace: NUnit.Framework.Interfaces Assembly: nunit.framework.dll Syntax public interface IWrapTestMethod : ICommandWrapper"
  },
  "api/NUnit.Framework.Interfaces.IXmlNodeBuilder.html": {
    "href": "api/NUnit.Framework.Interfaces.IXmlNodeBuilder.html",
    "title": "Interface IXmlNodeBuilder | NUnit Docs",
    "summary": "Interface IXmlNodeBuilder An object implementing IXmlNodeBuilder is able to build an XML representation of itself and any children. Namespace: NUnit.Framework.Interfaces Assembly: nunit.framework.dll Syntax public interface IXmlNodeBuilder Methods View Source AddToXml(TNode, bool) Returns a TNode representing the current object after adding it as a child of the supplied parent node. Declaration TNode AddToXml(TNode parentNode, bool recursive) Parameters Type Name Description TNode parentNode The parent node. bool recursive If true, children are included, where applicable Returns Type Description TNode View Source ToXml(bool) Returns a TNode representing the current object. Declaration TNode ToXml(bool recursive) Parameters Type Name Description bool recursive If true, children are included where applicable Returns Type Description TNode A TNode representing the result"
  },
  "api/NUnit.Framework.Interfaces.ResultState.html": {
    "href": "api/NUnit.Framework.Interfaces.ResultState.html",
    "title": "Class ResultState | NUnit Docs",
    "summary": "Class ResultState The ResultState class represents the outcome of running a test. It contains two pieces of information. The Status of the test is an enum indicating whether the test passed, failed, was skipped or was inconclusive. The Label provides a more detailed breakdown for use by client runners. Inheritance object ResultState Implements IEquatable<ResultState> Inherited Members object.GetType() object.MemberwiseClone() object.Equals(object, object) object.ReferenceEquals(object, object) Namespace: NUnit.Framework.Interfaces Assembly: nunit.framework.dll Syntax public class ResultState : IEquatable<ResultState> Constructors View Source ResultState(TestStatus) Initializes a new instance of the ResultState class. Declaration public ResultState(TestStatus status) Parameters Type Name Description TestStatus status The TestStatus. View Source ResultState(TestStatus, FailureSite) Initializes a new instance of the ResultState class. Declaration public ResultState(TestStatus status, FailureSite site) Parameters Type Name Description TestStatus status The TestStatus. FailureSite site The stage at which the result was produced View Source ResultState(TestStatus, string?) Initializes a new instance of the ResultState class. Declaration public ResultState(TestStatus status, string? label) Parameters Type Name Description TestStatus status The TestStatus. string label The label. View Source ResultState(TestStatus, string?, FailureSite) Initializes a new instance of the ResultState class. Declaration public ResultState(TestStatus status, string? label, FailureSite site) Parameters Type Name Description TestStatus status The TestStatus. string label The label. FailureSite site The stage at which the result was produced Fields View Source Cancelled The test was cancelled by the user Declaration public static readonly ResultState Cancelled Field Value Type Description ResultState View Source ChildFailure A suite failed because one or more child tests failed or had errors Declaration public static readonly ResultState ChildFailure Field Value Type Description ResultState View Source ChildIgnored A suite is marked ignored because one or more child tests were ignored Declaration public static readonly ResultState ChildIgnored Field Value Type Description ResultState View Source ChildWarning A suite failed because one or more child tests had warnings Declaration public static readonly ResultState ChildWarning Field Value Type Description ResultState View Source Error The test encountered an unexpected exception Declaration public static readonly ResultState Error Field Value Type Description ResultState View Source Explicit The test was skipped because it is explicit Declaration public static readonly ResultState Explicit Field Value Type Description ResultState View Source Failure The test failed Declaration public static readonly ResultState Failure Field Value Type Description ResultState View Source Ignored The test has been ignored. Declaration public static readonly ResultState Ignored Field Value Type Description ResultState View Source Inconclusive The result is inconclusive Declaration public static readonly ResultState Inconclusive Field Value Type Description ResultState View Source NotRunnable The test was not runnable. Declaration public static readonly ResultState NotRunnable Field Value Type Description ResultState View Source SetUpError A suite had an unexpected exception in its OneTimeSetUp Declaration public static readonly ResultState SetUpError Field Value Type Description ResultState View Source SetUpFailure A suite failed in its OneTimeSetUp Declaration public static readonly ResultState SetUpFailure Field Value Type Description ResultState View Source Skipped The test has been skipped. Declaration public static readonly ResultState Skipped Field Value Type Description ResultState View Source Success The test succeeded Declaration public static readonly ResultState Success Field Value Type Description ResultState View Source TearDownError A suite had an unexpected exception in its OneTimeDown Declaration public static readonly ResultState TearDownError Field Value Type Description ResultState View Source Warning The test issued a warning Declaration public static readonly ResultState Warning Field Value Type Description ResultState Properties View Source Label Gets the label under which this test result is categorized, or Empty if none. Declaration public string Label { get; } Property Value Type Description string View Source Site Gets the stage of test execution in which the failure or other result took place. Declaration public FailureSite Site { get; } Property Value Type Description FailureSite View Source Status Gets the TestStatus for the test. Declaration public TestStatus Status { get; } Property Value Type Description TestStatus The status. Methods View Source Equals(ResultState?) Indicates whether the current object is equal to another object of the same type. Declaration public bool Equals(ResultState? other) Parameters Type Name Description ResultState other An object to compare with this object. Returns Type Description bool View Source Equals(object?) Determines whether the specified object is equal to the current object. Declaration public override bool Equals(object? obj) Parameters Type Name Description object obj The object to compare with the current object. Returns Type Description bool Overrides object.Equals(object) View Source GetHashCode() Serves as the default hash function. Declaration public override int GetHashCode() Returns Type Description int Overrides object.GetHashCode() View Source Matches(ResultState) Test whether this ResultState has the same Status and Label as another one. In other words, the whether two are equal ignoring the Site. Declaration public bool Matches(ResultState other) Parameters Type Name Description ResultState other Returns Type Description bool View Source ToString() Returns a string that represents this instance. Declaration public override string ToString() Returns Type Description string A string that represents this instance. Overrides object.ToString() View Source WithSite(FailureSite) Get a new ResultState, which is the same as the current one but with the FailureSite set to the specified value. Declaration public ResultState WithSite(FailureSite site) Parameters Type Name Description FailureSite site The FailureSite to use Returns Type Description ResultState A new ResultState Operators View Source operator ==(ResultState?, ResultState?) Overload == operator for ResultStates Declaration public static bool operator ==(ResultState? left, ResultState? right) Parameters Type Name Description ResultState left ResultState right Returns Type Description bool View Source operator !=(ResultState?, ResultState?) Overload != operator for ResultStates Declaration public static bool operator !=(ResultState? left, ResultState? right) Parameters Type Name Description ResultState left ResultState right Returns Type Description bool Implements IEquatable<T>"
  },
  "api/NUnit.Framework.Interfaces.RunState.html": {
    "href": "api/NUnit.Framework.Interfaces.RunState.html",
    "title": "Enum RunState | NUnit Docs",
    "summary": "Enum RunState The RunState enum indicates whether a test can be executed. Namespace: NUnit.Framework.Interfaces Assembly: nunit.framework.dll Syntax public enum RunState Fields Name Description Explicit The test can only be run explicitly Ignored The test has been ignored. May appear on a Test, when the IgnoreAttribute is used. NotRunnable The test is not runnable. Runnable The test is runnable. Skipped The test has been skipped. This value may appear on a Test when certain attributes are used to skip the test."
  },
  "api/NUnit.Framework.Interfaces.TNode.AttributeDictionary.html": {
    "href": "api/NUnit.Framework.Interfaces.TNode.AttributeDictionary.html",
    "title": "Struct TNode.AttributeDictionary | NUnit Docs",
    "summary": "Struct TNode.AttributeDictionary Class used to represent the attributes of a node Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.GetType() object.Equals(object, object) object.ReferenceEquals(object, object) Namespace: NUnit.Framework.Interfaces Assembly: nunit.framework.dll Syntax public readonly struct TNode.AttributeDictionary Properties View Source Count Gets the number of key/value pairs contained in the Dictionary<TKey, TValue>. Declaration public int Count { get; } Property Value Type Description int View Source this[string] Gets or sets the value associated with the specified key. Overridden to return null if attribute is not found. Declaration public string? this[string key] { get; } Parameters Type Name Description string key The key. Property Value Type Description string Value of the attribute or null Methods View Source GetEnumerator() Returns an enumerator that iterates through the collection. Declaration public Dictionary<string, string>.Enumerator GetEnumerator() Returns Type Description Dictionary<string, string>.Enumerator"
  },
  "api/NUnit.Framework.Interfaces.TNode.NodeList.html": {
    "href": "api/NUnit.Framework.Interfaces.TNode.NodeList.html",
    "title": "Struct TNode.NodeList | NUnit Docs",
    "summary": "Struct TNode.NodeList Class used to represent a list of XmlResults Implements IEnumerable<TNode> IEnumerable Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.GetType() object.Equals(object, object) object.ReferenceEquals(object, object) Namespace: NUnit.Framework.Interfaces Assembly: nunit.framework.dll Syntax public readonly struct TNode.NodeList : IEnumerable<TNode>, IEnumerable Properties View Source Count Gets the number of elements contained in the collection. Declaration public int Count { get; } Property Value Type Description int View Source this[int] Gets or sets the element at the specified index. Declaration public TNode this[int index] { get; } Parameters Type Name Description int index Property Value Type Description TNode Methods View Source GetEnumerator() Returns an enumerator that iterates through the collection. Declaration public List<TNode>.Enumerator GetEnumerator() Returns Type Description List<TNode>.Enumerator Implements IEnumerable<T> IEnumerable"
  },
  "api/NUnit.Framework.Interfaces.TNode.html": {
    "href": "api/NUnit.Framework.Interfaces.TNode.html",
    "title": "Class TNode | NUnit Docs",
    "summary": "Class TNode TNode represents a single node in the XML representation of a Test or TestResult. It replaces System.Xml.XmlNode and System.Xml.Linq.XElement, providing a minimal set of methods for operating on the XML in a platform-independent manner. Inheritance object TNode Inherited Members object.GetType() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework.Interfaces Assembly: nunit.framework.dll Syntax public sealed class TNode Constructors View Source TNode(string) Constructs a new instance of TNode Declaration public TNode(string name) Parameters Type Name Description string name The name of the node View Source TNode(string, string?) Constructs a new instance of TNode with a value Declaration public TNode(string name, string? value) Parameters Type Name Description string name The name of the node string value The text content of the node View Source TNode(string, string?, bool) Constructs a new instance of TNode with a value Declaration public TNode(string name, string? value, bool valueIsCDATA) Parameters Type Name Description string name The name of the node string value The text content of the node bool valueIsCDATA Flag indicating whether to use CDATA when writing the text Properties View Source Attributes Gets the dictionary of attributes Declaration public TNode.AttributeDictionary Attributes { get; } Property Value Type Description TNode.AttributeDictionary View Source ChildNodes Gets a list of child nodes Declaration public TNode.NodeList ChildNodes { get; } Property Value Type Description TNode.NodeList View Source FirstChild Gets the first ChildNode Declaration public TNode? FirstChild { get; } Property Value Type Description TNode View Source Name Gets the name of the node Declaration public string Name { get; } Property Value Type Description string View Source OuterXml Gets the XML representation of this node. Declaration public string OuterXml { get; } Property Value Type Description string View Source Value Gets the value of the node Declaration public string? Value { get; set; } Property Value Type Description string View Source ValueIsCDATA Gets a flag indicating whether the value should be output using CDATA. Declaration public bool ValueIsCDATA { get; set; } Property Value Type Description bool Methods View Source AddAttribute(string, string) Adds an attribute with a specified name and value to the XmlNode. Declaration public void AddAttribute(string name, string value) Parameters Type Name Description string name The name of the attribute. string value The value of the attribute. View Source AddChildNode(TNode) Adds a child node to this node. Declaration public void AddChildNode(TNode node) Parameters Type Name Description TNode node The child node to add. View Source AddElement(string) Adds a new element as a child of the current node and returns it. Declaration public TNode AddElement(string name) Parameters Type Name Description string name The element name. Returns Type Description TNode The newly created child element View Source AddElement(string, string) Adds a new element with a value as a child of the current node and returns it. Declaration public TNode AddElement(string name, string value) Parameters Type Name Description string name The element name string value The text content of the new element Returns Type Description TNode The newly created child element View Source AddElementWithCDATA(string, string) Adds a new element with a value as a child of the current node and returns it. The value will be output using a CDATA section. Declaration public TNode AddElementWithCDATA(string name, string value) Parameters Type Name Description string name The element name string value The text content of the new element Returns Type Description TNode The newly created child element View Source FromXml(string) Create a TNode from its XML text representation Declaration public static TNode FromXml(string xmlText) Parameters Type Name Description string xmlText The XML text to be parsed Returns Type Description TNode A TNode View Source InsertChildNode(int, TNode) Inserts a child nodeat the specified index. Declaration public void InsertChildNode(int index, TNode node) Parameters Type Name Description int index The zero-based index at which node should be inserted. TNode node The node to insert. View Source SelectNodes(string) Finds all descendants of this node matching an XPath specification. The format of the specification is limited to what is needed by NUnit and its tests. Declaration public List<TNode> SelectNodes(string xpath) Parameters Type Name Description string xpath Returns Type Description List<TNode> View Source SelectSingleNode(string) Finds a single descendant of this node matching an XPath specification. The format of the specification is limited to what is needed by NUnit and its tests. Declaration public TNode? SelectSingleNode(string xpath) Parameters Type Name Description string xpath Returns Type Description TNode View Source WriteTo(XmlWriter) Writes the XML representation of the node to an XmlWriter Declaration public void WriteTo(XmlWriter writer) Parameters Type Name Description XmlWriter writer"
  },
  "api/NUnit.Framework.Interfaces.TestAttachment.html": {
    "href": "api/NUnit.Framework.Interfaces.TestAttachment.html",
    "title": "Class TestAttachment | NUnit Docs",
    "summary": "Class TestAttachment The TestAttachment class represents a file attached to a TestResult, with an optional description. Inheritance object TestAttachment Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework.Interfaces Assembly: nunit.framework.dll Syntax public class TestAttachment Constructors View Source TestAttachment(string, string?) Creates a TestAttachment class to represent a file attached to a test result. Declaration public TestAttachment(string filePath, string? description) Parameters Type Name Description string filePath Absolute file path to attachment file string description User specified description of attachment. May be null. Properties View Source Description User specified description of attachment. May be null. Declaration public string? Description { get; } Property Value Type Description string View Source FilePath Absolute file path to attachment file Declaration public string FilePath { get; } Property Value Type Description string"
  },
  "api/NUnit.Framework.Interfaces.TestMessage.html": {
    "href": "api/NUnit.Framework.Interfaces.TestMessage.html",
    "title": "Class TestMessage | NUnit Docs",
    "summary": "Class TestMessage The TestMessage class holds a message sent by a test to all listeners Inheritance object TestMessage Inherited Members object.GetType() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework.Interfaces Assembly: nunit.framework.dll Syntax public sealed class TestMessage Constructors View Source TestMessage(string, string, string?) Construct with text, destination type and the name of the test that produced the message. Declaration public TestMessage(string destination, string text, string? testId) Parameters Type Name Description string destination Destination of the message string text Text to be sent string testId ID of the test that produced the message Properties View Source Destination The Destination of the message. Declaration public string Destination { get; } Property Value Type Description string View Source Message The message to send to listeners Declaration public string Message { get; } Property Value Type Description string View Source TestId The ID of the test that sent the message Declaration public string? TestId { get; } Property Value Type Description string Methods View Source ToString() Converts TestMessage object to string Declaration public override string ToString() Returns Type Description string Overrides object.ToString() View Source ToXml() Returns the XML representation of the TestMessage object. Declaration public string ToXml() Returns Type Description string"
  },
  "api/NUnit.Framework.Interfaces.TestOutput.html": {
    "href": "api/NUnit.Framework.Interfaces.TestOutput.html",
    "title": "Class TestOutput | NUnit Docs",
    "summary": "Class TestOutput The TestOutput class holds a unit of output from a test to a specific output stream Inheritance object TestOutput Inherited Members object.GetType() object.MemberwiseClone() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework.Interfaces Assembly: nunit.framework.dll Syntax public class TestOutput Constructors View Source TestOutput(string, string, string?, string?) Construct with text, output destination type and the name of the test that produced the output. Declaration public TestOutput(string text, string stream, string? testId, string? testName) Parameters Type Name Description string text Text to be output string stream Name of the stream or channel to which the text should be written string testId Id of the test that produced the output string testName FullName of test that produced the output Properties View Source Stream Get the output type Declaration public string Stream { get; } Property Value Type Description string View Source TestId Get the id of the test that created the output Declaration public string? TestId { get; } Property Value Type Description string View Source TestName Get the name of the test that created the output Declaration public string? TestName { get; } Property Value Type Description string View Source Text Get the text Declaration public string Text { get; } Property Value Type Description string Methods View Source ToString() Return string representation of the object for debugging Declaration public override string ToString() Returns Type Description string Overrides object.ToString() View Source ToXml() Convert the TestOutput object to an XML string Declaration public string ToXml() Returns Type Description string"
  },
  "api/NUnit.Framework.Interfaces.TestStatus.html": {
    "href": "api/NUnit.Framework.Interfaces.TestStatus.html",
    "title": "Enum TestStatus | NUnit Docs",
    "summary": "Enum TestStatus The TestStatus enum indicates the result of running a test Namespace: NUnit.Framework.Interfaces Assembly: nunit.framework.dll Syntax public enum TestStatus Fields Name Description Failed The test failed Inconclusive The test was inconclusive Passed The test succeeded Skipped The test has been skipped Warning There was a warning"
  },
  "api/NUnit.Framework.Interfaces.html": {
    "href": "api/NUnit.Framework.Interfaces.html",
    "title": "Namespace NUnit.Framework.Interfaces | NUnit Docs",
    "summary": "Namespace NUnit.Framework.Interfaces Classes AssertionResult The AssertionResult class represents the result of a single assertion. ResultState The ResultState class represents the outcome of running a test. It contains two pieces of information. The Status of the test is an enum indicating whether the test passed, failed, was skipped or was inconclusive. The Label provides a more detailed breakdown for use by client runners. TNode TNode represents a single node in the XML representation of a Test or TestResult. It replaces System.Xml.XmlNode and System.Xml.Linq.XElement, providing a minimal set of methods for operating on the XML in a platform-independent manner. TestAttachment The TestAttachment class represents a file attached to a TestResult, with an optional description. TestMessage The TestMessage class holds a message sent by a test to all listeners TestOutput The TestOutput class holds a unit of output from a test to a specific output stream Structs TNode.AttributeDictionary Class used to represent the attributes of a node TNode.NodeList Class used to represent a list of XmlResults Interfaces IApplyToContext The IApplyToContext interface is implemented by attributes that want to make changes to the execution context before a test is run. IApplyToTest The IApplyToTest interface is implemented by self-applying attributes that modify the state of a test in some way. IApplyToTestSuite The IApplyToTestSuite interface is implemented by self-applying attributes that modify the state of a test suite in some way. ICombiningStrategy CombiningStrategy is the abstract base for classes that know how to combine values provided for individual test parameters to create a set of test cases. ICommandWrapper ICommandWrapper is implemented by attributes and other objects able to wrap a TestCommand with another command. IFixtureBuilder The IFixtureBuilder interface is exposed by a class that knows how to build test fixtures from a specified type. In general, it is exposed by an attribute, but it may be implemented in a helper class used by the attribute in some cases. IFixtureBuilder2 The IFixtureBuilder2 interface extends IFixtureBuilder by allowing use of a PreFilter, which is used to select methods as test cases. IImplyFixture IImplyFixture is an empty marker interface used by attributes like TestAttribute that cause the class where they are used to be treated as a TestFixture even without a TestFixtureAttribute. Marker interfaces are not usually considered a good practice, but we use it here to avoid cluttering the attribute hierarchy with classes that don't contain any extra implementation. IMethodInfo The IMethodInfo class is used to encapsulate information about a method in a platform-independent manner. IParameterDataProvider Provides data for a single test parameter. IParameterDataSource Provides data for a single test parameter. IParameterInfo The IParameterInfo interface is an abstraction of a .NET parameter. IPreFilter Implemented by filters for use in deciding which Types and Methods should be used to generate tests. IPropertyBag A PropertyBag represents a collection of name/value pairs that allows duplicate entries with the same key. Methods are provided for adding a new pair as well as for setting a key to a single value. All keys are strings but values may be of any type. Null values are not permitted, since a null entry represents the absence of the key. The entries in a PropertyBag are of two kinds: those that take a single value and those that take multiple values. However, the PropertyBag has no knowledge of which entries fall into each category and the distinction is entirely up to the code using the PropertyBag. When working with multi-valued properties, client code should use the Add method to add name/value pairs and indexing to retrieve a list of all values for a given key. For example: bag.Add(\"Tag\", \"one\"); bag.Add(\"Tag\", \"two\"); Assert.That(bag[\"Tag\"], Is.EqualTo(new string[] { \"one\", \"two\" })); When working with single-valued properties, client code should use the Set method to set the value and Get to retrieve the value. The GetSetting methods may also be used to retrieve the value in a type-safe manner while also providing default. For example: bag.Set(\"Priority\", \"low\"); bag.Set(\"Priority\", \"high\"); // replaces value Assert.That(bag.Get(\"Priority\"), Is.EqualTo(\"high\")); Assert.That(bag.GetSetting(\"Priority\", \"low\"), Is.EqualTo(\"high\")); IReflectionInfo The IReflectionInfo interface is implemented by NUnit wrapper objects that perform reflection. IRepeatTest Objects implementing this interface are used to wrap tests that can repeat. The implementing command is run once, invoking the chained commands any number of times. ISimpleTestBuilder The ISimpleTestBuilder interface is exposed by a class that knows how to build a single tests from a specified method. In general, it is exposed by an attribute, but it may be implemented in a helper class used by the attribute in some cases. ISuiteBuilder The ISuiteBuilder interface is exposed by a class that knows how to build a single test suite from a specified type. ITest Common interface supported by all representations of a test. Only includes informational fields. The Run method is specifically excluded to allow for data-only representations of a test. ITestBuilder The ITestBuilder interface is exposed by a class that knows how to build tests from a specified method. In general, it is exposed by an attribute which has additional information available to provide the necessary test parameters to distinguish the test cases built. ITestCaseBuilder The ITestCaseBuilder interface is exposed by a class that knows how to build a test from a specified method, possibly containing child test cases. ITestCaseData The ITestCaseData interface is implemented by a class that is able to return complete test cases for use by a parameterized test method. ITestData The ITestData interface is implemented by a class that represents a single instance of a parameterized test. ITestFilter Interface to be implemented by filters applied to tests. The filter applies when running the test, after it has been loaded, since this is the only time an ITest exists. ITestFixtureData The ITestCaseData interface is implemented by a class that is able to return the data required to create an instance of a parameterized test fixture. ITestListener The ITestListener interface is used internally to receive notifications of significant events while a test is being run. The events are propagated to clients by means of an AsyncCallback. NUnit extensions may also monitor these events. ITestResult The ITestResult interface represents the result of a test. ITypeInfo The ITypeInfo interface is an abstraction of a .NET Type IWrapSetUpTearDown Objects implementing this interface are used to wrap the entire test, including SetUp and TearDown. IWrapTestMethod Objects implementing this interface are used to wrap the TestMethodCommand itself. They apply after SetUp has been run and before TearDown. IXmlNodeBuilder An object implementing IXmlNodeBuilder is able to build an XML representation of itself and any children. Enums AssertionStatus AssertionStatus enumeration represents the possible outcomes of an assertion. The order of definition is significant, higher level values override lower ones in determining the overall result of a test. FailureSite The FailureSite enum indicates the stage of a test in which an error or failure occurred. RunState The RunState enum indicates whether a test can be executed. TestStatus The TestStatus enum indicates the result of running a test"
  },
  "api/NUnit.Framework.Is.html": {
    "href": "api/NUnit.Framework.Is.html",
    "title": "Class Is | NUnit Docs",
    "summary": "Class Is Helper class with properties and methods that supply a number of constraints used in Asserts. Inheritance object Is Iz Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework Assembly: nunit.framework.dll Syntax public abstract class Is Constructors View Source Is() Declaration protected Is() Properties View Source All Returns a ConstraintExpression, which will apply the following constraint to all members of a collection, succeeding if all of them succeed. Declaration public static ConstraintExpression All { get; } Property Value Type Description ConstraintExpression View Source Default Returns a constraint that tests for default value Declaration public static DefaultConstraint Default { get; } Property Value Type Description DefaultConstraint View Source Empty Returns a constraint that tests for empty Declaration public static EmptyConstraint Empty { get; } Property Value Type Description EmptyConstraint View Source Even Returns a constraint that tests for a number to be even (i.e. a multiple of two) Declaration public static MultipleOfConstraint Even { get; } Property Value Type Description MultipleOfConstraint View Source False Returns a constraint that tests for False Declaration public static FalseConstraint False { get; } Property Value Type Description FalseConstraint View Source NaN Returns a constraint that tests for NaN Declaration public static NaNConstraint NaN { get; } Property Value Type Description NaNConstraint View Source Negative Returns a constraint that tests for a negative value Declaration public static LessThanConstraint Negative { get; } Property Value Type Description LessThanConstraint View Source Not Returns a ConstraintExpression that negates any following constraint. Declaration public static ConstraintExpression Not { get; } Property Value Type Description ConstraintExpression View Source Null Returns a constraint that tests for null Declaration public static NullConstraint Null { get; } Property Value Type Description NullConstraint View Source Odd Returns a constraint that tests for a number to be odd. Declaration public static MultipleOfConstraint Odd { get; } Property Value Type Description MultipleOfConstraint View Source Ordered Returns a constraint that tests whether a collection is ordered Declaration public static CollectionOrderedConstraint Ordered { get; } Property Value Type Description CollectionOrderedConstraint View Source Positive Returns a constraint that tests for a positive value Declaration public static GreaterThanConstraint Positive { get; } Property Value Type Description GreaterThanConstraint View Source True Returns a constraint that tests for True Declaration public static TrueConstraint True { get; } Property Value Type Description TrueConstraint View Source Unique Returns a constraint that tests whether a collection contains all unique items. Declaration public static UniqueItemsConstraint Unique { get; } Property Value Type Description UniqueItemsConstraint View Source WhiteSpace Returns a constraint that tests for white-space Declaration public static WhiteSpaceConstraint WhiteSpace { get; } Property Value Type Description WhiteSpaceConstraint View Source XmlSerializable Returns a constraint that tests whether an object graph is serializable in XML format. Declaration public static XmlSerializableConstraint XmlSerializable { get; } Property Value Type Description XmlSerializableConstraint View Source Zero Returns a constraint that tests for equality with zero Declaration public static EqualConstraint Zero { get; } Property Value Type Description EqualConstraint Methods View Source AnyOf(ICollection) Returns a constraint that tests if an item is equal to any of parameters Declaration public static AnyOfConstraint AnyOf(ICollection expected) Parameters Type Name Description ICollection expected Expected values Returns Type Description AnyOfConstraint View Source AnyOf(params object?[]?) Returns a constraint that tests if an item is equal to any of parameters Declaration public static AnyOfConstraint AnyOf(params object?[]? expected) Parameters Type Name Description object[] expected Expected values Returns Type Description AnyOfConstraint View Source AssignableFrom(Type) Returns a constraint that tests whether the actual value is assignable from the type supplied as an argument. Declaration public static AssignableFromConstraint AssignableFrom(Type expectedType) Parameters Type Name Description Type expectedType Returns Type Description AssignableFromConstraint View Source AssignableFrom<TExpected>() Returns a constraint that tests whether the actual value is assignable from the type supplied as an argument. Declaration public static AssignableFromConstraint AssignableFrom<TExpected>() Returns Type Description AssignableFromConstraint Type Parameters Name Description TExpected View Source AssignableTo(Type) Returns a constraint that tests whether the actual value is assignable to the type supplied as an argument. Declaration public static AssignableToConstraint AssignableTo(Type expectedType) Parameters Type Name Description Type expectedType Returns Type Description AssignableToConstraint View Source AssignableTo<TExpected>() Returns a constraint that tests whether the actual value is assignable to the type supplied as an argument. Declaration public static AssignableToConstraint AssignableTo<TExpected>() Returns Type Description AssignableToConstraint Type Parameters Name Description TExpected View Source AtLeast(object) Returns a constraint that tests whether the actual value is greater than or equal to the supplied argument Declaration public static GreaterThanOrEqualConstraint AtLeast(object expected) Parameters Type Name Description object expected Returns Type Description GreaterThanOrEqualConstraint View Source AtMost(object) Returns a constraint that tests whether the actual value is less than or equal to the supplied argument Declaration public static LessThanOrEqualConstraint AtMost(object expected) Parameters Type Name Description object expected Returns Type Description LessThanOrEqualConstraint View Source EqualTo(byte) Returns a constraint that tests two numbers for equality Declaration public static EqualNumericConstraint<byte> EqualTo(byte expected) Parameters Type Name Description byte expected Returns Type Description EqualNumericConstraint<byte> View Source EqualTo(DateTime) Returns a constraint that tests two date time instances for equality. Declaration public static EqualTimeBaseConstraint<DateTime> EqualTo(DateTime expected) Parameters Type Name Description DateTime expected Returns Type Description EqualTimeBaseConstraint<DateTime> View Source EqualTo(DateTimeOffset) Returns a constraint that tests two date time offset instances for equality. Declaration public static EqualDateTimeOffsetConstraint EqualTo(DateTimeOffset expected) Parameters Type Name Description DateTimeOffset expected Returns Type Description EqualDateTimeOffsetConstraint View Source EqualTo(decimal) Returns a constraint that tests two numbers for equality Declaration public static EqualNumericConstraint<decimal> EqualTo(decimal expected) Parameters Type Name Description decimal expected Returns Type Description EqualNumericConstraint<decimal> View Source EqualTo(double) Returns a constraint that tests two numbers for equality Declaration public static EqualNumericConstraint<double> EqualTo(double expected) Parameters Type Name Description double expected Returns Type Description EqualNumericConstraint<double> View Source EqualTo(short) Returns a constraint that tests two numbers for equality Declaration public static EqualNumericConstraint<short> EqualTo(short expected) Parameters Type Name Description short expected Returns Type Description EqualNumericConstraint<short> View Source EqualTo(int) Returns a constraint that tests two numbers for equality Declaration public static EqualNumericConstraint<int> EqualTo(int expected) Parameters Type Name Description int expected Returns Type Description EqualNumericConstraint<int> View Source EqualTo(long) Returns a constraint that tests two numbers for equality Declaration public static EqualNumericConstraint<long> EqualTo(long expected) Parameters Type Name Description long expected Returns Type Description EqualNumericConstraint<long> View Source EqualTo(object?) Returns a constraint that tests two items for equality Declaration public static EqualConstraint EqualTo(object? expected) Parameters Type Name Description object expected Returns Type Description EqualConstraint View Source EqualTo(sbyte) Returns a constraint that tests two numbers for equality Declaration public static EqualNumericConstraint<sbyte> EqualTo(sbyte expected) Parameters Type Name Description sbyte expected Returns Type Description EqualNumericConstraint<sbyte> View Source EqualTo(float) Returns a constraint that tests two numbers for equality Declaration public static EqualNumericConstraint<float> EqualTo(float expected) Parameters Type Name Description float expected Returns Type Description EqualNumericConstraint<float> View Source EqualTo(string?) Returns a constraint that tests two strings for equality Declaration public static EqualStringConstraint EqualTo(string? expected) Parameters Type Name Description string expected Returns Type Description EqualStringConstraint View Source EqualTo(TimeSpan) Returns a constraint that tests two timespan instances for equality. Declaration public static EqualTimeBaseConstraint<TimeSpan> EqualTo(TimeSpan expected) Parameters Type Name Description TimeSpan expected Returns Type Description EqualTimeBaseConstraint<TimeSpan> View Source EqualTo(ushort) Returns a constraint that tests two numbers for equality Declaration public static EqualNumericConstraint<ushort> EqualTo(ushort expected) Parameters Type Name Description ushort expected Returns Type Description EqualNumericConstraint<ushort> View Source EqualTo(uint) Returns a constraint that tests two numbers for equality Declaration public static EqualNumericConstraint<uint> EqualTo(uint expected) Parameters Type Name Description uint expected Returns Type Description EqualNumericConstraint<uint> View Source EqualTo(ulong) Returns a constraint that tests two numbers for equality Declaration public static EqualNumericConstraint<ulong> EqualTo(ulong expected) Parameters Type Name Description ulong expected Returns Type Description EqualNumericConstraint<ulong> View Source EqualTo<T>(IEnumerable<T>?) Returns a constraint that tests two collections for equality. Declaration public static EqualConstraint<T> EqualTo<T>(IEnumerable<T>? expected) Parameters Type Name Description IEnumerable<T> expected Returns Type Description EqualConstraint<T> Type Parameters Name Description T View Source EqualTo<T>(T?) Returns a constraint that tests two items for equality Declaration public static EqualConstraint<T> EqualTo<T>(T? expected) Parameters Type Name Description T expected Returns Type Description EqualConstraint<T> Type Parameters Name Description T View Source EqualTo<T>(T[]?) Returns a constraint that tests two collections for equality. Declaration public static EqualConstraint<T> EqualTo<T>(T[]? expected) Parameters Type Name Description T[] expected Returns Type Description EqualConstraint<T> Type Parameters Name Description T View Source EquivalentTo(IEnumerable) Returns a constraint that tests whether the actual value is a collection containing the same elements as the collection supplied as an argument. Declaration public static CollectionEquivalentConstraint EquivalentTo(IEnumerable expected) Parameters Type Name Description IEnumerable expected Returns Type Description CollectionEquivalentConstraint View Source EquivalentTo<T>(IEnumerable<T>) Returns a constraint that tests whether the actual value is a collection containing the same elements as the collection supplied as an argument. Declaration public static CollectionEquivalentConstraint EquivalentTo<T>(IEnumerable<T> expected) Parameters Type Name Description IEnumerable<T> expected Returns Type Description CollectionEquivalentConstraint Type Parameters Name Description T View Source GreaterThan(object) Returns a constraint that tests whether the actual value is greater than the supplied argument Declaration public static GreaterThanConstraint GreaterThan(object expected) Parameters Type Name Description object expected Returns Type Description GreaterThanConstraint View Source GreaterThanOrEqualTo(object) Returns a constraint that tests whether the actual value is greater than or equal to the supplied argument Declaration public static GreaterThanOrEqualConstraint GreaterThanOrEqualTo(object expected) Parameters Type Name Description object expected Returns Type Description GreaterThanOrEqualConstraint View Source InRange(object, object) Returns a constraint that tests whether the actual value falls inclusively within a specified range. Declaration public static RangeConstraint InRange(object from, object to) Parameters Type Name Description object from Inclusive beginning of the range. object to Inclusive end of the range. Returns Type Description RangeConstraint View Source InstanceOf(Type) Returns a constraint that tests whether the actual value is of the type supplied as an argument or a derived type. Declaration public static InstanceOfTypeConstraint InstanceOf(Type expectedType) Parameters Type Name Description Type expectedType Returns Type Description InstanceOfTypeConstraint View Source InstanceOf<TExpected>() Returns a constraint that tests whether the actual value is of the type supplied as an argument or a derived type. Declaration public static InstanceOfTypeConstraint InstanceOf<TExpected>() Returns Type Description InstanceOfTypeConstraint Type Parameters Name Description TExpected View Source LessThan(object) Returns a constraint that tests whether the actual value is less than the supplied argument Declaration public static LessThanConstraint LessThan(object expected) Parameters Type Name Description object expected Returns Type Description LessThanConstraint View Source LessThanOrEqualTo(object) Returns a constraint that tests whether the actual value is less than or equal to the supplied argument Declaration public static LessThanOrEqualConstraint LessThanOrEqualTo(object expected) Parameters Type Name Description object expected Returns Type Description LessThanOrEqualConstraint View Source MultipleOf(int) Returns a constraint that tests for a number to be a multiple of another. Declaration public static MultipleOfConstraint MultipleOf(int multiple) Parameters Type Name Description int multiple Returns Type Description MultipleOfConstraint View Source SameAs(object?) Returns a constraint that tests that two references are the same object Declaration public static SameAsConstraint SameAs(object? expected) Parameters Type Name Description object expected Returns Type Description SameAsConstraint View Source SamePath(string) Returns a constraint that tests whether the path provided is the same as an expected path after canonicalization. Declaration public static SamePathConstraint SamePath(string expected) Parameters Type Name Description string expected Returns Type Description SamePathConstraint View Source SamePathOrUnder(string) Returns a constraint that tests whether the path provided is the same path or under an expected path after canonicalization. Declaration public static SamePathOrUnderConstraint SamePathOrUnder(string expected) Parameters Type Name Description string expected Returns Type Description SamePathOrUnderConstraint View Source SubPathOf(string) Returns a constraint that tests whether the path provided is a subpath of the expected path after canonicalization. Declaration public static SubPathConstraint SubPathOf(string expected) Parameters Type Name Description string expected Returns Type Description SubPathConstraint View Source SubsetOf(IEnumerable) Returns a constraint that tests whether the actual value is a subset of the collection supplied as an argument. Declaration public static CollectionSubsetConstraint SubsetOf(IEnumerable expected) Parameters Type Name Description IEnumerable expected Returns Type Description CollectionSubsetConstraint View Source SubsetOf<T>(IEnumerable<T>) Returns a constraint that tests whether the actual value is a subset of the collection supplied as an argument. Declaration public static CollectionSubsetConstraint SubsetOf<T>(IEnumerable<T> expected) Parameters Type Name Description IEnumerable<T> expected Returns Type Description CollectionSubsetConstraint Type Parameters Name Description T View Source SupersetOf(IEnumerable) Returns a constraint that tests whether the actual value is a superset of the collection supplied as an argument. Declaration public static CollectionSupersetConstraint SupersetOf(IEnumerable expected) Parameters Type Name Description IEnumerable expected Returns Type Description CollectionSupersetConstraint View Source SupersetOf<T>(IEnumerable<T>) Returns a constraint that tests whether the actual value is a superset of the collection supplied as an argument. Declaration public static CollectionSupersetConstraint SupersetOf<T>(IEnumerable<T> expected) Parameters Type Name Description IEnumerable<T> expected Returns Type Description CollectionSupersetConstraint Type Parameters Name Description T View Source TypeOf(Type) Returns a constraint that tests whether the actual value is of the exact type supplied as an argument. Declaration public static ExactTypeConstraint TypeOf(Type expectedType) Parameters Type Name Description Type expectedType Returns Type Description ExactTypeConstraint View Source TypeOf<TExpected>() Returns a constraint that tests whether the actual value is of the exact type supplied as an argument. Declaration public static ExactTypeConstraint TypeOf<TExpected>() Returns Type Description ExactTypeConstraint Type Parameters Name Description TExpected"
  },
  "api/NUnit.Framework.Iz.html": {
    "href": "api/NUnit.Framework.Iz.html",
    "title": "Class Iz | NUnit Docs",
    "summary": "Class Iz The Iz class is a synonym for Is intended for use in VB, which regards Is as a keyword. Inheritance object Is Iz Inherited Members Is.MultipleOf(int) Is.EqualTo(object) Is.EqualTo<T>(T) Is.EqualTo<T>(IEnumerable<T>) Is.EqualTo<T>(T[]) Is.EqualTo(string) Is.EqualTo(DateTimeOffset) Is.EqualTo(DateTime) Is.EqualTo(TimeSpan) Is.EqualTo(double) Is.EqualTo(float) Is.EqualTo(decimal) Is.EqualTo(long) Is.EqualTo(int) Is.EqualTo(short) Is.EqualTo(byte) Is.EqualTo(ulong) Is.EqualTo(uint) Is.EqualTo(ushort) Is.EqualTo(sbyte) Is.SameAs(object) Is.GreaterThan(object) Is.GreaterThanOrEqualTo(object) Is.AtLeast(object) Is.LessThan(object) Is.LessThanOrEqualTo(object) Is.AtMost(object) Is.TypeOf(Type) Is.TypeOf<TExpected>() Is.InstanceOf(Type) Is.InstanceOf<TExpected>() Is.AssignableFrom(Type) Is.AssignableFrom<TExpected>() Is.AssignableTo(Type) Is.AssignableTo<TExpected>() Is.EquivalentTo(IEnumerable) Is.EquivalentTo<T>(IEnumerable<T>) Is.SubsetOf(IEnumerable) Is.SubsetOf<T>(IEnumerable<T>) Is.SupersetOf(IEnumerable) Is.SupersetOf<T>(IEnumerable<T>) Is.SamePath(string) Is.SubPathOf(string) Is.SamePathOrUnder(string) Is.InRange(object, object) Is.AnyOf(params object[]) Is.AnyOf(ICollection) Is.Not Is.All Is.Null Is.Default Is.True Is.False Is.Positive Is.Negative Is.Zero Is.NaN Is.Even Is.Odd Is.Empty Is.WhiteSpace Is.Unique Is.XmlSerializable Is.Ordered object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework Assembly: nunit.framework.dll Syntax public abstract class Iz : Is Constructors View Source Iz() Declaration protected Iz()"
  },
  "api/NUnit.Framework.Legacy.ClassicAssert.html": {
    "href": "api/NUnit.Framework.Legacy.ClassicAssert.html",
    "title": "Class ClassicAssert | NUnit Docs",
    "summary": "Class ClassicAssert The Assert class contains a collection of static methods that implement the most common assertions used in NUnit. Inheritance object AssertBase Assert ClassicAssert Inherited Members Assert.Charlie() Assert.Pass(string) Assert.Pass() Assert.Fail(string) Assert.Fail() Assert.Warn(string) Assert.Ignore(string) Assert.Ignore() Assert.Inconclusive(string) Assert.Inconclusive() Assert.Multiple(TestDelegate) Assert.Multiple(AsyncTestDelegate) Assert.MultipleAsync(AsyncTestDelegate) Assert.EnterMultipleScope() Assert.ThrowsAsync(IResolveConstraint, AsyncTestDelegate, string, params object[]) Assert.ThrowsAsync(IResolveConstraint, AsyncTestDelegate) Assert.ThrowsAsync(Type, AsyncTestDelegate, string, params object[]) Assert.ThrowsAsync(Type, AsyncTestDelegate) Assert.ThrowsAsync<TActual>(AsyncTestDelegate, string, params object[]) Assert.ThrowsAsync<TActual>(AsyncTestDelegate) Assert.CatchAsync(AsyncTestDelegate, string, params object[]) Assert.CatchAsync(AsyncTestDelegate) Assert.CatchAsync(Type, AsyncTestDelegate, string, params object[]) Assert.CatchAsync(Type, AsyncTestDelegate) Assert.CatchAsync<TActual>(AsyncTestDelegate, string, params object[]) Assert.CatchAsync<TActual>(AsyncTestDelegate) Assert.DoesNotThrowAsync(AsyncTestDelegate, string, params object[]) Assert.DoesNotThrowAsync(AsyncTestDelegate) Assert.Throws(IResolveConstraint, TestDelegate, string, params object[]) Assert.Throws(IResolveConstraint, TestDelegate) Assert.Throws(Type, TestDelegate, string, params object[]) Assert.Throws(Type, TestDelegate) Assert.Throws<TActual>(TestDelegate, string, params object[]) Assert.Throws<TActual>(TestDelegate) Assert.Catch(TestDelegate, string, params object[]) Assert.Catch(TestDelegate) Assert.Catch(Type, TestDelegate, string, params object[]) Assert.Catch(Type, TestDelegate) Assert.Catch<TActual>(TestDelegate, string, params object[]) Assert.Catch<TActual>(TestDelegate) Assert.DoesNotThrow(TestDelegate, string, params object[]) Assert.DoesNotThrow(TestDelegate) Assert.That(bool, NUnitString, string) Assert.That(bool, FormattableString, string) Assert.That(bool, Func<string>, string) Assert.That(Func<bool>, NUnitString, string) Assert.That(Func<bool>, FormattableString, string) Assert.That(Func<bool>, Func<string>, string) Assert.That<TActual>(ActualValueDelegate<TActual>, IResolveConstraint, NUnitString, string, string) Assert.That<TActual>(ActualValueDelegate<TActual>, IResolveConstraint, FormattableString, string, string) Assert.That<TActual>(ActualValueDelegate<TActual>, IResolveConstraint, Func<string>, string, string) Assert.That(TestDelegate, IResolveConstraint, NUnitString, string, string) Assert.That(TestDelegate, IResolveConstraint, FormattableString, string, string) Assert.That(TestDelegate, IResolveConstraint, Func<string>, string, string) Assert.That<TActual>(TActual, IResolveConstraint, NUnitString, string, string) Assert.That<TActual>(TActual, IResolveConstraint, FormattableString, string, string) Assert.That<TActual>(TActual, IResolveConstraint, Func<string>, string, string) Assert.ByVal(object, IResolveConstraint, string, string, string) Assert.ThatAsync(AsyncTestDelegate, IResolveConstraint, NUnitString, string, string) Assert.ThatAsync(AsyncTestDelegate, IResolveConstraint, FormattableString, string, string) Assert.ThatAsync<T>(Func<Task<T>>, IResolveConstraint, NUnitString, string, string) Assert.ThatAsync<T>(Func<Task<T>>, IResolveConstraint, FormattableString, string, string) AssertBase.ConvertMessageWithArgs(string, object[]) object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework.Legacy Assembly: nunit.framework.legacy.dll Syntax public abstract class ClassicAssert : Assert Constructors View Source ClassicAssert() Declaration protected ClassicAssert() Methods View Source AreEqual(double, double, double) Verifies that two doubles are equal considering a delta. If the expected value is infinity then the delta value is ignored. Returns without throwing an exception when inside a multiple assert block. Declaration public static void AreEqual(double expected, double actual, double delta) Parameters Type Name Description double expected The expected value double actual The actual value double delta The maximum acceptable difference between the the expected and the actual View Source AreEqual(double, double, double, string, params object?[]?) Verifies that two doubles are equal considering a delta. If the expected value is infinity then the delta value is ignored. Returns without throwing an exception when inside a multiple assert block. Declaration public static void AreEqual(double expected, double actual, double delta, string message, params object?[]? args) Parameters Type Name Description double expected The expected value double actual The actual value double delta The maximum acceptable difference between the the expected and the actual string message The message to display in case of failure object[] args Array of objects to be used in formatting the message View Source AreEqual(object?, object?) Verifies that two objects are equal. Two objects are considered equal if both are null, or if both have the same value. NUnit has special semantics for some object types. Returns without throwing an exception when inside a multiple assert block. Declaration public static void AreEqual(object? expected, object? actual) Parameters Type Name Description object expected The value that is expected object actual The actual value View Source AreEqual(object?, object?, string, params object?[]?) Verifies that two objects are equal. Two objects are considered equal if both are null, or if both have the same value. NUnit has special semantics for some object types. Returns without throwing an exception when inside a multiple assert block. Declaration public static void AreEqual(object? expected, object? actual, string message, params object?[]? args) Parameters Type Name Description object expected The value that is expected object actual The actual value string message The message to display in case of failure object[] args Array of objects to be used in formatting the message View Source AreNotEqual(object?, object?) Verifies that two objects are not equal. Two objects are considered equal if both are null, or if both have the same value. NUnit has special semantics for some object types. Returns without throwing an exception when inside a multiple assert block. Declaration public static void AreNotEqual(object? expected, object? actual) Parameters Type Name Description object expected The value that is expected object actual The actual value View Source AreNotEqual(object?, object?, string, params object?[]?) Verifies that two objects are not equal. Two objects are considered equal if both are null, or if both have the same value. NUnit has special semantics for some object types. Returns without throwing an exception when inside a multiple assert block. Declaration public static void AreNotEqual(object? expected, object? actual, string message, params object?[]? args) Parameters Type Name Description object expected The value that is expected object actual The actual value string message The message to display in case of failure object[] args Array of objects to be used in formatting the message View Source AreNotSame(object?, object?) Asserts that two objects do not refer to the same object. Returns without throwing an exception when inside a multiple assert block. Declaration public static void AreNotSame(object? expected, object? actual) Parameters Type Name Description object expected The expected object object actual The actual object View Source AreNotSame(object?, object?, string, params object?[]?) Asserts that two objects do not refer to the same object. Returns without throwing an exception when inside a multiple assert block. Declaration public static void AreNotSame(object? expected, object? actual, string message, params object?[]? args) Parameters Type Name Description object expected The expected object object actual The actual object string message The message to display in case of failure object[] args Array of objects to be used in formatting the message View Source AreSame(object?, object?) Asserts that two objects refer to the same object. Returns without throwing an exception when inside a multiple assert block. Declaration public static void AreSame(object? expected, object? actual) Parameters Type Name Description object expected The expected object object actual The actual object View Source AreSame(object?, object?, string, params object?[]?) Asserts that two objects refer to the same object. Returns without throwing an exception when inside a multiple assert block. Declaration public static void AreSame(object? expected, object? actual, string message, params object?[]? args) Parameters Type Name Description object expected The expected object object actual The actual object string message The message to display in case of failure object[] args Array of objects to be used in formatting the message View Source AssertDoublesAreEqual(double, double, double, string, object?[]?) Helper for Assert.AreEqual(double expected, double actual, ...) allowing code generation to work consistently. Declaration protected static void AssertDoublesAreEqual(double expected, double actual, double delta, string message, object?[]? args) Parameters Type Name Description double expected The expected value double actual The actual value double delta The maximum acceptable difference between the the expected and the actual string message The message to display in case of failure object[] args Array of objects to be used in formatting the message View Source Contains(object?, ICollection?) Asserts that an object is contained in a collection. Returns without throwing an exception when inside a multiple assert block. Declaration public static void Contains(object? expected, ICollection? actual) Parameters Type Name Description object expected The expected object ICollection actual The collection to be examined View Source Contains(object?, ICollection?, string, params object?[]?) Asserts that an object is contained in a collection. Returns without throwing an exception when inside a multiple assert block. Declaration public static void Contains(object? expected, ICollection? actual, string message, params object?[]? args) Parameters Type Name Description object expected The expected object ICollection actual The collection to be examined string message The message to display in case of failure object[] args Array of objects to be used in formatting the message View Source False(bool) Asserts that a condition is false. Returns without throwing an exception when inside a multiple assert block. Declaration public static void False(bool condition) Parameters Type Name Description bool condition The evaluated condition View Source False(bool, string, params object?[]?) Asserts that a condition is false. Returns without throwing an exception when inside a multiple assert block. Declaration public static void False(bool condition, string message, params object?[]? args) Parameters Type Name Description bool condition The evaluated condition string message The message to display in case of failure object[] args Array of objects to be used in formatting the message View Source False(bool?) Asserts that a condition is false. Returns without throwing an exception when inside a multiple assert block. Declaration public static void False(bool? condition) Parameters Type Name Description bool? condition The evaluated condition View Source False(bool?, string, params object?[]?) Asserts that a condition is false. Returns without throwing an exception when inside a multiple assert block. Declaration public static void False(bool? condition, string message, params object?[]? args) Parameters Type Name Description bool? condition The evaluated condition string message The message to display in case of failure object[] args Array of objects to be used in formatting the message View Source Greater(decimal, decimal) Verifies that the first value is greater than the second value. If it is not, then an AssertionException is thrown. Declaration public static void Greater(decimal arg1, decimal arg2) Parameters Type Name Description decimal arg1 The first value, expected to be greater decimal arg2 The second value, expected to be less View Source Greater(decimal, decimal, string, params object[]) Verifies that the first value is greater than the second value. If it is not, then an AssertionException is thrown. Declaration public static void Greater(decimal arg1, decimal arg2, string message, params object[] args) Parameters Type Name Description decimal arg1 The first value, expected to be greater decimal arg2 The second value, expected to be less string message The message to display in case of failure object[] args Array of objects to be used in formatting the message View Source Greater(double, double) Verifies that the first value is greater than the second value. If it is not, then an AssertionException is thrown. Declaration public static void Greater(double arg1, double arg2) Parameters Type Name Description double arg1 The first value, expected to be greater double arg2 The second value, expected to be less View Source Greater(double, double, string, params object[]) Verifies that the first value is greater than the second value. If it is not, then an AssertionException is thrown. Declaration public static void Greater(double arg1, double arg2, string message, params object[] args) Parameters Type Name Description double arg1 The first value, expected to be greater double arg2 The second value, expected to be less string message The message to display in case of failure object[] args Array of objects to be used in formatting the message View Source Greater(IComparable, IComparable) Verifies that the first value is greater than the second value. If it is not, then an AssertionException is thrown. Declaration public static void Greater(IComparable arg1, IComparable arg2) Parameters Type Name Description IComparable arg1 The first value, expected to be greater IComparable arg2 The second value, expected to be less View Source Greater(IComparable, IComparable, string, params object[]) Verifies that the first value is greater than the second value. If it is not, then an AssertionException is thrown. Declaration public static void Greater(IComparable arg1, IComparable arg2, string message, params object[] args) Parameters Type Name Description IComparable arg1 The first value, expected to be greater IComparable arg2 The second value, expected to be less string message The message to display in case of failure object[] args Array of objects to be used in formatting the message View Source Greater(int, int) Verifies that the first int is greater than the second int. If it is not, then an AssertionException is thrown. Declaration public static void Greater(int arg1, int arg2) Parameters Type Name Description int arg1 The first value, expected to be greater int arg2 The second value, expected to be less View Source Greater(int, int, string, params object[]) Verifies that the first int is greater than the second int. If it is not, then an AssertionException is thrown. Declaration public static void Greater(int arg1, int arg2, string message, params object[] args) Parameters Type Name Description int arg1 The first value, expected to be greater int arg2 The second value, expected to be less string message The message to display in case of failure object[] args Array of objects to be used in formatting the message View Source Greater(long, long) Verifies that the first value is greater than the second value. If it is not, then an AssertionException is thrown. Declaration public static void Greater(long arg1, long arg2) Parameters Type Name Description long arg1 The first value, expected to be greater long arg2 The second value, expected to be less View Source Greater(long, long, string, params object[]) Verifies that the first value is greater than the second value. If it is not, then an AssertionException is thrown. Declaration public static void Greater(long arg1, long arg2, string message, params object[] args) Parameters Type Name Description long arg1 The first value, expected to be greater long arg2 The second value, expected to be less string message The message to display in case of failure object[] args Array of objects to be used in formatting the message View Source Greater(float, float) Verifies that the first value is greater than the second value. If it is not, then an AssertionException is thrown. Declaration public static void Greater(float arg1, float arg2) Parameters Type Name Description float arg1 The first value, expected to be greater float arg2 The second value, expected to be less View Source Greater(float, float, string, params object[]) Verifies that the first value is greater than the second value. If it is not, then an AssertionException is thrown. Declaration public static void Greater(float arg1, float arg2, string message, params object[] args) Parameters Type Name Description float arg1 The first value, expected to be greater float arg2 The second value, expected to be less string message The message to display in case of failure object[] args Array of objects to be used in formatting the message View Source Greater(uint, uint) Verifies that the first value is greater than the second value. If it is not, then an AssertionException is thrown. Declaration [CLSCompliant(false)] public static void Greater(uint arg1, uint arg2) Parameters Type Name Description uint arg1 The first value, expected to be greater uint arg2 The second value, expected to be less View Source Greater(uint, uint, string, params object[]) Verifies that the first value is greater than the second value. If it is not, then an AssertionException is thrown. Declaration [CLSCompliant(false)] public static void Greater(uint arg1, uint arg2, string message, params object[] args) Parameters Type Name Description uint arg1 The first value, expected to be greater uint arg2 The second value, expected to be less string message The message to display in case of failure object[] args Array of objects to be used in formatting the message View Source Greater(ulong, ulong) Verifies that the first value is greater than the second value. If it is not, then an AssertionException is thrown. Declaration [CLSCompliant(false)] public static void Greater(ulong arg1, ulong arg2) Parameters Type Name Description ulong arg1 The first value, expected to be greater ulong arg2 The second value, expected to be less View Source Greater(ulong, ulong, string, params object[]) Verifies that the first value is greater than the second value. If it is not, then an AssertionException is thrown. Declaration [CLSCompliant(false)] public static void Greater(ulong arg1, ulong arg2, string message, params object[] args) Parameters Type Name Description ulong arg1 The first value, expected to be greater ulong arg2 The second value, expected to be less string message The message to display in case of failure object[] args Array of objects to be used in formatting the message View Source GreaterOrEqual(decimal, decimal) Verifies that the first value is greater than or equal to the second value. If it is not, then an AssertionException is thrown. Declaration public static void GreaterOrEqual(decimal arg1, decimal arg2) Parameters Type Name Description decimal arg1 The first value, expected to be greater decimal arg2 The second value, expected to be less View Source GreaterOrEqual(decimal, decimal, string, params object[]) Verifies that the first value is greater than or equal to the second value. If it is not, then an AssertionException is thrown. Declaration public static void GreaterOrEqual(decimal arg1, decimal arg2, string message, params object[] args) Parameters Type Name Description decimal arg1 The first value, expected to be greater decimal arg2 The second value, expected to be less string message The message to display in case of failure object[] args Array of objects to be used in formatting the message View Source GreaterOrEqual(double, double) Verifies that the first value is greater than or equal to the second value. If it is not, then an AssertionException is thrown. Declaration public static void GreaterOrEqual(double arg1, double arg2) Parameters Type Name Description double arg1 The first value, expected to be greater double arg2 The second value, expected to be less View Source GreaterOrEqual(double, double, string, params object[]) Verifies that the first value is greater than or equal to the second value. If it is not, then an AssertionException is thrown. Declaration public static void GreaterOrEqual(double arg1, double arg2, string message, params object[] args) Parameters Type Name Description double arg1 The first value, expected to be greater double arg2 The second value, expected to be less string message The message to display in case of failure object[] args Array of objects to be used in formatting the message View Source GreaterOrEqual(IComparable, IComparable) Verifies that the first value is greater than or equal to the second value. If it is not, then an AssertionException is thrown. Declaration public static void GreaterOrEqual(IComparable arg1, IComparable arg2) Parameters Type Name Description IComparable arg1 The first value, expected to be greater IComparable arg2 The second value, expected to be less View Source GreaterOrEqual(IComparable, IComparable, string, params object[]) Verifies that the first value is greater than or equal to the second value. If it is not, then an AssertionException is thrown. Declaration public static void GreaterOrEqual(IComparable arg1, IComparable arg2, string message, params object[] args) Parameters Type Name Description IComparable arg1 The first value, expected to be greater IComparable arg2 The second value, expected to be less string message The message to display in case of failure object[] args Array of objects to be used in formatting the message View Source GreaterOrEqual(int, int) Verifies that the first value is greater than or equal to the second value. If it is not, then an AssertionException is thrown. Declaration public static void GreaterOrEqual(int arg1, int arg2) Parameters Type Name Description int arg1 The first value, expected to be greater int arg2 The second value, expected to be less View Source GreaterOrEqual(int, int, string, params object[]) Verifies that the first value is greater than or equal to the second value. If it is not, then an AssertionException is thrown. Declaration public static void GreaterOrEqual(int arg1, int arg2, string message, params object[] args) Parameters Type Name Description int arg1 The first value, expected to be greater int arg2 The second value, expected to be less string message The message to display in case of failure object[] args Array of objects to be used in formatting the message View Source GreaterOrEqual(long, long) Verifies that the first value is greater than or equal to the second value. If it is not, then an AssertionException is thrown. Declaration public static void GreaterOrEqual(long arg1, long arg2) Parameters Type Name Description long arg1 The first value, expected to be greater long arg2 The second value, expected to be less View Source GreaterOrEqual(long, long, string, params object[]) Verifies that the first value is greater than or equal to the second value. If it is not, then an AssertionException is thrown. Declaration public static void GreaterOrEqual(long arg1, long arg2, string message, params object[] args) Parameters Type Name Description long arg1 The first value, expected to be greater long arg2 The second value, expected to be less string message The message to display in case of failure object[] args Array of objects to be used in formatting the message View Source GreaterOrEqual(float, float) Verifies that the first value is greater than or equal to the second value. If it is not, then an AssertionException is thrown. Declaration public static void GreaterOrEqual(float arg1, float arg2) Parameters Type Name Description float arg1 The first value, expected to be greater float arg2 The second value, expected to be less View Source GreaterOrEqual(float, float, string, params object[]) Verifies that the first value is greater than or equal to the second value. If it is not, then an AssertionException is thrown. Declaration public static void GreaterOrEqual(float arg1, float arg2, string message, params object[] args) Parameters Type Name Description float arg1 The first value, expected to be greater float arg2 The second value, expected to be less string message The message to display in case of failure object[] args Array of objects to be used in formatting the message View Source GreaterOrEqual(uint, uint) Verifies that the first value is greater than or equal to the second value. If it is not, then an AssertionException is thrown. Declaration [CLSCompliant(false)] public static void GreaterOrEqual(uint arg1, uint arg2) Parameters Type Name Description uint arg1 The first value, expected to be greater uint arg2 The second value, expected to be less View Source GreaterOrEqual(uint, uint, string, params object[]) Verifies that the first value is greater than or equal to the second value. If it is not, then an AssertionException is thrown. Declaration [CLSCompliant(false)] public static void GreaterOrEqual(uint arg1, uint arg2, string message, params object[] args) Parameters Type Name Description uint arg1 The first value, expected to be greater uint arg2 The second value, expected to be less string message The message to display in case of failure object[] args Array of objects to be used in formatting the message View Source GreaterOrEqual(ulong, ulong) Verifies that the first value is greater than or equal to the second value. If it is not, then an AssertionException is thrown. Declaration [CLSCompliant(false)] public static void GreaterOrEqual(ulong arg1, ulong arg2) Parameters Type Name Description ulong arg1 The first value, expected to be greater ulong arg2 The second value, expected to be less View Source GreaterOrEqual(ulong, ulong, string, params object[]) Verifies that the first value is greater than or equal to the second value. If it is not, then an AssertionException is thrown. Declaration [CLSCompliant(false)] public static void GreaterOrEqual(ulong arg1, ulong arg2, string message, params object[] args) Parameters Type Name Description ulong arg1 The first value, expected to be greater ulong arg2 The second value, expected to be less string message The message to display in case of failure object[] args Array of objects to be used in formatting the message View Source IsAssignableFrom(Type, object?) Asserts that an object may be assigned a value of a given Type. Returns without throwing an exception when inside a multiple assert block. Declaration public static void IsAssignableFrom(Type expected, object? actual) Parameters Type Name Description Type expected The expected Type. object actual The object under examination View Source IsAssignableFrom(Type, object?, string, params object?[]?) Asserts that an object may be assigned a value of a given Type. Returns without throwing an exception when inside a multiple assert block. Declaration public static void IsAssignableFrom(Type expected, object? actual, string message, params object?[]? args) Parameters Type Name Description Type expected The expected Type. object actual The object under examination string message The message to display in case of failure object[] args Array of objects to be used in formatting the message View Source IsAssignableFrom<TExpected>(object?) Asserts that an object may be assigned a value of a given Type. Returns without throwing an exception when inside a multiple assert block. Declaration public static void IsAssignableFrom<TExpected>(object? actual) Parameters Type Name Description object actual The object under examination Type Parameters Name Description TExpected The expected Type. View Source IsAssignableFrom<TExpected>(object?, string, params object?[]?) Asserts that an object may be assigned a value of a given Type. Returns without throwing an exception when inside a multiple assert block. Declaration public static void IsAssignableFrom<TExpected>(object? actual, string message, params object?[]? args) Parameters Type Name Description object actual The object under examination string message The message to display in case of failure object[] args Array of objects to be used in formatting the message Type Parameters Name Description TExpected The expected Type. View Source IsEmpty(IEnumerable) Assert that an array, list or other collection is empty. Returns without throwing an exception when inside a multiple assert block. Declaration public static void IsEmpty(IEnumerable collection) Parameters Type Name Description IEnumerable collection An array, list or other collection implementing ICollection View Source IsEmpty(IEnumerable, string, params object?[]?) Assert that an array, list or other collection is empty. Returns without throwing an exception when inside a multiple assert block. Declaration public static void IsEmpty(IEnumerable collection, string message, params object?[]? args) Parameters Type Name Description IEnumerable collection An array, list or other collection implementing ICollection string message The message to display in case of failure object[] args Array of objects to be used in formatting the message View Source IsEmpty(string?) Assert that a string is empty. Returns without throwing an exception when inside a multiple assert block. Declaration public static void IsEmpty(string? aString) Parameters Type Name Description string aString The string to be tested View Source IsEmpty(string?, string, params object?[]?) Assert that a string is empty. Returns without throwing an exception when inside a multiple assert block. Declaration public static void IsEmpty(string? aString, string message, params object?[]? args) Parameters Type Name Description string aString The string to be tested string message The message to display in case of failure object[] args Array of objects to be used in formatting the message View Source IsFalse(bool) Asserts that a condition is false. Returns without throwing an exception when inside a multiple assert block. Declaration public static void IsFalse(bool condition) Parameters Type Name Description bool condition The evaluated condition View Source IsFalse(bool, string, params object?[]?) Asserts that a condition is false. Returns without throwing an exception when inside a multiple assert block. Declaration public static void IsFalse(bool condition, string message, params object?[]? args) Parameters Type Name Description bool condition The evaluated condition string message The message to display in case of failure object[] args Array of objects to be used in formatting the message View Source IsFalse(bool?) Asserts that a condition is false. Returns without throwing an exception when inside a multiple assert block. Declaration public static void IsFalse(bool? condition) Parameters Type Name Description bool? condition The evaluated condition View Source IsFalse(bool?, string, params object?[]?) Asserts that a condition is false. Returns without throwing an exception when inside a multiple assert block. Declaration public static void IsFalse(bool? condition, string message, params object?[]? args) Parameters Type Name Description bool? condition The evaluated condition string message The message to display in case of failure object[] args Array of objects to be used in formatting the message View Source IsInstanceOf(Type, object?) Asserts that an object is an instance of a given type. Returns without throwing an exception when inside a multiple assert block. Declaration public static void IsInstanceOf(Type expected, object? actual) Parameters Type Name Description Type expected The expected Type object actual The object being examined View Source IsInstanceOf(Type, object?, string, params object?[]?) Asserts that an object is an instance of a given type. Returns without throwing an exception when inside a multiple assert block. Declaration public static void IsInstanceOf(Type expected, object? actual, string message, params object?[]? args) Parameters Type Name Description Type expected The expected Type object actual The object being examined string message The message to display in case of failure object[] args Array of objects to be used in formatting the message View Source IsInstanceOf<TExpected>(object?) Asserts that an object is an instance of a given type. Returns without throwing an exception when inside a multiple assert block. Declaration public static void IsInstanceOf<TExpected>(object? actual) Parameters Type Name Description object actual The object being examined Type Parameters Name Description TExpected The expected Type View Source IsInstanceOf<TExpected>(object?, string, params object?[]?) Asserts that an object is an instance of a given type. Returns without throwing an exception when inside a multiple assert block. Declaration public static void IsInstanceOf<TExpected>(object? actual, string message, params object?[]? args) Parameters Type Name Description object actual The object being examined string message The message to display in case of failure object[] args Array of objects to be used in formatting the message Type Parameters Name Description TExpected The expected Type View Source IsNaN(double) Verifies that the double that is passed in is an NaN value. Returns without throwing an exception when inside a multiple assert block. Declaration public static void IsNaN(double aDouble) Parameters Type Name Description double aDouble The value that is to be tested View Source IsNaN(double, string, params object?[]?) Verifies that the double that is passed in is an NaN. Returns without throwing an exception when inside a multiple assert block. Declaration public static void IsNaN(double aDouble, string message, params object?[]? args) Parameters Type Name Description double aDouble The value that is to be tested string message The message to display in case of failure object[] args Array of objects to be used in formatting the message View Source IsNaN(double?) Verifies that the double that is passed in is an NaN value. Returns without throwing an exception when inside a multiple assert block. Declaration public static void IsNaN(double? aDouble) Parameters Type Name Description double? aDouble The value that is to be tested View Source IsNaN(double?, string, params object?[]?) Verifies that the double that is passed in is an NaN value. Returns without throwing an exception when inside a multiple assert block. Declaration public static void IsNaN(double? aDouble, string message, params object?[]? args) Parameters Type Name Description double? aDouble The value that is to be tested string message The message to display in case of failure object[] args Array of objects to be used in formatting the message View Source IsNotAssignableFrom(Type, object?) Asserts that an object may not be assigned a value of a given Type. Returns without throwing an exception when inside a multiple assert block. Declaration public static void IsNotAssignableFrom(Type expected, object? actual) Parameters Type Name Description Type expected The expected Type. object actual The object under examination View Source IsNotAssignableFrom(Type, object?, string, params object?[]?) Asserts that an object may not be assigned a value of a given Type. Returns without throwing an exception when inside a multiple assert block. Declaration public static void IsNotAssignableFrom(Type expected, object? actual, string message, params object?[]? args) Parameters Type Name Description Type expected The expected Type. object actual The object under examination string message The message to display in case of failure object[] args Array of objects to be used in formatting the message View Source IsNotAssignableFrom<TExpected>(object?) Asserts that an object may not be assigned a value of a given Type. Returns without throwing an exception when inside a multiple assert block. Declaration public static void IsNotAssignableFrom<TExpected>(object? actual) Parameters Type Name Description object actual The object under examination Type Parameters Name Description TExpected The expected Type. View Source IsNotAssignableFrom<TExpected>(object?, string, params object?[]?) Asserts that an object may not be assigned a value of a given Type. Returns without throwing an exception when inside a multiple assert block. Declaration public static void IsNotAssignableFrom<TExpected>(object? actual, string message, params object?[]? args) Parameters Type Name Description object actual The object under examination string message The message to display in case of failure object[] args Array of objects to be used in formatting the message Type Parameters Name Description TExpected The expected Type. View Source IsNotEmpty(IEnumerable) Assert that an array, list or other collection is not empty. Returns without throwing an exception when inside a multiple assert block. Declaration public static void IsNotEmpty(IEnumerable collection) Parameters Type Name Description IEnumerable collection An array, list or other collection implementing ICollection View Source IsNotEmpty(IEnumerable, string, params object?[]?) Assert that an array, list or other collection is not empty. Returns without throwing an exception when inside a multiple assert block. Declaration public static void IsNotEmpty(IEnumerable collection, string message, params object?[]? args) Parameters Type Name Description IEnumerable collection An array, list or other collection implementing ICollection string message The message to display in case of failure object[] args Array of objects to be used in formatting the message View Source IsNotEmpty(string?) Assert that a string is not empty. Returns without throwing an exception when inside a multiple assert block. Declaration public static void IsNotEmpty(string? aString) Parameters Type Name Description string aString The string to be tested View Source IsNotEmpty(string?, string, params object?[]?) Assert that a string is not empty. Returns without throwing an exception when inside a multiple assert block. Declaration public static void IsNotEmpty(string? aString, string message, params object?[]? args) Parameters Type Name Description string aString The string to be tested string message The message to display in case of failure object[] args Array of objects to be used in formatting the message View Source IsNotInstanceOf(Type, object?) Asserts that an object is not an instance of a given type. Returns without throwing an exception when inside a multiple assert block. Declaration public static void IsNotInstanceOf(Type expected, object? actual) Parameters Type Name Description Type expected The expected Type object actual The object being examined View Source IsNotInstanceOf(Type, object?, string, params object?[]?) Asserts that an object is not an instance of a given type. Returns without throwing an exception when inside a multiple assert block. Declaration public static void IsNotInstanceOf(Type expected, object? actual, string message, params object?[]? args) Parameters Type Name Description Type expected The expected Type object actual The object being examined string message The message to display in case of failure object[] args Array of objects to be used in formatting the message View Source IsNotInstanceOf<TExpected>(object?) Asserts that an object is not an instance of a given type. Returns without throwing an exception when inside a multiple assert block. Declaration public static void IsNotInstanceOf<TExpected>(object? actual) Parameters Type Name Description object actual The object being examined Type Parameters Name Description TExpected The expected Type View Source IsNotInstanceOf<TExpected>(object?, string, params object?[]?) Asserts that an object is not an instance of a given type. Returns without throwing an exception when inside a multiple assert block. Declaration public static void IsNotInstanceOf<TExpected>(object? actual, string message, params object?[]? args) Parameters Type Name Description object actual The object being examined string message The message to display in case of failure object[] args Array of objects to be used in formatting the message Type Parameters Name Description TExpected The expected Type View Source IsNotNull(object?) Verifies that the object that is passed in is not equal to null. Returns without throwing an exception when inside a multiple assert block. Declaration public static void IsNotNull(object? anObject) Parameters Type Name Description object anObject The object that is to be tested View Source IsNotNull(object?, string, params object?[]?) Verifies that the object that is passed in is not equal to null. Returns without throwing an exception when inside a multiple assert block. Declaration public static void IsNotNull(object? anObject, string message, params object?[]? args) Parameters Type Name Description object anObject The object that is to be tested string message The message to display in case of failure object[] args Array of objects to be used in formatting the message View Source IsNull(object?) Verifies that the object that is passed in is equal to null. Returns without throwing an exception when inside a multiple assert block. Declaration public static void IsNull(object? anObject) Parameters Type Name Description object anObject The object that is to be tested View Source IsNull(object?, string, params object?[]?) Verifies that the object that is passed in is equal to null. Returns without throwing an exception when inside a multiple assert block. Declaration public static void IsNull(object? anObject, string message, params object?[]? args) Parameters Type Name Description object anObject The object that is to be tested string message The message to display in case of failure object[] args Array of objects to be used in formatting the message View Source IsTrue(bool) Asserts that a condition is true. Returns without throwing an exception when inside a multiple assert block. Declaration public static void IsTrue(bool condition) Parameters Type Name Description bool condition The evaluated condition View Source IsTrue(bool, string, params object?[]?) Asserts that a condition is true. Returns without throwing an exception when inside a multiple assert block. Declaration public static void IsTrue(bool condition, string message, params object?[]? args) Parameters Type Name Description bool condition The evaluated condition string message The message to display in case of failure object[] args Array of objects to be used in formatting the message View Source IsTrue(bool?) Asserts that a condition is true. Returns without throwing an exception when inside a multiple assert block. Declaration public static void IsTrue(bool? condition) Parameters Type Name Description bool? condition The evaluated condition View Source IsTrue(bool?, string, params object?[]?) Asserts that a condition is true. Returns without throwing an exception when inside a multiple assert block. Declaration public static void IsTrue(bool? condition, string message, params object?[]? args) Parameters Type Name Description bool? condition The evaluated condition string message The message to display in case of failure object[] args Array of objects to be used in formatting the message View Source Less(decimal, decimal) Verifies that the first value is less than the second value. If it is not, then an AssertionException is thrown. Declaration public static void Less(decimal arg1, decimal arg2) Parameters Type Name Description decimal arg1 The first value, expected to be less decimal arg2 The second value, expected to be greater View Source Less(decimal, decimal, string, params object[]) Verifies that the first value is less than the second value. If it is not, then an AssertionException is thrown. Declaration public static void Less(decimal arg1, decimal arg2, string message, params object[] args) Parameters Type Name Description decimal arg1 The first value, expected to be less decimal arg2 The second value, expected to be greater string message The message to display in case of failure object[] args Array of objects to be used in formatting the message View Source Less(double, double) Verifies that the first value is less than the second value. If it is not, then an AssertionException is thrown. Declaration public static void Less(double arg1, double arg2) Parameters Type Name Description double arg1 The first value, expected to be less double arg2 The second value, expected to be greater View Source Less(double, double, string, params object[]) Verifies that the first value is less than the second value. If it is not, then an AssertionException is thrown. Declaration public static void Less(double arg1, double arg2, string message, params object[] args) Parameters Type Name Description double arg1 The first value, expected to be less double arg2 The second value, expected to be greater string message The message to display in case of failure object[] args Array of objects to be used in formatting the message View Source Less(IComparable, IComparable) Verifies that the first value is less than the second value. If it is not, then an AssertionException is thrown. Declaration public static void Less(IComparable arg1, IComparable arg2) Parameters Type Name Description IComparable arg1 The first value, expected to be less IComparable arg2 The second value, expected to be greater View Source Less(IComparable, IComparable, string, params object[]) Verifies that the first value is less than the second value. If it is not, then an AssertionException is thrown. Declaration public static void Less(IComparable arg1, IComparable arg2, string message, params object[] args) Parameters Type Name Description IComparable arg1 The first value, expected to be less IComparable arg2 The second value, expected to be greater string message The message to display in case of failure object[] args Array of objects to be used in formatting the message View Source Less(int, int) Verifies that the first value is less than the second value. If it is not, then an AssertionException is thrown. Declaration public static void Less(int arg1, int arg2) Parameters Type Name Description int arg1 The first value, expected to be less int arg2 The second value, expected to be greater View Source Less(int, int, string, params object[]) Verifies that the first value is less than the second value. If it is not, then an AssertionException is thrown. Declaration public static void Less(int arg1, int arg2, string message, params object[] args) Parameters Type Name Description int arg1 The first value, expected to be less int arg2 The second value, expected to be greater string message The message to display in case of failure object[] args Array of objects to be used in formatting the message View Source Less(long, long) Verifies that the first value is less than the second value. If it is not, then an AssertionException is thrown. Declaration public static void Less(long arg1, long arg2) Parameters Type Name Description long arg1 The first value, expected to be less long arg2 The second value, expected to be greater View Source Less(long, long, string, params object[]) Verifies that the first value is less than the second value. If it is not, then an AssertionException is thrown. Declaration public static void Less(long arg1, long arg2, string message, params object[] args) Parameters Type Name Description long arg1 The first value, expected to be less long arg2 The second value, expected to be greater string message The message to display in case of failure object[] args Array of objects to be used in formatting the message View Source Less(float, float) Verifies that the first value is less than the second value. If it is not, then an AssertionException is thrown. Declaration public static void Less(float arg1, float arg2) Parameters Type Name Description float arg1 The first value, expected to be less float arg2 The second value, expected to be greater View Source Less(float, float, string, params object[]) Verifies that the first value is less than the second value. If it is not, then an AssertionException is thrown. Declaration public static void Less(float arg1, float arg2, string message, params object[] args) Parameters Type Name Description float arg1 The first value, expected to be less float arg2 The second value, expected to be greater string message The message to display in case of failure object[] args Array of objects to be used in formatting the message View Source Less(uint, uint) Verifies that the first value is less than the second value. If it is not, then an AssertionException is thrown. Declaration [CLSCompliant(false)] public static void Less(uint arg1, uint arg2) Parameters Type Name Description uint arg1 The first value, expected to be less uint arg2 The second value, expected to be greater View Source Less(uint, uint, string, params object[]) Verifies that the first value is less than the second value. If it is not, then an AssertionException is thrown. Declaration [CLSCompliant(false)] public static void Less(uint arg1, uint arg2, string message, params object[] args) Parameters Type Name Description uint arg1 The first value, expected to be less uint arg2 The second value, expected to be greater string message The message to display in case of failure object[] args Array of objects to be used in formatting the message View Source Less(ulong, ulong) Verifies that the first value is less than the second value. If it is not, then an AssertionException is thrown. Declaration [CLSCompliant(false)] public static void Less(ulong arg1, ulong arg2) Parameters Type Name Description ulong arg1 The first value, expected to be less ulong arg2 The second value, expected to be greater View Source Less(ulong, ulong, string, params object[]) Verifies that the first value is less than the second value. If it is not, then an AssertionException is thrown. Declaration [CLSCompliant(false)] public static void Less(ulong arg1, ulong arg2, string message, params object[] args) Parameters Type Name Description ulong arg1 The first value, expected to be less ulong arg2 The second value, expected to be greater string message The message to display in case of failure object[] args Array of objects to be used in formatting the message View Source LessOrEqual(decimal, decimal) Verifies that the first value is less than or equal to the second value. If it is not, then an AssertionException is thrown. Declaration public static void LessOrEqual(decimal arg1, decimal arg2) Parameters Type Name Description decimal arg1 The first value, expected to be less decimal arg2 The second value, expected to be greater View Source LessOrEqual(decimal, decimal, string, params object[]) Verifies that the first value is less than or equal to the second value. If it is not, then an AssertionException is thrown. Declaration public static void LessOrEqual(decimal arg1, decimal arg2, string message, params object[] args) Parameters Type Name Description decimal arg1 The first value, expected to be less decimal arg2 The second value, expected to be greater string message The message to display in case of failure object[] args Array of objects to be used in formatting the message View Source LessOrEqual(double, double) Verifies that the first value is less than or equal to the second value. If it is not, then an AssertionException is thrown. Declaration public static void LessOrEqual(double arg1, double arg2) Parameters Type Name Description double arg1 The first value, expected to be less double arg2 The second value, expected to be greater View Source LessOrEqual(double, double, string, params object[]) Verifies that the first value is less than or equal to the second value. If it is not, then an AssertionException is thrown. Declaration public static void LessOrEqual(double arg1, double arg2, string message, params object[] args) Parameters Type Name Description double arg1 The first value, expected to be less double arg2 The second value, expected to be greater string message The message to display in case of failure object[] args Array of objects to be used in formatting the message View Source LessOrEqual(IComparable, IComparable) Verifies that the first value is less than or equal to the second value. If it is not, then an AssertionException is thrown. Declaration public static void LessOrEqual(IComparable arg1, IComparable arg2) Parameters Type Name Description IComparable arg1 The first value, expected to be less IComparable arg2 The second value, expected to be greater View Source LessOrEqual(IComparable, IComparable, string, params object[]) Verifies that the first value is less than or equal to the second value. If it is not, then an AssertionException is thrown. Declaration public static void LessOrEqual(IComparable arg1, IComparable arg2, string message, params object[] args) Parameters Type Name Description IComparable arg1 The first value, expected to be less IComparable arg2 The second value, expected to be greater string message The message to display in case of failure object[] args Array of objects to be used in formatting the message View Source LessOrEqual(int, int) Verifies that the first value is less than or equal to the second value. If it is not, then an AssertionException is thrown. Declaration public static void LessOrEqual(int arg1, int arg2) Parameters Type Name Description int arg1 The first value, expected to be less int arg2 The second value, expected to be greater View Source LessOrEqual(int, int, string, params object[]) Verifies that the first value is less than or equal to the second value. If it is not, then an AssertionException is thrown. Declaration public static void LessOrEqual(int arg1, int arg2, string message, params object[] args) Parameters Type Name Description int arg1 The first value, expected to be less int arg2 The second value, expected to be greater string message The message to display in case of failure object[] args Array of objects to be used in formatting the message View Source LessOrEqual(long, long) Verifies that the first value is less than or equal to the second value. If it is not, then an AssertionException is thrown. Declaration public static void LessOrEqual(long arg1, long arg2) Parameters Type Name Description long arg1 The first value, expected to be less long arg2 The second value, expected to be greater View Source LessOrEqual(long, long, string, params object[]) Verifies that the first value is less than or equal to the second value. If it is not, then an AssertionException is thrown. Declaration public static void LessOrEqual(long arg1, long arg2, string message, params object[] args) Parameters Type Name Description long arg1 The first value, expected to be less long arg2 The second value, expected to be greater string message The message to display in case of failure object[] args Array of objects to be used in formatting the message View Source LessOrEqual(float, float) Verifies that the first value is less than or equal to the second value. If it is not, then an AssertionException is thrown. Declaration public static void LessOrEqual(float arg1, float arg2) Parameters Type Name Description float arg1 The first value, expected to be less float arg2 The second value, expected to be greater View Source LessOrEqual(float, float, string, params object[]) Verifies that the first value is less than or equal to the second value. If it is not, then an AssertionException is thrown. Declaration public static void LessOrEqual(float arg1, float arg2, string message, params object[] args) Parameters Type Name Description float arg1 The first value, expected to be less float arg2 The second value, expected to be greater string message The message to display in case of failure object[] args Array of objects to be used in formatting the message View Source LessOrEqual(uint, uint) Verifies that the first value is less than or equal to the second value. If it is not, then an AssertionException is thrown. Declaration [CLSCompliant(false)] public static void LessOrEqual(uint arg1, uint arg2) Parameters Type Name Description uint arg1 The first value, expected to be less uint arg2 The second value, expected to be greater View Source LessOrEqual(uint, uint, string, params object[]) Verifies that the first value is less than or equal to the second value. If it is not, then an AssertionException is thrown. Declaration [CLSCompliant(false)] public static void LessOrEqual(uint arg1, uint arg2, string message, params object[] args) Parameters Type Name Description uint arg1 The first value, expected to be less uint arg2 The second value, expected to be greater string message The message to display in case of failure object[] args Array of objects to be used in formatting the message View Source LessOrEqual(ulong, ulong) Verifies that the first value is less than or equal to the second value. If it is not, then an AssertionException is thrown. Declaration [CLSCompliant(false)] public static void LessOrEqual(ulong arg1, ulong arg2) Parameters Type Name Description ulong arg1 The first value, expected to be less ulong arg2 The second value, expected to be greater View Source LessOrEqual(ulong, ulong, string, params object[]) Verifies that the first value is less than or equal to the second value. If it is not, then an AssertionException is thrown. Declaration [CLSCompliant(false)] public static void LessOrEqual(ulong arg1, ulong arg2, string message, params object[] args) Parameters Type Name Description ulong arg1 The first value, expected to be less ulong arg2 The second value, expected to be greater string message The message to display in case of failure object[] args Array of objects to be used in formatting the message View Source Negative(decimal) Asserts that a decimal is negative. Returns without throwing an exception when inside a multiple assert block. Declaration public static void Negative(decimal actual) Parameters Type Name Description decimal actual The number to be examined View Source Negative(decimal, string, params object?[]?) Asserts that a decimal is negative. Returns without throwing an exception when inside a multiple assert block. Declaration public static void Negative(decimal actual, string message, params object?[]? args) Parameters Type Name Description decimal actual The number to be examined string message The message to display in case of failure object[] args Array of objects to be used in formatting the message View Source Negative(double) Asserts that a double is negative. Returns without throwing an exception when inside a multiple assert block. Declaration public static void Negative(double actual) Parameters Type Name Description double actual The number to be examined View Source Negative(double, string, params object?[]?) Asserts that a double is negative. Returns without throwing an exception when inside a multiple assert block. Declaration public static void Negative(double actual, string message, params object?[]? args) Parameters Type Name Description double actual The number to be examined string message The message to display in case of failure object[] args Array of objects to be used in formatting the message View Source Negative(int) Asserts that an int is negative. Returns without throwing an exception when inside a multiple assert block. Declaration public static void Negative(int actual) Parameters Type Name Description int actual The number to be examined View Source Negative(int, string, params object?[]?) Asserts that an int is negative. Returns without throwing an exception when inside a multiple assert block. Declaration public static void Negative(int actual, string message, params object?[]? args) Parameters Type Name Description int actual The number to be examined string message The message to display in case of failure object[] args Array of objects to be used in formatting the message View Source Negative(long) Asserts that a Long is negative. Returns without throwing an exception when inside a multiple assert block. Declaration public static void Negative(long actual) Parameters Type Name Description long actual The number to be examined View Source Negative(long, string, params object?[]?) Asserts that a Long is negative. Returns without throwing an exception when inside a multiple assert block. Declaration public static void Negative(long actual, string message, params object?[]? args) Parameters Type Name Description long actual The number to be examined string message The message to display in case of failure object[] args Array of objects to be used in formatting the message View Source Negative(float) Asserts that a float is negative. Returns without throwing an exception when inside a multiple assert block. Declaration public static void Negative(float actual) Parameters Type Name Description float actual The number to be examined View Source Negative(float, string, params object?[]?) Asserts that a float is negative. Returns without throwing an exception when inside a multiple assert block. Declaration public static void Negative(float actual, string message, params object?[]? args) Parameters Type Name Description float actual The number to be examined string message The message to display in case of failure object[] args Array of objects to be used in formatting the message View Source Negative(uint) Asserts that an unsigned int is negative. Returns without throwing an exception when inside a multiple assert block. Declaration [CLSCompliant(false)] public static void Negative(uint actual) Parameters Type Name Description uint actual The number to be examined View Source Negative(uint, string, params object?[]?) Asserts that an unsigned int is negative. Returns without throwing an exception when inside a multiple assert block. Declaration [CLSCompliant(false)] public static void Negative(uint actual, string message, params object?[]? args) Parameters Type Name Description uint actual The number to be examined string message The message to display in case of failure object[] args Array of objects to be used in formatting the message View Source Negative(ulong) Asserts that an unsigned Long is negative. Returns without throwing an exception when inside a multiple assert block. Declaration [CLSCompliant(false)] public static void Negative(ulong actual) Parameters Type Name Description ulong actual The number to be examined View Source Negative(ulong, string, params object?[]?) Asserts that an unsigned Long is negative. Returns without throwing an exception when inside a multiple assert block. Declaration [CLSCompliant(false)] public static void Negative(ulong actual, string message, params object?[]? args) Parameters Type Name Description ulong actual The number to be examined string message The message to display in case of failure object[] args Array of objects to be used in formatting the message View Source NotNull(object?) Verifies that the object that is passed in is not equal to null. Returns without throwing an exception when inside a multiple assert block. Declaration public static void NotNull(object? anObject) Parameters Type Name Description object anObject The object that is to be tested View Source NotNull(object?, string, params object?[]?) Verifies that the object that is passed in is not equal to null. Returns without throwing an exception when inside a multiple assert block. Declaration public static void NotNull(object? anObject, string message, params object?[]? args) Parameters Type Name Description object anObject The object that is to be tested string message The message to display in case of failure object[] args Array of objects to be used in formatting the message View Source NotZero(decimal) Asserts that a decimal is not zero. Returns without throwing an exception when inside a multiple assert block. Declaration public static void NotZero(decimal actual) Parameters Type Name Description decimal actual The number to be examined View Source NotZero(decimal, string, params object?[]?) Asserts that a decimal is not zero. Returns without throwing an exception when inside a multiple assert block. Declaration public static void NotZero(decimal actual, string message, params object?[]? args) Parameters Type Name Description decimal actual The number to be examined string message The message to display in case of failure object[] args Array of objects to be used in formatting the message View Source NotZero(double) Asserts that a double is not zero. Returns without throwing an exception when inside a multiple assert block. Declaration public static void NotZero(double actual) Parameters Type Name Description double actual The number to be examined View Source NotZero(double, string, params object?[]?) Asserts that a double is not zero. Returns without throwing an exception when inside a multiple assert block. Declaration public static void NotZero(double actual, string message, params object?[]? args) Parameters Type Name Description double actual The number to be examined string message The message to display in case of failure object[] args Array of objects to be used in formatting the message View Source NotZero(int) Asserts that an int is not zero. Returns without throwing an exception when inside a multiple assert block. Declaration public static void NotZero(int actual) Parameters Type Name Description int actual The number to be examined View Source NotZero(int, string, params object?[]?) Asserts that an int is not zero. Returns without throwing an exception when inside a multiple assert block. Declaration public static void NotZero(int actual, string message, params object?[]? args) Parameters Type Name Description int actual The number to be examined string message The message to display in case of failure object[] args Array of objects to be used in formatting the message View Source NotZero(long) Asserts that a Long is not zero. Returns without throwing an exception when inside a multiple assert block. Declaration public static void NotZero(long actual) Parameters Type Name Description long actual The number to be examined View Source NotZero(long, string, params object?[]?) Asserts that a Long is not zero. Returns without throwing an exception when inside a multiple assert block. Declaration public static void NotZero(long actual, string message, params object?[]? args) Parameters Type Name Description long actual The number to be examined string message The message to display in case of failure object[] args Array of objects to be used in formatting the message View Source NotZero(float) Asserts that a float is not zero. Returns without throwing an exception when inside a multiple assert block. Declaration public static void NotZero(float actual) Parameters Type Name Description float actual The number to be examined View Source NotZero(float, string, params object?[]?) Asserts that a float is not zero. Returns without throwing an exception when inside a multiple assert block. Declaration public static void NotZero(float actual, string message, params object?[]? args) Parameters Type Name Description float actual The number to be examined string message The message to display in case of failure object[] args Array of objects to be used in formatting the message View Source NotZero(uint) Asserts that an unsigned int is not zero. Returns without throwing an exception when inside a multiple assert block. Declaration [CLSCompliant(false)] public static void NotZero(uint actual) Parameters Type Name Description uint actual The number to be examined View Source NotZero(uint, string, params object?[]?) Asserts that an unsigned int is not zero. Returns without throwing an exception when inside a multiple assert block. Declaration [CLSCompliant(false)] public static void NotZero(uint actual, string message, params object?[]? args) Parameters Type Name Description uint actual The number to be examined string message The message to display in case of failure object[] args Array of objects to be used in formatting the message View Source NotZero(ulong) Asserts that an unsigned Long is not zero. Returns without throwing an exception when inside a multiple assert block. Declaration [CLSCompliant(false)] public static void NotZero(ulong actual) Parameters Type Name Description ulong actual The number to be examined View Source NotZero(ulong, string, params object?[]?) Asserts that an unsigned Long is not zero. Returns without throwing an exception when inside a multiple assert block. Declaration [CLSCompliant(false)] public static void NotZero(ulong actual, string message, params object?[]? args) Parameters Type Name Description ulong actual The number to be examined string message The message to display in case of failure object[] args Array of objects to be used in formatting the message View Source Null(object?) Verifies that the object that is passed in is equal to null. Returns without throwing an exception when inside a multiple assert block. Declaration public static void Null(object? anObject) Parameters Type Name Description object anObject The object that is to be tested View Source Null(object?, string, params object?[]?) Verifies that the object that is passed in is equal to null. Returns without throwing an exception when inside a multiple assert block. Declaration public static void Null(object? anObject, string message, params object?[]? args) Parameters Type Name Description object anObject The object that is to be tested string message The message to display in case of failure object[] args Array of objects to be used in formatting the message View Source Positive(decimal) Asserts that a decimal is positive. Returns without throwing an exception when inside a multiple assert block. Declaration public static void Positive(decimal actual) Parameters Type Name Description decimal actual The number to be examined View Source Positive(decimal, string, params object?[]?) Asserts that a decimal is positive. Returns without throwing an exception when inside a multiple assert block. Declaration public static void Positive(decimal actual, string message, params object?[]? args) Parameters Type Name Description decimal actual The number to be examined string message The message to display in case of failure object[] args Array of objects to be used in formatting the message View Source Positive(double) Asserts that a double is positive. Returns without throwing an exception when inside a multiple assert block. Declaration public static void Positive(double actual) Parameters Type Name Description double actual The number to be examined View Source Positive(double, string, params object?[]?) Asserts that a double is positive. Returns without throwing an exception when inside a multiple assert block. Declaration public static void Positive(double actual, string message, params object?[]? args) Parameters Type Name Description double actual The number to be examined string message The message to display in case of failure object[] args Array of objects to be used in formatting the message View Source Positive(int) Asserts that an int is positive. Returns without throwing an exception when inside a multiple assert block. Declaration public static void Positive(int actual) Parameters Type Name Description int actual The number to be examined View Source Positive(int, string, params object?[]?) Asserts that an int is positive. Returns without throwing an exception when inside a multiple assert block. Declaration public static void Positive(int actual, string message, params object?[]? args) Parameters Type Name Description int actual The number to be examined string message The message to display in case of failure object[] args Array of objects to be used in formatting the message View Source Positive(long) Asserts that a Long is positive. Returns without throwing an exception when inside a multiple assert block. Declaration public static void Positive(long actual) Parameters Type Name Description long actual The number to be examined View Source Positive(long, string, params object?[]?) Asserts that a Long is positive. Returns without throwing an exception when inside a multiple assert block. Declaration public static void Positive(long actual, string message, params object?[]? args) Parameters Type Name Description long actual The number to be examined string message The message to display in case of failure object[] args Array of objects to be used in formatting the message View Source Positive(float) Asserts that a float is positive. Returns without throwing an exception when inside a multiple assert block. Declaration public static void Positive(float actual) Parameters Type Name Description float actual The number to be examined View Source Positive(float, string, params object?[]?) Asserts that a float is positive. Returns without throwing an exception when inside a multiple assert block. Declaration public static void Positive(float actual, string message, params object?[]? args) Parameters Type Name Description float actual The number to be examined string message The message to display in case of failure object[] args Array of objects to be used in formatting the message View Source Positive(uint) Asserts that an unsigned int is positive. Returns without throwing an exception when inside a multiple assert block. Declaration [CLSCompliant(false)] public static void Positive(uint actual) Parameters Type Name Description uint actual The number to be examined View Source Positive(uint, string, params object?[]?) Asserts that an unsigned int is positive. Returns without throwing an exception when inside a multiple assert block. Declaration [CLSCompliant(false)] public static void Positive(uint actual, string message, params object?[]? args) Parameters Type Name Description uint actual The number to be examined string message The message to display in case of failure object[] args Array of objects to be used in formatting the message View Source Positive(ulong) Asserts that an unsigned Long is positive. Returns without throwing an exception when inside a multiple assert block. Declaration [CLSCompliant(false)] public static void Positive(ulong actual) Parameters Type Name Description ulong actual The number to be examined View Source Positive(ulong, string, params object?[]?) Asserts that an unsigned Long is positive. Returns without throwing an exception when inside a multiple assert block. Declaration [CLSCompliant(false)] public static void Positive(ulong actual, string message, params object?[]? args) Parameters Type Name Description ulong actual The number to be examined string message The message to display in case of failure object[] args Array of objects to be used in formatting the message View Source True(bool) Asserts that a condition is true. Returns without throwing an exception when inside a multiple assert block. Declaration public static void True(bool condition) Parameters Type Name Description bool condition The evaluated condition View Source True(bool, string, params object?[]?) Asserts that a condition is true. Returns without throwing an exception when inside a multiple assert block. Declaration public static void True(bool condition, string message, params object?[]? args) Parameters Type Name Description bool condition The evaluated condition string message The message to display in case of failure object[] args Array of objects to be used in formatting the message View Source True(bool?) Asserts that a condition is true. Returns without throwing an exception when inside a multiple assert block. Declaration public static void True(bool? condition) Parameters Type Name Description bool? condition The evaluated condition View Source True(bool?, string, params object?[]?) Asserts that a condition is true. Returns without throwing an exception when inside a multiple assert block. Declaration public static void True(bool? condition, string message, params object?[]? args) Parameters Type Name Description bool? condition The evaluated condition string message The message to display in case of failure object[] args Array of objects to be used in formatting the message View Source Zero(decimal) Asserts that a decimal is zero. Returns without throwing an exception when inside a multiple assert block. Declaration public static void Zero(decimal actual) Parameters Type Name Description decimal actual The number to be examined View Source Zero(decimal, string, params object?[]?) Asserts that a decimal is zero. Returns without throwing an exception when inside a multiple assert block. Declaration public static void Zero(decimal actual, string message, params object?[]? args) Parameters Type Name Description decimal actual The number to be examined string message The message to display in case of failure object[] args Array of objects to be used in formatting the message View Source Zero(double) Asserts that a double is zero. Returns without throwing an exception when inside a multiple assert block. Declaration public static void Zero(double actual) Parameters Type Name Description double actual The number to be examined View Source Zero(double, string, params object?[]?) Asserts that a double is zero. Returns without throwing an exception when inside a multiple assert block. Declaration public static void Zero(double actual, string message, params object?[]? args) Parameters Type Name Description double actual The number to be examined string message The message to display in case of failure object[] args Array of objects to be used in formatting the message View Source Zero(int) Asserts that an int is zero. Returns without throwing an exception when inside a multiple assert block. Declaration public static void Zero(int actual) Parameters Type Name Description int actual The number to be examined View Source Zero(int, string, params object?[]?) Asserts that an int is zero. Returns without throwing an exception when inside a multiple assert block. Declaration public static void Zero(int actual, string message, params object?[]? args) Parameters Type Name Description int actual The number to be examined string message The message to display in case of failure object[] args Array of objects to be used in formatting the message View Source Zero(long) Asserts that a Long is zero. Returns without throwing an exception when inside a multiple assert block. Declaration public static void Zero(long actual) Parameters Type Name Description long actual The number to be examined View Source Zero(long, string, params object?[]?) Asserts that a Long is zero. Returns without throwing an exception when inside a multiple assert block. Declaration public static void Zero(long actual, string message, params object?[]? args) Parameters Type Name Description long actual The number to be examined string message The message to display in case of failure object[] args Array of objects to be used in formatting the message View Source Zero(float) Asserts that a float is zero. Returns without throwing an exception when inside a multiple assert block. Declaration public static void Zero(float actual) Parameters Type Name Description float actual The number to be examined View Source Zero(float, string, params object?[]?) Asserts that a float is zero. Returns without throwing an exception when inside a multiple assert block. Declaration public static void Zero(float actual, string message, params object?[]? args) Parameters Type Name Description float actual The number to be examined string message The message to display in case of failure object[] args Array of objects to be used in formatting the message View Source Zero(uint) Asserts that an unsigned int is zero. Returns without throwing an exception when inside a multiple assert block. Declaration [CLSCompliant(false)] public static void Zero(uint actual) Parameters Type Name Description uint actual The number to be examined View Source Zero(uint, string, params object?[]?) Asserts that an unsigned int is zero. Returns without throwing an exception when inside a multiple assert block. Declaration [CLSCompliant(false)] public static void Zero(uint actual, string message, params object?[]? args) Parameters Type Name Description uint actual The number to be examined string message The message to display in case of failure object[] args Array of objects to be used in formatting the message View Source Zero(ulong) Asserts that an unsigned Long is zero. Returns without throwing an exception when inside a multiple assert block. Declaration [CLSCompliant(false)] public static void Zero(ulong actual) Parameters Type Name Description ulong actual The number to be examined View Source Zero(ulong, string, params object?[]?) Asserts that an unsigned Long is zero. Returns without throwing an exception when inside a multiple assert block. Declaration [CLSCompliant(false)] public static void Zero(ulong actual, string message, params object?[]? args) Parameters Type Name Description ulong actual The number to be examined string message The message to display in case of failure object[] args Array of objects to be used in formatting the message"
  },
  "api/NUnit.Framework.Legacy.CollectionAssert.html": {
    "href": "api/NUnit.Framework.Legacy.CollectionAssert.html",
    "title": "Class CollectionAssert | NUnit Docs",
    "summary": "Class CollectionAssert A set of Assert methods operating on one or more collections Inheritance object AssertBase CollectionAssert Inherited Members AssertBase.ConvertMessageWithArgs(string, object[]) object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.GetHashCode() Namespace: NUnit.Framework.Legacy Assembly: nunit.framework.legacy.dll Syntax public abstract class CollectionAssert : AssertBase Constructors View Source CollectionAssert() Declaration protected CollectionAssert() Methods View Source AllItemsAreInstancesOfType(IEnumerable, Type) Asserts that all items contained in collection are of the type specified by expectedType. Declaration public static void AllItemsAreInstancesOfType(IEnumerable collection, Type expectedType) Parameters Type Name Description IEnumerable collection IEnumerable containing objects to be considered Type expectedType System.Type that all objects in collection must be instances of View Source AllItemsAreInstancesOfType(IEnumerable, Type, string, params object?[]?) Asserts that all items contained in collection are of the type specified by expectedType. Declaration public static void AllItemsAreInstancesOfType(IEnumerable collection, Type expectedType, string message, params object?[]? args) Parameters Type Name Description IEnumerable collection IEnumerable containing objects to be considered Type expectedType System.Type that all objects in collection must be instances of string message The message that will be displayed on failure object[] args Arguments to be used in formatting the message View Source AllItemsAreNotNull(IEnumerable) Asserts that all items contained in collection are not equal to null. Declaration public static void AllItemsAreNotNull(IEnumerable collection) Parameters Type Name Description IEnumerable collection IEnumerable containing objects to be considered View Source AllItemsAreNotNull(IEnumerable, string, params object?[]?) Asserts that all items contained in collection are not equal to null. Declaration public static void AllItemsAreNotNull(IEnumerable collection, string message, params object?[]? args) Parameters Type Name Description IEnumerable collection IEnumerable of objects to be considered string message The message that will be displayed on failure object[] args Arguments to be used in formatting the message View Source AllItemsAreUnique(IEnumerable) Ensures that every object contained in collection exists within the collection once and only once. Declaration public static void AllItemsAreUnique(IEnumerable collection) Parameters Type Name Description IEnumerable collection IEnumerable of objects to be considered View Source AllItemsAreUnique(IEnumerable, string, params object?[]?) Ensures that every object contained in collection exists within the collection once and only once. Declaration public static void AllItemsAreUnique(IEnumerable collection, string message, params object?[]? args) Parameters Type Name Description IEnumerable collection IEnumerable of objects to be considered string message The message that will be displayed on failure object[] args Arguments to be used in formatting the message View Source AreEqual(IEnumerable, IEnumerable) Asserts that expected and actual are exactly equal. The collections must have the same count, and contain the exact same objects in the same order. Declaration public static void AreEqual(IEnumerable expected, IEnumerable actual) Parameters Type Name Description IEnumerable expected The first IEnumerable of objects to be considered IEnumerable actual The second IEnumerable of objects to be considered View Source AreEqual(IEnumerable, IEnumerable, IComparer) Asserts that expected and actual are exactly equal. The collections must have the same count, and contain the exact same objects in the same order. If comparer is not null then it will be used to compare the objects. Declaration public static void AreEqual(IEnumerable expected, IEnumerable actual, IComparer comparer) Parameters Type Name Description IEnumerable expected The first IEnumerable of objects to be considered IEnumerable actual The second IEnumerable of objects to be considered IComparer comparer The IComparer to use in comparing objects from each IEnumerable View Source AreEqual(IEnumerable, IEnumerable, IComparer, string, params object?[]?) Asserts that expected and actual are exactly equal. The collections must have the same count, and contain the exact same objects in the same order. If comparer is not null then it will be used to compare the objects. Declaration public static void AreEqual(IEnumerable expected, IEnumerable actual, IComparer comparer, string message, params object?[]? args) Parameters Type Name Description IEnumerable expected The first IEnumerable of objects to be considered IEnumerable actual The second IEnumerable of objects to be considered IComparer comparer The IComparer to use in comparing objects from each IEnumerable string message The message that will be displayed on failure object[] args Arguments to be used in formatting the message View Source AreEqual(IEnumerable, IEnumerable, string, params object?[]?) Asserts that expected and actual are exactly equal. The collections must have the same count, and contain the exact same objects in the same order. Declaration public static void AreEqual(IEnumerable expected, IEnumerable actual, string message, params object?[]? args) Parameters Type Name Description IEnumerable expected The first IEnumerable of objects to be considered IEnumerable actual The second IEnumerable of objects to be considered string message The message that will be displayed on failure object[] args Arguments to be used in formatting the message View Source AreEquivalent(IEnumerable, IEnumerable) Asserts that expected and actual are equivalent, containing the same objects but the match may be in any order. Declaration public static void AreEquivalent(IEnumerable expected, IEnumerable actual) Parameters Type Name Description IEnumerable expected The first IEnumerable of objects to be considered IEnumerable actual The second IEnumerable of objects to be considered View Source AreEquivalent(IEnumerable, IEnumerable, string, params object?[]?) Asserts that expected and actual are equivalent, containing the same objects but the match may be in any order. Declaration public static void AreEquivalent(IEnumerable expected, IEnumerable actual, string message, params object?[]? args) Parameters Type Name Description IEnumerable expected The first IEnumerable of objects to be considered IEnumerable actual The second IEnumerable of objects to be considered string message The message that will be displayed on failure object[] args Arguments to be used in formatting the message View Source AreNotEqual(IEnumerable, IEnumerable) Asserts that expected and actual are not exactly equal. Declaration public static void AreNotEqual(IEnumerable expected, IEnumerable actual) Parameters Type Name Description IEnumerable expected The first IEnumerable of objects to be considered IEnumerable actual The second IEnumerable of objects to be considered View Source AreNotEqual(IEnumerable, IEnumerable, IComparer) Asserts that expected and actual are not exactly equal. If comparer is not null then it will be used to compare the objects. Declaration public static void AreNotEqual(IEnumerable expected, IEnumerable actual, IComparer comparer) Parameters Type Name Description IEnumerable expected The first IEnumerable of objects to be considered IEnumerable actual The second IEnumerable of objects to be considered IComparer comparer The IComparer to use in comparing objects from each IEnumerable View Source AreNotEqual(IEnumerable, IEnumerable, IComparer, string, params object?[]?) Asserts that expected and actual are not exactly equal. If comparer is not null then it will be used to compare the objects. Declaration public static void AreNotEqual(IEnumerable expected, IEnumerable actual, IComparer comparer, string message, params object?[]? args) Parameters Type Name Description IEnumerable expected The first IEnumerable of objects to be considered IEnumerable actual The second IEnumerable of objects to be considered IComparer comparer The IComparer to use in comparing objects from each IEnumerable string message The message that will be displayed on failure object[] args Arguments to be used in formatting the message View Source AreNotEqual(IEnumerable, IEnumerable, string, params object?[]?) Asserts that expected and actual are not exactly equal. Declaration public static void AreNotEqual(IEnumerable expected, IEnumerable actual, string message, params object?[]? args) Parameters Type Name Description IEnumerable expected The first IEnumerable of objects to be considered IEnumerable actual The second IEnumerable of objects to be considered string message The message that will be displayed on failure object[] args Arguments to be used in formatting the message View Source AreNotEquivalent(IEnumerable, IEnumerable) Asserts that expected and actual are not equivalent. Declaration public static void AreNotEquivalent(IEnumerable expected, IEnumerable actual) Parameters Type Name Description IEnumerable expected The first IEnumerable of objects to be considered IEnumerable actual The second IEnumerable of objects to be considered View Source AreNotEquivalent(IEnumerable, IEnumerable, string, params object?[]?) Asserts that expected and actual are not equivalent. Declaration public static void AreNotEquivalent(IEnumerable expected, IEnumerable actual, string message, params object?[]? args) Parameters Type Name Description IEnumerable expected The first IEnumerable of objects to be considered IEnumerable actual The second IEnumerable of objects to be considered string message The message that will be displayed on failure object[] args Arguments to be used in formatting the message View Source Contains(IEnumerable, object?) Asserts that collection contains actual as an item. Declaration public static void Contains(IEnumerable collection, object? actual) Parameters Type Name Description IEnumerable collection IEnumerable of objects to be considered object actual Object to be found within collection View Source Contains(IEnumerable, object?, string, params object?[]?) Asserts that collection contains actual as an item. Declaration public static void Contains(IEnumerable collection, object? actual, string message, params object?[]? args) Parameters Type Name Description IEnumerable collection IEnumerable of objects to be considered object actual Object to be found within collection string message The message that will be displayed on failure object[] args Arguments to be used in formatting the message View Source DoesNotContain(IEnumerable, object) Asserts that collection does not contain actual as an item. Declaration public static void DoesNotContain(IEnumerable collection, object actual) Parameters Type Name Description IEnumerable collection IEnumerable of objects to be considered object actual Object that cannot exist within collection View Source DoesNotContain(IEnumerable, object, string, params object?[]?) Asserts that collection does not contain actual as an item. Declaration public static void DoesNotContain(IEnumerable collection, object actual, string message, params object?[]? args) Parameters Type Name Description IEnumerable collection IEnumerable of objects to be considered object actual Object that cannot exist within collection string message The message that will be displayed on failure object[] args Arguments to be used in formatting the message View Source IsEmpty(IEnumerable) Assert that an array,list or other collection is empty Declaration public static void IsEmpty(IEnumerable collection) Parameters Type Name Description IEnumerable collection An array, list or other collection implementing IEnumerable View Source IsEmpty(IEnumerable, string, params object?[]?) Assert that an array, list or other collection is empty Declaration public static void IsEmpty(IEnumerable collection, string message, params object?[]? args) Parameters Type Name Description IEnumerable collection An array, list or other collection implementing IEnumerable string message The message to be displayed on failure object[] args Arguments to be used in formatting the message View Source IsNotEmpty(IEnumerable) Assert that an array, list or other collection is not empty. Declaration public static void IsNotEmpty(IEnumerable collection) Parameters Type Name Description IEnumerable collection An array, list or other collection implementing IEnumerable View Source IsNotEmpty(IEnumerable, string, params object?[]?) Assert that an array, list or other collection is not empty. Declaration public static void IsNotEmpty(IEnumerable collection, string message, params object?[]? args) Parameters Type Name Description IEnumerable collection An array, list or other collection implementing IEnumerable string message The message to be displayed on failure object[] args Arguments to be used in formatting the message View Source IsNotSubsetOf(IEnumerable, IEnumerable) Asserts that the superset does not contain the subset Declaration public static void IsNotSubsetOf(IEnumerable subset, IEnumerable superset) Parameters Type Name Description IEnumerable subset The IEnumerable subset to be considered IEnumerable superset The IEnumerable superset to be considered View Source IsNotSubsetOf(IEnumerable, IEnumerable, string, params object?[]?) Asserts that the superset does not contain the subset Declaration public static void IsNotSubsetOf(IEnumerable subset, IEnumerable superset, string message, params object?[]? args) Parameters Type Name Description IEnumerable subset The IEnumerable subset to be considered IEnumerable superset The IEnumerable superset to be considered string message The message that will be displayed on failure object[] args Arguments to be used in formatting the message View Source IsNotSupersetOf(IEnumerable, IEnumerable) Asserts that the subset does not contain the superset Declaration public static void IsNotSupersetOf(IEnumerable superset, IEnumerable subset) Parameters Type Name Description IEnumerable superset The IEnumerable superset to be considered IEnumerable subset The IEnumerable subset to be considered View Source IsNotSupersetOf(IEnumerable, IEnumerable, string, params object?[]?) Asserts that the subset does not contain the superset Declaration public static void IsNotSupersetOf(IEnumerable superset, IEnumerable subset, string message, params object?[]? args) Parameters Type Name Description IEnumerable superset The IEnumerable superset to be considered IEnumerable subset The IEnumerable subset to be considered string message The message that will be displayed on failure object[] args Arguments to be used in formatting the message View Source IsOrdered(IEnumerable) Assert that an array, list or other collection is ordered Declaration public static void IsOrdered(IEnumerable collection) Parameters Type Name Description IEnumerable collection An array, list or other collection implementing IEnumerable View Source IsOrdered(IEnumerable, IComparer) Assert that an array, list or other collection is ordered Declaration public static void IsOrdered(IEnumerable collection, IComparer comparer) Parameters Type Name Description IEnumerable collection An array, list or other collection implementing IEnumerable IComparer comparer A custom comparer to perform the comparisons View Source IsOrdered(IEnumerable, IComparer, string, params object?[]?) Assert that an array, list or other collection is ordered Declaration public static void IsOrdered(IEnumerable collection, IComparer comparer, string message, params object?[]? args) Parameters Type Name Description IEnumerable collection An array, list or other collection implementing IEnumerable IComparer comparer A custom comparer to perform the comparisons string message The message to be displayed on failure object[] args Arguments to be used in formatting the message View Source IsOrdered(IEnumerable, string, params object?[]?) Assert that an array, list or other collection is ordered Declaration public static void IsOrdered(IEnumerable collection, string message, params object?[]? args) Parameters Type Name Description IEnumerable collection An array, list or other collection implementing IEnumerable string message The message to be displayed on failure object[] args Arguments to be used in formatting the message View Source IsSubsetOf(IEnumerable, IEnumerable) Asserts that the superset contains the subset. Declaration public static void IsSubsetOf(IEnumerable subset, IEnumerable superset) Parameters Type Name Description IEnumerable subset The IEnumerable subset to be considered IEnumerable superset The IEnumerable superset to be considered View Source IsSubsetOf(IEnumerable, IEnumerable, string, params object?[]?) Asserts that the superset contains the subset. Declaration public static void IsSubsetOf(IEnumerable subset, IEnumerable superset, string message, params object?[]? args) Parameters Type Name Description IEnumerable subset The IEnumerable subset to be considered IEnumerable superset The IEnumerable superset to be considered string message The message that will be displayed on failure object[] args Arguments to be used in formatting the message View Source IsSupersetOf(IEnumerable, IEnumerable) Asserts that the subset contains the superset. Declaration public static void IsSupersetOf(IEnumerable superset, IEnumerable subset) Parameters Type Name Description IEnumerable superset The IEnumerable superset to be considered IEnumerable subset The IEnumerable subset to be considered View Source IsSupersetOf(IEnumerable, IEnumerable, string, params object?[]?) Asserts that the subset contains the superset. Declaration public static void IsSupersetOf(IEnumerable superset, IEnumerable subset, string message, params object?[]? args) Parameters Type Name Description IEnumerable superset The IEnumerable superset to be considered IEnumerable subset The IEnumerable subset to be considered string message The message that will be displayed on failure object[] args Arguments to be used in formatting the message View Source ReferenceEquals(object, object) DO NOT USE! The ReferenceEquals method throws an InvalidOperationException. This is done to make sure there is no mistake by calling this function. Declaration public static void ReferenceEquals(object a, object b) Parameters Type Name Description object a object b"
  },
  "api/NUnit.Framework.Legacy.DirectoryAssert.html": {
    "href": "api/NUnit.Framework.Legacy.DirectoryAssert.html",
    "title": "Class DirectoryAssert | NUnit Docs",
    "summary": "Class DirectoryAssert Asserts on Directories Inheritance object AssertBase DirectoryAssert Inherited Members AssertBase.ConvertMessageWithArgs(string, object[]) object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework.Legacy Assembly: nunit.framework.legacy.dll Syntax public abstract class DirectoryAssert : AssertBase Constructors View Source DirectoryAssert() Declaration protected DirectoryAssert() Methods View Source AreEqual(DirectoryInfo, DirectoryInfo) Verifies that two directories are equal. Two directories are considered equal if both are null, or if both point to the same directory. If they are not equal an AssertionException is thrown. Declaration public static void AreEqual(DirectoryInfo expected, DirectoryInfo actual) Parameters Type Name Description DirectoryInfo expected A directory containing the value that is expected DirectoryInfo actual A directory containing the actual value View Source AreEqual(DirectoryInfo, DirectoryInfo, string, params object?[]?) Verifies that two directories are equal. Two directories are considered equal if both are null, or if both point to the same directory. If they are not equal an AssertionException is thrown. Declaration public static void AreEqual(DirectoryInfo expected, DirectoryInfo actual, string message, params object?[]? args) Parameters Type Name Description DirectoryInfo expected A directory containing the value that is expected DirectoryInfo actual A directory containing the actual value string message The message to display if the directories are not equal object[] args Arguments to be used in formatting the message View Source AreNotEqual(DirectoryInfo?, DirectoryInfo?) Asserts that two directories are not equal. If they are equal an AssertionException is thrown. Declaration public static void AreNotEqual(DirectoryInfo? expected, DirectoryInfo? actual) Parameters Type Name Description DirectoryInfo expected A directory containing the value that is expected DirectoryInfo actual A directory containing the actual value View Source AreNotEqual(DirectoryInfo?, DirectoryInfo?, string, params object?[]?) Asserts that two directories are not equal. If they are equal an AssertionException is thrown. Declaration public static void AreNotEqual(DirectoryInfo? expected, DirectoryInfo? actual, string message, params object?[]? args) Parameters Type Name Description DirectoryInfo expected A directory containing the value that is expected DirectoryInfo actual A directory containing the actual value string message The message to display if directories are not equal object[] args Arguments to be used in formatting the message View Source DoesNotExist(DirectoryInfo) Asserts that the directory does not exist. If it does exist an AssertionException is thrown. Declaration public static void DoesNotExist(DirectoryInfo actual) Parameters Type Name Description DirectoryInfo actual A directory containing the actual value View Source DoesNotExist(DirectoryInfo, string, params object?[]?) Asserts that the directory does not exist. If it does exist an AssertionException is thrown. Declaration public static void DoesNotExist(DirectoryInfo actual, string message, params object?[]? args) Parameters Type Name Description DirectoryInfo actual A directory containing the actual value string message The message to display if directories are not equal object[] args Arguments to be used in formatting the message View Source DoesNotExist(string) Asserts that the directory does not exist. If it does exist an AssertionException is thrown. Declaration public static void DoesNotExist(string actual) Parameters Type Name Description string actual The path to a directory containing the actual value View Source DoesNotExist(string, string, params object?[]?) Asserts that the directory does not exist. If it does exist an AssertionException is thrown. Declaration public static void DoesNotExist(string actual, string message, params object?[]? args) Parameters Type Name Description string actual The path to a directory containing the actual value string message The message to display if directories are not equal object[] args Arguments to be used in formatting the message View Source Exists(DirectoryInfo) Asserts that the directory exists. If it does not exist an AssertionException is thrown. Declaration public static void Exists(DirectoryInfo actual) Parameters Type Name Description DirectoryInfo actual A directory containing the actual value View Source Exists(DirectoryInfo, string, params object?[]?) Asserts that the directory exists. If it does not exist an AssertionException is thrown. Declaration public static void Exists(DirectoryInfo actual, string message, params object?[]? args) Parameters Type Name Description DirectoryInfo actual A directory containing the actual value string message The message to display if directories are not equal object[] args Arguments to be used in formatting the message View Source Exists(string) Asserts that the directory exists. If it does not exist an AssertionException is thrown. Declaration public static void Exists(string actual) Parameters Type Name Description string actual The path to a directory containing the actual value View Source Exists(string, string, params object?[]?) Asserts that the directory exists. If it does not exist an AssertionException is thrown. Declaration public static void Exists(string actual, string message, params object?[]? args) Parameters Type Name Description string actual The path to a directory containing the actual value string message The message to display if directories are not equal object[] args Arguments to be used in formatting the message"
  },
  "api/NUnit.Framework.Legacy.FileAssert.html": {
    "href": "api/NUnit.Framework.Legacy.FileAssert.html",
    "title": "Class FileAssert | NUnit Docs",
    "summary": "Class FileAssert Asserts on Files Inheritance object AssertBase FileAssert Inherited Members AssertBase.ConvertMessageWithArgs(string, object[]) object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework.Legacy Assembly: nunit.framework.legacy.dll Syntax public abstract class FileAssert : AssertBase Constructors View Source FileAssert() Declaration protected FileAssert() Methods View Source AreEqual(FileInfo, FileInfo) Verifies that two files are equal. Two files are considered equal if both are null, or if both have the same value byte for byte. If they are not equal an AssertionException is thrown. Declaration public static void AreEqual(FileInfo expected, FileInfo actual) Parameters Type Name Description FileInfo expected A file containing the value that is expected FileInfo actual A file containing the actual value View Source AreEqual(FileInfo, FileInfo, string, params object?[]?) Verifies that two files are equal. Two files are considered equal if both are null, or if both have the same value byte for byte. If they are not equal an AssertionException is thrown. Declaration public static void AreEqual(FileInfo expected, FileInfo actual, string message, params object?[]? args) Parameters Type Name Description FileInfo expected A file containing the value that is expected FileInfo actual A file containing the actual value string message The message to display if Streams are not equal object[] args Arguments to be used in formatting the message View Source AreEqual(Stream?, Stream?) Verifies that two Streams are equal. Two Streams are considered equal if both are null, or if both have the same value byte for byte. If they are not equal an AssertionException is thrown. Declaration public static void AreEqual(Stream? expected, Stream? actual) Parameters Type Name Description Stream expected The expected Stream Stream actual The actual Stream View Source AreEqual(Stream?, Stream?, string, params object?[]?) Verifies that two Streams are equal. Two Streams are considered equal if both are null, or if both have the same value byte for byte. If they are not equal an AssertionException is thrown. Declaration public static void AreEqual(Stream? expected, Stream? actual, string message, params object?[]? args) Parameters Type Name Description Stream expected The expected Stream Stream actual The actual Stream string message The message to display if Streams are not equal object[] args Arguments to be used in formatting the message View Source AreEqual(string, string) Verifies that two files are equal. Two files are considered equal if both are null, or if both have the same value byte for byte. If they are not equal an AssertionException is thrown. Declaration public static void AreEqual(string expected, string actual) Parameters Type Name Description string expected The path to a file containing the value that is expected string actual The path to a file containing the actual value View Source AreEqual(string, string, string, params object?[]?) Verifies that two files are equal. Two files are considered equal if both are null, or if both have the same value byte for byte. If they are not equal an AssertionException is thrown. Declaration public static void AreEqual(string expected, string actual, string message, params object?[]? args) Parameters Type Name Description string expected The path to a file containing the value that is expected string actual The path to a file containing the actual value string message The message to display if Streams are not equal object[] args Arguments to be used in formatting the message View Source AreNotEqual(FileInfo, FileInfo) Asserts that two files are not equal. If they are equal an AssertionException is thrown. Declaration public static void AreNotEqual(FileInfo expected, FileInfo actual) Parameters Type Name Description FileInfo expected A file containing the value that is expected FileInfo actual A file containing the actual value View Source AreNotEqual(FileInfo, FileInfo, string, params object?[]?) Asserts that two files are not equal. If they are equal an AssertionException is thrown. Declaration public static void AreNotEqual(FileInfo expected, FileInfo actual, string message, params object?[]? args) Parameters Type Name Description FileInfo expected A file containing the value that is expected FileInfo actual A file containing the actual value string message The message to display if Streams are not equal object[] args Arguments to be used in formatting the message View Source AreNotEqual(Stream?, Stream?) Asserts that two Streams are not equal. If they are equal an AssertionException is thrown. Declaration public static void AreNotEqual(Stream? expected, Stream? actual) Parameters Type Name Description Stream expected The expected Stream Stream actual The actual Stream View Source AreNotEqual(Stream?, Stream?, string, params object?[]?) Asserts that two Streams are not equal. If they are equal an AssertionException is thrown. Declaration public static void AreNotEqual(Stream? expected, Stream? actual, string message, params object?[]? args) Parameters Type Name Description Stream expected The expected Stream Stream actual The actual Stream string message The message to be displayed when the two Stream are the same. object[] args Arguments to be used in formatting the message View Source AreNotEqual(string, string) Asserts that two files are not equal. If they are equal an AssertionException is thrown. Declaration public static void AreNotEqual(string expected, string actual) Parameters Type Name Description string expected The path to a file containing the value that is expected string actual The path to a file containing the actual value View Source AreNotEqual(string, string, string, params object?[]?) Asserts that two files are not equal. If they are equal an AssertionException is thrown. Declaration public static void AreNotEqual(string expected, string actual, string message, params object?[]? args) Parameters Type Name Description string expected The path to a file containing the value that is expected string actual The path to a file containing the actual value string message The message to display if Streams are not equal object[] args Arguments to be used in formatting the message View Source DoesNotExist(FileInfo) Asserts that the file does not exist. If it does exist an AssertionException is thrown. Declaration public static void DoesNotExist(FileInfo actual) Parameters Type Name Description FileInfo actual A file containing the actual value View Source DoesNotExist(FileInfo, string, params object?[]?) Asserts that the file does not exist. If it does exist an AssertionException is thrown. Declaration public static void DoesNotExist(FileInfo actual, string message, params object?[]? args) Parameters Type Name Description FileInfo actual A file containing the actual value string message The message to display if Streams are not equal object[] args Arguments to be used in formatting the message View Source DoesNotExist(string) Asserts that the file does not exist. If it does exist an AssertionException is thrown. Declaration public static void DoesNotExist(string actual) Parameters Type Name Description string actual The path to a file containing the actual value View Source DoesNotExist(string, string, params object?[]?) Asserts that the file does not exist. If it does exist an AssertionException is thrown. Declaration public static void DoesNotExist(string actual, string message, params object?[]? args) Parameters Type Name Description string actual The path to a file containing the actual value string message The message to display if Streams are not equal object[] args Arguments to be used in formatting the message View Source Exists(FileInfo) Asserts that the file exists. If it does not exist an AssertionException is thrown. Declaration public static void Exists(FileInfo actual) Parameters Type Name Description FileInfo actual A file containing the actual value View Source Exists(FileInfo, string, params object?[]?) Asserts that the file exists. If it does not exist an AssertionException is thrown. Declaration public static void Exists(FileInfo actual, string message, params object?[]? args) Parameters Type Name Description FileInfo actual A file containing the actual value string message The message to display if Streams are not equal object[] args Arguments to be used in formatting the message View Source Exists(string) Asserts that the file exists. If it does not exist an AssertionException is thrown. Declaration public static void Exists(string actual) Parameters Type Name Description string actual The path to a file containing the actual value View Source Exists(string, string, params object?[]?) Asserts that the file exists. If it does not exist an AssertionException is thrown. Declaration public static void Exists(string actual, string message, params object?[]? args) Parameters Type Name Description string actual The path to a file containing the actual value string message The message to display if Streams are not equal object[] args Arguments to be used in formatting the message"
  },
  "api/NUnit.Framework.Legacy.StringAssert.html": {
    "href": "api/NUnit.Framework.Legacy.StringAssert.html",
    "title": "Class StringAssert | NUnit Docs",
    "summary": "Class StringAssert Basic Asserts on strings. Inheritance object AssertBase StringAssert Inherited Members AssertBase.ConvertMessageWithArgs(string, object[]) object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework.Legacy Assembly: nunit.framework.legacy.dll Syntax public abstract class StringAssert : AssertBase Constructors View Source StringAssert() Declaration protected StringAssert() Methods View Source AreEqualIgnoringCase(string, string) Asserts that two strings are equal, without regard to case. Declaration public static void AreEqualIgnoringCase(string expected, string actual) Parameters Type Name Description string expected The expected string string actual The actual string View Source AreEqualIgnoringCase(string, string, string, params object?[]?) Asserts that two strings are equal, without regard to case. Declaration public static void AreEqualIgnoringCase(string expected, string actual, string message, params object?[]? args) Parameters Type Name Description string expected The expected string string actual The actual string string message The message to display in case of failure object[] args Arguments used in formatting the message View Source AreNotEqualIgnoringCase(string, string) Asserts that two strings are not equal, without regard to case. Declaration public static void AreNotEqualIgnoringCase(string expected, string actual) Parameters Type Name Description string expected The expected string string actual The actual string View Source AreNotEqualIgnoringCase(string, string, string, params object?[]?) Asserts that two strings are not equal, without regard to case. Declaration public static void AreNotEqualIgnoringCase(string expected, string actual, string message, params object?[]? args) Parameters Type Name Description string expected The expected string string actual The actual string string message The message to display in case of failure object[] args Arguments used in formatting the message View Source Contains(string, string) Asserts that a string is found within another string. Declaration public static void Contains(string expected, string actual) Parameters Type Name Description string expected The expected string string actual The string to be examined View Source Contains(string, string, string, params object?[]?) Asserts that a string is found within another string. Declaration public static void Contains(string expected, string actual, string message, params object?[]? args) Parameters Type Name Description string expected The expected string string actual The string to be examined string message The message to display in case of failure object[] args Arguments used in formatting the message View Source DoesNotContain(string, string) Asserts that a string is found within another string. Declaration public static void DoesNotContain(string expected, string actual) Parameters Type Name Description string expected The expected string string actual The string to be examined View Source DoesNotContain(string, string, string, params object?[]?) Asserts that a string is not found within another string. Declaration public static void DoesNotContain(string expected, string actual, string message, params object?[]? args) Parameters Type Name Description string expected The expected string string actual The string to be examined string message The message to display in case of failure object[] args Arguments used in formatting the message View Source DoesNotEndWith(string, string) Asserts that a string does not end with another string. Declaration public static void DoesNotEndWith(string expected, string actual) Parameters Type Name Description string expected The expected string string actual The string to be examined View Source DoesNotEndWith(string, string, string, params object?[]?) Asserts that a string does not end with another string. Declaration public static void DoesNotEndWith(string expected, string actual, string message, params object?[]? args) Parameters Type Name Description string expected The expected string string actual The string to be examined string message The message to display in case of failure object[] args Arguments used in formatting the message View Source DoesNotMatch(string, string) Asserts that a string does not match an expected regular expression pattern. Declaration public static void DoesNotMatch(string pattern, string actual) Parameters Type Name Description string pattern The regex pattern to be used string actual The actual string View Source DoesNotMatch(string, string, string, params object?[]?) Asserts that a string does not match an expected regular expression pattern. Declaration public static void DoesNotMatch(string pattern, string actual, string message, params object?[]? args) Parameters Type Name Description string pattern The regex pattern to be used string actual The actual string string message The message to display in case of failure object[] args Arguments used in formatting the message View Source DoesNotStartWith(string, string) Asserts that a string does not start with another string. Declaration public static void DoesNotStartWith(string expected, string actual) Parameters Type Name Description string expected The expected string string actual The string to be examined View Source DoesNotStartWith(string, string, string, params object?[]?) Asserts that a string does not start with another string. Declaration public static void DoesNotStartWith(string expected, string actual, string message, params object?[]? args) Parameters Type Name Description string expected The expected string string actual The string to be examined string message The message to display in case of failure object[] args Arguments used in formatting the message View Source EndsWith(string, string) Asserts that a string ends with another string. Declaration public static void EndsWith(string expected, string actual) Parameters Type Name Description string expected The expected string string actual The string to be examined View Source EndsWith(string, string, string, params object?[]?) Asserts that a string ends with another string. Declaration public static void EndsWith(string expected, string actual, string message, params object?[]? args) Parameters Type Name Description string expected The expected string string actual The string to be examined string message The message to display in case of failure object[] args Arguments used in formatting the message View Source IsMatch(string, string) Asserts that a string matches an expected regular expression pattern. Declaration public static void IsMatch(string pattern, string actual) Parameters Type Name Description string pattern The regex pattern to be matched string actual The actual string View Source IsMatch(string, string, string, params object?[]?) Asserts that a string matches an expected regular expression pattern. Declaration public static void IsMatch(string pattern, string actual, string message, params object?[]? args) Parameters Type Name Description string pattern The regex pattern to be matched string actual The actual string string message The message to display in case of failure object[] args Arguments used in formatting the message View Source StartsWith(string, string) Asserts that a string starts with another string. Declaration public static void StartsWith(string expected, string actual) Parameters Type Name Description string expected The expected string string actual The string to be examined View Source StartsWith(string, string, string, params object?[]?) Asserts that a string starts with another string. Declaration public static void StartsWith(string expected, string actual, string message, params object?[]? args) Parameters Type Name Description string expected The expected string string actual The string to be examined string message The message to display in case of failure object[] args Arguments used in formatting the message"
  },
  "api/NUnit.Framework.Legacy.html": {
    "href": "api/NUnit.Framework.Legacy.html",
    "title": "Namespace NUnit.Framework.Legacy | NUnit Docs",
    "summary": "Namespace NUnit.Framework.Legacy Classes ClassicAssert The Assert class contains a collection of static methods that implement the most common assertions used in NUnit. CollectionAssert A set of Assert methods operating on one or more collections DirectoryAssert Asserts on Directories FileAssert Asserts on Files StringAssert Basic Asserts on strings."
  },
  "api/NUnit.Framework.LevelOfParallelismAttribute.html": {
    "href": "api/NUnit.Framework.LevelOfParallelismAttribute.html",
    "title": "Class LevelOfParallelismAttribute | NUnit Docs",
    "summary": "Class LevelOfParallelismAttribute Sets the number of worker threads that may be allocated by the framework for running tests. Inheritance object Attribute NUnitAttribute PropertyAttribute LevelOfParallelismAttribute Implements IApplyToTest Inherited Members PropertyAttribute.ApplyToTest(Test) PropertyAttribute.Properties Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId object.GetType() object.ToString() object.Equals(object, object) object.ReferenceEquals(object, object) Namespace: NUnit.Framework Assembly: nunit.framework.dll Syntax [AttributeUsage(AttributeTargets.Assembly, AllowMultiple = false, Inherited = false)] public sealed class LevelOfParallelismAttribute : PropertyAttribute, IApplyToTest Constructors View Source LevelOfParallelismAttribute(int) Construct a LevelOfParallelismAttribute. Declaration public LevelOfParallelismAttribute(int level) Parameters Type Name Description int level The number of worker threads to be created by the framework. Implements IApplyToTest"
  },
  "api/NUnit.Framework.LifeCycle.html": {
    "href": "api/NUnit.Framework.LifeCycle.html",
    "title": "Enum LifeCycle | NUnit Docs",
    "summary": "Enum LifeCycle Specifies the life cycle for a test fixture. Namespace: NUnit.Framework Assembly: nunit.framework.dll Syntax public enum LifeCycle Fields Name Description InstancePerTestCase A new instance is created for each test case. SingleInstance A single instance is created and shared for all test cases."
  },
  "api/NUnit.Framework.MaxTimeAttribute.html": {
    "href": "api/NUnit.Framework.MaxTimeAttribute.html",
    "title": "Class MaxTimeAttribute | NUnit Docs",
    "summary": "Class MaxTimeAttribute Specifies the maximum time (in milliseconds) for a test case to succeed. Inheritance object Attribute NUnitAttribute PropertyAttribute MaxTimeAttribute Implements IApplyToTest IWrapSetUpTearDown ICommandWrapper Inherited Members PropertyAttribute.ApplyToTest(Test) PropertyAttribute.Properties Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId object.GetType() object.ToString() object.Equals(object, object) object.ReferenceEquals(object, object) Namespace: NUnit.Framework Assembly: nunit.framework.dll Syntax [AttributeUsage(AttributeTargets.Method, AllowMultiple = false, Inherited = false)] public sealed class MaxTimeAttribute : PropertyAttribute, IApplyToTest, IWrapSetUpTearDown, ICommandWrapper Constructors View Source MaxTimeAttribute(int) Construct a MaxTimeAttribute, given a time in milliseconds. Declaration public MaxTimeAttribute(int milliseconds) Parameters Type Name Description int milliseconds The maximum elapsed time in milliseconds Implements IApplyToTest IWrapSetUpTearDown ICommandWrapper"
  },
  "api/NUnit.Framework.MultipleAssertException.html": {
    "href": "api/NUnit.Framework.MultipleAssertException.html",
    "title": "Class MultipleAssertException | NUnit Docs",
    "summary": "Class MultipleAssertException Thrown when an assertion failed. Inheritance object Exception ResultStateException MultipleAssertException Implements ISerializable Inherited Members Exception.GetBaseException() Exception.ToString() Exception.GetType() Exception.TargetSite Exception.Message Exception.Data Exception.InnerException Exception.HelpLink Exception.Source Exception.HResult Exception.StackTrace Exception.SerializeObjectState object.MemberwiseClone() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework Assembly: nunit.framework.dll Syntax public class MultipleAssertException : ResultStateException, ISerializable Constructors View Source MultipleAssertException(ITestResult) Construct based on the TestResult so far. This is the constructor used normally, when exiting the multiple assert block with failures. Not used internally but provided to facilitate debugging. Declaration public MultipleAssertException(ITestResult testResult) Parameters Type Name Description ITestResult testResult The current result, up to this point. The result is not used internally by NUnit but is provided to facilitate debugging. Properties View Source ResultState Gets the ResultState provided by this exception. Declaration public override ResultState ResultState { get; } Property Value Type Description ResultState Overrides ResultStateException.ResultState View Source TestResult Gets the ITestResult of this test at the point the exception was thrown, Declaration public ITestResult TestResult { get; } Property Value Type Description ITestResult Implements ISerializable"
  },
  "api/NUnit.Framework.NUnitAttribute.html": {
    "href": "api/NUnit.Framework.NUnitAttribute.html",
    "title": "Class NUnitAttribute | NUnit Docs",
    "summary": "Class NUnitAttribute Abstract base class for all custom attributes defined by NUnit. Inheritance object Attribute NUnitAttribute CategoryAttribute CombiningStrategyAttribute DatapointAttribute DatapointSourceAttribute DefaultFloatingPointToleranceAttribute ExplicitAttribute FixtureLifeCycleAttribute IgnoreAttribute IncludeExcludeAttribute OneTimeSetUpAttribute OneTimeTearDownAttribute OrderAttribute PropertyAttribute RandomAttribute RangeAttribute RetryAttribute SetUpAttribute SetUpFixtureAttribute SingleThreadedAttribute TearDownAttribute TestAssemblyDirectoryResolveAttribute TestAttribute TestCaseAttribute TestCaseSourceAttribute TestFixtureAttribute TestFixtureSourceAttribute ValueSourceAttribute ValuesAttribute Inherited Members Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object, object) object.ReferenceEquals(object, object) Namespace: NUnit.Framework Assembly: nunit.framework.dll Syntax public abstract class NUnitAttribute : Attribute Constructors View Source NUnitAttribute() Default constructor Declaration public NUnitAttribute()"
  },
  "api/NUnit.Framework.NUnitString.html": {
    "href": "api/NUnit.Framework.NUnitString.html",
    "title": "Struct NUnitString | NUnit Docs",
    "summary": "Struct NUnitString A class to allow postponing the actual formatting of interpolated strings. Inherited Members ValueType.Equals(object) ValueType.GetHashCode() object.GetType() object.Equals(object, object) object.ReferenceEquals(object, object) Namespace: NUnit.Framework Assembly: nunit.framework.dll Syntax public readonly struct NUnitString Remarks This class is needed as the compiler prefers to call a string overload vs a FormattableString overload. https://www.damirscorner.com/blog/posts/20180921-FormattableStringAsMethodParameter.html Constructors View Source NUnitString(string?) Initializes a new instance of the NUnitString class. Declaration public NUnitString(string? message) Parameters Type Name Description string message The message formattable to hold. Methods View Source ToString() Declaration public override string ToString() Returns Type Description string Overrides ValueType.ToString() Operators View Source implicit operator NUnitString(FormattableString) Implicit conversion from a FormattableString to a NUnitString. Declaration [Obsolete(\"This only exists for the compiler\")] public static implicit operator NUnitString(FormattableString formattableMessage) Parameters Type Name Description FormattableString formattableMessage The message formattable to hold. Returns Type Description NUnitString Remarks Should never be called. It only exists for the compiler. View Source implicit operator NUnitString(string?) Implicit conversion from a string to a NUnitString. Declaration public static implicit operator NUnitString(string? message) Parameters Type Name Description string message The message formattable to hold. Returns Type Description NUnitString"
  },
  "api/NUnit.Framework.NetPlatformAttribute.html": {
    "href": "api/NUnit.Framework.NetPlatformAttribute.html",
    "title": "Class NetPlatformAttribute | NUnit Docs",
    "summary": "Class NetPlatformAttribute Marks an assembly, test fixture or test method as applying to a specific platform. Inheritance object Attribute NUnitAttribute IncludeExcludeAttribute NetPlatformAttribute Implements IApplyToTest Inherited Members IncludeExcludeAttribute.Include IncludeExcludeAttribute.Exclude IncludeExcludeAttribute.Reason Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object, object) object.ReferenceEquals(object, object) Namespace: NUnit.Framework Assembly: nunit.framework.dll Syntax [AttributeUsage(AttributeTargets.Assembly|AttributeTargets.Class|AttributeTargets.Method, AllowMultiple = true, Inherited = false)] public class NetPlatformAttribute : IncludeExcludeAttribute, IApplyToTest Remarks This class is a replacement for the PlatformAttribute class, the platform names are based on the values in the TargetFramework. See: https://learn.microsoft.com/en-us/dotnet/fundamentals/code-analysis/quality-rules/ca1416 Constructors View Source NetPlatformAttribute() Constructor with no platforms specified, for use with named property syntax. Declaration public NetPlatformAttribute() View Source NetPlatformAttribute(string?) Constructor taking one or more platforms Declaration public NetPlatformAttribute(string? platforms) Parameters Type Name Description string platforms Comma-delimited list of platforms Methods View Source ApplyToTest(Test) Causes a test to be skipped if this NewPlatformAttribute is not satisfied. Declaration public void ApplyToTest(Test test) Parameters Type Name Description Test test The test to modify Implements IApplyToTest"
  },
  "api/NUnit.Framework.NonParallelizableAttribute.html": {
    "href": "api/NUnit.Framework.NonParallelizableAttribute.html",
    "title": "Class NonParallelizableAttribute | NUnit Docs",
    "summary": "Class NonParallelizableAttribute Marks tests that should NOT be run in parallel. Inheritance object Attribute NUnitAttribute PropertyAttribute ParallelizableAttribute NonParallelizableAttribute Implements IApplyToTest IApplyToContext Inherited Members ParallelizableAttribute.ApplyToTest(Test) ParallelizableAttribute.ApplyToContext(TestExecutionContext) ParallelizableAttribute.Scope PropertyAttribute.Properties Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId object.GetType() object.ToString() object.Equals(object, object) object.ReferenceEquals(object, object) Namespace: NUnit.Framework Assembly: nunit.framework.dll Syntax [AttributeUsage(AttributeTargets.Assembly|AttributeTargets.Class|AttributeTargets.Method, AllowMultiple = false, Inherited = true)] public sealed class NonParallelizableAttribute : ParallelizableAttribute, IApplyToTest, IApplyToContext Constructors View Source NonParallelizableAttribute() Construct a NonParallelizableAttribute. Declaration public NonParallelizableAttribute() Implements IApplyToTest IApplyToContext"
  },
  "api/NUnit.Framework.OneTimeSetUpAttribute.html": {
    "href": "api/NUnit.Framework.OneTimeSetUpAttribute.html",
    "title": "Class OneTimeSetUpAttribute | NUnit Docs",
    "summary": "Class OneTimeSetUpAttribute Identifies a method that is called once to perform setup before any child tests are run. Inheritance object Attribute NUnitAttribute OneTimeSetUpAttribute Inherited Members Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object, object) object.ReferenceEquals(object, object) Namespace: NUnit.Framework Assembly: nunit.framework.dll Syntax [AttributeUsage(AttributeTargets.Method, AllowMultiple = false, Inherited = true)] public class OneTimeSetUpAttribute : NUnitAttribute Constructors View Source OneTimeSetUpAttribute() Declaration public OneTimeSetUpAttribute()"
  },
  "api/NUnit.Framework.OneTimeTearDownAttribute.html": {
    "href": "api/NUnit.Framework.OneTimeTearDownAttribute.html",
    "title": "Class OneTimeTearDownAttribute | NUnit Docs",
    "summary": "Class OneTimeTearDownAttribute Identifies a method to be called once after all the child tests have run. The method is guaranteed to be called, even if an exception is thrown. Inheritance object Attribute NUnitAttribute OneTimeTearDownAttribute Inherited Members Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object, object) object.ReferenceEquals(object, object) Namespace: NUnit.Framework Assembly: nunit.framework.dll Syntax [AttributeUsage(AttributeTargets.Method, AllowMultiple = false, Inherited = true)] public class OneTimeTearDownAttribute : NUnitAttribute Constructors View Source OneTimeTearDownAttribute() Declaration public OneTimeTearDownAttribute()"
  },
  "api/NUnit.Framework.OrderAttribute.html": {
    "href": "api/NUnit.Framework.OrderAttribute.html",
    "title": "Class OrderAttribute | NUnit Docs",
    "summary": "Class OrderAttribute Defines the order that the test will run in Inheritance object Attribute NUnitAttribute OrderAttribute Implements IApplyToTest IApplyToTestSuite Inherited Members Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object, object) object.ReferenceEquals(object, object) Namespace: NUnit.Framework Assembly: nunit.framework.dll Syntax [AttributeUsage(AttributeTargets.Class|AttributeTargets.Method, AllowMultiple = false, Inherited = true)] public class OrderAttribute : NUnitAttribute, IApplyToTest, IApplyToTestSuite Constructors View Source OrderAttribute(int) Defines the order that the test will run in Declaration public OrderAttribute(int order) Parameters Type Name Description int order The order that the test will run in Fields View Source Order The order that the test will run in Declaration public readonly int Order Field Value Type Description int Methods View Source ApplyToTest(Test) Modifies a test as defined for the specific attribute. Declaration public void ApplyToTest(Test test) Parameters Type Name Description Test test The test to modify View Source ApplyToTestSuite(TestSuite) Modifies a test suite as defined for the specific attribute. Declaration public void ApplyToTestSuite(TestSuite testSuite) Parameters Type Name Description TestSuite testSuite The test suite to modify Implements IApplyToTest IApplyToTestSuite"
  },
  "api/NUnit.Framework.PairwiseAttribute.html": {
    "href": "api/NUnit.Framework.PairwiseAttribute.html",
    "title": "Class PairwiseAttribute | NUnit Docs",
    "summary": "Class PairwiseAttribute Marks a test as using a pairwise join of any supplied argument data. Arguments will be combined in such a way that all possible pairs of arguments are used. Inheritance object Attribute NUnitAttribute CombiningStrategyAttribute PairwiseAttribute Implements ITestBuilder IApplyToTest Inherited Members CombiningStrategyAttribute.BuildFrom(IMethodInfo, Test) CombiningStrategyAttribute.ApplyToTest(Test) Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object, object) object.ReferenceEquals(object, object) Namespace: NUnit.Framework Assembly: nunit.framework.dll Syntax [AttributeUsage(AttributeTargets.Method, AllowMultiple = false, Inherited = false)] public class PairwiseAttribute : CombiningStrategyAttribute, ITestBuilder, IApplyToTest Constructors View Source PairwiseAttribute() Default constructor Declaration public PairwiseAttribute() Implements ITestBuilder IApplyToTest"
  },
  "api/NUnit.Framework.ParallelScope.html": {
    "href": "api/NUnit.Framework.ParallelScope.html",
    "title": "Enum ParallelScope | NUnit Docs",
    "summary": "Enum ParallelScope Specifies the degree to which a test, and its descendants, may be run in parallel. Namespace: NUnit.Framework Assembly: nunit.framework.dll Syntax [Flags] public enum ParallelScope Fields Name Description All The test and its descendants may be run in parallel with others at the same level. Valid on classes and parameterized methods. For assemblies it is recommended to use Children instead, as Self has no effect on assemblies. Children Descendants of the test may be run in parallel with one another. Valid on assemblies and classes but not on non-parameterized methods. Fixtures Descendants of the test down to the level of TestFixtures may be run in parallel with one another. Valid on assemblies and classes but not on methods. Self The test may be run in parallel with others at the same level. Valid on classes and methods but has no effect on assemblies."
  },
  "api/NUnit.Framework.ParallelizableAttribute.html": {
    "href": "api/NUnit.Framework.ParallelizableAttribute.html",
    "title": "Class ParallelizableAttribute | NUnit Docs",
    "summary": "Class ParallelizableAttribute Marks a test assembly, fixture or method that may be run in parallel. Inheritance object Attribute NUnitAttribute PropertyAttribute ParallelizableAttribute NonParallelizableAttribute Implements IApplyToTest IApplyToContext Inherited Members PropertyAttribute.Properties Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object, object) object.ReferenceEquals(object, object) Namespace: NUnit.Framework Assembly: nunit.framework.dll Syntax [AttributeUsage(AttributeTargets.Assembly|AttributeTargets.Class|AttributeTargets.Method, AllowMultiple = false, Inherited = true)] public class ParallelizableAttribute : PropertyAttribute, IApplyToTest, IApplyToContext Constructors View Source ParallelizableAttribute() Construct a ParallelizableAttribute using default ParallelScope.Self. Declaration public ParallelizableAttribute() View Source ParallelizableAttribute(ParallelScope) Construct a ParallelizableAttribute with a specified scope. Declaration public ParallelizableAttribute(ParallelScope scope) Parameters Type Name Description ParallelScope scope The ParallelScope associated with this attribute. Properties View Source Scope Defines the degree to which this test and its descendants may be run in parallel Declaration public ParallelScope Scope { get; } Property Value Type Description ParallelScope Methods View Source ApplyToContext(TestExecutionContext) Modify the context to be used for child tests Declaration public void ApplyToContext(TestExecutionContext context) Parameters Type Name Description TestExecutionContext context The current TestExecutionContext View Source ApplyToTest(Test) Overridden to check for invalid combinations of settings Declaration public override void ApplyToTest(Test test) Parameters Type Name Description Test test Overrides PropertyAttribute.ApplyToTest(Test) Implements IApplyToTest IApplyToContext"
  },
  "api/NUnit.Framework.PlatformAttribute.html": {
    "href": "api/NUnit.Framework.PlatformAttribute.html",
    "title": "Class PlatformAttribute | NUnit Docs",
    "summary": "Class PlatformAttribute Marks an assembly, test fixture or test method as applying to a specific platform. Inheritance object Attribute NUnitAttribute IncludeExcludeAttribute PlatformAttribute Implements IApplyToTest Inherited Members IncludeExcludeAttribute.Include IncludeExcludeAttribute.Exclude IncludeExcludeAttribute.Reason Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object, object) object.ReferenceEquals(object, object) Namespace: NUnit.Framework Assembly: nunit.framework.dll Syntax [AttributeUsage(AttributeTargets.Assembly|AttributeTargets.Class|AttributeTargets.Method, AllowMultiple = true, Inherited = false)] public class PlatformAttribute : IncludeExcludeAttribute, IApplyToTest Constructors View Source PlatformAttribute() Constructor with no platforms specified, for use with named property syntax. Declaration public PlatformAttribute() View Source PlatformAttribute(string?) Constructor taking one or more platforms Declaration public PlatformAttribute(string? platforms) Parameters Type Name Description string platforms Comma-delimited list of platforms Methods View Source ApplyToTest(Test) Causes a test to be skipped if this PlatformAttribute is not satisfied. Declaration public void ApplyToTest(Test test) Parameters Type Name Description Test test The test to modify Implements IApplyToTest"
  },
  "api/NUnit.Framework.PropertyAttribute.html": {
    "href": "api/NUnit.Framework.PropertyAttribute.html",
    "title": "Class PropertyAttribute | NUnit Docs",
    "summary": "Class PropertyAttribute Attaches information to a test assembly, fixture or method as a name/value pair. Inheritance object Attribute NUnitAttribute PropertyAttribute ApartmentAttribute AuthorAttribute CancelAfterAttribute DescriptionAttribute LevelOfParallelismAttribute MaxTimeAttribute ParallelizableAttribute RepeatAttribute RequiresThreadAttribute SetCultureAttribute SetUICultureAttribute TestOfAttribute TimeoutAttribute Implements IApplyToTest Inherited Members Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object, object) object.ReferenceEquals(object, object) Namespace: NUnit.Framework Assembly: nunit.framework.dll Syntax [AttributeUsage(AttributeTargets.Assembly|AttributeTargets.Class|AttributeTargets.Method, AllowMultiple = true, Inherited = true)] public class PropertyAttribute : NUnitAttribute, IApplyToTest Constructors View Source PropertyAttribute() Constructor for derived classes that set the property dictionary directly. Declaration protected PropertyAttribute() View Source PropertyAttribute(object) Constructor for use by derived classes that use the name of the type as the property name. Derived classes must ensure that the Type of the property value is a standard type supported by the BCL. Any custom types will cause a serialization Exception when in the client. Declaration protected PropertyAttribute(object propertyValue) Parameters Type Name Description object propertyValue View Source PropertyAttribute(string, double) Construct a PropertyAttribute with a name and double value Declaration public PropertyAttribute(string propertyName, double propertyValue) Parameters Type Name Description string propertyName The name of the property double propertyValue The property value View Source PropertyAttribute(string, int) Construct a PropertyAttribute with a name and int value Declaration public PropertyAttribute(string propertyName, int propertyValue) Parameters Type Name Description string propertyName The name of the property int propertyValue The property value View Source PropertyAttribute(string, string) Construct a PropertyAttribute with a name and string value Declaration public PropertyAttribute(string propertyName, string propertyValue) Parameters Type Name Description string propertyName The name of the property string propertyValue The property value Properties View Source Properties Gets the property dictionary for this attribute Declaration public IPropertyBag Properties { get; } Property Value Type Description IPropertyBag Methods View Source ApplyToTest(Test) Modifies a test by adding properties to it. Declaration public virtual void ApplyToTest(Test test) Parameters Type Name Description Test test The test to modify Implements IApplyToTest"
  },
  "api/NUnit.Framework.RandomAttribute.html": {
    "href": "api/NUnit.Framework.RandomAttribute.html",
    "title": "Class RandomAttribute | NUnit Docs",
    "summary": "Class RandomAttribute Supplies a set of random values to a single parameter of a parameterized test. Inheritance object Attribute NUnitAttribute RandomAttribute Implements IParameterDataSource Inherited Members Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object, object) object.ReferenceEquals(object, object) Namespace: NUnit.Framework Assembly: nunit.framework.dll Syntax [AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false, Inherited = false)] public class RandomAttribute : NUnitAttribute, IParameterDataSource Constructors View Source RandomAttribute(byte, byte, int) Generates byte values within a specified range. Declaration public RandomAttribute(byte min, byte max, int count) Parameters Type Name Description byte min byte max int count View Source RandomAttribute(double, double, int) Generates double values within a specified range. Declaration public RandomAttribute(double min, double max, int count) Parameters Type Name Description double min double max int count View Source RandomAttribute(short, short, int) Generates short values within a specified range. Declaration public RandomAttribute(short min, short max, int count) Parameters Type Name Description short min short max int count View Source RandomAttribute(int) Construct a random set of values appropriate for the Type of the parameter on which the attribute appears, specifying only the count. Declaration public RandomAttribute(int count) Parameters Type Name Description int count View Source RandomAttribute(int, int, int) Generates int values within a specified range. Declaration public RandomAttribute(int min, int max, int count) Parameters Type Name Description int min int max int count View Source RandomAttribute(long, long, int) Generates long values within a specified range. Declaration public RandomAttribute(long min, long max, int count) Parameters Type Name Description long min long max int count View Source RandomAttribute(sbyte, sbyte, int) Generates sbyte values within a specified range. Declaration [CLSCompliant(false)] public RandomAttribute(sbyte min, sbyte max, int count) Parameters Type Name Description sbyte min sbyte max int count View Source RandomAttribute(float, float, int) Generates float values within a specified range. Declaration public RandomAttribute(float min, float max, int count) Parameters Type Name Description float min float max int count View Source RandomAttribute(ushort, ushort, int) Generates ushort values within a specified range. Declaration [CLSCompliant(false)] public RandomAttribute(ushort min, ushort max, int count) Parameters Type Name Description ushort min ushort max int count View Source RandomAttribute(uint, uint, int) Generates uint values within a specified range. Declaration [CLSCompliant(false)] public RandomAttribute(uint min, uint max, int count) Parameters Type Name Description uint min uint max int count View Source RandomAttribute(ulong, ulong, int) Generates ulong values within a specified range. Declaration [CLSCompliant(false)] public RandomAttribute(ulong min, ulong max, int count) Parameters Type Name Description ulong min ulong max int count Properties View Source Distinct If true, no value will be repeated. Declaration public bool Distinct { get; set; } Property Value Type Description bool Methods View Source GetData(IParameterInfo) Retrieves a list of arguments which can be passed to the specified parameter. Declaration public IEnumerable GetData(IParameterInfo parameter) Parameters Type Name Description IParameterInfo parameter The parameter of a parameterized test. Returns Type Description IEnumerable Implements IParameterDataSource"
  },
  "api/NUnit.Framework.RangeAttribute.html": {
    "href": "api/NUnit.Framework.RangeAttribute.html",
    "title": "Class RangeAttribute | NUnit Docs",
    "summary": "Class RangeAttribute Supplies a range of values to an individual parameter of a parameterized test. Inheritance object Attribute NUnitAttribute RangeAttribute Implements IParameterDataSource Inherited Members Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId object.GetType() object.MemberwiseClone() object.Equals(object, object) object.ReferenceEquals(object, object) Namespace: NUnit.Framework Assembly: nunit.framework.dll Syntax [AttributeUsage(AttributeTargets.Parameter, AllowMultiple = true, Inherited = false)] public class RangeAttribute : NUnitAttribute, IParameterDataSource Constructors View Source RangeAttribute(double, double, double) Constructs a range of double values with the specified step size. Declaration public RangeAttribute(double from, double to, double step) Parameters Type Name Description double from double to double step View Source RangeAttribute(int, int) Constructs a range of int values using the default step of 1. Declaration public RangeAttribute(int from, int to) Parameters Type Name Description int from int to View Source RangeAttribute(int, int, int) Constructs a range of int values with the specified step size. Declaration public RangeAttribute(int from, int to, int step) Parameters Type Name Description int from int to int step View Source RangeAttribute(long, long) Constructs a range of long values using a default step of 1. Declaration public RangeAttribute(long from, long to) Parameters Type Name Description long from long to View Source RangeAttribute(long, long, long) Constructs a range of long values with the specified step size. Declaration public RangeAttribute(long from, long to, long step) Parameters Type Name Description long from long to long step View Source RangeAttribute(float, float, float) Constructs a range of float values with the specified step size. Declaration public RangeAttribute(float from, float to, float step) Parameters Type Name Description float from float to float step View Source RangeAttribute(uint, uint) Constructs a range of uint values using the default step of 1. Declaration [CLSCompliant(false)] public RangeAttribute(uint from, uint to) Parameters Type Name Description uint from uint to View Source RangeAttribute(uint, uint, uint) Constructs a range of uint values with the specified step size. Declaration [CLSCompliant(false)] public RangeAttribute(uint from, uint to, uint step) Parameters Type Name Description uint from uint to uint step View Source RangeAttribute(ulong, ulong) Constructs a range of ulong values using the default step of 1. Declaration [CLSCompliant(false)] public RangeAttribute(ulong from, ulong to) Parameters Type Name Description ulong from ulong to View Source RangeAttribute(ulong, ulong, ulong) Constructs a range of ulong values with the specified step size. Declaration [CLSCompliant(false)] public RangeAttribute(ulong from, ulong to, ulong step) Parameters Type Name Description ulong from ulong to ulong step Methods View Source GetData(IParameterInfo) Retrieves a list of arguments which can be passed to the specified parameter. Declaration public IEnumerable GetData(IParameterInfo parameter) Parameters Type Name Description IParameterInfo parameter The parameter of a parameterized test. Returns Type Description IEnumerable View Source ToString() Returns a string that represents the current object. Declaration public override string ToString() Returns Type Description string Overrides object.ToString() Implements IParameterDataSource"
  },
  "api/NUnit.Framework.RepeatAttribute.RepeatedTestCommand.html": {
    "href": "api/NUnit.Framework.RepeatAttribute.RepeatedTestCommand.html",
    "title": "Class RepeatAttribute.RepeatedTestCommand | NUnit Docs",
    "summary": "Class RepeatAttribute.RepeatedTestCommand The test command for the RepeatAttribute Inheritance object TestCommand DelegatingTestCommand RepeatAttribute.RepeatedTestCommand Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework Assembly: nunit.framework.dll Syntax public class RepeatAttribute.RepeatedTestCommand : DelegatingTestCommand Constructors View Source RepeatedTestCommand(TestCommand, int, bool) Initializes a new instance of the RepeatAttribute.RepeatedTestCommand class. Declaration public RepeatedTestCommand(TestCommand innerCommand, int repeatCount, bool stopOnFailure) Parameters Type Name Description TestCommand innerCommand The inner command. int repeatCount The number of repetitions bool stopOnFailure Whether to stop when a test is not successful or not Methods View Source Execute(TestExecutionContext) Runs the test, saving a TestResult in the supplied TestExecutionContext. Declaration public override TestResult Execute(TestExecutionContext context) Parameters Type Name Description TestExecutionContext context The context in which the test should run. Returns Type Description TestResult A TestResult Overrides NUnit.Framework.Internal.Commands.TestCommand.Execute(NUnit.Framework.Internal.TestExecutionContext)"
  },
  "api/NUnit.Framework.RepeatAttribute.html": {
    "href": "api/NUnit.Framework.RepeatAttribute.html",
    "title": "Class RepeatAttribute | NUnit Docs",
    "summary": "Class RepeatAttribute Specifies that a test should be run multiple times. Inheritance object Attribute NUnitAttribute PropertyAttribute RepeatAttribute Implements IApplyToTest IRepeatTest ICommandWrapper Inherited Members PropertyAttribute.ApplyToTest(Test) PropertyAttribute.Properties Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object, object) object.ReferenceEquals(object, object) Namespace: NUnit.Framework Assembly: nunit.framework.dll Syntax [AttributeUsage(AttributeTargets.Method, AllowMultiple = false, Inherited = false)] public class RepeatAttribute : PropertyAttribute, IApplyToTest, IRepeatTest, ICommandWrapper Constructors View Source RepeatAttribute(int) Construct a RepeatAttribute Declaration public RepeatAttribute(int count) Parameters Type Name Description int count The number of times to run the test View Source RepeatAttribute(int, bool) Construct a RepeatAttribute Declaration public RepeatAttribute(int count, bool stopOnFailure) Parameters Type Name Description int count The number of times to run the test bool stopOnFailure Whether to stop when a test is not successful or not Properties View Source StopOnFailure Whether to stop when a test is not successful or not Declaration public bool StopOnFailure { get; set; } Property Value Type Description bool Methods View Source Wrap(TestCommand) Wrap a command and return the result. Declaration public TestCommand Wrap(TestCommand command) Parameters Type Name Description TestCommand command The command to be wrapped Returns Type Description TestCommand The wrapped command Implements IApplyToTest IRepeatTest ICommandWrapper"
  },
  "api/NUnit.Framework.RequiresThreadAttribute.html": {
    "href": "api/NUnit.Framework.RequiresThreadAttribute.html",
    "title": "Class RequiresThreadAttribute | NUnit Docs",
    "summary": "Class RequiresThreadAttribute Marks a test that must run on a separate thread. Inheritance object Attribute NUnitAttribute PropertyAttribute RequiresThreadAttribute Implements IApplyToTest Inherited Members PropertyAttribute.ApplyToTest(Test) PropertyAttribute.Properties Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object, object) object.ReferenceEquals(object, object) Namespace: NUnit.Framework Assembly: nunit.framework.dll Syntax [AttributeUsage(AttributeTargets.Assembly|AttributeTargets.Class|AttributeTargets.Method, AllowMultiple = false, Inherited = true)] public class RequiresThreadAttribute : PropertyAttribute, IApplyToTest Constructors View Source RequiresThreadAttribute() Construct a RequiresThreadAttribute Declaration public RequiresThreadAttribute() View Source RequiresThreadAttribute(ApartmentState) Construct a RequiresThreadAttribute, specifying the apartment Declaration public RequiresThreadAttribute(ApartmentState apartment) Parameters Type Name Description ApartmentState apartment Implements IApplyToTest"
  },
  "api/NUnit.Framework.ResultStateException.html": {
    "href": "api/NUnit.Framework.ResultStateException.html",
    "title": "Class ResultStateException | NUnit Docs",
    "summary": "Class ResultStateException Abstract base for Exceptions that terminate a test and provide a ResultState. Inheritance object Exception ResultStateException AssertionException IgnoreException InconclusiveException MultipleAssertException SuccessException Implements ISerializable Inherited Members Exception.GetBaseException() Exception.ToString() Exception.GetType() Exception.TargetSite Exception.Message Exception.Data Exception.InnerException Exception.HelpLink Exception.Source Exception.HResult Exception.StackTrace Exception.SerializeObjectState object.MemberwiseClone() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework Assembly: nunit.framework.dll Syntax public abstract class ResultStateException : Exception, ISerializable Constructors View Source ResultStateException(string) Declaration protected ResultStateException(string message) Parameters Type Name Description string message The error message that explains the reason for the exception View Source ResultStateException(string, Exception?) Declaration public ResultStateException(string message, Exception? inner) Parameters Type Name Description string message The error message that explains the reason for the exception Exception inner The exception that caused the current exception Properties View Source ResultState Gets the ResultState provided by this exception Declaration public abstract ResultState ResultState { get; } Property Value Type Description ResultState Implements ISerializable"
  },
  "api/NUnit.Framework.RetryAttribute.RetryCommand.html": {
    "href": "api/NUnit.Framework.RetryAttribute.RetryCommand.html",
    "title": "Class RetryAttribute.RetryCommand | NUnit Docs",
    "summary": "Class RetryAttribute.RetryCommand The test command for the RetryAttribute Inheritance object TestCommand DelegatingTestCommand RetryAttribute.RetryCommand Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework Assembly: nunit.framework.dll Syntax public class RetryAttribute.RetryCommand : DelegatingTestCommand Constructors View Source RetryCommand(TestCommand, int) Initializes a new instance of the RetryAttribute.RetryCommand class. Declaration public RetryCommand(TestCommand innerCommand, int tryCount) Parameters Type Name Description TestCommand innerCommand The inner command. int tryCount The maximum number of repetitions Methods View Source Execute(TestExecutionContext) Runs the test, saving a TestResult in the supplied TestExecutionContext. Declaration public override TestResult Execute(TestExecutionContext context) Parameters Type Name Description TestExecutionContext context The context in which the test should run. Returns Type Description TestResult A TestResult Overrides NUnit.Framework.Internal.Commands.TestCommand.Execute(NUnit.Framework.Internal.TestExecutionContext)"
  },
  "api/NUnit.Framework.RetryAttribute.html": {
    "href": "api/NUnit.Framework.RetryAttribute.html",
    "title": "Class RetryAttribute | NUnit Docs",
    "summary": "Class RetryAttribute Specifies that a test method should be rerun on failure up to the specified maximum number of times. Inheritance object Attribute NUnitAttribute RetryAttribute Implements IRepeatTest ICommandWrapper Inherited Members Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object, object) object.ReferenceEquals(object, object) Namespace: NUnit.Framework Assembly: nunit.framework.dll Syntax [AttributeUsage(AttributeTargets.Method, AllowMultiple = false, Inherited = false)] public class RetryAttribute : NUnitAttribute, IRepeatTest, ICommandWrapper Constructors View Source RetryAttribute(int) Construct a RetryAttribute Declaration public RetryAttribute(int tryCount) Parameters Type Name Description int tryCount The maximum number of times the test should be run if it fails Methods View Source Wrap(TestCommand) Wrap a command and return the result. Declaration public TestCommand Wrap(TestCommand command) Parameters Type Name Description TestCommand command The command to be wrapped Returns Type Description TestCommand The wrapped command Implements IRepeatTest ICommandWrapper"
  },
  "api/NUnit.Framework.SequentialAttribute.html": {
    "href": "api/NUnit.Framework.SequentialAttribute.html",
    "title": "Class SequentialAttribute | NUnit Docs",
    "summary": "Class SequentialAttribute Marks a test to use a sequential join of any provided argument data. Arguments will be combined into test cases, taking the next value of each argument until all are used. Inheritance object Attribute NUnitAttribute CombiningStrategyAttribute SequentialAttribute Implements ITestBuilder IApplyToTest Inherited Members CombiningStrategyAttribute.BuildFrom(IMethodInfo, Test) CombiningStrategyAttribute.ApplyToTest(Test) Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object, object) object.ReferenceEquals(object, object) Namespace: NUnit.Framework Assembly: nunit.framework.dll Syntax [AttributeUsage(AttributeTargets.Method, AllowMultiple = false, Inherited = false)] public class SequentialAttribute : CombiningStrategyAttribute, ITestBuilder, IApplyToTest Constructors View Source SequentialAttribute() Default constructor Declaration public SequentialAttribute() Implements ITestBuilder IApplyToTest"
  },
  "api/NUnit.Framework.SetCultureAttribute.html": {
    "href": "api/NUnit.Framework.SetCultureAttribute.html",
    "title": "Class SetCultureAttribute | NUnit Docs",
    "summary": "Class SetCultureAttribute Sets the current Culture on an assembly, test fixture or test method for the duration of a test. The culture remains set until the test or fixture completes and is then reset to its original value. Inheritance object Attribute NUnitAttribute PropertyAttribute SetCultureAttribute Implements IApplyToTest IApplyToContext Inherited Members PropertyAttribute.ApplyToTest(Test) PropertyAttribute.Properties Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object, object) object.ReferenceEquals(object, object) Namespace: NUnit.Framework Assembly: nunit.framework.dll Syntax [AttributeUsage(AttributeTargets.Assembly|AttributeTargets.Class|AttributeTargets.Method, AllowMultiple = false, Inherited = true)] public class SetCultureAttribute : PropertyAttribute, IApplyToTest, IApplyToContext Constructors View Source SetCultureAttribute(string) Construct given the name of a culture Declaration public SetCultureAttribute(string culture) Parameters Type Name Description string culture Implements IApplyToTest IApplyToContext See Also SetUICultureAttribute"
  },
  "api/NUnit.Framework.SetUICultureAttribute.html": {
    "href": "api/NUnit.Framework.SetUICultureAttribute.html",
    "title": "Class SetUICultureAttribute | NUnit Docs",
    "summary": "Class SetUICultureAttribute Sets the current UI Culture on an assembly, test fixture or test method for the duration of a test. The UI culture remains set until the test or fixture completes and is then reset to its original value. Inheritance object Attribute NUnitAttribute PropertyAttribute SetUICultureAttribute Implements IApplyToTest IApplyToContext Inherited Members PropertyAttribute.ApplyToTest(Test) PropertyAttribute.Properties Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object, object) object.ReferenceEquals(object, object) Namespace: NUnit.Framework Assembly: nunit.framework.dll Syntax [AttributeUsage(AttributeTargets.Assembly|AttributeTargets.Class|AttributeTargets.Method, AllowMultiple = false, Inherited = true)] public class SetUICultureAttribute : PropertyAttribute, IApplyToTest, IApplyToContext Constructors View Source SetUICultureAttribute(string) Construct given the name of a culture Declaration public SetUICultureAttribute(string culture) Parameters Type Name Description string culture Implements IApplyToTest IApplyToContext See Also SetCultureAttribute"
  },
  "api/NUnit.Framework.SetUpAttribute.html": {
    "href": "api/NUnit.Framework.SetUpAttribute.html",
    "title": "Class SetUpAttribute | NUnit Docs",
    "summary": "Class SetUpAttribute Identifies a method to be called immediately before each test is run. Inheritance object Attribute NUnitAttribute SetUpAttribute Inherited Members Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object, object) object.ReferenceEquals(object, object) Namespace: NUnit.Framework Assembly: nunit.framework.dll Syntax [AttributeUsage(AttributeTargets.Method, AllowMultiple = false, Inherited = true)] public class SetUpAttribute : NUnitAttribute Constructors View Source SetUpAttribute() Declaration public SetUpAttribute()"
  },
  "api/NUnit.Framework.SetUpFixtureAttribute.html": {
    "href": "api/NUnit.Framework.SetUpFixtureAttribute.html",
    "title": "Class SetUpFixtureAttribute | NUnit Docs",
    "summary": "Class SetUpFixtureAttribute Identifies a class as containing OneTimeSetUpAttribute or OneTimeTearDownAttribute methods for all the test fixtures under a given namespace. Inheritance object Attribute NUnitAttribute SetUpFixtureAttribute Implements IFixtureBuilder Inherited Members Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object, object) object.ReferenceEquals(object, object) Namespace: NUnit.Framework Assembly: nunit.framework.dll Syntax [AttributeUsage(AttributeTargets.Class, AllowMultiple = false, Inherited = true)] public class SetUpFixtureAttribute : NUnitAttribute, IFixtureBuilder Constructors View Source SetUpFixtureAttribute() Declaration public SetUpFixtureAttribute() Methods View Source BuildFrom(ITypeInfo) Builds a NUnit.Framework.Internal.SetUpFixture from the specified type. Declaration public IEnumerable<TestSuite> BuildFrom(ITypeInfo typeInfo) Parameters Type Name Description ITypeInfo typeInfo The type info of the fixture to be used. Returns Type Description IEnumerable<TestSuite> Implements IFixtureBuilder"
  },
  "api/NUnit.Framework.SingleThreadedAttribute.html": {
    "href": "api/NUnit.Framework.SingleThreadedAttribute.html",
    "title": "Class SingleThreadedAttribute | NUnit Docs",
    "summary": "Class SingleThreadedAttribute Marks a test fixture as requiring all child tests to be run on the same thread as the OneTimeSetUp and OneTimeTearDown. A flag in the NUnit.Framework.Internal.TestExecutionContext is set forcing all child tests to be run sequentially on the current thread. Any ParallelScope setting is ignored. Inheritance object Attribute NUnitAttribute SingleThreadedAttribute Implements IApplyToContext Inherited Members Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object, object) object.ReferenceEquals(object, object) Namespace: NUnit.Framework Assembly: nunit.framework.dll Syntax [AttributeUsage(AttributeTargets.Class, AllowMultiple = false, Inherited = true)] public class SingleThreadedAttribute : NUnitAttribute, IApplyToContext Constructors View Source SingleThreadedAttribute() Declaration public SingleThreadedAttribute() Methods View Source ApplyToContext(TestExecutionContext) Apply changes to the TestExecutionContext Declaration public void ApplyToContext(TestExecutionContext context) Parameters Type Name Description TestExecutionContext context The TestExecutionContext Implements IApplyToContext"
  },
  "api/NUnit.Framework.SuccessException.html": {
    "href": "api/NUnit.Framework.SuccessException.html",
    "title": "Class SuccessException | NUnit Docs",
    "summary": "Class SuccessException Thrown when an assertion failed. Inheritance object Exception ResultStateException SuccessException Implements ISerializable Inherited Members Exception.GetBaseException() Exception.ToString() Exception.GetType() Exception.TargetSite Exception.Message Exception.Data Exception.InnerException Exception.HelpLink Exception.Source Exception.HResult Exception.StackTrace Exception.SerializeObjectState object.MemberwiseClone() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework Assembly: nunit.framework.dll Syntax public class SuccessException : ResultStateException, ISerializable Constructors View Source SuccessException(string) Declaration public SuccessException(string message) Parameters Type Name Description string message View Source SuccessException(string, Exception?) Declaration public SuccessException(string message, Exception? inner) Parameters Type Name Description string message The error message that explains the reason for the exception Exception inner The exception that caused the current exception Properties View Source ResultState Gets the ResultState provided by this exception Declaration public override ResultState ResultState { get; } Property Value Type Description ResultState Overrides ResultStateException.ResultState Implements ISerializable"
  },
  "api/NUnit.Framework.TearDownAttribute.html": {
    "href": "api/NUnit.Framework.TearDownAttribute.html",
    "title": "Class TearDownAttribute | NUnit Docs",
    "summary": "Class TearDownAttribute Identifies a method to be called immediately after each test is run. The method is guaranteed to be called, even if an exception is thrown. Inheritance object Attribute NUnitAttribute TearDownAttribute Inherited Members Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object, object) object.ReferenceEquals(object, object) Namespace: NUnit.Framework Assembly: nunit.framework.dll Syntax [AttributeUsage(AttributeTargets.Method, AllowMultiple = false, Inherited = true)] public class TearDownAttribute : NUnitAttribute Constructors View Source TearDownAttribute() Declaration public TearDownAttribute()"
  },
  "api/NUnit.Framework.TestActionAttribute.html": {
    "href": "api/NUnit.Framework.TestActionAttribute.html",
    "title": "Class TestActionAttribute | NUnit Docs",
    "summary": "Class TestActionAttribute Abstract attribute providing actions to execute before and after tests. Inheritance object Attribute TestActionAttribute Implements ITestAction Inherited Members Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object, object) object.ReferenceEquals(object, object) Namespace: NUnit.Framework Assembly: nunit.framework.dll Syntax [AttributeUsage(AttributeTargets.Assembly|AttributeTargets.Class|AttributeTargets.Method|AttributeTargets.Interface, AllowMultiple = true, Inherited = true)] public abstract class TestActionAttribute : Attribute, ITestAction Constructors View Source TestActionAttribute() Declaration protected TestActionAttribute() Properties View Source Targets Provides the target for the action attribute Declaration public virtual ActionTargets Targets { get; } Property Value Type Description ActionTargets Methods View Source AfterTest(ITest) Executed after each test is run Declaration public virtual void AfterTest(ITest test) Parameters Type Name Description ITest test The test that has just been run. View Source BeforeTest(ITest) Executed before each test is run Declaration public virtual void BeforeTest(ITest test) Parameters Type Name Description ITest test The test that is going to be run. Implements ITestAction"
  },
  "api/NUnit.Framework.TestAssemblyDirectoryResolveAttribute.html": {
    "href": "api/NUnit.Framework.TestAssemblyDirectoryResolveAttribute.html",
    "title": "Class TestAssemblyDirectoryResolveAttribute | NUnit Docs",
    "summary": "Class TestAssemblyDirectoryResolveAttribute Marks a test assembly as needing a special assembly resolution hook that will explicitly search the test assembly's directory for dependent assemblies. This works around a conflict between mixed-mode assembly initialization and tests running in their own AppDomain in some cases. Inheritance object Attribute NUnitAttribute TestAssemblyDirectoryResolveAttribute Inherited Members Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object, object) object.ReferenceEquals(object, object) Namespace: NUnit.Framework Assembly: nunit.framework.dll Syntax [AttributeUsage(AttributeTargets.Assembly, AllowMultiple = false, Inherited = false)] public class TestAssemblyDirectoryResolveAttribute : NUnitAttribute Constructors View Source TestAssemblyDirectoryResolveAttribute() Declaration public TestAssemblyDirectoryResolveAttribute()"
  },
  "api/NUnit.Framework.TestAttribute.html": {
    "href": "api/NUnit.Framework.TestAttribute.html",
    "title": "Class TestAttribute | NUnit Docs",
    "summary": "Class TestAttribute Marks the method as callable from the NUnit test runner. Inheritance object Attribute NUnitAttribute TestAttribute Implements ISimpleTestBuilder IApplyToTest IImplyFixture Inherited Members Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object, object) object.ReferenceEquals(object, object) Namespace: NUnit.Framework Assembly: nunit.framework.dll Syntax [AttributeUsage(AttributeTargets.Method, AllowMultiple = false, Inherited = true)] public class TestAttribute : NUnitAttribute, ISimpleTestBuilder, IApplyToTest, IImplyFixture Examples [TestFixture] public class Fixture { [Test] public void MethodToTest() {} [Test(Description = \"more detailed description\")] public void TestDescriptionMethod() {} } Constructors View Source TestAttribute() Declaration public TestAttribute() Properties View Source Author The author of this test Declaration public string? Author { get; set; } Property Value Type Description string View Source Description Descriptive text for this test Declaration public string? Description { get; set; } Property Value Type Description string View Source ExpectedResult Gets or sets the expected result. Not valid if the test method has parameters. Declaration public object? ExpectedResult { get; set; } Property Value Type Description object The result. View Source TestOf The type that this test is testing Declaration public Type? TestOf { get; set; } Property Value Type Description Type Methods View Source ApplyToTest(Test) Modifies a test by adding a description, if not already set. Declaration public void ApplyToTest(Test test) Parameters Type Name Description Test test The test to modify View Source BuildFrom(IMethodInfo, Test?) Builds a single test from the specified method and context. Declaration public TestMethod BuildFrom(IMethodInfo method, Test? suite) Parameters Type Name Description IMethodInfo method The method for which a test is to be constructed. Test suite The suite to which the test will be added. Returns Type Description TestMethod Implements ISimpleTestBuilder IApplyToTest IImplyFixture"
  },
  "api/NUnit.Framework.TestCaseAttribute-1.html": {
    "href": "api/NUnit.Framework.TestCaseAttribute-1.html",
    "title": "Class TestCaseAttribute<T> | NUnit Docs",
    "summary": "Class TestCaseAttribute<T> Marks a method as a parameterized test suite and provides arguments for each test case. Inheritance object Attribute NUnitAttribute TestCaseAttribute TestCaseAttribute<T> Implements ITestBuilder ITestCaseData ITestData IImplyFixture Inherited Members TestCaseAttribute.BuildFrom(IMethodInfo, Test) TestCaseAttribute.TestName TestCaseAttribute.RunState TestCaseAttribute.Arguments TestCaseAttribute.Properties TestCaseAttribute.ExpectedResult TestCaseAttribute.HasExpectedResult TestCaseAttribute.Description TestCaseAttribute.Author TestCaseAttribute.TestOf TestCaseAttribute.Ignore TestCaseAttribute.Explicit TestCaseAttribute.Reason TestCaseAttribute.IgnoreReason TestCaseAttribute.IncludePlatform TestCaseAttribute.ExcludePlatform TestCaseAttribute.TypeArgs TestCaseAttribute.Category TestCaseAttribute.Until Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object, object) object.ReferenceEquals(object, object) Namespace: NUnit.Framework Assembly: nunit.framework.dll Syntax [AttributeUsage(AttributeTargets.Method, AllowMultiple = true, Inherited = false)] public class TestCaseAttribute<T> : TestCaseAttribute, ITestBuilder, ITestCaseData, ITestData, IImplyFixture Type Parameters Name Description T Constructors View Source TestCaseAttribute(T) Construct a TestCaseAttribute with a list of arguments. Declaration public TestCaseAttribute(T argument) Parameters Type Name Description T argument Implements ITestBuilder ITestCaseData ITestData IImplyFixture"
  },
  "api/NUnit.Framework.TestCaseAttribute-2.html": {
    "href": "api/NUnit.Framework.TestCaseAttribute-2.html",
    "title": "Class TestCaseAttribute<T1, T2> | NUnit Docs",
    "summary": "Class TestCaseAttribute<T1, T2> Marks a method as a parameterized test suite and provides arguments for each test case. Inheritance object Attribute NUnitAttribute TestCaseAttribute TestCaseAttribute<T1, T2> Implements ITestBuilder ITestCaseData ITestData IImplyFixture Inherited Members TestCaseAttribute.BuildFrom(IMethodInfo, Test) TestCaseAttribute.TestName TestCaseAttribute.RunState TestCaseAttribute.Arguments TestCaseAttribute.Properties TestCaseAttribute.ExpectedResult TestCaseAttribute.HasExpectedResult TestCaseAttribute.Description TestCaseAttribute.Author TestCaseAttribute.TestOf TestCaseAttribute.Ignore TestCaseAttribute.Explicit TestCaseAttribute.Reason TestCaseAttribute.IgnoreReason TestCaseAttribute.IncludePlatform TestCaseAttribute.ExcludePlatform TestCaseAttribute.TypeArgs TestCaseAttribute.Category TestCaseAttribute.Until Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object, object) object.ReferenceEquals(object, object) Namespace: NUnit.Framework Assembly: nunit.framework.dll Syntax [AttributeUsage(AttributeTargets.Method, AllowMultiple = true, Inherited = false)] public class TestCaseAttribute<T1, T2> : TestCaseAttribute, ITestBuilder, ITestCaseData, ITestData, IImplyFixture Type Parameters Name Description T1 T2 Constructors View Source TestCaseAttribute(T1, T2) Construct a TestCaseAttribute with a list of arguments. Declaration public TestCaseAttribute(T1 argument1, T2 argument2) Parameters Type Name Description T1 argument1 T2 argument2 Implements ITestBuilder ITestCaseData ITestData IImplyFixture"
  },
  "api/NUnit.Framework.TestCaseAttribute-3.html": {
    "href": "api/NUnit.Framework.TestCaseAttribute-3.html",
    "title": "Class TestCaseAttribute<T1, T2, T3> | NUnit Docs",
    "summary": "Class TestCaseAttribute<T1, T2, T3> Marks a method as a parameterized test suite and provides arguments for each test case. Inheritance object Attribute NUnitAttribute TestCaseAttribute TestCaseAttribute<T1, T2, T3> Implements ITestBuilder ITestCaseData ITestData IImplyFixture Inherited Members TestCaseAttribute.BuildFrom(IMethodInfo, Test) TestCaseAttribute.TestName TestCaseAttribute.RunState TestCaseAttribute.Arguments TestCaseAttribute.Properties TestCaseAttribute.ExpectedResult TestCaseAttribute.HasExpectedResult TestCaseAttribute.Description TestCaseAttribute.Author TestCaseAttribute.TestOf TestCaseAttribute.Ignore TestCaseAttribute.Explicit TestCaseAttribute.Reason TestCaseAttribute.IgnoreReason TestCaseAttribute.IncludePlatform TestCaseAttribute.ExcludePlatform TestCaseAttribute.TypeArgs TestCaseAttribute.Category TestCaseAttribute.Until Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object, object) object.ReferenceEquals(object, object) Namespace: NUnit.Framework Assembly: nunit.framework.dll Syntax [AttributeUsage(AttributeTargets.Method, AllowMultiple = true, Inherited = false)] public class TestCaseAttribute<T1, T2, T3> : TestCaseAttribute, ITestBuilder, ITestCaseData, ITestData, IImplyFixture Type Parameters Name Description T1 T2 T3 Constructors View Source TestCaseAttribute(T1, T2, T3) Construct a TestCaseAttribute with a list of arguments. Declaration public TestCaseAttribute(T1 argument1, T2 argument2, T3 argument3) Parameters Type Name Description T1 argument1 T2 argument2 T3 argument3 Implements ITestBuilder ITestCaseData ITestData IImplyFixture"
  },
  "api/NUnit.Framework.TestCaseAttribute-4.html": {
    "href": "api/NUnit.Framework.TestCaseAttribute-4.html",
    "title": "Class TestCaseAttribute<T1, T2, T3, T4> | NUnit Docs",
    "summary": "Class TestCaseAttribute<T1, T2, T3, T4> Marks a method as a parameterized test suite and provides arguments for each test case. Inheritance object Attribute NUnitAttribute TestCaseAttribute TestCaseAttribute<T1, T2, T3, T4> Implements ITestBuilder ITestCaseData ITestData IImplyFixture Inherited Members TestCaseAttribute.BuildFrom(IMethodInfo, Test) TestCaseAttribute.TestName TestCaseAttribute.RunState TestCaseAttribute.Arguments TestCaseAttribute.Properties TestCaseAttribute.ExpectedResult TestCaseAttribute.HasExpectedResult TestCaseAttribute.Description TestCaseAttribute.Author TestCaseAttribute.TestOf TestCaseAttribute.Ignore TestCaseAttribute.Explicit TestCaseAttribute.Reason TestCaseAttribute.IgnoreReason TestCaseAttribute.IncludePlatform TestCaseAttribute.ExcludePlatform TestCaseAttribute.TypeArgs TestCaseAttribute.Category TestCaseAttribute.Until Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object, object) object.ReferenceEquals(object, object) Namespace: NUnit.Framework Assembly: nunit.framework.dll Syntax [AttributeUsage(AttributeTargets.Method, AllowMultiple = true, Inherited = false)] public class TestCaseAttribute<T1, T2, T3, T4> : TestCaseAttribute, ITestBuilder, ITestCaseData, ITestData, IImplyFixture Type Parameters Name Description T1 T2 T3 T4 Constructors View Source TestCaseAttribute(T1, T2, T3, T4) Construct a TestCaseAttribute with a list of arguments. Declaration public TestCaseAttribute(T1 argument1, T2 argument2, T3 argument3, T4 argument4) Parameters Type Name Description T1 argument1 T2 argument2 T3 argument3 T4 argument4 Implements ITestBuilder ITestCaseData ITestData IImplyFixture"
  },
  "api/NUnit.Framework.TestCaseAttribute-5.html": {
    "href": "api/NUnit.Framework.TestCaseAttribute-5.html",
    "title": "Class TestCaseAttribute<T1, T2, T3, T4, T5> | NUnit Docs",
    "summary": "Class TestCaseAttribute<T1, T2, T3, T4, T5> Marks a method as a parameterized test suite and provides arguments for each test case. Inheritance object Attribute NUnitAttribute TestCaseAttribute TestCaseAttribute<T1, T2, T3, T4, T5> Implements ITestBuilder ITestCaseData ITestData IImplyFixture Inherited Members TestCaseAttribute.BuildFrom(IMethodInfo, Test) TestCaseAttribute.TestName TestCaseAttribute.RunState TestCaseAttribute.Arguments TestCaseAttribute.Properties TestCaseAttribute.ExpectedResult TestCaseAttribute.HasExpectedResult TestCaseAttribute.Description TestCaseAttribute.Author TestCaseAttribute.TestOf TestCaseAttribute.Ignore TestCaseAttribute.Explicit TestCaseAttribute.Reason TestCaseAttribute.IgnoreReason TestCaseAttribute.IncludePlatform TestCaseAttribute.ExcludePlatform TestCaseAttribute.TypeArgs TestCaseAttribute.Category TestCaseAttribute.Until Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object, object) object.ReferenceEquals(object, object) Namespace: NUnit.Framework Assembly: nunit.framework.dll Syntax [AttributeUsage(AttributeTargets.Method, AllowMultiple = true, Inherited = false)] public class TestCaseAttribute<T1, T2, T3, T4, T5> : TestCaseAttribute, ITestBuilder, ITestCaseData, ITestData, IImplyFixture Type Parameters Name Description T1 T2 T3 T4 T5 Constructors View Source TestCaseAttribute(T1, T2, T3, T4, T5) Construct a TestCaseAttribute with a list of arguments. Declaration public TestCaseAttribute(T1 argument1, T2 argument2, T3 argument3, T4 argument4, T5 argument5) Parameters Type Name Description T1 argument1 T2 argument2 T3 argument3 T4 argument4 T5 argument5 Implements ITestBuilder ITestCaseData ITestData IImplyFixture"
  },
  "api/NUnit.Framework.TestCaseAttribute.html": {
    "href": "api/NUnit.Framework.TestCaseAttribute.html",
    "title": "Class TestCaseAttribute | NUnit Docs",
    "summary": "Class TestCaseAttribute Marks a method as a parameterized test suite and provides arguments for each test case. Inheritance object Attribute NUnitAttribute TestCaseAttribute TestCaseAttribute<T> TestCaseAttribute<T1, T2> TestCaseAttribute<T1, T2, T3> TestCaseAttribute<T1, T2, T3, T4> TestCaseAttribute<T1, T2, T3, T4, T5> Implements ITestBuilder ITestCaseData ITestData IImplyFixture Inherited Members Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object, object) object.ReferenceEquals(object, object) Namespace: NUnit.Framework Assembly: nunit.framework.dll Syntax [AttributeUsage(AttributeTargets.Method, AllowMultiple = true, Inherited = false)] public class TestCaseAttribute : NUnitAttribute, ITestBuilder, ITestCaseData, ITestData, IImplyFixture Constructors View Source TestCaseAttribute(object?) Construct a TestCaseAttribute with a single argument Declaration public TestCaseAttribute(object? arg) Parameters Type Name Description object arg View Source TestCaseAttribute(object?, object?) Construct a TestCaseAttribute with a two arguments Declaration public TestCaseAttribute(object? arg1, object? arg2) Parameters Type Name Description object arg1 object arg2 View Source TestCaseAttribute(object?, object?, object?) Construct a TestCaseAttribute with a three arguments Declaration public TestCaseAttribute(object? arg1, object? arg2, object? arg3) Parameters Type Name Description object arg1 object arg2 object arg3 View Source TestCaseAttribute(params object?[]?) Construct a TestCaseAttribute with a list of arguments. This constructor is not CLS-Compliant Declaration public TestCaseAttribute(params object?[]? arguments) Parameters Type Name Description object[] arguments Properties View Source Arguments Gets the list of arguments to a test case Declaration public object?[] Arguments { get; } Property Value Type Description object[] View Source Author The author of this test Declaration public string? Author { get; set; } Property Value Type Description string View Source Category Gets and sets the category for this test case. May be a comma-separated list of categories. Declaration public string? Category { get; set; } Property Value Type Description string View Source Description Gets or sets the description. Declaration public string? Description { get; set; } Property Value Type Description string The description. View Source ExcludePlatform Comma-delimited list of platforms to not run the test for Declaration public string? ExcludePlatform { get; set; } Property Value Type Description string View Source ExpectedResult Gets or sets the expected result. Declaration public object? ExpectedResult { get; set; } Property Value Type Description object The result. View Source Explicit Gets or sets a value indicating whether this TestCaseAttribute is explicit. Declaration public bool Explicit { get; set; } Property Value Type Description bool true if explicit; otherwise, false. View Source HasExpectedResult Returns true if the expected result has been set Declaration public bool HasExpectedResult { get; } Property Value Type Description bool View Source Ignore Gets or sets the reason for ignoring the test Declaration public string? Ignore { get; set; } Property Value Type Description string View Source IgnoreReason Gets or sets the ignore reason. When set to a non-null non-empty value, the test is marked as ignored. Declaration public string? IgnoreReason { get; set; } Property Value Type Description string The ignore reason. View Source IncludePlatform Comma-delimited list of platforms to run the test for Declaration public string? IncludePlatform { get; set; } Property Value Type Description string View Source Properties Gets the properties of the test case Declaration public IPropertyBag Properties { get; } Property Value Type Description IPropertyBag View Source Reason Gets or sets the reason for not running the test. Declaration public string? Reason { get; set; } Property Value Type Description string The reason. View Source RunState Gets or sets the RunState of this test case. Declaration public RunState RunState { get; } Property Value Type Description RunState View Source TestName Gets or sets the name of the test. Declaration public string? TestName { get; set; } Property Value Type Description string The name of the test. View Source TestOf The type that this test is testing Declaration public Type? TestOf { get; set; } Property Value Type Description Type View Source TypeArgs Get or set the type arguments for a generic test method. If not set explicitly, the generic types will be inferred based on the test case parameters. Declaration public Type[]? TypeArgs { get; set; } Property Value Type Description Type[] View Source Until Gets and sets the ignore until date for this test case. Declaration public string? Until { get; set; } Property Value Type Description string Methods View Source BuildFrom(IMethodInfo, Test?) Builds a single test from the specified method and context. Declaration public IEnumerable<TestMethod> BuildFrom(IMethodInfo method, Test? suite) Parameters Type Name Description IMethodInfo method The MethodInfo for which tests are to be constructed. Test suite The suite to which the tests will be added. Returns Type Description IEnumerable<TestMethod> Implements ITestBuilder ITestCaseData ITestData IImplyFixture"
  },
  "api/NUnit.Framework.TestCaseData-1.html": {
    "href": "api/NUnit.Framework.TestCaseData-1.html",
    "title": "Class TestCaseData<T> | NUnit Docs",
    "summary": "Class TestCaseData<T> Marks a method as a parameterized test suite and provides arguments for each test case. Inheritance object TestParameters TestCaseParameters TestCaseData TestCaseData<T> Implements ITestCaseData ITestData IApplyToTest Inherited Members TestCaseData.Returns(object) TestCaseData.SetName(string) TestCaseData.SetArgDisplayNames(params string[]) TestCaseData.SetDescription(string) TestCaseData.SetCategory(string) TestCaseData.SetProperty(string, string) TestCaseData.SetProperty(string, int) TestCaseData.SetProperty(string, double) TestCaseData.Explicit() TestCaseData.Explicit(string) TestCaseData.Ignore(string) object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework Assembly: nunit.framework.dll Syntax public class TestCaseData<T> : TestCaseData, ITestCaseData, ITestData, IApplyToTest Type Parameters Name Description T Constructors View Source TestCaseData(T) Construct a TestCaseData with a list of arguments. Declaration public TestCaseData(T argument) Parameters Type Name Description T argument Implements ITestCaseData ITestData IApplyToTest"
  },
  "api/NUnit.Framework.TestCaseData-2.html": {
    "href": "api/NUnit.Framework.TestCaseData-2.html",
    "title": "Class TestCaseData<T1, T2> | NUnit Docs",
    "summary": "Class TestCaseData<T1, T2> Marks a method as a parameterized test suite and provides arguments for each test case. Inheritance object TestParameters TestCaseParameters TestCaseData TestCaseData<T1, T2> Implements ITestCaseData ITestData IApplyToTest Inherited Members TestCaseData.Returns(object) TestCaseData.SetName(string) TestCaseData.SetArgDisplayNames(params string[]) TestCaseData.SetDescription(string) TestCaseData.SetCategory(string) TestCaseData.SetProperty(string, string) TestCaseData.SetProperty(string, int) TestCaseData.SetProperty(string, double) TestCaseData.Explicit() TestCaseData.Explicit(string) TestCaseData.Ignore(string) object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework Assembly: nunit.framework.dll Syntax public class TestCaseData<T1, T2> : TestCaseData, ITestCaseData, ITestData, IApplyToTest Type Parameters Name Description T1 T2 Constructors View Source TestCaseData(T1, T2) Construct a TestCaseData with a list of arguments. Declaration public TestCaseData(T1 argument1, T2 argument2) Parameters Type Name Description T1 argument1 T2 argument2 Implements ITestCaseData ITestData IApplyToTest"
  },
  "api/NUnit.Framework.TestCaseData-3.html": {
    "href": "api/NUnit.Framework.TestCaseData-3.html",
    "title": "Class TestCaseData<T1, T2, T3> | NUnit Docs",
    "summary": "Class TestCaseData<T1, T2, T3> Marks a method as a parameterized test suite and provides arguments for each test case. Inheritance object TestParameters TestCaseParameters TestCaseData TestCaseData<T1, T2, T3> Implements ITestCaseData ITestData IApplyToTest Inherited Members TestCaseData.Returns(object) TestCaseData.SetName(string) TestCaseData.SetArgDisplayNames(params string[]) TestCaseData.SetDescription(string) TestCaseData.SetCategory(string) TestCaseData.SetProperty(string, string) TestCaseData.SetProperty(string, int) TestCaseData.SetProperty(string, double) TestCaseData.Explicit() TestCaseData.Explicit(string) TestCaseData.Ignore(string) object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework Assembly: nunit.framework.dll Syntax public class TestCaseData<T1, T2, T3> : TestCaseData, ITestCaseData, ITestData, IApplyToTest Type Parameters Name Description T1 T2 T3 Constructors View Source TestCaseData(T1, T2, T3) Construct a TestCaseData with a list of arguments. Declaration public TestCaseData(T1 argument1, T2 argument2, T3 argument3) Parameters Type Name Description T1 argument1 T2 argument2 T3 argument3 Implements ITestCaseData ITestData IApplyToTest"
  },
  "api/NUnit.Framework.TestCaseData-4.html": {
    "href": "api/NUnit.Framework.TestCaseData-4.html",
    "title": "Class TestCaseData<T1, T2, T3, T4> | NUnit Docs",
    "summary": "Class TestCaseData<T1, T2, T3, T4> Marks a method as a parameterized test suite and provides arguments for each test case. Inheritance object TestParameters TestCaseParameters TestCaseData TestCaseData<T1, T2, T3, T4> Implements ITestCaseData ITestData IApplyToTest Inherited Members TestCaseData.Returns(object) TestCaseData.SetName(string) TestCaseData.SetArgDisplayNames(params string[]) TestCaseData.SetDescription(string) TestCaseData.SetCategory(string) TestCaseData.SetProperty(string, string) TestCaseData.SetProperty(string, int) TestCaseData.SetProperty(string, double) TestCaseData.Explicit() TestCaseData.Explicit(string) TestCaseData.Ignore(string) object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework Assembly: nunit.framework.dll Syntax public class TestCaseData<T1, T2, T3, T4> : TestCaseData, ITestCaseData, ITestData, IApplyToTest Type Parameters Name Description T1 T2 T3 T4 Constructors View Source TestCaseData(T1, T2, T3, T4) Construct a TestCaseData with a list of arguments. Declaration public TestCaseData(T1 argument1, T2 argument2, T3 argument3, T4 argument4) Parameters Type Name Description T1 argument1 T2 argument2 T3 argument3 T4 argument4 Implements ITestCaseData ITestData IApplyToTest"
  },
  "api/NUnit.Framework.TestCaseData-5.html": {
    "href": "api/NUnit.Framework.TestCaseData-5.html",
    "title": "Class TestCaseData<T1, T2, T3, T4, T5> | NUnit Docs",
    "summary": "Class TestCaseData<T1, T2, T3, T4, T5> Marks a method as a parameterized test suite and provides arguments for each test case. Inheritance object TestParameters TestCaseParameters TestCaseData TestCaseData<T1, T2, T3, T4, T5> Implements ITestCaseData ITestData IApplyToTest Inherited Members TestCaseData.Returns(object) TestCaseData.SetName(string) TestCaseData.SetArgDisplayNames(params string[]) TestCaseData.SetDescription(string) TestCaseData.SetCategory(string) TestCaseData.SetProperty(string, string) TestCaseData.SetProperty(string, int) TestCaseData.SetProperty(string, double) TestCaseData.Explicit() TestCaseData.Explicit(string) TestCaseData.Ignore(string) object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework Assembly: nunit.framework.dll Syntax public class TestCaseData<T1, T2, T3, T4, T5> : TestCaseData, ITestCaseData, ITestData, IApplyToTest Type Parameters Name Description T1 T2 T3 T4 T5 Constructors View Source TestCaseData(T1, T2, T3, T4, T5) Construct a TestCaseData with a list of arguments. Declaration public TestCaseData(T1 argument1, T2 argument2, T3 argument3, T4 argument4, T5 argument5) Parameters Type Name Description T1 argument1 T2 argument2 T3 argument3 T4 argument4 T5 argument5 Implements ITestCaseData ITestData IApplyToTest"
  },
  "api/NUnit.Framework.TestCaseData.html": {
    "href": "api/NUnit.Framework.TestCaseData.html",
    "title": "Class TestCaseData | NUnit Docs",
    "summary": "Class TestCaseData The TestCaseData class represents a set of arguments and other parameter info to be used for a parameterized test case. It is derived from TestCaseParameters and adds a fluent syntax for use in initializing the test case. Inheritance object TestParameters TestCaseParameters TestCaseData TestCaseData<T> TestCaseData<T1, T2> TestCaseData<T1, T2, T3> TestCaseData<T1, T2, T3, T4> TestCaseData<T1, T2, T3, T4, T5> Implements ITestCaseData ITestData IApplyToTest Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework Assembly: nunit.framework.dll Syntax public class TestCaseData : TestCaseParameters, ITestCaseData, ITestData, IApplyToTest Constructors View Source TestCaseData(object?) Initializes a new instance of the TestCaseData class. Declaration public TestCaseData(object? arg) Parameters Type Name Description object arg The argument. View Source TestCaseData(object?, object?) Initializes a new instance of the TestCaseData class. Declaration public TestCaseData(object? arg1, object? arg2) Parameters Type Name Description object arg1 The first argument. object arg2 The second argument. View Source TestCaseData(object?, object?, object?) Initializes a new instance of the TestCaseData class. Declaration public TestCaseData(object? arg1, object? arg2, object? arg3) Parameters Type Name Description object arg1 The first argument. object arg2 The second argument. object arg3 The third argument. View Source TestCaseData(params object?[]?) Initializes a new instance of the TestCaseData class. Declaration public TestCaseData(params object?[]? args) Parameters Type Name Description object[] args The arguments. Methods View Source Explicit() Marks the test case as explicit. Declaration public TestCaseData Explicit() Returns Type Description TestCaseData View Source Explicit(string) Marks the test case as explicit, specifying the reason. Declaration public TestCaseData Explicit(string reason) Parameters Type Name Description string reason Returns Type Description TestCaseData View Source Ignore(string) Ignores this TestCase, specifying the reason. Declaration public IgnoredTestCaseData Ignore(string reason) Parameters Type Name Description string reason The reason. Returns Type Description IgnoredTestCaseData View Source Returns(object?) Sets the expected result for the test Declaration public TestCaseData Returns(object? result) Parameters Type Name Description object result The expected result Returns Type Description TestCaseData A modified TestCaseData View Source SetArgDisplayNames(params string[]?) Sets the list of display names to use as the parameters in the test name. Declaration public TestCaseData SetArgDisplayNames(params string[]? displayNames) Parameters Type Name Description string[] displayNames Returns Type Description TestCaseData The modified TestCaseData instance Examples TestCaseData testCase = new TestCaseData(args) .SetArgDisplayNames(\"arg1DisplayName\", \"arg2DisplayName\"); View Source SetCategory(string) Applies a category to the test Declaration public TestCaseData SetCategory(string category) Parameters Type Name Description string category Returns Type Description TestCaseData View Source SetDescription(string) Sets the description for the test case being constructed. Declaration public TestCaseData SetDescription(string description) Parameters Type Name Description string description The description. Returns Type Description TestCaseData The modified TestCaseData instance. View Source SetName(string?) Sets the name of the test case Declaration public TestCaseData SetName(string? name) Parameters Type Name Description string name Returns Type Description TestCaseData The modified TestCaseData instance Remarks Consider using SetArgDisplayNames(params string[]?)for setting argument values in the test name. SetArgDisplayNames(params string[]?) allows you to specify the display names for parameters directly without needing to use tokens like {m}. View Source SetProperty(string, double) Applies a named property to the test Declaration public TestCaseData SetProperty(string propName, double propValue) Parameters Type Name Description string propName double propValue Returns Type Description TestCaseData View Source SetProperty(string, int) Applies a named property to the test Declaration public TestCaseData SetProperty(string propName, int propValue) Parameters Type Name Description string propName int propValue Returns Type Description TestCaseData View Source SetProperty(string, string) Applies a named property to the test Declaration public TestCaseData SetProperty(string propName, string propValue) Parameters Type Name Description string propName string propValue Returns Type Description TestCaseData Implements ITestCaseData ITestData IApplyToTest"
  },
  "api/NUnit.Framework.TestCaseSourceAttribute.html": {
    "href": "api/NUnit.Framework.TestCaseSourceAttribute.html",
    "title": "Class TestCaseSourceAttribute | NUnit Docs",
    "summary": "Class TestCaseSourceAttribute Indicates the source to be used to provide test fixture instances for a test class. Inheritance object Attribute NUnitAttribute TestCaseSourceAttribute Implements ITestBuilder IImplyFixture Inherited Members Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object, object) object.ReferenceEquals(object, object) Namespace: NUnit.Framework Assembly: nunit.framework.dll Syntax [AttributeUsage(AttributeTargets.Method, AllowMultiple = true, Inherited = false)] public class TestCaseSourceAttribute : NUnitAttribute, ITestBuilder, IImplyFixture Constructors View Source TestCaseSourceAttribute(string) Construct with the name of the method, property or field that will provide data Declaration public TestCaseSourceAttribute(string sourceName) Parameters Type Name Description string sourceName The name of a static method, property or field that will provide data. View Source TestCaseSourceAttribute(string, object?[]?) Construct with a name Declaration public TestCaseSourceAttribute(string sourceName, object?[]? methodParams) Parameters Type Name Description string sourceName The name of a static method, property or field that will provide data. object[] methodParams A set of parameters passed to the method, works only if the Source Name is a method. If the source name is a field or property has no effect. View Source TestCaseSourceAttribute(Type) Construct with a Type Declaration public TestCaseSourceAttribute(Type sourceType) Parameters Type Name Description Type sourceType The type that will provide data View Source TestCaseSourceAttribute(Type, string) Construct with a Type and name Declaration public TestCaseSourceAttribute(Type sourceType, string sourceName) Parameters Type Name Description Type sourceType The Type that will provide data string sourceName The name of a static method, property or field that will provide data. View Source TestCaseSourceAttribute(Type, string, object?[]?) Construct with a Type and name Declaration public TestCaseSourceAttribute(Type sourceType, string sourceName, object?[]? methodParams) Parameters Type Name Description Type sourceType The Type that will provide data string sourceName The name of a static method, property or field that will provide data. object[] methodParams A set of parameters passed to the method, works only if the Source Name is a method. If the source name is a field or property has no effect. Properties View Source Category Gets or sets the category associated with every fixture created from this attribute. May be a single category or a comma-separated list. Declaration public string? Category { get; set; } Property Value Type Description string View Source MethodParams A set of parameters passed to the method, works only if the Source Name is a method. If the source name is a field or property has no effect. Declaration public object?[]? MethodParams { get; } Property Value Type Description object[] View Source SourceName The name of a the method, property or field to be used as a source Declaration public string? SourceName { get; } Property Value Type Description string View Source SourceType A Type to be used as a source Declaration public Type? SourceType { get; } Property Value Type Description Type Methods View Source BuildFrom(IMethodInfo, Test?) Builds any number of tests from the specified method and context. Declaration public IEnumerable<TestMethod> BuildFrom(IMethodInfo method, Test? suite) Parameters Type Name Description IMethodInfo method The IMethod for which tests are to be constructed. Test suite The suite to which the tests will be added. Returns Type Description IEnumerable<TestMethod> Implements ITestBuilder IImplyFixture"
  },
  "api/NUnit.Framework.TestContext.PropertyBagAdapter.html": {
    "href": "api/NUnit.Framework.TestContext.PropertyBagAdapter.html",
    "title": "Class TestContext.PropertyBagAdapter | NUnit Docs",
    "summary": "Class TestContext.PropertyBagAdapter TestContext.PropertyBagAdapter adapts an IPropertyBag for consumption by the user. Inheritance object TestContext.PropertyBagAdapter Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework Assembly: nunit.framework.dll Syntax public class TestContext.PropertyBagAdapter Constructors View Source PropertyBagAdapter(IPropertyBag) Construct a TestContext.PropertyBagAdapter from a source IPropertyBag. Declaration public PropertyBagAdapter(IPropertyBag source) Parameters Type Name Description IPropertyBag source Properties View Source this[string] Returns a collection of properties with the given key. Declaration public IEnumerable<object> this[string key] { get; } Parameters Type Name Description string key Property Value Type Description IEnumerable<object> View Source Keys Returns a collection of the property keys. Declaration public ICollection<string> Keys { get; } Property Value Type Description ICollection<string> Methods View Source ContainsKey(string) Indicates whether key is found in this TestContext.PropertyBagAdapter. Declaration public bool ContainsKey(string key) Parameters Type Name Description string key Returns Type Description bool View Source Count(string) Returns the count of elements with the given key. Declaration public int Count(string key) Parameters Type Name Description string key Returns Type Description int View Source Get(string) Get the first property with the given key, if it can be found, otherwise returns null. Declaration public object? Get(string key) Parameters Type Name Description string key Returns Type Description object"
  },
  "api/NUnit.Framework.TestContext.PropertyHierachyItem.html": {
    "href": "api/NUnit.Framework.TestContext.PropertyHierachyItem.html",
    "title": "Class TestContext.PropertyHierachyItem | NUnit Docs",
    "summary": "Class TestContext.PropertyHierachyItem Represents properties at different test levels Inheritance object TestContext.PropertyHierachyItem Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework Assembly: nunit.framework.dll Syntax public class TestContext.PropertyHierachyItem Constructors View Source PropertyHierachyItem() Property with empty name and level. Declaration public PropertyHierachyItem() View Source PropertyHierachyItem(string, string) Property with given name and level. Declaration public PropertyHierachyItem(string name, string level) Parameters Type Name Description string name string level Properties View Source Level Name of test level, from ITest Declaration public string Level { get; } Property Value Type Description string View Source Name Name of propertyHierarchyItem Declaration public string Name { get; } Property Value Type Description string"
  },
  "api/NUnit.Framework.TestContext.PropertyValueHierarchyItem.html": {
    "href": "api/NUnit.Framework.TestContext.PropertyValueHierarchyItem.html",
    "title": "Class TestContext.PropertyValueHierarchyItem | NUnit Docs",
    "summary": "Class TestContext.PropertyValueHierarchyItem Represents property value at different test levels Inheritance object TestContext.PropertyValueHierarchyItem Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework Assembly: nunit.framework.dll Syntax public class TestContext.PropertyValueHierarchyItem Constructors View Source PropertyValueHierarchyItem(string, IList) Initializes a new instance of the TestContext.PropertyValueHierarchyItem class. Declaration public PropertyValueHierarchyItem(string testName, IList propValues) Parameters Type Name Description string testName Level IList propValues List of values Properties View Source Level Level of the test (aka test name) Declaration public string Level { get; set; } Property Value Type Description string View Source Values List of values for the given level Declaration public IList Values { get; set; } Property Value Type Description IList"
  },
  "api/NUnit.Framework.TestContext.ResultAdapter.html": {
    "href": "api/NUnit.Framework.TestContext.ResultAdapter.html",
    "title": "Class TestContext.ResultAdapter | NUnit Docs",
    "summary": "Class TestContext.ResultAdapter ResultAdapter adapts a TestResult for consumption by the user test code. Inheritance object TestContext.ResultAdapter Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework Assembly: nunit.framework.dll Syntax public class TestContext.ResultAdapter Constructors View Source ResultAdapter(TestResult) Construct a ResultAdapter for a TestResult Declaration public ResultAdapter(TestResult result) Parameters Type Name Description TestResult result The TestResult to be adapted Properties View Source Assertions Gets a list of the assertion results generated up to this point in the test. Declaration public IEnumerable<AssertionResult> Assertions { get; } Property Value Type Description IEnumerable<AssertionResult> View Source FailCount Gets the number of test cases that failed when running the test and all its children. Declaration public int FailCount { get; } Property Value Type Description int View Source InconclusiveCount Gets the number of test cases that were inconclusive when running the test and all its children. Declaration public int InconclusiveCount { get; } Property Value Type Description int View Source Message Gets the message associated with a test failure or with not running the test Declaration public string Message { get; } Property Value Type Description string View Source Outcome Gets a ResultState representing the outcome of the test up to this point in its execution. Declaration public ResultState Outcome { get; } Property Value Type Description ResultState View Source PassCount Gets the number of test cases that passed when running the test and all its children. Declaration public int PassCount { get; } Property Value Type Description int View Source SkipCount Gets the number of test cases that were skipped when running the test and all its children. Declaration public int SkipCount { get; } Property Value Type Description int View Source StackTrace Gets any stack trace associated with an error or failure. Declaration public virtual string? StackTrace { get; } Property Value Type Description string View Source WarningCount Gets the number of test cases that had warnings when running the test and all its children. Declaration public int WarningCount { get; } Property Value Type Description int"
  },
  "api/NUnit.Framework.TestContext.TestAdapter.html": {
    "href": "api/NUnit.Framework.TestContext.TestAdapter.html",
    "title": "Class TestContext.TestAdapter | NUnit Docs",
    "summary": "Class TestContext.TestAdapter TestAdapter adapts a Test for consumption by the user test code. Inheritance object TestContext.TestAdapter Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework Assembly: nunit.framework.dll Syntax public class TestContext.TestAdapter Constructors View Source TestAdapter(Test) Construct a TestAdapter for a Test Declaration public TestAdapter(Test test) Parameters Type Name Description Test test The Test to be adapted Properties View Source Arguments The arguments to use in creating the test or empty array if none are required. Declaration public object?[] Arguments { get; } Property Value Type Description object[] View Source ClassName The ClassName of the test Declaration public string? ClassName { get; } Property Value Type Description string View Source DisplayName Get the display name of the test. Declaration public string? DisplayName { get; } Property Value Type Description string View Source ExpectedResult The expected result if there is one for the test Declaration public object? ExpectedResult { get; } Property Value Type Description object View Source FullName The FullName of the test Declaration public string FullName { get; } Property Value Type Description string View Source ID Gets the unique Id of a test Declaration public string ID { get; } Property Value Type Description string View Source Method The method representing the test. Declaration public IMethodInfo? Method { get; } Property Value Type Description IMethodInfo View Source MethodName The name of the method representing the test. Declaration public string? MethodName { get; } Property Value Type Description string View Source Name The name of the test, which may or may not be the same as the method name. Declaration public string Name { get; } Property Value Type Description string View Source Namespace Get the Namespace of the test. Declaration public string? Namespace { get; } Property Value Type Description string View Source Parent The parent of this test or suite Declaration public ITest? Parent { get; } Property Value Type Description ITest View Source Properties A shallow copy of the properties of the test. Declaration public TestContext.PropertyBagAdapter Properties { get; } Property Value Type Description TestContext.PropertyBagAdapter View Source Type Gets the underlying Type. Declaration public Type? Type { get; } Property Value Type Description Type Methods View Source AllCategories() Return all categories in the hierarchy flattened Declaration public IEnumerable<string> AllCategories() Returns Type Description IEnumerable<string> View Source AllPropertyValues(string) Returns all values of a given property, with no duplicates Declaration public IEnumerable<object> AllPropertyValues(string property) Parameters Type Name Description string property Name of property Returns Type Description IEnumerable<object> View Source PropertyHierarchy() Returns all properties in the hierarchy Utility method for getting all properties in the hierarchy, with their included name, level and values. Declaration public IDictionary<TestContext.PropertyHierachyItem, IList> PropertyHierarchy() Returns Type Description IDictionary<TestContext.PropertyHierachyItem, IList>"
  },
  "api/NUnit.Framework.TestContext.html": {
    "href": "api/NUnit.Framework.TestContext.html",
    "title": "Class TestContext | NUnit Docs",
    "summary": "Class TestContext Provide the context information of the current test. This is an adapter for the internal ExecutionContext class, hiding the internals from the user test. Inheritance object TestContext Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework Assembly: nunit.framework.dll Syntax public class TestContext Constructors View Source TestContext(TestExecutionContext) Construct a TestContext for an ExecutionContext Declaration public TestContext(TestExecutionContext testExecutionContext) Parameters Type Name Description TestExecutionContext testExecutionContext The ExecutionContext to adapt Fields View Source Error Gets a TextWriter that will send output directly to Console.Error Declaration public static TextWriter Error Field Value Type Description TextWriter View Source Parameters TestParameters object holds parameters for the test run, if any are specified Declaration public static readonly TestParameters Parameters Field Value Type Description TestParameters View Source Progress Gets a TextWriter for use in displaying immediate progress messages Declaration public static readonly TextWriter Progress Field Value Type Description TextWriter Properties View Source AssertCount Gets the number of assertions executed up to this point in the test. Declaration public int AssertCount { get; } Property Value Type Description int View Source CancellationToken Gets the CancellationToken for the test case. Declaration public CancellationToken CancellationToken { get; } Property Value Type Description CancellationToken View Source CurrentContext Get the current test context. This is created as needed. The user may save the context for use within a test, but it should not be used outside the test for which it is created. Declaration public static TestContext CurrentContext { get; } Property Value Type Description TestContext View Source CurrentRepeatCount Get the number of times the current Test has been repeated when using the RetryAttribute or RepeatAttribute. Declaration public int CurrentRepeatCount { get; } Property Value Type Description int View Source Out Gets a TextWriter that will send output to the current test result. Declaration public static TextWriter Out { get; } Property Value Type Description TextWriter View Source Random Gets the random generator. Declaration public Randomizer Random { get; } Property Value Type Description Randomizer The random generator. View Source Result Gets a Representation of the TestResult for the current test. Declaration public TestContext.ResultAdapter Result { get; } Property Value Type Description TestContext.ResultAdapter View Source Test Get a representation of the current test. Declaration public TestContext.TestAdapter Test { get; } Property Value Type Description TestContext.TestAdapter View Source TestDirectory Gets the directory containing the current test assembly. Declaration public string TestDirectory { get; } Property Value Type Description string View Source WorkDirectory Gets the directory to be used for outputting files created by this test run. Declaration public string WorkDirectory { get; } Property Value Type Description string View Source WorkerId Gets the unique name of the Worker that is executing this test. Declaration public string? WorkerId { get; } Property Value Type Description string Methods View Source AddFormatter(ValueFormatterFactory) This method adds a new ValueFormatterFactory to the chain of responsibility used for formatting values in messages. The scope of the change is the current TestContext. Declaration public static void AddFormatter(ValueFormatterFactory formatterFactory) Parameters Type Name Description ValueFormatterFactory formatterFactory The factory delegate View Source AddFormatter<TSupported>(ValueFormatter) This method provides a simplified way to add a ValueFormatter delegate to the chain of responsibility, creating the factory delegate internally. It is useful when the Type of the object is the only criterion for selection of the formatter, since it can be used without getting involved with a compound function. Declaration public static void AddFormatter<TSupported>(ValueFormatter formatter) Parameters Type Name Description ValueFormatter formatter The ValueFormatter delegate Type Parameters Name Description TSupported The type supported by this formatter View Source AddTestAttachment(string, string?) Attach a file to the current test result Declaration public static void AddTestAttachment(string filePath, string? description = null) Parameters Type Name Description string filePath Relative or absolute file path to attachment string description Optional description of attachment View Source Write(bool) Write the string representation of a boolean value to the current result Declaration public static void Write(bool value) Parameters Type Name Description bool value View Source Write(char) Write a char to the current result Declaration public static void Write(char value) Parameters Type Name Description char value View Source Write(char[]?) Write a char array to the current result Declaration public static void Write(char[]? value) Parameters Type Name Description char[] value View Source Write(decimal) Write the string representation of a decimal value to the current result Declaration public static void Write(decimal value) Parameters Type Name Description decimal value View Source Write(double) Write the string representation of a double to the current result Declaration public static void Write(double value) Parameters Type Name Description double value View Source Write(int) Write the string representation of an Int32 value to the current result Declaration public static void Write(int value) Parameters Type Name Description int value View Source Write(long) Write the string representation of an Int64 value to the current result Declaration public static void Write(long value) Parameters Type Name Description long value View Source Write(object?) Write the string representation of an object to the current result Declaration public static void Write(object? value) Parameters Type Name Description object value View Source Write(float) Write the string representation of a Single value to the current result Declaration public static void Write(float value) Parameters Type Name Description float value View Source Write(string?) Write a string to the current result Declaration public static void Write(string? value) Parameters Type Name Description string value View Source Write(string, object?) Write a formatted string to the current result Declaration public static void Write(string format, object? arg1) Parameters Type Name Description string format object arg1 View Source Write(string, object?, object?) Write a formatted string to the current result Declaration public static void Write(string format, object? arg1, object? arg2) Parameters Type Name Description string format object arg1 object arg2 View Source Write(string, object?, object?, object?) Write a formatted string to the current result Declaration public static void Write(string format, object? arg1, object? arg2, object? arg3) Parameters Type Name Description string format object arg1 object arg2 object arg3 View Source Write(string, params object?[]) Write a formatted string to the current result Declaration public static void Write(string format, params object?[] args) Parameters Type Name Description string format object[] args View Source Write(uint) Write the string representation of a UInt32 value to the current result Declaration [CLSCompliant(false)] public static void Write(uint value) Parameters Type Name Description uint value View Source Write(ulong) Write the string representation of a UInt64 value to the current result Declaration [CLSCompliant(false)] public static void Write(ulong value) Parameters Type Name Description ulong value View Source WriteLine() Write a line terminator to the current result Declaration public static void WriteLine() View Source WriteLine(bool) Write the string representation of a boolean value to the current result followed by a line terminator Declaration public static void WriteLine(bool value) Parameters Type Name Description bool value View Source WriteLine(char) Write a char to the current result followed by a line terminator Declaration public static void WriteLine(char value) Parameters Type Name Description char value View Source WriteLine(char[]?) Write a char array to the current result followed by a line terminator Declaration public static void WriteLine(char[]? value) Parameters Type Name Description char[] value View Source WriteLine(decimal) Write the string representation of a decimal value to the current result followed by a line terminator Declaration public static void WriteLine(decimal value) Parameters Type Name Description decimal value View Source WriteLine(double) Write the string representation of a double to the current result followed by a line terminator Declaration public static void WriteLine(double value) Parameters Type Name Description double value View Source WriteLine(int) Write the string representation of an Int32 value to the current result followed by a line terminator Declaration public static void WriteLine(int value) Parameters Type Name Description int value View Source WriteLine(long) Write the string representation of an Int64 value to the current result followed by a line terminator Declaration public static void WriteLine(long value) Parameters Type Name Description long value View Source WriteLine(object?) Write the string representation of an object to the current result followed by a line terminator Declaration public static void WriteLine(object? value) Parameters Type Name Description object value View Source WriteLine(float) Write the string representation of a Single value to the current result followed by a line terminator Declaration public static void WriteLine(float value) Parameters Type Name Description float value View Source WriteLine(string?) Write a string to the current result followed by a line terminator Declaration public static void WriteLine(string? value) Parameters Type Name Description string value View Source WriteLine(string, object?) Write a formatted string to the current result followed by a line terminator Declaration public static void WriteLine(string format, object? arg1) Parameters Type Name Description string format object arg1 View Source WriteLine(string, object?, object?) Write a formatted string to the current result followed by a line terminator Declaration public static void WriteLine(string format, object? arg1, object? arg2) Parameters Type Name Description string format object arg1 object arg2 View Source WriteLine(string, object?, object?, object?) Write a formatted string to the current result followed by a line terminator Declaration public static void WriteLine(string format, object? arg1, object? arg2, object? arg3) Parameters Type Name Description string format object arg1 object arg2 object arg3 View Source WriteLine(string, params object?[]) Write a formatted string to the current result followed by a line terminator Declaration public static void WriteLine(string format, params object?[] args) Parameters Type Name Description string format object[] args View Source WriteLine(uint) Write the string representation of a UInt32 value to the current result followed by a line terminator Declaration [CLSCompliant(false)] public static void WriteLine(uint value) Parameters Type Name Description uint value View Source WriteLine(ulong) Write the string representation of a UInt64 value to the current result followed by a line terminator Declaration [CLSCompliant(false)] public static void WriteLine(ulong value) Parameters Type Name Description ulong value"
  },
  "api/NUnit.Framework.TestDelegate.html": {
    "href": "api/NUnit.Framework.TestDelegate.html",
    "title": "Delegate TestDelegate | NUnit Docs",
    "summary": "Delegate TestDelegate Delegate used by tests that execute code and capture any thrown exception. Namespace: NUnit.Framework Assembly: nunit.framework.dll Syntax public delegate void TestDelegate() Constructors View Source TestDelegate(object, nint) Declaration public TestDelegate(object @object, nint method) Parameters Type Name Description object object nint method Methods View Source BeginInvoke(AsyncCallback, object) Declaration public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object @object) Parameters Type Name Description AsyncCallback callback object object Returns Type Description IAsyncResult View Source EndInvoke(IAsyncResult) Declaration public virtual void EndInvoke(IAsyncResult result) Parameters Type Name Description IAsyncResult result View Source Invoke() Declaration public virtual void Invoke()"
  },
  "api/NUnit.Framework.TestFixtureAttribute.html": {
    "href": "api/NUnit.Framework.TestFixtureAttribute.html",
    "title": "Class TestFixtureAttribute | NUnit Docs",
    "summary": "Class TestFixtureAttribute Marks the class as a TestFixture. Inheritance object Attribute NUnitAttribute TestFixtureAttribute Implements IFixtureBuilder2 IFixtureBuilder ITestFixtureData ITestData Inherited Members Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object, object) object.ReferenceEquals(object, object) Namespace: NUnit.Framework Assembly: nunit.framework.dll Syntax [AttributeUsage(AttributeTargets.Class, AllowMultiple = true, Inherited = true)] public class TestFixtureAttribute : NUnitAttribute, IFixtureBuilder2, IFixtureBuilder, ITestFixtureData, ITestData Constructors View Source TestFixtureAttribute() Default constructor Declaration public TestFixtureAttribute() View Source TestFixtureAttribute(params object?[]?) Construct with a object[] representing a set of arguments. The arguments may later be separated into type arguments and constructor arguments. Declaration public TestFixtureAttribute(params object?[]? arguments) Parameters Type Name Description object[] arguments Properties View Source Arguments The arguments originally provided to the attribute Declaration public object?[] Arguments { get; } Property Value Type Description object[] View Source Author The author of this fixture Declaration public string? Author { get; set; } Property Value Type Description string View Source Category Gets and sets the category for this fixture. May be a comma-separated list of categories. Declaration public string? Category { get; set; } Property Value Type Description string View Source Description Descriptive text for this fixture Declaration public string? Description { get; set; } Property Value Type Description string View Source Explicit Gets or sets a value indicating whether this TestFixtureAttribute is explicit. Declaration public bool Explicit { get; set; } Property Value Type Description bool true if explicit; otherwise, false. View Source Ignore Gets or sets the ignore reason. May set RunState as a side effect. Declaration public string? Ignore { get; set; } Property Value Type Description string The ignore reason. View Source IgnoreReason Gets or sets the ignore reason. When set to a non-null non-empty value, the test is marked as ignored. Declaration public string? IgnoreReason { get; set; } Property Value Type Description string The ignore reason. View Source Properties Properties pertaining to this fixture Declaration public IPropertyBag Properties { get; } Property Value Type Description IPropertyBag View Source Reason Gets or sets the reason for not running the fixture. Declaration public string? Reason { get; set; } Property Value Type Description string The reason. View Source RunState Gets or sets the RunState of this test fixture. Declaration public RunState RunState { get; } Property Value Type Description RunState View Source TestName Gets or sets the name of the test. Declaration public string? TestName { get; set; } Property Value Type Description string The name of the test. View Source TestOf The type that this fixture is testing Declaration public Type? TestOf { get; set; } Property Value Type Description Type View Source TypeArgs Get or set the type arguments. If not set explicitly, any leading arguments that are Types are taken as type arguments. Declaration public Type[] TypeArgs { get; set; } Property Value Type Description Type[] Methods View Source BuildFrom(ITypeInfo) Builds a single test fixture from the specified type. Declaration public IEnumerable<TestSuite> BuildFrom(ITypeInfo typeInfo) Parameters Type Name Description ITypeInfo typeInfo Returns Type Description IEnumerable<TestSuite> View Source BuildFrom(ITypeInfo, IPreFilter) Builds a single test fixture from the specified type. Declaration public IEnumerable<TestSuite> BuildFrom(ITypeInfo typeInfo, IPreFilter filter) Parameters Type Name Description ITypeInfo typeInfo The type info of the fixture to be used. IPreFilter filter Filter used to select methods as tests. Returns Type Description IEnumerable<TestSuite> Implements IFixtureBuilder2 IFixtureBuilder ITestFixtureData ITestData"
  },
  "api/NUnit.Framework.TestFixtureData.html": {
    "href": "api/NUnit.Framework.TestFixtureData.html",
    "title": "Class TestFixtureData | NUnit Docs",
    "summary": "Class TestFixtureData The TestFixtureData class represents a set of arguments and other parameter info to be used for a parameterized fixture. It is derived from TestFixtureParameters and adds a fluent syntax for use in initializing the fixture. Inheritance object TestParameters TestFixtureParameters TestFixtureData Implements IApplyToTest ITestFixtureData ITestData Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework Assembly: nunit.framework.dll Syntax public class TestFixtureData : TestFixtureParameters, IApplyToTest, ITestFixtureData, ITestData Constructors View Source TestFixtureData(object?) Initializes a new instance of the TestFixtureData class. Declaration public TestFixtureData(object? arg) Parameters Type Name Description object arg The argument. View Source TestFixtureData(object?, object?) Initializes a new instance of the TestFixtureData class. Declaration public TestFixtureData(object? arg1, object? arg2) Parameters Type Name Description object arg1 The first argument. object arg2 The second argument. View Source TestFixtureData(object?, object?, object?) Initializes a new instance of the TestFixtureData class. Declaration public TestFixtureData(object? arg1, object? arg2, object? arg3) Parameters Type Name Description object arg1 The first argument. object arg2 The second argument. object arg3 The third argument. View Source TestFixtureData(params object?[]?) Initializes a new instance of the TestFixtureData class. Declaration public TestFixtureData(params object?[]? args) Parameters Type Name Description object[] args The arguments. Methods View Source Explicit() Marks the test fixture as explicit. Declaration public TestFixtureData Explicit() Returns Type Description TestFixtureData View Source Explicit(string) Marks the test fixture as explicit, specifying the reason. Declaration public TestFixtureData Explicit(string reason) Parameters Type Name Description string reason Returns Type Description TestFixtureData View Source Ignore(string) Ignores this TestFixture, specifying the reason. Declaration public TestFixtureData Ignore(string reason) Parameters Type Name Description string reason The reason. Returns Type Description TestFixtureData View Source SetArgDisplayNames(params string[]?) Sets the list of display names to use as the parameters in the test name. Declaration public TestFixtureData SetArgDisplayNames(params string[]? displayNames) Parameters Type Name Description string[] displayNames Returns Type Description TestFixtureData Implements IApplyToTest ITestFixtureData ITestData"
  },
  "api/NUnit.Framework.TestFixtureSourceAttribute.html": {
    "href": "api/NUnit.Framework.TestFixtureSourceAttribute.html",
    "title": "Class TestFixtureSourceAttribute | NUnit Docs",
    "summary": "Class TestFixtureSourceAttribute Identifies the source used to provide test fixture instances for a test class. Inheritance object Attribute NUnitAttribute TestFixtureSourceAttribute Implements IFixtureBuilder2 IFixtureBuilder Inherited Members Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object, object) object.ReferenceEquals(object, object) Namespace: NUnit.Framework Assembly: nunit.framework.dll Syntax [AttributeUsage(AttributeTargets.Class, AllowMultiple = true, Inherited = false)] public class TestFixtureSourceAttribute : NUnitAttribute, IFixtureBuilder2, IFixtureBuilder Constructors View Source TestFixtureSourceAttribute(string) Construct with the name of the method, property or field that will provide data Declaration public TestFixtureSourceAttribute(string sourceName) Parameters Type Name Description string sourceName The name of a static method, property or field that will provide data. View Source TestFixtureSourceAttribute(Type) Construct with a Type Declaration public TestFixtureSourceAttribute(Type sourceType) Parameters Type Name Description Type sourceType The type that will provide data View Source TestFixtureSourceAttribute(Type, string) Construct with a Type and name Declaration public TestFixtureSourceAttribute(Type sourceType, string sourceName) Parameters Type Name Description Type sourceType The Type that will provide data string sourceName The name of a static method, property or field that will provide data. Fields View Source MUST_BE_STATIC Error message string is public so the tests can use it Declaration public const string MUST_BE_STATIC = \"The sourceName specified on a TestCaseSourceAttribute must refer to a static field, property or method.\" Field Value Type Description string Properties View Source Category Gets or sets the category associated with every fixture created from this attribute. May be a single category or a comma-separated list. Declaration public string? Category { get; set; } Property Value Type Description string View Source SourceName The name of a the method, property or field to be used as a source Declaration public string? SourceName { get; } Property Value Type Description string View Source SourceType A Type to be used as a source Declaration public Type? SourceType { get; } Property Value Type Description Type Methods View Source BuildFrom(ITypeInfo) Builds any number of test fixtures from the specified type. Declaration public IEnumerable<TestSuite> BuildFrom(ITypeInfo typeInfo) Parameters Type Name Description ITypeInfo typeInfo The TypeInfo for which fixtures are to be constructed. Returns Type Description IEnumerable<TestSuite> View Source BuildFrom(ITypeInfo, IPreFilter) Builds any number of test fixtures from the specified type. Declaration public IEnumerable<TestSuite> BuildFrom(ITypeInfo typeInfo, IPreFilter filter) Parameters Type Name Description ITypeInfo typeInfo The TypeInfo for which fixtures are to be constructed. IPreFilter filter PreFilter used to select methods as tests. Returns Type Description IEnumerable<TestSuite> View Source GetParametersFor(Type) Returns a set of ITestFixtureData items for use as arguments to a parameterized test fixture. Declaration public IEnumerable<ITestFixtureData> GetParametersFor(Type sourceType) Parameters Type Name Description Type sourceType The type for which data is needed. Returns Type Description IEnumerable<ITestFixtureData> Implements IFixtureBuilder2 IFixtureBuilder"
  },
  "api/NUnit.Framework.TestOfAttribute.html": {
    "href": "api/NUnit.Framework.TestOfAttribute.html",
    "title": "Class TestOfAttribute | NUnit Docs",
    "summary": "Class TestOfAttribute Indicates the method or class the assembly, test fixture or test method is testing. Inheritance object Attribute NUnitAttribute PropertyAttribute TestOfAttribute Implements IApplyToTest Inherited Members PropertyAttribute.ApplyToTest(Test) PropertyAttribute.Properties Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object, object) object.ReferenceEquals(object, object) Namespace: NUnit.Framework Assembly: nunit.framework.dll Syntax [AttributeUsage(AttributeTargets.Assembly|AttributeTargets.Class|AttributeTargets.Method, AllowMultiple = true, Inherited = false)] public class TestOfAttribute : PropertyAttribute, IApplyToTest Constructors View Source TestOfAttribute(string) Initializes a new instance of the TestOfAttribute class. Declaration public TestOfAttribute(string typeName) Parameters Type Name Description string typeName The type that is being tested. View Source TestOfAttribute(Type) Initializes a new instance of the TestOfAttribute class. Declaration public TestOfAttribute(Type type) Parameters Type Name Description Type type The type that is being tested. Implements IApplyToTest"
  },
  "api/NUnit.Framework.TestParameters.html": {
    "href": "api/NUnit.Framework.TestParameters.html",
    "title": "Class TestParameters | NUnit Docs",
    "summary": "Class TestParameters TestParameters class holds any named parameters supplied to the test run Inheritance object TestParameters Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework Assembly: nunit.framework.dll Syntax public class TestParameters Constructors View Source TestParameters() Declaration public TestParameters() Properties View Source Count Gets the number of test parameters Declaration public int Count { get; } Property Value Type Description int View Source this[string] Indexer provides access to the internal dictionary Declaration public string? this[string name] { get; } Parameters Type Name Description string name Name of the parameter Property Value Type Description string Value of the parameter or null if not present View Source Names Gets a collection of the test parameter names Declaration public ICollection<string> Names { get; } Property Value Type Description ICollection<string> Methods View Source Exists(string) Gets a flag indicating whether a parameter with the specified name exists. Declaration public bool Exists(string name) Parameters Type Name Description string name Name of the parameter Returns Type Description bool True if it exists, otherwise false View Source Get(string) Get method is a simple alternative to the indexer Declaration public string? Get(string name) Parameters Type Name Description string name Name of the parameter Returns Type Description string Value of the parameter or null if not present View Source Get(string, string?) Get the value of a parameter or a default string Declaration public string? Get(string name, string? defaultValue) Parameters Type Name Description string name Name of the parameter string defaultValue Default value of the parameter Returns Type Description string Value of the parameter or default value if not present View Source Get<T>(string, T) Get the value of a parameter or return a default Declaration public T Get<T>(string name, T defaultValue) Parameters Type Name Description string name Name of the parameter T defaultValue Default value of the parameter Returns Type Description T Value of the parameter or default value if not present Type Parameters Name Description T The return Type"
  },
  "api/NUnit.Framework.TheoryAttribute.html": {
    "href": "api/NUnit.Framework.TheoryAttribute.html",
    "title": "Class TheoryAttribute | NUnit Docs",
    "summary": "Class TheoryAttribute Indicates that a test method is a theory and can be run multiple times with different input data. Inheritance object Attribute NUnitAttribute CombiningStrategyAttribute TheoryAttribute Implements IApplyToTest ITestBuilder IImplyFixture Inherited Members CombiningStrategyAttribute.BuildFrom(IMethodInfo, Test) CombiningStrategyAttribute.ApplyToTest(Test) Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object, object) object.ReferenceEquals(object, object) Namespace: NUnit.Framework Assembly: nunit.framework.dll Syntax [AttributeUsage(AttributeTargets.Method, AllowMultiple = false, Inherited = true)] public class TheoryAttribute : CombiningStrategyAttribute, IApplyToTest, ITestBuilder, IImplyFixture Remarks The theory attribute allows a test to be executed with a variety of data sets. For more details, please refer to the NUnit documentation. Examples public class SqrtTests { [DatapointSource] public double[] values = new double[] { 0.0, 1.0, -1.0, 42.0 }; [Theory] public void SquareRootDefinition(double num) { Assume.That(num >= 0.0); double sqrt = Math.Sqrt(num); Assert.That(sqrt >= 0.0); Assert.That(sqrt * sqrt, Is.EqualTo(num).Within(0.000001)); } } Constructors View Source TheoryAttribute(bool) Construct the attribute, specifying a combining strategy and source of parameter data. Declaration public TheoryAttribute(bool searchInDeclaringTypes = false) Parameters Type Name Description bool searchInDeclaringTypes Implements IApplyToTest ITestBuilder IImplyFixture See Also NUnit Theory Documentation"
  },
  "api/NUnit.Framework.Throws.html": {
    "href": "api/NUnit.Framework.Throws.html",
    "title": "Class Throws | NUnit Docs",
    "summary": "Class Throws Helper class with properties and methods that supply constraints that operate on exceptions. Inheritance object Throws Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework Assembly: nunit.framework.dll Syntax public abstract class Throws Constructors View Source Throws() Declaration protected Throws() Properties View Source ArgumentException Creates a constraint specifying an expected ArgumentException Declaration public static ExactTypeConstraint ArgumentException { get; } Property Value Type Description ExactTypeConstraint View Source ArgumentNullException Creates a constraint specifying an expected ArgumentNullException Declaration public static ExactTypeConstraint ArgumentNullException { get; } Property Value Type Description ExactTypeConstraint View Source Exception Creates a constraint specifying an expected exception Declaration public static ResolvableConstraintExpression Exception { get; } Property Value Type Description ResolvableConstraintExpression View Source InnerException Creates a constraint specifying an exception with a given InnerException Declaration public static ResolvableConstraintExpression InnerException { get; } Property Value Type Description ResolvableConstraintExpression View Source InvalidOperationException Creates a constraint specifying an expected InvalidOperationException Declaration public static ExactTypeConstraint InvalidOperationException { get; } Property Value Type Description ExactTypeConstraint View Source Nothing Creates a constraint specifying that no exception is thrown Declaration public static ThrowsNothingConstraint Nothing { get; } Property Value Type Description ThrowsNothingConstraint View Source TargetInvocationException Creates a constraint specifying an expected TargetInvocationException Declaration public static ExactTypeConstraint TargetInvocationException { get; } Property Value Type Description ExactTypeConstraint Methods View Source InstanceOf(Type) Creates a constraint specifying the type of exception expected Declaration public static InstanceOfTypeConstraint InstanceOf(Type expectedType) Parameters Type Name Description Type expectedType Returns Type Description InstanceOfTypeConstraint View Source InstanceOf<TExpected>() Creates a constraint specifying the type of exception expected Declaration public static InstanceOfTypeConstraint InstanceOf<TExpected>() where TExpected : Exception Returns Type Description InstanceOfTypeConstraint Type Parameters Name Description TExpected View Source TypeOf(Type) Creates a constraint specifying the exact type of exception expected Declaration public static ExactTypeConstraint TypeOf(Type expectedType) Parameters Type Name Description Type expectedType Returns Type Description ExactTypeConstraint View Source TypeOf<TExpected>() Creates a constraint specifying the exact type of exception expected Declaration public static ExactTypeConstraint TypeOf<TExpected>() where TExpected : Exception Returns Type Description ExactTypeConstraint Type Parameters Name Description TExpected"
  },
  "api/NUnit.Framework.TimeoutAttribute.html": {
    "href": "api/NUnit.Framework.TimeoutAttribute.html",
    "title": "Class TimeoutAttribute | NUnit Docs",
    "summary": "Class TimeoutAttribute Applies a timeout in milliseconds to a test. When applied to a method, the test is cancelled if the timeout is exceeded. When applied to a class or assembly, the default timeout is set for all contained test methods. Inheritance object Attribute NUnitAttribute PropertyAttribute TimeoutAttribute Implements IApplyToTest IApplyToContext Inherited Members PropertyAttribute.ApplyToTest(Test) PropertyAttribute.Properties Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object, object) object.ReferenceEquals(object, object) Namespace: NUnit.Framework Assembly: nunit.framework.dll Syntax [AttributeUsage(AttributeTargets.Assembly|AttributeTargets.Class|AttributeTargets.Method, AllowMultiple = false, Inherited = false)] [Obsolete(\".NET No longer supports aborting threads as it is not a safe thing to do. Update your tests to use CancelAfterAttribute instead\")] public class TimeoutAttribute : PropertyAttribute, IApplyToTest, IApplyToContext Constructors View Source TimeoutAttribute(int) Construct a TimeoutAttribute given a time in milliseconds Declaration public TimeoutAttribute(int timeout) Parameters Type Name Description int timeout The timeout value in milliseconds Implements IApplyToTest IApplyToContext"
  },
  "api/NUnit.Framework.ValueSourceAttribute.html": {
    "href": "api/NUnit.Framework.ValueSourceAttribute.html",
    "title": "Class ValueSourceAttribute | NUnit Docs",
    "summary": "Class ValueSourceAttribute Indicates the source used to provide data for one parameter of a test method. Inheritance object Attribute NUnitAttribute ValueSourceAttribute Implements IParameterDataSource Inherited Members Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object, object) object.ReferenceEquals(object, object) Namespace: NUnit.Framework Assembly: nunit.framework.dll Syntax [AttributeUsage(AttributeTargets.Parameter, AllowMultiple = true, Inherited = false)] public class ValueSourceAttribute : NUnitAttribute, IParameterDataSource Constructors View Source ValueSourceAttribute(string?) Construct with the name of the factory - for use with languages that don't support params arrays. Declaration public ValueSourceAttribute(string? sourceName) Parameters Type Name Description string sourceName The name of a static method, property or field that will provide data. View Source ValueSourceAttribute(Type?, string?) Construct with a Type and name - for use with languages that don't support params arrays. Declaration public ValueSourceAttribute(Type? sourceType, string? sourceName) Parameters Type Name Description Type sourceType The Type that will provide data string sourceName The name of a static method, property or field that will provide data. Properties View Source SourceName The name of a the method, property or field to be used as a source Declaration public string? SourceName { get; } Property Value Type Description string View Source SourceType A Type to be used as a source Declaration public Type? SourceType { get; } Property Value Type Description Type Methods View Source GetData(IParameterInfo) Retrieves a list of arguments which can be passed to the specified parameter. Declaration public IEnumerable GetData(IParameterInfo parameter) Parameters Type Name Description IParameterInfo parameter The parameter of a parameterized test. Returns Type Description IEnumerable Implements IParameterDataSource"
  },
  "api/NUnit.Framework.ValuesAttribute.html": {
    "href": "api/NUnit.Framework.ValuesAttribute.html",
    "title": "Class ValuesAttribute | NUnit Docs",
    "summary": "Class ValuesAttribute Provides literal arguments for an individual parameter of a test. Inheritance object Attribute NUnitAttribute ValuesAttribute Implements IParameterDataSource Inherited Members Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object, object) object.ReferenceEquals(object, object) Namespace: NUnit.Framework Assembly: nunit.framework.dll Syntax [AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false, Inherited = false)] public class ValuesAttribute : NUnitAttribute, IParameterDataSource Constructors View Source ValuesAttribute() Constructs for use with an Enum parameter. Will pass every enum value in to the test. Declaration public ValuesAttribute() View Source ValuesAttribute(object?) Construct with one argument Declaration public ValuesAttribute(object? arg1) Parameters Type Name Description object arg1 View Source ValuesAttribute(object?, object?) Construct with two arguments Declaration public ValuesAttribute(object? arg1, object? arg2) Parameters Type Name Description object arg1 object arg2 View Source ValuesAttribute(object?, object?, object?) Construct with three arguments Declaration public ValuesAttribute(object? arg1, object? arg2, object? arg3) Parameters Type Name Description object arg1 object arg2 object arg3 View Source ValuesAttribute(params object?[]?) Construct with an array of arguments Declaration public ValuesAttribute(params object?[]? args) Parameters Type Name Description object[] args Fields View Source data The collection of data to be returned. Must be set by any derived attribute classes. We use an object[] so that the individual elements may have their type changed in GetData if necessary Declaration protected object?[] data Field Value Type Description object[] Methods View Source GetData(IParameterInfo) Retrieves a list of arguments which can be passed to the specified parameter. Declaration public IEnumerable GetData(IParameterInfo parameter) Parameters Type Name Description IParameterInfo parameter The parameter of a parameterized test. Returns Type Description IEnumerable Implements IParameterDataSource"
  },
  "api/NUnit.Framework.Warn.html": {
    "href": "api/NUnit.Framework.Warn.html",
    "title": "Class Warn | NUnit Docs",
    "summary": "Class Warn Provides static methods to express conditions that must be met for the test to succeed. If any test fails, a warning is issued. Inheritance object Warn Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Framework Assembly: nunit.framework.dll Syntax public abstract class Warn Constructors View Source Warn() Declaration protected Warn() Methods View Source If(bool, NUnitString, string) Asserts that a condition is false. If the condition is true, a warning is issued. Declaration public static void If(bool condition, NUnitString message = default, string actualExpression = \"\") Parameters Type Name Description bool condition The evaluated condition NUnitString message The message to display if the condition is false string actualExpression View Source If(bool, FormattableString, string) Asserts that a condition is false. If the condition is true, a warning is issued. Declaration public static void If(bool condition, FormattableString message, string actualExpression = \"\") Parameters Type Name Description bool condition The evaluated condition FormattableString message The message to display if the condition is false string actualExpression View Source If(bool, Func<string>, string) Asserts that a condition is false. If the condition is true, a warning is issued. Declaration public static void If(bool condition, Func<string> getExceptionMessage, string actualExpression = \"\") Parameters Type Name Description bool condition The evaluated condition Func<string> getExceptionMessage A function to build the message included with the Exception string actualExpression View Source If(Func<bool>, NUnitString, string) Asserts that a condition is false. If the condition is true a warning is issued. Declaration public static void If(Func<bool> condition, NUnitString message = default, string actualExpression = \"\") Parameters Type Name Description Func<bool> condition A lambda that returns a Boolean NUnitString message The message to display if the condition is true string actualExpression View Source If(Func<bool>, FormattableString, string) Asserts that a condition is false. If the condition is true a warning is issued. Declaration public static void If(Func<bool> condition, FormattableString message, string actualExpression = \"\") Parameters Type Name Description Func<bool> condition A lambda that returns a Boolean FormattableString message The message to display if the condition is true string actualExpression View Source If(Func<bool>, Func<string>, string) Asserts that a condition is false. If the condition is true a warning is issued. Declaration public static void If(Func<bool> condition, Func<string> getExceptionMessage, string actualExpression = \"\") Parameters Type Name Description Func<bool> condition A lambda that returns a Boolean Func<string> getExceptionMessage A function to build the message included with the Exception string actualExpression View Source If<TActual>(ActualValueDelegate<TActual>, IResolveConstraint, NUnitString, string, string) Apply a constraint to an actual value, succeeding if the constraint fails and issuing a warning on success. Declaration public static void If<TActual>(ActualValueDelegate<TActual> del, IResolveConstraint expr, NUnitString message = default, string actualExpression = \"\", string constraintExpression = \"\") Parameters Type Name Description ActualValueDelegate<TActual> del An ActualValueDelegate returning the value to be tested IResolveConstraint expr A Constraint expression to be applied NUnitString message The message that will be displayed on failure string actualExpression string constraintExpression Type Parameters Name Description TActual The Type being compared. View Source If<TActual>(ActualValueDelegate<TActual>, IResolveConstraint, FormattableString, string, string) Apply a constraint to an actual value, succeeding if the constraint fails and issuing a warning on success. Declaration public static void If<TActual>(ActualValueDelegate<TActual> del, IResolveConstraint expr, FormattableString message, string actualExpression = \"\", string constraintExpression = \"\") Parameters Type Name Description ActualValueDelegate<TActual> del An ActualValueDelegate returning the value to be tested IResolveConstraint expr A Constraint expression to be applied FormattableString message The message that will be displayed on failure string actualExpression string constraintExpression Type Parameters Name Description TActual The Type being compared. View Source If<TActual>(ActualValueDelegate<TActual>, IResolveConstraint, Func<string>, string, string) Apply a constraint to an actual value, succeeding if the constraint fails and issuing a warning on failure. Declaration public static void If<TActual>(ActualValueDelegate<TActual> del, IResolveConstraint expr, Func<string> getExceptionMessage, string actualExpression = \"\", string constraintExpression = \"\") Parameters Type Name Description ActualValueDelegate<TActual> del An ActualValueDelegate returning the value to be tested IResolveConstraint expr A Constraint expression to be applied Func<string> getExceptionMessage A function to build the message included with the Exception string actualExpression string constraintExpression Type Parameters Name Description TActual The Type being compared. View Source If<TActual>(TActual, IResolveConstraint, NUnitString, string, string) Apply a constraint to an actual value, succeeding if the constraint fails and issuing a warning if it succeeds. Declaration public static void If<TActual>(TActual actual, IResolveConstraint expression, NUnitString message = default, string actualExpression = \"\", string constraintExpression = \"\") Parameters Type Name Description TActual actual The actual value to test IResolveConstraint expression A Constraint expression to be applied NUnitString message The message that will be displayed on failure string actualExpression string constraintExpression Type Parameters Name Description TActual The Type being compared. View Source If<TActual>(TActual, IResolveConstraint, FormattableString, string, string) Apply a constraint to an actual value, succeeding if the constraint fails and issuing a warning if it succeeds. Declaration public static void If<TActual>(TActual actual, IResolveConstraint expression, FormattableString message, string actualExpression = \"\", string constraintExpression = \"\") Parameters Type Name Description TActual actual The actual value to test IResolveConstraint expression A Constraint expression to be applied FormattableString message The message that will be displayed on failure string actualExpression string constraintExpression Type Parameters Name Description TActual The Type being compared. View Source If<TActual>(TActual, IResolveConstraint, Func<string>, string, string) Apply a constraint to an actual value, succeeding if the constraint is satisfied and issuing a warning on failure. Declaration public static void If<TActual>(TActual actual, IResolveConstraint expression, Func<string> getExceptionMessage, string actualExpression = \"\", string constraintExpression = \"\") Parameters Type Name Description TActual actual The actual value to test IResolveConstraint expression A Constraint expression to be applied Func<string> getExceptionMessage A function to build the message included with the Exception string actualExpression string constraintExpression Type Parameters Name Description TActual The Type being compared. View Source Unless(bool, NUnitString, string) Asserts that a condition is true. If the condition is false, a warning is issued. Declaration public static void Unless(bool condition, NUnitString message = default, string actualExpression = \"\") Parameters Type Name Description bool condition The evaluated condition NUnitString message The message to display if the condition is false string actualExpression View Source Unless(bool, FormattableString, string) Asserts that a condition is true. If the condition is false, a warning is issued. Declaration public static void Unless(bool condition, FormattableString message, string actualExpression = \"\") Parameters Type Name Description bool condition The evaluated condition FormattableString message The message to display if the condition is false string actualExpression View Source Unless(bool, Func<string>, string) Asserts that a condition is true. If the condition is false, a warning is issued. Declaration public static void Unless(bool condition, Func<string> getExceptionMessage, string actualExpression = \"\") Parameters Type Name Description bool condition The evaluated condition Func<string> getExceptionMessage A function to build the message included with the Exception string actualExpression View Source Unless(Func<bool>, NUnitString, string) Asserts that a condition is true. If the condition is false, a warning is issued. Declaration public static void Unless(Func<bool> condition, NUnitString message = default, string actualExpression = \"\") Parameters Type Name Description Func<bool> condition A lambda that returns a Boolean NUnitString message The message to display if the condition is false string actualExpression View Source Unless(Func<bool>, FormattableString, string) Asserts that a condition is true. If the condition is false, a warning is issued. Declaration public static void Unless(Func<bool> condition, FormattableString message, string actualExpression = \"\") Parameters Type Name Description Func<bool> condition A lambda that returns a Boolean FormattableString message The message to display if the condition is false string actualExpression View Source Unless(Func<bool>, Func<string>, string) Asserts that a condition is true. If the condition is false, a warning is issued. Declaration public static void Unless(Func<bool> condition, Func<string> getExceptionMessage, string actualExpression = \"\") Parameters Type Name Description Func<bool> condition A lambda that returns a Boolean Func<string> getExceptionMessage A function to build the message included with the Exception string actualExpression View Source Unless<TActual>(ActualValueDelegate<TActual>, IResolveConstraint, NUnitString, string, string) Apply a constraint to an actual value, succeeding if the constraint is satisfied and issuing a warning on failure. Declaration public static void Unless<TActual>(ActualValueDelegate<TActual> del, IResolveConstraint expr, NUnitString message = default, string actualExpression = \"\", string constraintExpression = \"\") Parameters Type Name Description ActualValueDelegate<TActual> del An ActualValueDelegate returning the value to be tested IResolveConstraint expr A Constraint expression to be applied NUnitString message The message that will be displayed on failure string actualExpression string constraintExpression Type Parameters Name Description TActual The Type being compared. View Source Unless<TActual>(ActualValueDelegate<TActual>, IResolveConstraint, FormattableString, string, string) Apply a constraint to an actual value, succeeding if the constraint is satisfied and issuing a warning on failure. Declaration public static void Unless<TActual>(ActualValueDelegate<TActual> del, IResolveConstraint expr, FormattableString message, string actualExpression = \"\", string constraintExpression = \"\") Parameters Type Name Description ActualValueDelegate<TActual> del An ActualValueDelegate returning the value to be tested IResolveConstraint expr A Constraint expression to be applied FormattableString message The message that will be displayed on failure string actualExpression string constraintExpression Type Parameters Name Description TActual The Type being compared. View Source Unless<TActual>(ActualValueDelegate<TActual>, IResolveConstraint, Func<string>, string, string) Apply a constraint to an actual value, succeeding if the constraint is satisfied and issuing a warning on failure. Declaration public static void Unless<TActual>(ActualValueDelegate<TActual> del, IResolveConstraint expr, Func<string> getExceptionMessage, string actualExpression = \"\", string constraintExpression = \"\") Parameters Type Name Description ActualValueDelegate<TActual> del An ActualValueDelegate returning the value to be tested IResolveConstraint expr A Constraint expression to be applied Func<string> getExceptionMessage A function to build the message included with the Exception string actualExpression string constraintExpression Type Parameters Name Description TActual The Type being compared. View Source Unless<TActual>(TActual, IResolveConstraint, NUnitString, string, string) Apply a constraint to an actual value, succeeding if the constraint is satisfied and issuing a warning on failure. Declaration public static void Unless<TActual>(TActual actual, IResolveConstraint expression, NUnitString message = default, string actualExpression = \"\", string constraintExpression = \"\") Parameters Type Name Description TActual actual The actual value to test IResolveConstraint expression A Constraint expression to be applied NUnitString message The message that will be displayed on failure string actualExpression string constraintExpression Type Parameters Name Description TActual The Type being compared. View Source Unless<TActual>(TActual, IResolveConstraint, FormattableString, string, string) Apply a constraint to an actual value, succeeding if the constraint is satisfied and issuing a warning on failure. Declaration public static void Unless<TActual>(TActual actual, IResolveConstraint expression, FormattableString message, string actualExpression = \"\", string constraintExpression = \"\") Parameters Type Name Description TActual actual The actual value to test IResolveConstraint expression A Constraint expression to be applied FormattableString message The message that will be displayed on failure string actualExpression string constraintExpression Type Parameters Name Description TActual The Type being compared. View Source Unless<TActual>(TActual, IResolveConstraint, Func<string>, string, string) Apply a constraint to an actual value, succeeding if the constraint is satisfied and issuing a warning on failure. Declaration public static void Unless<TActual>(TActual actual, IResolveConstraint expression, Func<string> getExceptionMessage, string actualExpression = \"\", string constraintExpression = \"\") Parameters Type Name Description TActual actual The actual value to test IResolveConstraint expression A Constraint expression to be applied Func<string> getExceptionMessage A function to build the message included with the Exception string actualExpression string constraintExpression Type Parameters Name Description TActual The Type being compared."
  },
  "api/NUnit.Framework.html": {
    "href": "api/NUnit.Framework.html",
    "title": "Namespace NUnit.Framework | NUnit Docs",
    "summary": "Namespace NUnit.Framework Classes ApartmentAttribute Marks a test as needing to be run in a particular threading apartment state. This will cause it to run in a separate thread if necessary. Assert The Assert class contains a collection of static methods that implement the most common assertions used in NUnit. AssertBase Base class for different Assert, containing helper functions AssertionException Thrown when an assertion failed. Assume Provides static methods to express the assumptions that must be met for a test to give a meaningful result. If an assumption is not met, the test should produce an inconclusive result. AuthorAttribute Provides the author of a test or test fixture. CancelAfterAttribute Applies a timeout in milliseconds to a test. When applied to a method, the test's cancellation token is cancelled if the timeout is exceeded. CategoryAttribute Applies a category to a test CombinatorialAttribute Marks a test to use a combinatorial join of any argument data provided. Since this is the default, the attribute is optional. CombiningStrategyAttribute Marks a test as using a particular CombiningStrategy to join any supplied parameter data. Since this is the default, the attribute is optional. Contains Helper class with properties and methods that supply a number of constraints used in Asserts. CultureAttribute Marks an assembly, test fixture or test method as applying to a specific Culture. DatapointAttribute Marks a field for use as a datapoint when executing a theory within the same fixture that requires an argument of the field's Type. DatapointSourceAttribute Marks a field, property or method as providing a set of datapoints for use in executing any theories within the same fixture that require an argument of the provided type. The data source may provide an array of the required Type or an IEnumerable<T>. Synonymous with DatapointsAttribute. DatapointsAttribute Marks a field, property or method as providing a set of datapoints for use in executing any theories within the same fixture that require an argument of the provided Type. The data source may provide an array of the required Type or an IEnumerable<T>. Synonymous with DatapointSourceAttribute. DefaultFloatingPointToleranceAttribute Sets the tolerance used by default when checking the equality of floating point values within the test assembly, fixture or method. DescriptionAttribute Provides the descriptive text relating to the assembly, test fixture or test method. Does Helper class with properties and methods that supply a number of constraints used in Asserts. EqualNumericWithoutUsingConstraintExtensions Extension methods for EqualNumericWithoutUsingConstraint<T>. ExplicitAttribute Marks an assembly, test fixture or test method such that it will only run if explicitly executed from the GUI, command line or included within a test filter. The test will not be run simply because an enclosing suite is run. FixtureLifeCycleAttribute Specify the life cycle of a Fixture Has Helper class with properties and methods that supply a number of constraints used in Asserts. IEqualWithUsingConstraintExtensions Allows specifying a custom comparer for the EqualConstraint. IgnoreAttribute Marks an assembly, test fixture or test method as being ignored. Ignored tests result in a warning message when the tests are run. IgnoreException Thrown when an assertion failed. IncludeExcludeAttribute Abstract base for attributes that are used to include tests in the test run based on environmental settings. InconclusiveException Thrown when a test executes inconclusively. Is Helper class with properties and methods that supply a number of constraints used in Asserts. Iz The Iz class is a synonym for Is intended for use in VB, which regards Is as a keyword. LevelOfParallelismAttribute Sets the number of worker threads that may be allocated by the framework for running tests. MaxTimeAttribute Specifies the maximum time (in milliseconds) for a test case to succeed. MultipleAssertException Thrown when an assertion failed. NUnitAttribute Abstract base class for all custom attributes defined by NUnit. NetPlatformAttribute Marks an assembly, test fixture or test method as applying to a specific platform. NonParallelizableAttribute Marks tests that should NOT be run in parallel. OneTimeSetUpAttribute Identifies a method that is called once to perform setup before any child tests are run. OneTimeTearDownAttribute Identifies a method to be called once after all the child tests have run. The method is guaranteed to be called, even if an exception is thrown. OrderAttribute Defines the order that the test will run in PairwiseAttribute Marks a test as using a pairwise join of any supplied argument data. Arguments will be combined in such a way that all possible pairs of arguments are used. ParallelizableAttribute Marks a test assembly, fixture or method that may be run in parallel. PlatformAttribute Marks an assembly, test fixture or test method as applying to a specific platform. PropertyAttribute Attaches information to a test assembly, fixture or method as a name/value pair. RandomAttribute Supplies a set of random values to a single parameter of a parameterized test. RangeAttribute Supplies a range of values to an individual parameter of a parameterized test. RepeatAttribute Specifies that a test should be run multiple times. RepeatAttribute.RepeatedTestCommand The test command for the RepeatAttribute RequiresThreadAttribute Marks a test that must run on a separate thread. ResultStateException Abstract base for Exceptions that terminate a test and provide a ResultState. RetryAttribute Specifies that a test method should be rerun on failure up to the specified maximum number of times. RetryAttribute.RetryCommand The test command for the RetryAttribute SequentialAttribute Marks a test to use a sequential join of any provided argument data. Arguments will be combined into test cases, taking the next value of each argument until all are used. SetCultureAttribute Sets the current Culture on an assembly, test fixture or test method for the duration of a test. The culture remains set until the test or fixture completes and is then reset to its original value. SetUICultureAttribute Sets the current UI Culture on an assembly, test fixture or test method for the duration of a test. The UI culture remains set until the test or fixture completes and is then reset to its original value. SetUpAttribute Identifies a method to be called immediately before each test is run. SetUpFixtureAttribute Identifies a class as containing OneTimeSetUpAttribute or OneTimeTearDownAttribute methods for all the test fixtures under a given namespace. SingleThreadedAttribute Marks a test fixture as requiring all child tests to be run on the same thread as the OneTimeSetUp and OneTimeTearDown. A flag in the NUnit.Framework.Internal.TestExecutionContext is set forcing all child tests to be run sequentially on the current thread. Any ParallelScope setting is ignored. SuccessException Thrown when an assertion failed. TearDownAttribute Identifies a method to be called immediately after each test is run. The method is guaranteed to be called, even if an exception is thrown. TestActionAttribute Abstract attribute providing actions to execute before and after tests. TestAssemblyDirectoryResolveAttribute Marks a test assembly as needing a special assembly resolution hook that will explicitly search the test assembly's directory for dependent assemblies. This works around a conflict between mixed-mode assembly initialization and tests running in their own AppDomain in some cases. TestAttribute Marks the method as callable from the NUnit test runner. TestCaseAttribute Marks a method as a parameterized test suite and provides arguments for each test case. TestCaseAttribute<T> Marks a method as a parameterized test suite and provides arguments for each test case. TestCaseAttribute<T1, T2> Marks a method as a parameterized test suite and provides arguments for each test case. TestCaseAttribute<T1, T2, T3> Marks a method as a parameterized test suite and provides arguments for each test case. TestCaseAttribute<T1, T2, T3, T4> Marks a method as a parameterized test suite and provides arguments for each test case. TestCaseAttribute<T1, T2, T3, T4, T5> Marks a method as a parameterized test suite and provides arguments for each test case. TestCaseData The TestCaseData class represents a set of arguments and other parameter info to be used for a parameterized test case. It is derived from TestCaseParameters and adds a fluent syntax for use in initializing the test case. TestCaseData<T> Marks a method as a parameterized test suite and provides arguments for each test case. TestCaseData<T1, T2> Marks a method as a parameterized test suite and provides arguments for each test case. TestCaseData<T1, T2, T3> Marks a method as a parameterized test suite and provides arguments for each test case. TestCaseData<T1, T2, T3, T4> Marks a method as a parameterized test suite and provides arguments for each test case. TestCaseData<T1, T2, T3, T4, T5> Marks a method as a parameterized test suite and provides arguments for each test case. TestCaseSourceAttribute Indicates the source to be used to provide test fixture instances for a test class. TestContext Provide the context information of the current test. This is an adapter for the internal ExecutionContext class, hiding the internals from the user test. TestContext.PropertyBagAdapter TestContext.PropertyBagAdapter adapts an IPropertyBag for consumption by the user. TestContext.PropertyHierachyItem Represents properties at different test levels TestContext.PropertyValueHierarchyItem Represents property value at different test levels TestContext.ResultAdapter ResultAdapter adapts a TestResult for consumption by the user test code. TestContext.TestAdapter TestAdapter adapts a Test for consumption by the user test code. TestFixtureAttribute Marks the class as a TestFixture. TestFixtureData The TestFixtureData class represents a set of arguments and other parameter info to be used for a parameterized fixture. It is derived from TestFixtureParameters and adds a fluent syntax for use in initializing the fixture. TestFixtureSourceAttribute Identifies the source used to provide test fixture instances for a test class. TestOfAttribute Indicates the method or class the assembly, test fixture or test method is testing. TestParameters TestParameters class holds any named parameters supplied to the test run TheoryAttribute Indicates that a test method is a theory and can be run multiple times with different input data. Throws Helper class with properties and methods that supply constraints that operate on exceptions. TimeoutAttribute Applies a timeout in milliseconds to a test. When applied to a method, the test is cancelled if the timeout is exceeded. When applied to a class or assembly, the default timeout is set for all contained test methods. ValueSourceAttribute Indicates the source used to provide data for one parameter of a test method. ValuesAttribute Provides literal arguments for an individual parameter of a test. Warn Provides static methods to express conditions that must be met for the test to succeed. If any test fails, a warning is issued. Structs NUnitString A class to allow postponing the actual formatting of interpolated strings. Interfaces IEqualWithUsingConstraint<T> Interface for equal constraints which support user comparisons. ITestAction When implemented by an attribute, this interface implemented to provide actions to execute before and after tests. Enums ActionTargets The different targets a test action attribute can be applied to LifeCycle Specifies the life cycle for a test fixture. ParallelScope Specifies the degree to which a test, and its descendants, may be run in parallel. Delegates AsyncTestDelegate Delegate used by tests that execute async code and capture any thrown exception. TestDelegate Delegate used by tests that execute code and capture any thrown exception."
  },
  "api/NUnit.FrameworkPackageSettings.html": {
    "href": "api/NUnit.FrameworkPackageSettings.html",
    "title": "Class FrameworkPackageSettings | NUnit Docs",
    "summary": "Class FrameworkPackageSettings FrameworkPackageSettings is a static class containing constant values that are used as keys in setting up a TestPackage. These values are used in the framework, and set in the runner. Setting values may be a string, int or bool. Inheritance object FrameworkPackageSettings Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit Assembly: nunit.framework.dll Syntax public static class FrameworkPackageSettings Fields View Source DebugTests Flag (bool) indicating whether tests are being debugged. Declaration public const string DebugTests = \"DebugTests\" Field Value Type Description string View Source DefaultCulture A string representing the default thread culture to be used for running tests. String should be a valid BCP-47 culture name. If culture is unset, tests run on the machine's default culture. Declaration public const string DefaultCulture = \"DefaultCulture\" Field Value Type Description string View Source DefaultTestNamePattern The default naming pattern used in generating test names Declaration public const string DefaultTestNamePattern = \"DefaultTestNamePattern\" Field Value Type Description string View Source DefaultTimeout Integer value in milliseconds for the default timeout value for test cases. If not specified, there is no timeout except as specified by attributes on the tests themselves. Declaration public const string DefaultTimeout = \"DefaultTimeout\" Field Value Type Description string View Source DefaultUICulture A string representing the default thread UI culture to be used for running tests. String should be a valid BCP-47 culture name. If culture is unset, tests run on the machine's default culture. Declaration public const string DefaultUICulture = \"DefaultUICulture\" Field Value Type Description string View Source InternalTraceLevel The InternalTraceLevel for this run. Values are: \"Default\", \"Off\", \"Error\", \"Warning\", \"Info\", \"Debug\", \"Verbose\". Default is \"Off\". \"Debug\" and \"Verbose\" are synonyms. Declaration public const string InternalTraceLevel = \"InternalTraceLevel\" Field Value Type Description string View Source InternalTraceWriter A TextWriter to which the internal trace will be sent. Declaration public const string InternalTraceWriter = \"InternalTraceWriter\" Field Value Type Description string View Source LOAD A list of tests to be loaded. Declaration public const string LOAD = \"LOAD\" Field Value Type Description string View Source NumberOfTestWorkers The number of test threads to run for the assembly. If set to 1, a single queue is used. If set to 0, tests are executed directly, without queuing. Declaration public const string NumberOfTestWorkers = \"NumberOfTestWorkers\" Field Value Type Description string View Source PauseBeforeRun Flag (bool) indicating whether to pause execution of tests to allow the user to attach a debugger. Declaration public const string PauseBeforeRun = \"PauseBeforeRun\" Field Value Type Description string View Source RandomSeed The random seed to be used for this assembly. If specified as the value reported from a prior run, the framework should generate identical random values for tests as were used for that run, provided that no change has been made to the test assembly. Default is a random value itself. Declaration public const string RandomSeed = \"RandomSeed\" Field Value Type Description string View Source RunOnMainThread If true, the tests will run on the same thread as the NUnit runner itself Declaration public const string RunOnMainThread = \"RunOnMainThread\" Field Value Type Description string View Source StopOnError If true, execution stops after the first error or failure. Declaration public const string StopOnError = \"StopOnError\" Field Value Type Description string View Source SynchronousEvents If true, use of the event queue is suppressed and test events are synchronous. Declaration public const string SynchronousEvents = \"SynchronousEvents\" Field Value Type Description string View Source TestParameters Parameters to be passed on to the tests, serialized to a single string which needs parsing. Obsoleted by TestParametersDictionary; kept for backward compatibility. Declaration public const string TestParameters = \"TestParameters\" Field Value Type Description string View Source TestParametersDictionary Parameters to be passed on to the tests, already parsed into an IDictionary<string, string>. Replaces TestParameters. Declaration public const string TestParametersDictionary = \"TestParametersDictionary\" Field Value Type Description string View Source ThrowOnEachFailureUnderDebugger If true, asserts in multiple asserts block will throw first-chance exception on failure. Declaration public const string ThrowOnEachFailureUnderDebugger = \"ThrowOnEachFailureUnderDebugger\" Field Value Type Description string View Source WorkDirectory Full path of the directory to be used for work and result files. This path is provided to tests by the framework TestContext. Declaration public const string WorkDirectory = \"WorkDirectory\" Field Value Type Description string"
  },
  "api/NUnit.Options.Option.html": {
    "href": "api/NUnit.Options.Option.html",
    "title": "Class Option | NUnit Docs",
    "summary": "Class Option Inheritance object Option Inherited Members object.GetType() object.MemberwiseClone() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Options Assembly: nunitlite.dll Syntax public abstract class Option Constructors View Source Option(string, string) Declaration protected Option(string prototype, string description) Parameters Type Name Description string prototype string description View Source Option(string, string, int) Declaration protected Option(string prototype, string description, int maxValueCount) Parameters Type Name Description string prototype string description int maxValueCount Properties View Source Description Declaration public string Description { get; } Property Value Type Description string View Source MaxValueCount Declaration public int MaxValueCount { get; } Property Value Type Description int View Source OptionValueType Declaration public OptionValueType OptionValueType { get; } Property Value Type Description OptionValueType View Source Prototype Declaration public string Prototype { get; } Property Value Type Description string Methods View Source GetNames() Declaration public string[] GetNames() Returns Type Description string[] View Source GetValueSeparators() Declaration public string[] GetValueSeparators() Returns Type Description string[] View Source Invoke(OptionContext) Declaration public void Invoke(OptionContext c) Parameters Type Name Description OptionContext c View Source OnParseComplete(OptionContext) Declaration protected abstract void OnParseComplete(OptionContext c) Parameters Type Name Description OptionContext c View Source Parse<T>(string, OptionContext) Declaration protected static T Parse<T>(string value, OptionContext c) Parameters Type Name Description string value OptionContext c Returns Type Description T Type Parameters Name Description T View Source ToString() Declaration public override string ToString() Returns Type Description string Overrides object.ToString()"
  },
  "api/NUnit.Options.OptionAction-2.html": {
    "href": "api/NUnit.Options.OptionAction-2.html",
    "title": "Delegate OptionAction<TKey, TValue> | NUnit Docs",
    "summary": "Delegate OptionAction<TKey, TValue> Namespace: NUnit.Options Assembly: nunitlite.dll Syntax public delegate void OptionAction<TKey, TValue>(TKey key, TValue value) Parameters Type Name Description TKey key TValue value Type Parameters Name Description TKey TValue Constructors View Source OptionAction(object, nint) Declaration public OptionAction(object @object, nint method) Parameters Type Name Description object object nint method Methods View Source BeginInvoke(TKey, TValue, AsyncCallback, object) Declaration public virtual IAsyncResult BeginInvoke(TKey key, TValue value, AsyncCallback callback, object @object) Parameters Type Name Description TKey key TValue value AsyncCallback callback object object Returns Type Description IAsyncResult View Source EndInvoke(IAsyncResult) Declaration public virtual void EndInvoke(IAsyncResult result) Parameters Type Name Description IAsyncResult result View Source Invoke(TKey, TValue) Declaration public virtual void Invoke(TKey key, TValue value) Parameters Type Name Description TKey key TValue value"
  },
  "api/NUnit.Options.OptionContext.html": {
    "href": "api/NUnit.Options.OptionContext.html",
    "title": "Class OptionContext | NUnit Docs",
    "summary": "Class OptionContext Inheritance object OptionContext Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Options Assembly: nunitlite.dll Syntax public class OptionContext Constructors View Source OptionContext(OptionSet) Declaration public OptionContext(OptionSet set) Parameters Type Name Description OptionSet set Properties View Source Option Declaration public Option Option { get; set; } Property Value Type Description Option View Source OptionIndex Declaration public int OptionIndex { get; set; } Property Value Type Description int View Source OptionName Declaration public string OptionName { get; set; } Property Value Type Description string View Source OptionSet Declaration public OptionSet OptionSet { get; } Property Value Type Description OptionSet View Source OptionValues Declaration public OptionValueCollection OptionValues { get; } Property Value Type Description OptionValueCollection"
  },
  "api/NUnit.Options.OptionException.html": {
    "href": "api/NUnit.Options.OptionException.html",
    "title": "Class OptionException | NUnit Docs",
    "summary": "Class OptionException Inheritance object Exception OptionException Implements ISerializable Inherited Members Exception.GetBaseException() Exception.ToString() Exception.GetType() Exception.TargetSite Exception.Message Exception.Data Exception.InnerException Exception.HelpLink Exception.Source Exception.HResult Exception.StackTrace Exception.SerializeObjectState object.MemberwiseClone() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Options Assembly: nunitlite.dll Syntax public class OptionException : Exception, ISerializable Constructors View Source OptionException() Declaration public OptionException() View Source OptionException(string, string) Declaration public OptionException(string message, string optionName) Parameters Type Name Description string message string optionName View Source OptionException(string, string, Exception) Declaration public OptionException(string message, string optionName, Exception innerException) Parameters Type Name Description string message string optionName Exception innerException Properties View Source OptionName Declaration public string OptionName { get; } Property Value Type Description string Implements ISerializable"
  },
  "api/NUnit.Options.OptionSet.html": {
    "href": "api/NUnit.Options.OptionSet.html",
    "title": "Class OptionSet | NUnit Docs",
    "summary": "Class OptionSet Inheritance object Collection<Option> KeyedCollection<string, Option> OptionSet CommandLineOptions Implements IList<Option> ICollection<Option> IList ICollection IReadOnlyList<Option> IReadOnlyCollection<Option> IEnumerable<Option> IEnumerable Inherited Members KeyedCollection<string, Option>.Contains(string) KeyedCollection<string, Option>.TryGetValue(string, out Option) KeyedCollection<string, Option>.Remove(string) KeyedCollection<string, Option>.ChangeItemKey(Option, string) KeyedCollection<string, Option>.ClearItems() KeyedCollection<string, Option>.GetKeyForItem(Option) KeyedCollection<string, Option>.InsertItem(int, Option) KeyedCollection<string, Option>.RemoveItem(int) KeyedCollection<string, Option>.SetItem(int, Option) KeyedCollection<string, Option>.Comparer KeyedCollection<string, Option>.this[string] KeyedCollection<string, Option>.Dictionary Collection<Option>.Clear() Collection<Option>.CopyTo(Option[], int) Collection<Option>.Contains(Option) Collection<Option>.GetEnumerator() Collection<Option>.IndexOf(Option) Collection<Option>.Insert(int, Option) Collection<Option>.Remove(Option) Collection<Option>.RemoveAt(int) Collection<Option>.ClearItems() Collection<Option>.Count Collection<Option>.Items Collection<Option>.this[int] object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Options Assembly: nunitlite.dll Syntax public class OptionSet : KeyedCollection<string, Option>, IList<Option>, ICollection<Option>, IList, ICollection, IReadOnlyList<Option>, IReadOnlyCollection<Option>, IEnumerable<Option>, IEnumerable Constructors View Source OptionSet() Declaration public OptionSet() Methods View Source Add(Option) Declaration public OptionSet Add(Option option) Parameters Type Name Description Option option Returns Type Description OptionSet View Source Add(string, OptionAction<string, string>) Declaration public OptionSet Add(string prototype, OptionAction<string, string> action) Parameters Type Name Description string prototype OptionAction<string, string> action Returns Type Description OptionSet View Source Add(string, Action<string>) Declaration public OptionSet Add(string prototype, Action<string> action) Parameters Type Name Description string prototype Action<string> action Returns Type Description OptionSet View Source Add(string, string, OptionAction<string, string>) Declaration public OptionSet Add(string prototype, string description, OptionAction<string, string> action) Parameters Type Name Description string prototype string description OptionAction<string, string> action Returns Type Description OptionSet View Source Add(string, string, Action<string>) Declaration public OptionSet Add(string prototype, string description, Action<string> action) Parameters Type Name Description string prototype string description Action<string> action Returns Type Description OptionSet View Source Add<T>(string, Action<T>) Declaration public OptionSet Add<T>(string prototype, Action<T> action) Parameters Type Name Description string prototype Action<T> action Returns Type Description OptionSet Type Parameters Name Description T View Source Add<T>(string, string, Action<T>) Declaration public OptionSet Add<T>(string prototype, string description, Action<T> action) Parameters Type Name Description string prototype string description Action<T> action Returns Type Description OptionSet Type Parameters Name Description T View Source Add<TKey, TValue>(string, OptionAction<TKey, TValue>) Declaration public OptionSet Add<TKey, TValue>(string prototype, OptionAction<TKey, TValue> action) Parameters Type Name Description string prototype OptionAction<TKey, TValue> action Returns Type Description OptionSet Type Parameters Name Description TKey TValue View Source Add<TKey, TValue>(string, string, OptionAction<TKey, TValue>) Declaration public OptionSet Add<TKey, TValue>(string prototype, string description, OptionAction<TKey, TValue> action) Parameters Type Name Description string prototype string description OptionAction<TKey, TValue> action Returns Type Description OptionSet Type Parameters Name Description TKey TValue View Source CreateOptionContext() Declaration protected virtual OptionContext CreateOptionContext() Returns Type Description OptionContext View Source GetKeyForItem(Option) Declaration protected override string GetKeyForItem(Option item) Parameters Type Name Description Option item Returns Type Description string Overrides KeyedCollection<string, Option>.GetKeyForItem(Option) View Source GetOptionParts(string, out string, out string, out string, out string) Declaration protected bool GetOptionParts(string argument, out string flag, out string name, out string sep, out string value) Parameters Type Name Description string argument string flag string name string sep string value Returns Type Description bool View Source InsertItem(int, Option) Declaration protected override void InsertItem(int index, Option item) Parameters Type Name Description int index Option item Overrides KeyedCollection<string, Option>.InsertItem(int, Option) View Source MessageLocalizer(string) Declaration public string MessageLocalizer(string msg) Parameters Type Name Description string msg Returns Type Description string View Source Parse(IEnumerable<string>) Declaration public List<string> Parse(IEnumerable<string> arguments) Parameters Type Name Description IEnumerable<string> arguments Returns Type Description List<string> View Source Parse(string, OptionContext) Declaration protected virtual bool Parse(string argument, OptionContext c) Parameters Type Name Description string argument OptionContext c Returns Type Description bool View Source RemoveItem(int) Declaration protected override void RemoveItem(int index) Parameters Type Name Description int index Overrides KeyedCollection<string, Option>.RemoveItem(int) View Source SetItem(int, Option) Declaration protected override void SetItem(int index, Option item) Parameters Type Name Description int index Option item Overrides KeyedCollection<string, Option>.SetItem(int, Option) View Source WriteOptionDescriptions(TextWriter) Declaration public void WriteOptionDescriptions(TextWriter o) Parameters Type Name Description TextWriter o Implements IList<T> ICollection<T> IList ICollection IReadOnlyList<T> IReadOnlyCollection<T> IEnumerable<T> IEnumerable"
  },
  "api/NUnit.Options.OptionValueCollection.html": {
    "href": "api/NUnit.Options.OptionValueCollection.html",
    "title": "Class OptionValueCollection | NUnit Docs",
    "summary": "Class OptionValueCollection Inheritance object OptionValueCollection Implements IList ICollection IList<string> ICollection<string> IEnumerable<string> IEnumerable Inherited Members object.GetType() object.MemberwiseClone() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnit.Options Assembly: nunitlite.dll Syntax public class OptionValueCollection : IList, ICollection, IList<string>, ICollection<string>, IEnumerable<string>, IEnumerable Properties View Source Count Declaration public int Count { get; } Property Value Type Description int View Source IsReadOnly Declaration public bool IsReadOnly { get; } Property Value Type Description bool View Source this[int] Declaration public string this[int index] { get; set; } Parameters Type Name Description int index Property Value Type Description string Methods View Source Add(string) Declaration public void Add(string item) Parameters Type Name Description string item View Source Clear() Declaration public void Clear() View Source Contains(string) Declaration public bool Contains(string item) Parameters Type Name Description string item Returns Type Description bool View Source CopyTo(string[], int) Declaration public void CopyTo(string[] array, int arrayIndex) Parameters Type Name Description string[] array int arrayIndex View Source GetEnumerator() Declaration public IEnumerator<string> GetEnumerator() Returns Type Description IEnumerator<string> View Source IndexOf(string) Declaration public int IndexOf(string item) Parameters Type Name Description string item Returns Type Description int View Source Insert(int, string) Declaration public void Insert(int index, string item) Parameters Type Name Description int index string item View Source Remove(string) Declaration public bool Remove(string item) Parameters Type Name Description string item Returns Type Description bool View Source RemoveAt(int) Declaration public void RemoveAt(int index) Parameters Type Name Description int index View Source ToArray() Declaration public string[] ToArray() Returns Type Description string[] View Source ToList() Declaration public List<string> ToList() Returns Type Description List<string> View Source ToString() Declaration public override string ToString() Returns Type Description string Overrides object.ToString() Implements IList ICollection IList<T> ICollection<T> IEnumerable<T> IEnumerable"
  },
  "api/NUnit.Options.OptionValueType.html": {
    "href": "api/NUnit.Options.OptionValueType.html",
    "title": "Enum OptionValueType | NUnit Docs",
    "summary": "Enum OptionValueType Namespace: NUnit.Options Assembly: nunitlite.dll Syntax public enum OptionValueType Fields Name Description None Optional Required"
  },
  "api/NUnit.Options.html": {
    "href": "api/NUnit.Options.html",
    "title": "Namespace NUnit.Options | NUnit Docs",
    "summary": "Namespace NUnit.Options Classes Option OptionContext OptionException OptionSet OptionValueCollection Enums OptionValueType Delegates OptionAction<TKey, TValue>"
  },
  "api/NUnit.html": {
    "href": "api/NUnit.html",
    "title": "Namespace NUnit | NUnit Docs",
    "summary": "Namespace NUnit Classes FrameworkPackageSettings FrameworkPackageSettings is a static class containing constant values that are used as keys in setting up a TestPackage. These values are used in the framework, and set in the runner. Setting values may be a string, int or bool."
  },
  "api/NUnitLite.AutoRun.html": {
    "href": "api/NUnitLite.AutoRun.html",
    "title": "Class AutoRun | NUnit Docs",
    "summary": "Class AutoRun The AutoRun class is used by executable test assemblies to control their own execution. Call it from your executable test like this: new AutoRun().Execute(args); The arguments can be those passed into your exe or constructed for the purpose in your code. If the tests are in a dll, you can write a stub executable that runs them like this: new Autorun().Execute(testAssembly, args); When running tests compiled against the .NET Standard framework, the methods above are not available. Run your tests like this: new AutoRun().Execute(testAssembly, args, output, input); Where output is an ExtendedTextWriter (normally a ColorConsoleWriter) and input is usually Console.In and is used by the --wait option. Inheritance object AutoRun Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnitLite Assembly: nunitlite.dll Syntax public class AutoRun Constructors View Source AutoRun() Default Constructor, only used where GetCallingAssembly is available Declaration public AutoRun() View Source AutoRun(Assembly) Constructor for use where GetCallingAssembly is not available, requiring the assembly to be passed. Declaration public AutoRun(Assembly testAssembly) Parameters Type Name Description Assembly testAssembly The test assembly Methods View Source Execute(string[]) Execute the tests in the assembly, passing in a list of arguments. Declaration public int Execute(string[] args) Parameters Type Name Description string[] args arguments for NUnitLite to use Returns Type Description int View Source Execute(string[], ExtendedTextWriter, TextReader) Execute the tests in the assembly, passing in a list of arguments, a test assembly a writer and a reader. For use in builds for runtimes that don't support Assembly.GetCallingAssembly(). Declaration public int Execute(string[] args, ExtendedTextWriter writer, TextReader reader) Parameters Type Name Description string[] args Arguments passed to NUnitLite ExtendedTextWriter writer An ExtendedTextWriter to which output will be written TextReader reader A TextReader used when waiting for input Returns Type Description int"
  },
  "api/NUnitLite.NUnit2XmlOutputWriter.html": {
    "href": "api/NUnitLite.NUnit2XmlOutputWriter.html",
    "title": "Class NUnit2XmlOutputWriter | NUnit Docs",
    "summary": "Class NUnit2XmlOutputWriter NUnit2XmlOutputWriter is able to create an XML file representing the result of a test run in NUnit 2.x format. Inheritance object OutputWriter NUnit2XmlOutputWriter Inherited Members OutputWriter.WriteResultFile(ITestResult, string, IDictionary<string, object>, TestFilter) OutputWriter.WriteTestFile(ITest, string) object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnitLite Assembly: nunitlite.dll Syntax public class NUnit2XmlOutputWriter : OutputWriter Constructors View Source NUnit2XmlOutputWriter() Declaration public NUnit2XmlOutputWriter() Methods View Source WriteResultFile(ITestResult, TextWriter, IDictionary<string, object>, TestFilter) Writes the result of a test run to a specified TextWriter. Declaration public override void WriteResultFile(ITestResult result, TextWriter writer, IDictionary<string, object> runSettings, TestFilter filter) Parameters Type Name Description ITestResult result The test result for the run TextWriter writer The TextWriter to which the xml will be written IDictionary<string, object> runSettings TestFilter filter Overrides OutputWriter.WriteResultFile(ITestResult, TextWriter, IDictionary<string, object>, TestFilter) View Source WriteTestFile(ITest, TextWriter) Write info about a test Declaration public override void WriteTestFile(ITest test, TextWriter writer) Parameters Type Name Description ITest test The test TextWriter writer A TextWriter Overrides OutputWriter.WriteTestFile(ITest, TextWriter)"
  },
  "api/NUnitLite.NUnit3XmlOutputWriter.html": {
    "href": "api/NUnitLite.NUnit3XmlOutputWriter.html",
    "title": "Class NUnit3XmlOutputWriter | NUnit Docs",
    "summary": "Class NUnit3XmlOutputWriter NUnit3XmlOutputWriter is responsible for writing the results of a test to a file in NUnit 3 format. Inheritance object OutputWriter NUnit3XmlOutputWriter Inherited Members OutputWriter.WriteResultFile(ITestResult, string, IDictionary<string, object>, TestFilter) OutputWriter.WriteTestFile(ITest, string) object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnitLite Assembly: nunitlite.dll Syntax public class NUnit3XmlOutputWriter : OutputWriter Constructors View Source NUnit3XmlOutputWriter() Declaration public NUnit3XmlOutputWriter() Methods View Source WriteResultFile(ITestResult, TextWriter, IDictionary<string, object>, TestFilter) Writes the test result to the specified TextWriter Declaration public override void WriteResultFile(ITestResult result, TextWriter writer, IDictionary<string, object> runSettings, TestFilter filter) Parameters Type Name Description ITestResult result The result to be written to a file TextWriter writer A TextWriter to which the result is written IDictionary<string, object> runSettings TestFilter filter Overrides OutputWriter.WriteResultFile(ITestResult, TextWriter, IDictionary<string, object>, TestFilter) View Source WriteTestFile(ITest, TextWriter) Writes test info to the specified TextWriter Declaration public override void WriteTestFile(ITest test, TextWriter writer) Parameters Type Name Description ITest test The test to be written TextWriter writer A TextWriter to which the test info is written Overrides OutputWriter.WriteTestFile(ITest, TextWriter)"
  },
  "api/NUnitLite.NUnitLiteOptions.html": {
    "href": "api/NUnitLite.NUnitLiteOptions.html",
    "title": "Class NUnitLiteOptions | NUnit Docs",
    "summary": "Class NUnitLiteOptions NUnitLiteOptions encapsulates the option settings for NUnitLite. Currently, there are no additional options beyond those common options that are shared with nunit3-console. If NUnitLite should acquire some unique options, they should be placed here. Inheritance object Collection<Option> KeyedCollection<string, Option> OptionSet CommandLineOptions NUnitLiteOptions Implements IList<Option> ICollection<Option> IList ICollection IReadOnlyList<Option> IReadOnlyCollection<Option> IEnumerable<Option> IEnumerable Inherited Members CommandLineOptions.Validate() CommandLineOptions.CheckOptionCombinations() CommandLineOptions.RequiredValue(string, string, params string[]) CommandLineOptions.RequiredInt(string, string) CommandLineOptions.ConfigureOptions(bool) CommandLineOptions.InputFileRequired CommandLineOptions.Explore CommandLineOptions.ShowHelp CommandLineOptions.ShowVersion CommandLineOptions.InputFile CommandLineOptions.TestList CommandLineOptions.PreFilters CommandLineOptions.TestParameters CommandLineOptions.WhereClause CommandLineOptions.WhereClauseSpecified CommandLineOptions.DefaultTimeout CommandLineOptions.DefaultTimeoutSpecified CommandLineOptions.RandomSeed CommandLineOptions.RandomSeedSpecified CommandLineOptions.DefaultTestNamePattern CommandLineOptions.NumberOfTestWorkers CommandLineOptions.NumberOfTestWorkersSpecified CommandLineOptions.StopOnError CommandLineOptions.WaitBeforeExit CommandLineOptions.NoHeader CommandLineOptions.NoColor CommandLineOptions.TeamCity CommandLineOptions.OutFile CommandLineOptions.OutFileSpecified CommandLineOptions.ErrFile CommandLineOptions.ErrFileSpecified CommandLineOptions.DisplayTestLabels CommandLineOptions.WorkDirectory CommandLineOptions.WorkDirectorySpecified CommandLineOptions.InternalTraceLevel CommandLineOptions.InternalTraceLevelSpecified CommandLineOptions.ResultOutputSpecifications CommandLineOptions.ExploreOutputSpecifications CommandLineOptions.ErrorMessages OptionSet.MessageLocalizer(string) OptionSet.GetKeyForItem(Option) OptionSet.InsertItem(int, Option) OptionSet.RemoveItem(int) OptionSet.SetItem(int, Option) OptionSet.Add(Option) OptionSet.Add(string, Action<string>) OptionSet.Add(string, string, Action<string>) OptionSet.Add(string, OptionAction<string, string>) OptionSet.Add(string, string, OptionAction<string, string>) OptionSet.Add<T>(string, Action<T>) OptionSet.Add<T>(string, string, Action<T>) OptionSet.Add<TKey, TValue>(string, OptionAction<TKey, TValue>) OptionSet.Add<TKey, TValue>(string, string, OptionAction<TKey, TValue>) OptionSet.CreateOptionContext() OptionSet.Parse(IEnumerable<string>) OptionSet.GetOptionParts(string, out string, out string, out string, out string) OptionSet.Parse(string, OptionContext) OptionSet.WriteOptionDescriptions(TextWriter) KeyedCollection<string, Option>.Contains(string) KeyedCollection<string, Option>.TryGetValue(string, out Option) KeyedCollection<string, Option>.Remove(string) KeyedCollection<string, Option>.ChangeItemKey(Option, string) KeyedCollection<string, Option>.ClearItems() KeyedCollection<string, Option>.GetKeyForItem(Option) KeyedCollection<string, Option>.InsertItem(int, Option) KeyedCollection<string, Option>.RemoveItem(int) KeyedCollection<string, Option>.SetItem(int, Option) KeyedCollection<string, Option>.Comparer KeyedCollection<string, Option>.this[string] KeyedCollection<string, Option>.Dictionary Collection<Option>.Clear() Collection<Option>.CopyTo(Option[], int) Collection<Option>.Contains(Option) Collection<Option>.GetEnumerator() Collection<Option>.IndexOf(Option) Collection<Option>.Insert(int, Option) Collection<Option>.Remove(Option) Collection<Option>.RemoveAt(int) Collection<Option>.ClearItems() Collection<Option>.Count Collection<Option>.Items Collection<Option>.this[int] object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnitLite Assembly: nunitlite.dll Syntax public class NUnitLiteOptions : CommandLineOptions, IList<Option>, ICollection<Option>, IList, ICollection, IReadOnlyList<Option>, IReadOnlyCollection<Option>, IEnumerable<Option>, IEnumerable Constructors View Source NUnitLiteOptions(bool, params string[]) Declaration public NUnitLiteOptions(bool requireInputFile, params string[] args) Parameters Type Name Description bool requireInputFile string[] args View Source NUnitLiteOptions(params string[]) Constructor Declaration public NUnitLiteOptions(params string[] args) Parameters Type Name Description string[] args Implements IList<T> ICollection<T> IList ICollection IReadOnlyList<T> IReadOnlyCollection<T> IEnumerable<T> IEnumerable"
  },
  "api/NUnitLite.OutputManager.html": {
    "href": "api/NUnitLite.OutputManager.html",
    "title": "Class OutputManager | NUnit Docs",
    "summary": "Class OutputManager OutputManager is responsible for creating output files from a test run in various formats. Inheritance object OutputManager Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnitLite Assembly: nunitlite.dll Syntax public class OutputManager Constructors View Source OutputManager(string) Construct an OutputManager Declaration public OutputManager(string workDirectory) Parameters Type Name Description string workDirectory The directory to use for reports Methods View Source WriteResultFile(ITestResult, OutputSpecification, IDictionary<string, object>, TestFilter) Write the result of a test run according to a spec. Declaration public void WriteResultFile(ITestResult result, OutputSpecification spec, IDictionary<string, object> runSettings, TestFilter filter) Parameters Type Name Description ITestResult result The test result OutputSpecification spec An output specification IDictionary<string, object> runSettings Settings TestFilter filter Filter View Source WriteTestFile(ITest, OutputSpecification) Write out the result of exploring the tests Declaration public void WriteTestFile(ITest test, OutputSpecification spec) Parameters Type Name Description ITest test The top-level test OutputSpecification spec An OutputSpecification"
  },
  "api/NUnitLite.OutputWriter.html": {
    "href": "api/NUnitLite.OutputWriter.html",
    "title": "Class OutputWriter | NUnit Docs",
    "summary": "Class OutputWriter OutputWriter is an abstract class used to write test results to a file in various formats. Specific OutputWriters are derived from this class. Inheritance object OutputWriter NUnit2XmlOutputWriter NUnit3XmlOutputWriter TestCaseOutputWriter Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnitLite Assembly: nunitlite.dll Syntax public abstract class OutputWriter Constructors View Source OutputWriter() Declaration protected OutputWriter() Methods View Source WriteResultFile(ITestResult, TextWriter, IDictionary<string, object>, TestFilter) Abstract method that writes a test result to a TextWriter Declaration public abstract void WriteResultFile(ITestResult result, TextWriter writer, IDictionary<string, object> runSettings, TestFilter filter) Parameters Type Name Description ITestResult result The result to be written TextWriter writer A TextWriter to which the result is written IDictionary<string, object> runSettings A dictionary of settings used for this test run TestFilter filter View Source WriteResultFile(ITestResult, string, IDictionary<string, object>, TestFilter) Writes a test result to a file Declaration public void WriteResultFile(ITestResult result, string outputPath, IDictionary<string, object> runSettings, TestFilter filter) Parameters Type Name Description ITestResult result The result to be written string outputPath Path to the file to which the result is written IDictionary<string, object> runSettings A dictionary of settings used for this test run TestFilter filter The filter to apply View Source WriteTestFile(ITest, TextWriter) Abstract method that writes test info to a TextWriter Declaration public abstract void WriteTestFile(ITest test, TextWriter writer) Parameters Type Name Description ITest test The test to be written TextWriter writer A TextWriter to which the test info is written View Source WriteTestFile(ITest, string) Writes test info to a file Declaration public void WriteTestFile(ITest test, string outputPath) Parameters Type Name Description ITest test The test to be written string outputPath Path to the file to which the test info is written"
  },
  "api/NUnitLite.ResultSummary.html": {
    "href": "api/NUnitLite.ResultSummary.html",
    "title": "Class ResultSummary | NUnit Docs",
    "summary": "Class ResultSummary Helper class used to summarize the result of a test run Inheritance object ResultSummary Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnitLite Assembly: nunitlite.dll Syntax public class ResultSummary Constructors View Source ResultSummary(ITestResult) Initializes a new instance of the ResultSummary class. Declaration public ResultSummary(ITestResult result) Parameters Type Name Description ITestResult result The result. Properties View Source Duration Gets or sets the elapsed time for running the test in seconds Declaration public double Duration { get; } Property Value Type Description double View Source EndTime Gets or sets the time the test finished running. Declaration public DateTime EndTime { get; } Property Value Type Description DateTime View Source ErrorCount Gets the error count Declaration public int ErrorCount { get; } Property Value Type Description int View Source ExplicitCount Gets the explicit count Declaration public int ExplicitCount { get; } Property Value Type Description int View Source FailedCount Returns the number of failed test cases (including errors and invalid tests) Declaration public int FailedCount { get; } Property Value Type Description int View Source FailureCount Gets count of failed tests, excluding errors and invalid tests Declaration public int FailureCount { get; } Property Value Type Description int View Source IgnoreCount Gets the ignore count Declaration public int IgnoreCount { get; } Property Value Type Description int View Source InconclusiveCount Gets the count of inconclusive tests Declaration public int InconclusiveCount { get; } Property Value Type Description int View Source InvalidCount Returns the number of test cases that were not runnable due to errors in the signature of the class or method. Such tests are also counted as Errors. Declaration public int InvalidCount { get; } Property Value Type Description int View Source InvalidTestFixtures Invalid Test Fixtures Declaration public int InvalidTestFixtures { get; } Property Value Type Description int View Source NotRunCount Gets the number of tests not run for any reason. Declaration public int NotRunCount { get; } Property Value Type Description int View Source PassCount Gets the count of passed tests Declaration public int PassCount { get; } Property Value Type Description int View Source ResultState Gets the ResultState of the test result, which indicates the success or failure of the test. Declaration public ResultState ResultState { get; } Property Value Type Description ResultState View Source RunCount Returns the number of test cases actually run. Declaration public int RunCount { get; } Property Value Type Description int View Source SkipCount Gets the count of skipped tests, excluding ignored tests Declaration public int SkipCount { get; } Property Value Type Description int View Source StartTime Gets or sets the time the test started running. Declaration public DateTime StartTime { get; } Property Value Type Description DateTime View Source TestCount Gets the number of test cases for which results have been summarized. Any tests excluded by use of Category or Explicit attributes are not counted. Declaration public int TestCount { get; } Property Value Type Description int View Source TotalSkipCount Returns the sum of skipped test cases, including ignored and explicit tests Declaration public int TotalSkipCount { get; } Property Value Type Description int View Source WarningCount Gets count of tests with warnings Declaration public int WarningCount { get; } Property Value Type Description int"
  },
  "api/NUnitLite.TeamCityEventListener.html": {
    "href": "api/NUnitLite.TeamCityEventListener.html",
    "title": "Class TeamCityEventListener | NUnit Docs",
    "summary": "Class TeamCityEventListener TeamCityEventListener class handles ITestListener events by issuing TeamCity service messages on the Console. Inheritance object TeamCityEventListener Implements ITestListener Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnitLite Assembly: nunitlite.dll Syntax public class TeamCityEventListener : ITestListener Constructors View Source TeamCityEventListener() Default constructor using Console.Out Declaration public TeamCityEventListener() Remarks This constructor must be called before Console.Out is redirected in order to work correctly under TeamCity. View Source TeamCityEventListener(TextWriter) Construct a TeamCityEventListener specifying a TextWriter. Used for testing. Declaration public TeamCityEventListener(TextWriter outWriter) Parameters Type Name Description TextWriter outWriter The TextWriter to receive normal messages. Methods View Source SendMessage(TestMessage) Called when a test produces a message to be sent to listeners Declaration public void SendMessage(TestMessage message) Parameters Type Name Description TestMessage message A TestMessage object containing the text to send View Source TestFinished(ITestResult) Called when a test has finished Declaration public void TestFinished(ITestResult result) Parameters Type Name Description ITestResult result The result of the test View Source TestOutput(TestOutput) Called when a test produces output for immediate display Declaration public void TestOutput(TestOutput output) Parameters Type Name Description TestOutput output A TestOutput object containing the text to display View Source TestStarted(ITest) Called when a test has just started Declaration public void TestStarted(ITest test) Parameters Type Name Description ITest test The test that is starting Implements ITestListener"
  },
  "api/NUnitLite.TestCaseOutputWriter.html": {
    "href": "api/NUnitLite.TestCaseOutputWriter.html",
    "title": "Class TestCaseOutputWriter | NUnit Docs",
    "summary": "Class TestCaseOutputWriter TestCaseOutputWriter lists test cases Inheritance object OutputWriter TestCaseOutputWriter Inherited Members OutputWriter.WriteResultFile(ITestResult, string, IDictionary<string, object>, TestFilter) OutputWriter.WriteTestFile(ITest, string) object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnitLite Assembly: nunitlite.dll Syntax public class TestCaseOutputWriter : OutputWriter Constructors View Source TestCaseOutputWriter() Declaration public TestCaseOutputWriter() Methods View Source WriteResultFile(ITestResult, TextWriter, IDictionary<string, object>, TestFilter) Write a list of test cases to a file Declaration public override void WriteResultFile(ITestResult result, TextWriter writer, IDictionary<string, object> runSettings, TestFilter filter) Parameters Type Name Description ITestResult result TextWriter writer IDictionary<string, object> runSettings TestFilter filter Overrides OutputWriter.WriteResultFile(ITestResult, TextWriter, IDictionary<string, object>, TestFilter) View Source WriteTestFile(ITest, TextWriter) Write a list of test cases to a file Declaration public override void WriteTestFile(ITest test, TextWriter writer) Parameters Type Name Description ITest test TextWriter writer Overrides OutputWriter.WriteTestFile(ITest, TextWriter)"
  },
  "api/NUnitLite.TextRunner.html": {
    "href": "api/NUnitLite.TextRunner.html",
    "title": "Class TextRunner | NUnit Docs",
    "summary": "Class TextRunner TextRunner is a general purpose class that runs tests and outputs to a text-based user interface (TextUI). Call it from your Main like this: new TextRunner(textWriter).Execute(args); OR new TextUI().Execute(args); The provided TextWriter is used by default, unless the arguments to Execute override it using -out. The second form uses the Console, provided it exists on the platform. NOTE: When running on a platform without a Console, such as Windows Phone, the results will simply not appear if you fail to specify a file in the call itself or as an option. Inheritance object TextRunner Implements ITestListener Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnitLite Assembly: nunitlite.dll Syntax public class TextRunner : ITestListener Constructors View Source TextRunner() Initializes a new instance of the TextRunner class without specifying an assembly. This is interpreted as allowing a single input file in the argument list to Execute(). Declaration public TextRunner() View Source TextRunner(Assembly) Initializes a new instance of the TextRunner class specifying a test assembly whose tests are to be run. Declaration public TextRunner(Assembly testAssembly) Parameters Type Name Description Assembly testAssembly Fields View Source FILE_NOT_FOUND File not found Declaration public const int FILE_NOT_FOUND = -2 Field Value Type Description int View Source INVALID_ARG Invalid Arguments Declaration public const int INVALID_ARG = -1 Field Value Type Description int View Source INVALID_TEST_FIXTURE Invalid test suite Declaration public const int INVALID_TEST_FIXTURE = -4 Field Value Type Description int View Source OK OK Declaration public const int OK = 0 Field Value Type Description int View Source UNEXPECTED_ERROR Unexpected error occurred Declaration public const int UNEXPECTED_ERROR = -100 Field Value Type Description int Properties View Source Summary Declaration public ResultSummary Summary { get; } Property Value Type Description ResultSummary Methods View Source CreateTestFilter(NUnitLiteOptions) Create the test filter for this run - public for testing Declaration public static TestFilter CreateTestFilter(NUnitLiteOptions options) Parameters Type Name Description NUnitLiteOptions options Returns Type Description TestFilter View Source Execute(ExtendedTextWriter, TextReader, string[]) Declaration public int Execute(ExtendedTextWriter writer, TextReader reader, string[] args) Parameters Type Name Description ExtendedTextWriter writer TextReader reader string[] args Returns Type Description int View Source Execute(string[]) Declaration public int Execute(string[] args) Parameters Type Name Description string[] args Returns Type Description int View Source MakeRunSettings(NUnitLiteOptions) Make the settings for this run - this is public for testing Declaration public static Dictionary<string, object> MakeRunSettings(NUnitLiteOptions options) Parameters Type Name Description NUnitLiteOptions options Returns Type Description Dictionary<string, object> View Source ReportResults(ITestResult) Declaration public void ReportResults(ITestResult result) Parameters Type Name Description ITestResult result View Source RunTests(TestFilter, IDictionary<string, object>) Declaration public int RunTests(TestFilter filter, IDictionary<string, object> runSettings) Parameters Type Name Description TestFilter filter IDictionary<string, object> runSettings Returns Type Description int View Source SendMessage(TestMessage) Called when a test produces a message to be sent to listeners Declaration public void SendMessage(TestMessage message) Parameters Type Name Description TestMessage message A TestMessage object containing the text to send View Source TestFinished(ITestResult) Called when a test has finished Declaration public void TestFinished(ITestResult result) Parameters Type Name Description ITestResult result The result of the test View Source TestOutput(TestOutput) Called when a test produces output for immediate display Declaration public void TestOutput(TestOutput output) Parameters Type Name Description TestOutput output A TestOutput object containing the text to display View Source TestStarted(ITest) Called when a test or suite has just started Declaration public void TestStarted(ITest test) Parameters Type Name Description ITest test The test that is starting Implements ITestListener"
  },
  "api/NUnitLite.TextUI.html": {
    "href": "api/NUnitLite.TextUI.html",
    "title": "Class TextUI | NUnit Docs",
    "summary": "Class TextUI Inheritance object TextUI Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnitLite Assembly: nunitlite.dll Syntax public class TextUI Constructors View Source TextUI(ExtendedTextWriter, TextReader, NUnitLiteOptions) Declaration public TextUI(ExtendedTextWriter writer, TextReader reader, NUnitLiteOptions options) Parameters Type Name Description ExtendedTextWriter writer TextReader reader NUnitLiteOptions options Properties View Source Writer Declaration public ExtendedTextWriter Writer { get; } Property Value Type Description ExtendedTextWriter Methods View Source DisplayDiscoveryReport(TimeStamp, TimeStamp) Declaration public void DisplayDiscoveryReport(TimeStamp startTime, TimeStamp endTime) Parameters Type Name Description TimeStamp startTime TimeStamp endTime View Source DisplayError(string) Declaration public void DisplayError(string text) Parameters Type Name Description string text View Source DisplayErrors(IList<string>) Declaration public void DisplayErrors(IList<string> messages) Parameters Type Name Description IList<string> messages View Source DisplayErrorsFailuresAndWarningsReport(ITestResult) Declaration public void DisplayErrorsFailuresAndWarningsReport(ITestResult result) Parameters Type Name Description ITestResult result View Source DisplayHeader() Writes the header. Declaration public void DisplayHeader() View Source DisplayHelp() Declaration public void DisplayHelp() View Source DisplayNotRunReport(ITestResult) Declaration public void DisplayNotRunReport(ITestResult result) Parameters Type Name Description ITestResult result View Source DisplayRunSettings() Declaration public void DisplayRunSettings() View Source DisplayRuntimeEnvironment() Displays info about the runtime environment. Declaration public void DisplayRuntimeEnvironment() View Source DisplaySummaryReport(ResultSummary) Declaration public void DisplaySummaryReport(ResultSummary summary) Parameters Type Name Description ResultSummary summary View Source DisplayTestFiles(IEnumerable<string>) Declaration public void DisplayTestFiles(IEnumerable<string> testFiles) Parameters Type Name Description IEnumerable<string> testFiles View Source DisplayTestFilters() Declaration public void DisplayTestFilters() View Source DisplayWarning(string) Declaration public void DisplayWarning(string text) Parameters Type Name Description string text View Source TestFinished(ITestResult) Declaration public void TestFinished(ITestResult result) Parameters Type Name Description ITestResult result View Source TestOutput(TestOutput) Declaration public void TestOutput(TestOutput output) Parameters Type Name Description TestOutput output View Source TestStarted(ITest) Declaration public void TestStarted(ITest test) Parameters Type Name Description ITest test View Source WaitForUser(string) Declaration public void WaitForUser(string message) Parameters Type Name Description string message"
  },
  "api/NUnitLite.TimeStamp.html": {
    "href": "api/NUnitLite.TimeStamp.html",
    "title": "Class TimeStamp | NUnit Docs",
    "summary": "Class TimeStamp Inheritance object TimeStamp Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: NUnitLite Assembly: nunitlite.dll Syntax public class TimeStamp Constructors View Source TimeStamp() Declaration public TimeStamp() Properties View Source DateTime Declaration public DateTime DateTime { get; } Property Value Type Description DateTime View Source Ticks Declaration public long Ticks { get; } Property Value Type Description long Methods View Source TicksToSeconds(long) Declaration public static double TicksToSeconds(long ticks) Parameters Type Name Description long ticks Returns Type Description double"
  },
  "api/NUnitLite.html": {
    "href": "api/NUnitLite.html",
    "title": "Namespace NUnitLite | NUnit Docs",
    "summary": "Namespace NUnitLite Classes AutoRun The AutoRun class is used by executable test assemblies to control their own execution. Call it from your executable test like this: new AutoRun().Execute(args); The arguments can be those passed into your exe or constructed for the purpose in your code. If the tests are in a dll, you can write a stub executable that runs them like this: new Autorun().Execute(testAssembly, args); When running tests compiled against the .NET Standard framework, the methods above are not available. Run your tests like this: new AutoRun().Execute(testAssembly, args, output, input); Where output is an ExtendedTextWriter (normally a ColorConsoleWriter) and input is usually Console.In and is used by the --wait option. NUnit2XmlOutputWriter NUnit2XmlOutputWriter is able to create an XML file representing the result of a test run in NUnit 2.x format. NUnit3XmlOutputWriter NUnit3XmlOutputWriter is responsible for writing the results of a test to a file in NUnit 3 format. NUnitLiteOptions NUnitLiteOptions encapsulates the option settings for NUnitLite. Currently, there are no additional options beyond those common options that are shared with nunit3-console. If NUnitLite should acquire some unique options, they should be placed here. OutputManager OutputManager is responsible for creating output files from a test run in various formats. OutputWriter OutputWriter is an abstract class used to write test results to a file in various formats. Specific OutputWriters are derived from this class. ResultSummary Helper class used to summarize the result of a test run TeamCityEventListener TeamCityEventListener class handles ITestListener events by issuing TeamCity service messages on the Console. TestCaseOutputWriter TestCaseOutputWriter lists test cases TextRunner TextRunner is a general purpose class that runs tests and outputs to a text-based user interface (TextUI). Call it from your Main like this: new TextRunner(textWriter).Execute(args); OR new TextUI().Execute(args); The provided TextWriter is used by default, unless the arguments to Execute override it using -out. The second form uses the Console, provided it exists on the platform. NOTE: When running on a platform without a Console, such as Windows Phone, the results will simply not appear if you fail to specify a file in the call itself or as an option. TextUI TimeStamp"
  },
  "api/System.Web.UI.ICallbackEventHandler.html": {
    "href": "api/System.Web.UI.ICallbackEventHandler.html",
    "title": "Interface ICallbackEventHandler | NUnit Docs",
    "summary": "Interface ICallbackEventHandler A shim of the .NET interface for platforms that do not support it. Used to indicate that a control can be the target of a callback event on the server. Namespace: System.Web.UI Assembly: nunit.framework.dll Syntax public interface ICallbackEventHandler Methods View Source GetCallbackResult() Returns the results of a callback event that targets a control. Declaration string GetCallbackResult() Returns Type Description string View Source RaiseCallbackEvent(string) Processes a callback event that targets a control. Declaration void RaiseCallbackEvent(string report) Parameters Type Name Description string report"
  },
  "api/System.Web.UI.html": {
    "href": "api/System.Web.UI.html",
    "title": "Namespace System.Web.UI | NUnit Docs",
    "summary": "Namespace System.Web.UI Interfaces ICallbackEventHandler A shim of the .NET interface for platforms that do not support it. Used to indicate that a control can be the target of a callback event on the server."
  },
  "articles/developer-info/Best-practices-for-XML-documentation.html": {
    "href": "articles/developer-info/Best-practices-for-XML-documentation.html",
    "title": "Best Practices for XML Documentation | NUnit Docs",
    "summary": "Best Practices for XML Documentation XML documentation has a significant impact on the end user's experience. Unlike other parts of the code, XML comments (as well as exception messages) are user-facing and highly visible. They can save valuable time and even make the difference for an end user between a confusing debugging session and no debugging needed in the first place. Polished and informative XML documentation provides a noticeably positive experience. Sentences Always end sentences with proper punctuation, typically a period. If there aren't enough words to form a sentence, it's likely that they are redundant. Try to add enough context to make a sentence to avoid anemic documentation. Rather than The comparer, say Used to compare the <paramref name=\"items\"/>. The added clarity is desirable. <see>, <paramref> and <typeparamref> Use <see cref=\"TypeOrMember\"/>, <paramref name=\"parameterName\"/> and <typeparamref name=\"T\"/> whenever possible. The compiler checks the validity of the names and overloads. Future refactoring can be done with confidence that you aren't leaving the docs out of date. This also provides a seamless experience by creating links in the Object Browser and intellisense and colorizes intellisense. Consider using <see langword=\"null\"/> for keywords to maintain the seamlessness. <summary> Add a <summary> tag for each public type and member. However, prefer to give each type and member a really communicative name. If those names end up covering all the user could need to know, remove the <summary> tag (if this does not cause a build warning) to avoid super redundant documentation. If they do not, add relevant details. <param> and <typeparam> Add a <param> tag for each parameter describing what effect it has (rather than what it is). However, prefer to give each parameter a really communicative name. If those names end up covering all the user could need to know about all the parameters, remove all the <param> tags to avoid super redundant documentation. If they do not, add relevant details to each <param> to the extent possible. The same applies to <typeparam> tags. They are shown by intellisense as the user enters type parameter lists exactly the way <param> descriptions are shown as the user enters method parameter lists. <typeparam> elements are just as important on generic methods as they are on generic type definitions. <returns> and <value> Don't spend any time on the <returns> or <value> tags since the contents are not typically seen. Important details should all be in the <summary>. If the IDE auto-inserts them, just remove them. Empty tags Do not leave any empty tags. Either remove them or fill them out. This includes the compiler's all-or-none <param> and <typeparam> tag enforcement. <exception> Consider documenting things that lead to exceptions being thrown using the <exception> tag. This can really get the end user up to speed on things that aren't immediately obvious from the method signature. Sadly intellisense will only show the <exception> type thrown, not the message, so for important messages it's good to also include the message a second time in the summary: /// <summary> /// Does foo. If <see cref=\"OtherProperty\"/> is not set, throws <see cref=\"InvalidOperationException\"/>. /// </summary> /// <exception cref=\"InvalidOperationException\">Thrown when <see cref=\"OtherProperty\"/> is not set.</exception>"
  },
  "articles/developer-info/Coding-Standards.html": {
    "href": "articles/developer-info/Coding-Standards.html",
    "title": "Coding Standards | NUnit Docs",
    "summary": "Coding Standards In order to keep the code consistent, we follow certain conventions. Many of the choices we have made are somewhat arbitrary and could easily have gone another way. At this point, most of these conventions are already well-established, so please don't re-open a discussion about them unless you have new issues to present. Notice that these standards are all stylistic. Do not write standards that tell people how to program. For example, we don't need a standard that tells us to always dispose of disposable objects because that's part of the normal \"standard\" for C# programming. In other words, these standards are about relatively trivial things that we have all agreed to do the same way. Making Changes If you do want to make changes, please initiate a discussion of what you want to change on the developer list first. If you are intending to standardize more things than we usually standardize, it's wise to discuss it first to avoid wasting time! General - Please Read This Follow these guidelines unless you have an extremely good reason not to. Add a comment explaining why you are not following them so others will know your reasoning. Don't make arbitrary changes in existing code merely to conform them to these guidelines. Normally, you should only change the parts of a file that you have to edit in order to fix a bug or implement new functionality. In particular, don't use automatic formatting to change an entire file at once as this makes it difficult to identify the underlying code changes when we do a code review. In cases where we make broad changes in layout or naming, they should be committed separately from any bug fixes or feature changes in order to keep the review process as simple as possible. That said, we don't do this very often, since we have real work to do! Visual Studio can be set up to match the coding standards by importing the nunit.vssettings file from this repository. This file will only change the C# indentation and formatting settings. It will not modify any other Visual Studio settings. It can be imported into Visual Studio 2010 and later by going to Tools | Import and Export Settings... Copyright NUnit is licensed under the MIT license. Each file is prefixed by the NUnit Copyright Notice Copyright (c) Charlie Poole, Rob Prouse and Contributors. MIT License - see LICENSE.txt enclosed in appropriate comment characters for the language of the file. Notes Charlie Poole and Rob Prouse are the copyright holders for the NUnit code on behalf of the NUnit community. Do not place your name on the copyright line if you wish to contribute code. The year is not included in the copyright file header. In the NUnit Framework project, you can insert the copyright header in a file using the quick fix Ctrl+. in Visual Studio. Language Level Each NUnit project sets its own C# language level. We generally aim to keep the code buildable by folks who don't necessarily have the latest compilers, so this is sometimes not the very latest level. Currently, the maximum level for most NUnit projects is C# 6. Note that targeting a particular level of C# does not mean that all features are available. Features are limited based on the framework targeted as well. For example, the engine currently targets .NET 2.0, which means that System.Linq extensions cannot be used in the code. Layout Namespace, Class, Structure, Interface, Enumeration and Method Definitions Place the opening and closing braces on a line by themselves and at the same level of indentation as their parent. public class MyClass : BaseClass, SomeInterface { public void SomeMethod(int num, string name) { // code of the method } } An exception may be made if a method body or class definition is empty public virtual void SomeMethod(int num, string name) { } public class GadgetList : List<Gadget> { } Property Definitions Prefer automatic backing variables wherever possible public string SomeProperty { get; private set; } If a getter or setter has only one statement, a single line should normally be used public string SomeProperty { get { return _innerList.SomeProperty; } } If there is more than one statement, use the same layout as for method definitions public string SomeProperty { get { if (_innerList == null) InitializeInnerList(); return _innerList.SomeProperty; } } Spaces Method declarations and method calls should not have spaces between the method name and the parenthesis, nor within the parenthesis. Put a space after a comma between parameters. public void SomeMethod(int x, int y) { Console.WriteLine(\"{0}+{1}={2}\", x, y, x + y); } Control flow statements should have a space between the keyword and the parenthesis, but not within the parenthesis. for (int i = 1; i < 10; i++) { // Do Something } There should be no spaces in expression parenthesis, type casts, generics or array brackets, but there should be a space before and after binary operators. int x = a * (b + c); var list = new List<int>(); list.Add(x); var y = (double)list[0]; Indentation Use four consecutive spaces per level of indent. Don't use tabs - except where the IDE can be set to convert tabs to four spaces. In Visual Studio, set the tab size to 4, the indent size to 4 and make sure Insert spaces is selected. Indent content of code blocks. In switch statements, indent both the case labels and the case blocks. Indent case blocks even if not using braces. switch (name) { case \"John\": break; } Newlines Methods and Properties should be separated by one blank line. Private member variables should have no blank lines. Blocks of related code should have not have any blank lines. Blank lines can be used to visually group sections of code, but there should never be multiple blank lines. If brackets are not used on a control flow statement with a single line, a blank line should follow. public static double GetAttribute(XmlNode result, string name, double defaultValue) { var attr = result.Attributes[name]; double attributeValue; if (attr == null || !double.TryParse(attr.Value, NumberStyles.Any, CultureInfo.InvariantCulture, out attributeValue)) return defaultValue; return attributeValue; } Naming The following table shows our naming standard for various types of names. All names should be clear enough that somebody unfamiliar with the code can learn about the code by reading them, rather than having to understand the code in order to figure out the names. We don't use any form of \"Hungarian\" notation. For items that may vary by project, the project’s root .editorconfig and solution DotSettings may provide the defaults and diagnostics expected for PRs in that project. Named Item Naming Standard Notes Namespaces PascalCasing Types PascalCasing For framework types with a special C# name, we use the C# name. So... int rather than System.Int32. Methods PascalCasing Properties PascalCasing Events PascalCasing Public and Protected Fields PascalCasing(with allowance for API compatibility) Includes constant fields.Public and protected variable fields should be avoided. Private and Internal Fields (may vary by project) Includes constant fields.Do not use this with fields designated by a leading underscore. Keep each file to the same standard, renaming when changes are made.Use readonly wherever appropriate for private fields. Parameters camelCasing Local Variables camelCasing Comments Use doc comments on all publicly accessible members. Keep the audience in mind. For example, comments on publicly used framework methods or attributes should be written for easy understanding by users, while comments on internal methods should target folks who work on NUnit. Don't comment what is obvious. Do comment unusual algorithms and the reasoning behind some choices made. Use TODO comments when needed, but make sure to go back periodically and do whatever it is! File Organization Normally, have one public type per source file. An exception is made for a simple enumeration, which is used in the interface of the public type and seems to \"belong\" to it. Example: TestResult and ResultState Name the source file after the public type it represents. The Directory hierarchy and Namespace hierarchy should match. For example, if the root namespace for a project is NUnit.Framework, files in the Constraints subdirectory should be in the NUnit.Framework.Constraints namespace. Wherever possible, classes should be laid out in the following order, Private member variables Constructors Dispose Public Properties Protected Properties Private Properties Public Methods Protected Methods Private Methods Using statements should be sorted as follows: All System namespaces All Other namespaces, including NUnit's It is permissible, but not required, to place using statements inside the namespace block, in shortened form, for namespaces that are descendants of the namespace itself. Note that the compiler will permit other uses of shortened namespaces within the namespace block, but we prefer to limit ourselves to descendants. Non-descendant namespaces should be listed in full form in the main using block. using System; using System.Collections; using System.Collections.Generic; using System.IO; using NUnit.Engine.Interfaces; using NUnit.Engine.Internal.Execution; // OK, but inside the namespace is preferred namespace NUnit.Engine.Internal { using Execution; // Preferred location /* ... */ } Use of Regions [Needs to be filled in] Use of the var keyword The var keyword should be used where the type is obvious to someone reading the code, for example when creating a new object. Use the full type whenever the type is not obvious, for example when initializing a variable with the return value of a method. var i = 12; var list = new List<int>(); Foo foo = GetFoo();"
  },
  "articles/developer-info/Contributions.html": {
    "href": "articles/developer-info/Contributions.html",
    "title": "Contributions | NUnit Docs",
    "summary": "Contributions This page contains guidelines to follow when evaluating and accepting contributions in form of source code from other developers. Shape All proposed changes to the code should come in the form of GitHub pull requests. Pull requests are built automatically on the build server and they make it easy to track the origin of any change. Quality When appropriate, pull requests should contain enough unit tests to provide coverage for the changes they introduce. Because pull requests are built automatically on the build server it is important to check that the changes pass all tests. Ideally pull requests should contain only few commits which address directly the issue or feature. Integrating There are several ways a pull request can be integrated into NUnit's repository: Pull requests can be merged automatically using GitHub's Web interface. This is an option only if they are clean of useless commits which would only cause confusion and clutter the history for no good reason. Merging pull requests using GitHub Web interface creates a merge commit even when fast-forward would be possible. Pull requests can be merged manually once they've been checked out locally. Usually this would result in a fast-forward commit if no other changes appeared in the branch where the pull request is being integrated. In other cases you may still have the option to rebase the changes rather than merging. Although a linear history is nice, it's probably even better to force a merge instead, because it records more clearly where those changes came from and also because it automatically closes the pull request (although there may be GitHub hooks to close the pull request, perhaps mentioning its # in the commit message, which I'm not aware of). Usually it is preferable to use GitHub's automatic merge, and if the pull request does not comply with the few commits rule ask the contributor to sanitize it before doing it yourself. Avoid committing contributions by repeating the changes in the pull request manually, because this loses track of the origin of changes. Special reviews Anyone submitting a PR can ask for extra review or review by a particular person. Just say so in the PR indicating what needs special review. If you want someone particular to review it, use @ notation. By default, any PR is eligible to merge after it is reviewed as OK. If anyone wants to create a PR early to get feedback on the code, then he should say so right at the top of the PR. Cleaning up After a pull request has been integrated remember to close associated issues, when appropriate and if such issues exist. If a pull request has been integrated manually remember to close the pull request afterwards. The branch of a pull request, in case it belongs to the NUnit's repository might be deleted as well. GitHub provides the option to do so in the Web user interface. Be careful before deleting a branch that the author may have intended the branch to be long-lived. Notes For contributions from within the team, using branches on the NUnit repository rather than clones, don't forget to delete the branches once merged unless they need to hang around for long-running work"
  },
  "articles/developer-info/Issue-Tracking.html": {
    "href": "articles/developer-info/Issue-Tracking.html",
    "title": "Issue Tracking | NUnit Docs",
    "summary": "Issue Tracking We use the GitHub issue tracker to keep track of our ongoing work. We supplement GitHub's native issue handling by using ZenHub, which provides a number of additional features. Workflow We use a ZenHub Board with a standard set of pipelines to track the flow of work in each repo. Our standard set of pipeline columns are slightly different from the ZenHub default: New Issues All issues start as new. We like to review them as quickly as possible. Some issues can be immediately closed while others need to be categorized for further work. We usually assign at least an is and a priority label (see below) to every issue and then move it to either the Discussion or the Backlog column. Discussion These are items that require some discussion, either about whether we want to do them or how they should be implemented. Some items here may require confirmation or design as well. Backlog This is our product backlog consisting of all the issues we want to get done now or in the future. In the past, we have often put things we didn't really want to do in our Backlog, assigning them a low priority. While this avoids having to say no to the requester, it doesn't do them any real service. Putting an issue into the Backlog should mean that it will eventually make it to a release. To Do These are things we are ready to get working on right now and represent a suggestion to developers as to what to choose to work on next. Most but not all of them will be scheduled for the next milestone. This is a good place to keep issues that are blocking other work, so as to encourage developers to get the issue done. Note Since the number of people actively working on a given project varies, we can't establish a fixed number of items to keep in this column. The project lead should try to keep it to a reasonable size, generally no more than twice the number of active developers. If it seems to be growing too rapidly, some of the issues should be moved to the backlog. In Progress These are issues that somebody is already working on. That person should be shown as assigned to the issue and would normally be the one to move the issue into this column. Done When all work is done and the person doing it feels it is ready to be merged, the issue should be moved to this column. It remains there while comments are discussed and small changes are made. If the comments will lead to significant rework, then move the issue back to In Progress. Closed Issues go here automatically when they are closed. Issue Assignment Normally, committers self-assign items they want to work on. Please don't assign something to yourself and then let it sit. As a matter of courtesy, nobody else will start working on something that is assigned to you, so the result is that the work won't get done. GitHub won't let non-committers assign issues to themselves (or anyone) so if a contributor wants to work on an issue, they should post a comment to that effect. One of the committers will make the assignment. In many cases, the assignment will be shared between the contributor and a committer who is providing mentoring for them. If an issue that is assigned to you then you should do what needs to be done. For example, if it's in the discussion column, then it's up to you to make sure the discussion happens and progresses to a conclusion. If it's marked confirm then you should confirm it. If it's marked design then you should do the design and get it reviewed. And, of course, if it's ready for implementation you should do that! Issue Labels We try to use a standard set of labels across all the NUnit repositories. In some cases, an individual project may not yet have been converted to use these labels, but we expect to do so soon. That said, don't stress about whether something is a bug or an enhancement, normal versus low priority, etc. Just pick one. If things change later, the label can be changed as well. This is only intended to help us organize a relatively large number of issues, not to give us extra work. What it is Labels starting with is: indicate the nature of the issue. Only one should be used, based on the judgment of the committer who assigns the label. If there is no is: label, then we presumably don't know what the item is and should not be working on it! is:bug Something that isn't working as designed. is:docs Solely pertaining to the documentation or sample code. is:enhancement An addition or improvement to an existing feature. is:feature An entirely new feature. is:idea An idea about something we might do. We discuss these until they are either dropped or turned into a feature or enhancement we can work on. is:question Just a question - we discourage these as issues but they do happen. is:build Something to do with how we build the software, scripts, etc. is:refactor What it says: refactoring that is needed. Priority Labels starting with pri: indicate the priority of an issue. Pick just one, please. Priority may, of course, change over time, as items become more or less important to us. If no priority is assigned, we shouldn't be working on it. pri:critical Should only apply to bugs, which need to be fixed immediately, dropping everything else. At times, we will even speed up the release cycle due to a critical bug. pri:high High priority - implement as soon as possible. pri:normal Standard priority - implement when we can. pri:low Low priority - implement later or not at all. PRs and issues that need attention The goal with these is to keep team members from having to do tedious re-scanning to figure out the state of each long-lived PR or issue as well as increasing awareness. awaiting:contributor: Blocked until the contributor responds to the team's request for changes. awaiting:team: Blocked until a team member responds to a question or problem. awaiting:discussion: Blocked until the team comes to consensus on a design question. awaiting:review: Blocked until an additional team member approves or requests changes. Close Reason Labels starting with closed: indicate the status of the bug at closing and should only appear on closed bugs. Please remember to apply one of these when closing a bug as it makes it easier to review the list of closed bugs without opening each one to see what the disposition was. closed:done The work called for is done, i.e. the bug is fixed or the feature/enhancement is implemented. closed:duplicate The issue is a duplicate of one that we are working. A comment should indicate the issue number. closed:notabug The issue (generally a bug) is not valid or the feature already exists. There should be an explanatory comment. closed:norepro While the issue (generally a bug) may exist on the user's system, we have tried and are unable to reproduce it. If somebody later figures out a repro, the issue can be reopened. closed:wontfix The issue is possibly valid but we don't intend to implement it. It may be out of scope for the project or inconsistent with the values and priorities of the project. There should be an explanatory comment. Other Labels confirm Somebody should verify that the issue actually exists and then remove the label. In some cases, a bug may have been reported against an older version of NUnit and needs to be checked out using the current code. blocked The issue cannot be worked on until something else happens, external to the project. There should be a comment on the issue indicating what that something is. design Some design decisions need to be made before this can really be worked on. Sometimes this label may be applied before anything happens and other times the work may have started but reached a point where design decisions need to be made involving others in the team. up-for-grabs Indicates a backlog issue ready for implementation where we would love for the wider community to jump in and be assigned! Whoever adds this label should couple it with a comment suggesting what code to look at and a general approach to working the issue. easyfix Indicates an issue that is expected to take no more than a few nights' work. Epics Where appropriate, we make use of the ZenHub Epic feature to create issues that include a number of sub-issues. For example, when we split the original NUnit repository into separate framework and engine repositories, we created an epic that included a number of separate issues that had to be completed in order to accomplish the split smoothly. Milestones We use GitHub Milestones to represent future releases. Generally milestones are created by the project or team leader, who also decides what issues to place into the milestone. Our practice is to only schedule a limited number of key features in advance for each milestone, rather than trying to \"fill\" the milestone with the amount of work we think can be completed. Other work is only added to the next milestone after it has been completed. We do it this way because the amount of time developers have to spend on our projects can vary considerably over the course of time. We never know how much work will be done in a given period. Since we can't predict both the timing and the content of each release, we have chosen to hold the time constant and vary the content."
  },
  "articles/developer-info/Notes-Toward-NUnit-4.0.html": {
    "href": "articles/developer-info/Notes-Toward-NUnit-4.0.html",
    "title": "Notes Toward NUnit 4.0 | NUnit Docs",
    "summary": "Notes Toward NUnit 4.0 This page describes plans for the next major releases of NUnit, focusing on major changes we expect to make. Also see Towards NUnit 4 for more details on the changes. Extensions With the release of nunit3-console 4.0, we intend to stop distributing the teamcity-event-listener bundled with the console as a standard extension. We will continue to support the --teamcity option in the console runner when the extension is installed separately by the user. API possibilities https://github.com/nunit/nunit/issues/2437"
  },
  "articles/developer-info/Packaging-Extensions.html": {
    "href": "articles/developer-info/Packaging-Extensions.html",
    "title": "Packaging Extensions | NUnit Docs",
    "summary": "Packaging Extensions The NUnit Console/Engine currently ships with the following extensions, NUnit.Extension.NUnitProjectLoader NUnit.Extension.VSProjectLoader NUnit.Extension.NUnitV2ResultWriter NUnit.Extension.NUnitV2Driver NUnit.Extension.TeamCityEventListener All but the TeamCityEventListener are built and shipped by the NUnit team. These extensions must be built and released before building and releasing the Console/Engine, but only if they are changed and a release is planned. For the 3.5 release, all extensions will be built and released with the console. Future releases of each extension will be on an as-needed basis and the version numbers of the extensions and the console/engine will diverge over time. Create a Release Branch All work on releases should be done on a branch. Fetch and pull latest from master Create a branch in the form release-3.5 As you make the changes below, push the branch to GitHub and create a Pull Request to allow other team members to review your changes. Do not merge this branch/PR, we will create a separate PR to merge the changes back into master. Make Sure it Works Close all instances of Visual Studio or other IDE to ensure that no changes are left unsaved. Do a clean build and run all the tests on Windows. You may use the command below or three separate commands if preferred. If you encounter errors at any stage, you're not actually ready to release! build.cmd -Target=Clean build.cmd -Target=Test Repeat the build on a Linux system, if available. If this is not possible, be sure to scrutinize the results from the Travis CI build carefully. On Linux, you may use the command ./build -Target=Test Make sure that the most recent commits of master passed all tests in the CI builds. Check the builds on both Travis and AppVeyor. Review Milestone Status Check the milestone for the current release to see that there are no open issues. Any issues that are not going to be in this release should be moved to a future milestone. This may be the time to create the next milestone. Make sure that completed issues are marked with the appropriate 'closed' label depending on disposition. The release notes will end up reflecting issues marked closed:done. Check all future open milestones for completed issues. Anything that is completed will be included in this release so change its milestone to the current release. Check Versioning AssemblyVersion and AssemblyFileVersion are set in src\\extension\\Properties\\AssemblyInfo.cs and should match the version in build.cake. These values are normally incremented after a release, but should be checked. Update Copyright Year The copyright year in all the source files is only updated as they are changed, but the copyright in the [assembly: AssemblyCopyright(\"...\")] should be updated to the year of the release. If necessary, update the year in the general copyright notice LICENSE.txt. The .nuspec files in solution root contains a copyright line, which should also be updated. Notices at the top of each source code file are only updated when copyrightable changes are made to the file, not at the time of release. Push All Changes Make sure the release branch and any changes are pushed to GitHub, reviewed in a PR and all CI servers are passing. Creating the Release Clear the package directory to avoid confusion: erase package\\* This is not absolutely required, but will be helpful if you have other release packages present in the directory. You should be working on the release branch. Do a pull to make sure you have everything up to date. If changes of any significance were merged, you should test again before creating the release. Ensure that the release build is up to date. If you have any doubt whether the latest code changes have actually been built, do a clean build. If the build is up to date you may skip this step. build -Target Build Create the packages by running: build -Target Package Verify that the correct package has been created in the package sub-directory. NUnit..Extension.{NAME}.{VERSION}.nupkg Testing the Release Open the NuGet package from the package sub-directory using NuGet Package Explorer. Inspect the package metadata for errors and check that the tools folder contains the extension dll and any dependent assemblies. Next install the extension into a project with the NUnit.ConsoleRunner package and make sure you can run tests. If you are releasing the V2 driver, run NUnit 2 tests. If you are releasing the V2 Result Writer, write out V2 results. Archiving the Release Packages are archived on nunit.org in the downloads directory. Create a new sub-folder under downloads/extensions/v3/EXTENSION_NAME for the release. Upload all the package files into that directory. Publishing the Release Github Log onto Github and go to the extension repository. Select Releases and then click on the \"Draft a new release\" button. Enter a tag to be used for the release in the format v3.x.y Select your release branch as the target for the tag. Enter a title for the release, like NUnit Project Loader Extension 3.5 release. If you type 'N' you'll get some hints. Add a description of the release. It will be easier if you have prepared this in advance and can just paste it in. If this is an Alpha or Beta release, check the box that indicates a pre-release. Upload the nupkg package you created. Click the \"Publish release\" button to publish the release on Github. NuGet Sign on to nuget.org. Select Upload package. Browse to the location of the nupkg you created and upload it. Verify that the info is correct and click the \"Submit\" button. Merge into Master Close your release Pull Request Create a new branch off of your release branch Increment the version in the various locations. For example 3.5 -> 3.6. See the Update Package Versions section above. Push your changes to GitHub Create a pull request from your branch making sure it is based off master Notify Users Send notifications to the mailing list and twitter if the changes to the extension warrant it. Close the Milestone The milestone representing this release should be closed at this time."
  },
  "articles/developer-info/Packaging-the-Console-and-Engine.html": {
    "href": "articles/developer-info/Packaging-the-Console-and-Engine.html",
    "title": "Packaging the Console and Engine | NUnit Docs",
    "summary": "Packaging the Console and Engine Note TODO: This documentation was copied from the original packaging info and needs to be updated for packaging just the Console and Engine. This note describes how to create release packages for the NUnit console runner and test engine. Currently, all the builds and packaging must be done on a single Windows machine. This is likely to change in the future as we add more platforms. Software Prerequisites Various software combinations and environments may be used to build the NUnit 3 console runner and engine. Our standard environment is Visual Studio 2017 15.6+ Community Edition. Preparing for Release Merge latest into the release branch Fetch and pull latest from master Checkout the release branch and merge master Do not merge the release branch, we will create a separate PR to merge the changes back into master. Make Sure it Works Close all instances of Visual Studio or other IDE to ensure that no changes are left unsaved. Do a clean build and run all the tests on Windows. You may use the command below or three separate commands if preferred. If you encounter errors at any stage, you're not actually ready to release! build.cmd -Target=Clean build.cmd -Target=Test Repeat the build on a Linux system, if available. If this is not possible, be sure to scrutinize the results from the Travis CI build carefully. On Linux, you may use the command ./build -Target=Test Make sure that the most recent commits of master passed all tests in the CI builds. Check the builds on both Travis and AppVeyor. Check on TeamCity once we get that build working again. Review Milestone Status Check the milestone for the current release to see that there are no open issues. Any issues that are not going to be in this release should be moved to a future milestone. This may be the time to create the next milestone. Make sure that completed issues are marked with the appropriate 'closed' label depending on disposition. The release notes will end up reflecting issues marked closed:done. Check all future open milestones for completed issues. Anything that is completed will be included in this release so change its milestone to the current release. Check Assembly Versioning AssemblyVersion and AssemblyFileVersion are set separately for the framework, engine, engine api and console runner. Each is kept in a separate file and they may be updated separately. Using the 3.4.1 release as an example, version information would be set as follows: Component | File to Update | AssemblyVersion | AssemblyFileVersion --------------------- | ------------------- | --------------- | ------------------- Engine | EngineVersion.cs | 3.4.1.0 | 3.4.1.0 Engine API | EngineApiVersion.cs | 3.0.0.0 | 3.4.1.0 Console | ConsoleVersion.cs | 3.4.1.0 | 3.4.1.0 Notes The Engine API AssemblyVersion is fixed and will not be changed unless it becomes necessary to modify the API in a non-additive manner. These values will normally already be correct for the release, since they should have been set immediately following the prior release. Update Copyright Year The copyright year in all the source files is only updated as they are changed, but the copyright in the [assembly: AssemblyCopyright(\"...\")] and the copyright text displayed by nunit3-console and nunitlite should be updated to the year of the release. Search for AssemblyCopyright in the solution and update it where needed, then check Program.cs in nunit3-console for default values used when no attribute is found. If necessary, update the year in the general copyright notice LICENSE.txt. Note that these copyright notices refer to each of the packages in their entirety. Each of the .nuspec files in the nuget subdirectory contains a copyright line, which should also be updated. Notices at the top of each source code file are only updated when copyrightable changes are made to the file, not at the time of release. Update Package Versions The package version is updated in the build.cake file. The following lines appear near the beginning of the file. Update the versions and modifiers if necessary. Normally, they will already have been set correctly. var version=\"3.4.1\"; var modifier=\"\" The version variables are three-part version numbers that follow the basic principles of semantic versioning. Since we publish a number of nuget packages, we use the nuget implementation of semantic versioning. For NUnit, the major version is updated only rarely. Normal releases will update the minor version and set the third component to zero. The third component is incremented when \"hot fixes\" are made to a production release or for builds created for a special purpose. For pre-release versions, a non-empty modifier is specified. This is a suffix added to the version. Our standard suffixes are currently -alpha-n, -beta-n and -rc-n The build script adds an additional suffix of -dbg to any packages created using a Debug build. Note The first alpha, beta or rc release may omit the -n. In that case, any following alpha, beta or rc should use -2. Update CHANGES File The CHANGES.txt file in the project root contains all relevant changes for each release. It contains the same information as the release notes in the project documentation, in text format. Because the CHANGES file includes the date of the release, you must know when the release is coming out in order to edit it. Otherwise, it will be necessary to make a final change to the file at the point of making the release. Create new sections in the CHANGES file to match those for prior releases. To ensure that all changes are included, review closed issues in the current and any future milestones. If an issue for a previous milestone was actually completed and closed, move it to the current milestone, since that's where it is being released. Include all issues resolved as closed:done in the issues section of the file. Significant feature additions and changes should be documented, even if they are also listed with issue numbers. Reviewing commits and merged pull requests may help in catching additional changes. You should commit the CHANGES file separately from the version number changes since that commit will be merged back into master while the version changes will not. Update the Documentation The Release Notes section of the documentation site should match the content of the CHANGES.txt file except for any format differences. Note Now that the documentation is being kept in a web site generated by github markdown, it may be possible to use the github markdown text directly in this file for future releases. For any significant changes to how NUnit is used or what it does, the appropriate pages of the documentation should be updated or new pages created. If you do this in advance of the release (which is actually a good idea) you should do it in a way that the new documentation is not visible until the release is actually made. Push All Changes If you made any changes to the files in git as part of the preceding steps. Make sure you have pushed them and they have been reviewed in the PR. Creating the Release Clear the package directory to avoid confusion: erase package\\* This is not absolutely required, but will be helpful if you have other release packages present in the directory. You should be working on the release branch. Do a pull to make sure you have everything up to date. If changes of any significance were merged, you should test again before creating the release. Create the packages by running: build -Target Package Verify that the correct packages have been created in the package sub-directory: NUnit.Console.VERSION.nupkg NUnit.ConsoleRunner.VERSION.nupkg NUnit.Engine.VERSION.nupkg NUnit.Engine.Api.VERSION.nupkg NUnit.Engine.Tool.VERSION.nupkg (Do not release) NUnit.Runners.VERSION.nupkg Testing the Release The degree to which each package needs testing may vary depending on what has been changed. Usually, you should install all the NuGet packages into a test project, verifying that the Archiving the Release Packages are archived on nunit.org in the downloads directory. Create a new sub-folder under downloads/nunit/v3 for the release. Upload all the package files into that directory. Publishing the Release Github Log onto Github and go to the main NUnit repository at https://github.com/nunit/nunit. Select Releases and then click on the \"Draft a new release\" button. Enter a tag to be used for the release. Currently our tags are simply the version of the release, like 3.0.0-alpha-5. If you start typing with '3' you'll get a list of earlier release tags so you can see the format. Select your release branch as the target for the tag. Enter a title for the release, like NUnit 3.0 RC release. If you type 'N' you'll get some hints. Add a description of the release. It will be easier if you have prepared this in advance and can just paste it in. If this is an Alpha or Beta release, check the box that indicates a pre-release. Upload the packages you created earlier either directly from the package directory or from their archive location. Note that we upload all the packages, including those that are also published on NuGet. Click the \"Publish release\" button to publish the release on Github. NuGet Sign on to nuget.org. Select Upload package. Browse to the location of the NUnit.Console.VERSION.nupkg you created and upload it. Verify that the info is correct and click the \"Submit\" button. Repeat steps 2-4 for the other NuGet packages. Do not upload NUnit.Engine.Tool.VERSION.nupkg. Merge into Master Close your release Pull Request Create a new branch off of your release branch Increment the version in the various locations from the even release to the SemVer odd dev release number. For example 3.2 -> 3.3. See the Update Package Versions section above. Push your changes to GitHub Create a pull request from your branch making sure it is based off master Website If changes to the website have been accumulated in a branch, now is the time to merge it and upload the pages to the site. Notify Users Send notifications to the mailing list and twitter. Close the Milestone The milestone representing this release should be closed at this time."
  },
  "articles/developer-info/Packaging-the-Framework.html": {
    "href": "articles/developer-info/Packaging-the-Framework.html",
    "title": "Packaging the Framework | NUnit Docs",
    "summary": "Packaging the Framework This note describes how to create release packages for the NUnit Framework. Currently, all the builds and packaging must be done on a single Windows machine. Software Prerequisites Various software combinations and environments may be used to build NUnit components. The following software is what we have used and tested for building everything and creating the release packages. We'll add options to the list as we find them. Visual Studio 2022 17.10 or newer with the NuGet Package manager. .NET 6.0 SDK .NET 8.0 SDK Preparing for Release Create a Release Branch All work on releases should be done on a branch. On master git switch main, Pull latest git pull Create a branch to prepare the release git switch -c releaseXYZ, where XYZ is the release number, e.g. 4.2.0. Push the branch to GitHub git push -u origin releaseXYZ As you make the changes below, push the changes to GitHub and create a Pull Request targeting the main branch to allow other team members to review your changes. The PR can be created in the web or using the GitHub CLI with gh pr create -a rprouse -B release -t \"Release 3.13\" Make Sure it Works Close all instances of Visual Studio or other IDE to ensure that no changes are left unsaved. Do a clean build and run all the tests on Windows. You may use the command below or three separate commands if preferred. If you encounter errors at any stage, you're not actually ready to release! build --target clean build --target test Repeat the build on a Linux system, if available. If this is not possible, be sure to scrutinize the results from the Linux Github actions build carefully. On Linux, you may use the command build -target=test Review Milestone Status Check the milestone for the current release to see that there are no open issues. Any issues that are not going to be in this release should be moved to a future milestone. This may be the time to create the next milestone. Check all future open milestones for completed issues. Anything that is completed will be included in this release so change its milestone to the current release. Review all closed issues without a milestone. Move them to the current milestone if they were fixed in this release, or set their milestone to Closed without action for questions and issues that were closed without a fix. You can use the following query to find issues that need to be reviewed: is:issue no:milestone is:closed -label:closed:sep -label:closed:notabug -label:is:question -label:closed:wontfix -label:closed:noresponsefromreporter -label:closed:fixedin_newer_version -label:closed_moved_to_discussion -label:closed:duplicate -label:closed:byDesign Update Copyright Year If necessary, update the year in the general copyright notice LICENSE.txt. Note that these copyright notices refer to each of the packages in their entirety. Each of the .nuspec files in the nuget subdirectory contains a copyright line, which should also be updated. Update the version number if needed The version is given using MinVer. If the version number doesn't match you expected XYZ, you update the version number by adding and pushing a tag in main. Note that this tag has to be on the commit that you're releasing. Update Release notes in framework.md To generate the change list in the format required, use the GetChanges console app from NUnit.InternalTools which fetches and prints all issues in the given milestone, e.g. for milestone 4.0: Build a release version of the app, and go to the GetChanges directory. Run the following command, with the appropriate version number and milestone number: bin\\Release\\net7.0\\getchanges.exe -o nunit -r nunit -l -m 4.2 > changes4.2.md The -o and -r options specify the owner and repo, respectively. The -l option includes all links, including those that are closed. The -m option specifies the milestone. If no milestone is specified, the current milestone is used. Note: You might need to manually create the NUnit.IssuePr.XYZ link file. It will be automated in the future. Copy content of the file created to the top of framework.md file in the docs directory. Update the Documentation For any significant changes to how NUnit is used or what it does, the appropriate pages of the documentation should be updated or new pages created. For new features or changes to features, include the version of NUnit that the feature was implemented in. Push All Changes Push all changes to the files in git as part of the preceding steps. Make sure you have pushed them and they have been reviewed in the PR. Then merge the PR to main. Pull down the changes to your local machine. Creating the Release Locally The release should not be built on a developers machine, it should be built by the build servers. The following steps are only for reproducing the steps locally. Clear the package directory (if it exists) to avoid confusion: del package\\* This is not absolutely required, but will be helpful if you have other release packages present in the directory. You should be working on the release branch. Do a pull to make sure you have everything up to date. If changes of any significance were merged, you should test again before creating the release. Ensure that the release build is up to date. If you have any doubt whether the latest code changes have actually been built, do a clean build. If the build is up to date you may skip this step. build --target build Optionally create the image directory manually build --target createimage You do this to ensure that the latest build is used for packaging. If the images directory does not already contain a subdirectory named for this release (package version and suffix) you may skip this step as a new one will be created automatically. Create the packages by running: build --target package Verify that the correct packages have been created in the package sub-directory: NUnit-VERSION.zip NUnit.VERSION.nupkg NUnit.VERSION.snupkg NUnitLite.VERSION.nupkg NUnitLite.VERSION.snupkg Testing the Release The degree to which each package needs testing may vary depending on what has been changed. At a minimum, Ensure the NUnit Framework CI build succeeds on all platforms and that the tests passed. Download Package.zip from the build and extract it locally, or use the ones you built locally. Five files should be extracted, NUnit.{version}.nupkg, NUnit.{version}.snupkg, NunitLite.{version}.nupkg, NunitLite.{version}.snupkg and NUnit.Framework-{version}.zip. In Visual Studio, create a test project and add your local directory as a package source. Install the packages and verify that they apply to the project correctly. Run unit tests for platforms or features that have changed in the release. Publishing the Release Github Log onto Github and go to the main NUnit repository at https://github.com/nunit/nunit. Select Releases and then click on the \"Draft a new release\" button. Enter a tag to be used for the release. Currently our tags are simply the version of the release, like 4.2.0. Don't add a v prefix to the tag. MinVer is set up to be used without the prefix. Note that the tag already exists, as you created it when you pushed the commit, or after that push. Enter a title for the release, like NUnit 3.13. If you type 'N' you'll get some hints. Use the preamble from the release notes for the description and add a link to the full release notes on the docs website. If this is an Alpha or Beta release, check the box that indicates a pre-release. Upload the five files from Package folder that you downloaded or built locally. Note that we upload all the packages, including those that are also published on NuGet. Click the \"Publish release\" button to publish the release on Github. NuGet Sign on to nuget.org. Select Upload package. Browse to the location of the NUnit.VERSION.nupkg you created and upload it. Verify that the info is correct and click the \"Submit\" button. Repeat steps 2-4 for NUnitLite.VERSION.nupkg and the two snupkg files. Website Create a PR to update the NUnit.org website with the release. Use the _posts folder and add a new one there. Notify Users Send notifications to twitter, both for NUnit and for your own, add to your LinkedIn and any other relevant SosMed channels you have. Close the Milestone The milestone representing this release should be closed at this time."
  },
  "articles/developer-info/Packaging-the-Installer.html": {
    "href": "articles/developer-info/Packaging-the-Installer.html",
    "title": "Packaging the Installer | NUnit Docs",
    "summary": "Packaging the Installer Before packaging the installer, you must first package and release the Console and Engine. See Packaging the Console and Engine Prepare the Release Get latest from master Update CHANGES.TXT. Set the date of the release, and list any packages which have been upgraded since the last release. Check the version and displayVersion in build.cake. They should have been updated at the last release. Package the release, .\\build.ps1 or .\\build.cmd Check the distribution directory for NUnit.{VERSION}.msi and NUnit.{VERSION}.zip Test the Release Test the Installer Install NUnit.{VERSION}.msi Ensure it installs correctly Check that the extensions included in build.cake are installed Run unit tests using the install Ensure the extensions work by running NUnit 2 tests and by creating NUnit 2 test results Check the version in the nunit3-console.exe output headers when running tests. Test the ZIP File Unzip NUnit.{VERSION}.zip Check that the extensions included in build.cake are installed Run unit tests using the install Ensure the extensions work by running NUnit 2 tests and by creating NUnit 2 test results Check the version in the nunit3-console.exe output headers when running tests. Archiving the Release Packages are archived on nunit.org in the downloads directory. Add the MSI and ZIP to the existing downloads/nunit/v3 for the Console/Engine release. Publishing the Release Log onto Github and go to the main nunit-console repository at https://github.com/nunit/nunit-console. Go to the releases tab and edit the existing Console release Add the MSI and ZIP files to the release Update the website if required Tag the Release Still on master, tag the release with the version, git tag v3.5 Push the tags to GitHub, git push --tags Increment the Version Create a release branch git checkout -b release-3.5 Increment the version and displayVersion in build.cake. Check-in your changes and push to GitHub Create a Pull Request, have it reviewed, merged and delete the branch Close the milestone if one exists Note The release branch in this project is not like the release branches in other projects, we don't save it. If we need to go back and do hotfixes, we will branch off the tag that was created for the release. We do this because there are usually no changes required to this repository for a release except incrementing the version post release. Any larger changes to this repository should be done and tested prior to a release using the normal Pull Request workflow"
  },
  "articles/developer-info/Packaging-the-V2-Adapter.html": {
    "href": "articles/developer-info/Packaging-the-V2-Adapter.html",
    "title": "Packaging the V2 Adapter | NUnit Docs",
    "summary": "Packaging the V2 Adapter Introduction There are two purposes for building the adapter, one is for creating the packages for a release - which is what this page is about, the other is for creating whatever you need for debugging or testing purposes. The procedure described here is for those people who need to release a new version of the adapter. Preparing the source code Versioning The version numbers follow the basic principles of semantic versioning. (The fourth number is used for debug versions under development, and will always be 0 for release versions.) The version numbers have to be edited in the following files, and should match: File Change AssemblyInfo.cs, found in the NUnitTestAdapter project change both file and assembly version number source.extensions.vsixmanifest, found under the NUnitTestAdapterInstall project change Version tag nunit-vs-adapter.build, found under the Solution Items folder. change the version number, but only use the two first digits. license.rtf, found under the NUNitTestAdapterInstall project. If the major/minor number has changed, update that here, 2nd line. If year is changed, update copyright years accordingly. Build Build a release version, AnyCPU. Packaging Use NAnt and use the package target NAnt package Run this from the solution root folder The resulting files can be found in the \"package\" folder: NUnitVisualStudioTestAdapter-[VERSION].vsix This is the extension for Visual Studio, which is uploaded to the Visual Studio Gallery. NUnitVisualStudioTestAdapter-[VERSION].zip This is a zipped package for use with TFS Server Builds when you don't use the NuGet package in your solution. See [this blog] for more information. NUnitVisualStudioTestAdapter-[VERSION].nupkg This is the NuGet package, which is uploaded to NuGet for the adapter NUnitVisualStudioTestAdapterAndFramework-[VERSION].nupkg This is a NuGet package which includes the NUnit 2.6.3 framework, uploaded to NuGet for the adapter with framework Publishing the Release Create a release on GitHub. Few people use this directly, but it is the benchmark release and provides an archive of all past releases, so we do this first. Github will automatically create zip and tar files containing the source. In addition, upload all four packages created above as a part of the release. Upload the vsix package to the Visual Studio Gallery using the NUnitDeveloper account. If you don't have access to that account, ask one of the committers with access to do the upload for you. Upload the two NuGet packages to nuget.org. You use your own account for this but you must have been pre-authorized in order for it to work. If you are not authorized, ask a committer with access to do it for you. Update the documentation pages in this web site as needed. In order to do this quickly after publishing the packages, you may want to clone the nunit/docs repository and prepare a pull request in advance. Update the website as needed. The website is maintained in the nunit.org repository to which all committers have access. You should create a branch like 'release-n.n' and make the necessary changes there. There are three vsAdapterXxxxx files that will probably require updating. Add an announcement to the home page and remove any announcement for an older version of the adapter.Create a pull request to merge your changes into the master branch. For rapid publication, you should create the PR and have it reviewed in advance, performing the merge after the packages are published. Publicize the release, first announcing it on the nunit-developer and nunit-discuss lists and then more widely as appropriate. [We should develop a list of places.] Notes Publishing the release requires access to various online accounts, which are mentioned above. For obvious reasons, the passwords are not provided. Contact Charlie or Terje if you need this access. The website and docs site contain duplicate information at this time. In future, the duplication will be eliminated. When a change is merged into the nunit.org master branch, one of the project leaders uploads it manually to the web site. This will be automated in the future. Prerequisites Visual Studio 2013 You need Visual Studio 2013. We use the ultimate edition, but it should be enough with the premium edition. (I will probably work with both the Pro or the Express editions too, but we haven't tried them). The latest 1.1 version is built using Update 2 RC. Visual Studio 2013 SDK You need this to work with the vsix. Download from https://www.microsoft.com/en-us/download/details.aspx?id=40758 NAnt Download from http://nant.sourceforge.net/. We use the 0.92 version. NuGet You need the nuget.exe in your path. Download the exe from http://nuget.codeplex.com/downloads/get/784779. We use the 2.8 version VS2012 TestPlatform object model You need to have this around, the adapter and the test project refer to this. The easiest way to get it, is to have VS2012 installed and get it from there. It is located at a location similar to \"C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\Common7\\IDE\\CommonExtensions\\Microsoft\\TestWindow\" and is named Microsoft.VisualStudio.TestPlatform.ObjectModel.dll You might need to fix up these references if the locations doesn't match what has been used. Github Close the Milestone Draft and publish a Release, named like \"Version 2.0\". Add all the binaries to the same release. Tag the release like V2.0 Documentation The adapter release notes should be updated. The file is named vsTestAdapterReleaseNotes.html, and is found under Docs/2.6.4 in the nunit.org repository, branch \"vs-adapter-2.0\" Also check that the files vsTestAdapterLicense.html and vsTestAdapterReleaseNotes.html is up to date."
  },
  "articles/developer-info/Packaging-the-V3-Adapter.html": {
    "href": "articles/developer-info/Packaging-the-V3-Adapter.html",
    "title": "",
    "summary": ""
  },
  "articles/developer-info/Packaging-the-V3-and-V4-Adapter.html": {
    "href": "articles/developer-info/Packaging-the-V3-and-V4-Adapter.html",
    "title": "Packaging the V3/V4 Adapter | NUnit Docs",
    "summary": "Packaging the V3/V4 Adapter Introduction There are two purposes for building the adapter, one is for creating the packages for a release - which is what this page is about, the other is for creating whatever you need for debugging or testing purposes. For the latter, see [How to build and debug the adapter] The procedure described here is for those people who need to release a new version of the adapter. Preparing the source code Update to the latest version of NUnit This may not be necessary for all releases. However, if the NUnit version used by the adapter is being updated, it is important to do it correctly. The NUnit3TestAdapter, NUnit3TestAdapterInstall and NUnit3TestAdapterTests projects should all reference the same versions of the NUnit Engine package, normally the most recent. The NUnit3TestAdapterTests and NUnitTestDemo projects should reference the same version of the NUnit framework package, also normally the most recent. Note that this is currently the same version as the engine package, but this may not continue to be the case if the frequency of release of the two packages differs. Assembly References At this time, after upgrading the NUnit engine package, you have to manually adjust the references, removing several that are added automatically by the package and adding an Alias. We will try to eliminate this manual step in the future. For each of the NUnit3TestAdapter, NUnit3TestAdapterTests and NUnit3TestAdapterInstall projects, remove references to nunit-agent and nunit-agent-x86, leaving only the four Mono.Cecil references, nunit.engine and nunit.engine.api. For the NUnit3TestAdapter project, modify the properties for nunit-engine by entering \"ENG\" for Aliases. Versioning The version numbers follow the basic principles of [semantic versioning]. (The fourth number is used for debug versions under development, and will always be 0 for release versions.) The version numbers have to be edited in the following files, and should match: File Change AssemblyInfo.cs, found in the NUnitTestAdapter project change both file and assembly version number appveyor.yml, found under the Solution Items folder. change the version number, but only use the three first digits. build.cake, found under the Solution Items folder. change the version number, but only use the three first digits. Build Use the build command to build and test a release version. build -t Test build -t Acceptance Packaging Use the build command to create packages build -t Package Run this from the solution root folder The resulting files can be found in the \"package\" folder: NUnit3TestAdapter-[VERSION].zip This is a zipped package for use with TFS Server Builds when you don't use the NuGet package in your solution. See [this blog] for more information. NUnit3TestAdapter.[VERSION].nupkg This is the NuGet package, which is uploaded to [NuGet for the adapter] Testing the Packages Test the NuGet package on the latest Visual Studio, but if you have earlier versions it is recommended to test on those too, down to VS 2012. Publishing the Release Create a release on GitHub. Few people use this directly, but it is the benchmark release and provides an archive of all past releases, so we do this first. Github will automatically create zip and tar files containing the source. In addition, upload all three packages created above as a part of the release. Upload the NuGet package to nuget.org. You use your own account for this but you must have been pre-authorized in order for it to work. If you are not authorized, ask a committer with access to do it for you. Update the documentation pages in the site as needed. Be sure to update the Release Notes page. In order to perform the update quickly after publishing the packages, you may want to clone the nunit/docs repository and prepare the pull request in advance. Publicize the release, first announcing it on the nunit-developer and nunit-discuss lists and then more widely as appropriate. [We should develop a list of places.] Note Publishing the release requires access to various online accounts, which are mentioned above. For obvious reasons, the passwords are not provided. Contact Charlie or Terje if you need this access. Prerequisites Visual Studio Visual Studio 2022 is required in order to build and develop the adapter. .Net SDKs You need at least the .Net Core 3.1, .net 5, 6 and 7 SDKs installed. Not all are required for the build, but they are required for the tests. You also need .Net Framework 4.6.2 installed. Links NuGet for the adapter Other GitHub Repositories That Need to be Updated .Net test templates You should raise PR in the dotnet test template repo to update the test templates to use the latest version of the adapter. See this PR for an example. Right now (March 2023), Microsoft doesn't accept more PRs to the repo."
  },
  "articles/developer-info/Team-Practices.html": {
    "href": "articles/developer-info/Team-Practices.html",
    "title": "Team Practices | NUnit Docs",
    "summary": "Team Practices How We Work As a Team Issue Tracking How we track bugs, enhancements and features on GitHub. Contributions Explains how to review and merge code submitted by other developers. Technical Practices Building and testing See BUILDING.md in each repository. Coding Standards Describes coding standards used in NUnit. Best practices for XML documentation Guidelines to consider when dealing with public APIs. Packaging the Framework How to create the packages for a new NUnit Framework release. Packaging the Console and Engine How to create the packages for a new NUnit Console and Engine release. Packaging Extensions How to create the packages and release NUnit Extensions. Packaging the Installer How to create and release the NUnit MSI Installer. Packaging the V2 Adapter How to create the packages for a new NUnit 2 VS Adapter release. Packaging the V3 Adapter How to create the packages for a new NUnit 3 VS Adapter release."
  },
  "articles/developer-info/The-Teams.html": {
    "href": "articles/developer-info/The-Teams.html",
    "title": "The Teams in the NUnit Project | NUnit Docs",
    "summary": "The Teams in the NUnit Project The NUnit project is made up of several teams, each with its own focus and responsibilities, and with a set of team members. The team members are a bunch of dedicated people from all over the globe, who are passionate about NUnit and want to make it better. They are all volunteers, and they do this in their spare time. The current teams Core Team This team has overall responsibility for the NUnit organization. It defines the vision for NUnit, decides what projects should be included, appoints leads for other teams and maintainers for projects, sets standards and ensures we follow them. Team Lead: Terje Sandstrom Framework Team This team maintains the NUnit framework, which is the assembly referenced by user tests, as well as NUnitLite. Team Lead: Rob Prouse Engine Team The Engine Team maintains the NUnit3-Console runner, the Engine, and a number of extensions. Team Lead: Charlie Poole VS Extensions Team NUnit's extensions to the Visual Studio IDE and dotnet. Team Lead: Terje Sandstrom Analyzer Team The team that works on the NUnit Analyzers Project. Team Lead: Mikkel Nylander Bundgaard Documentation Team The team that works on the documentation for NUnit. Team Lead: Sean Killeen Membership matrix Current team memberships, listed in a kind of chronological order Name Core Team Framework Engine VS Extensions Analyzer Documentation Charlie Poole \uD83C\uDDFA\uD83C\uDDF8 ✔️ ✔️ Rob Prouse \uD83C\uDDE8\uD83C\uDDE6 ✔️ ✔️ ✔️ ✔️ Terje Sandstrom \uD83C\uDDF3\uD83C\uDDF4 ✔️ ✔️ ✔️ ✔️ Joseph Musser \uD83C\uDDFA\uD83C\uDDF8 ✔️ ✔️ ✔️ ✔️ Mikkel Nylander Bundgaard \uD83C\uDDE9\uD83C\uDDF0 ✔️ ✔️ ✔️ ✔️ Sean Killeen \uD83C\uDDFA\uD83C\uDDF8 ✔️ ✔️ ✔️ Steven Weerdenburg \uD83C\uDDE8\uD83C\uDDE6 ✔️ ✔️ Ihor Sychevskyi \uD83C\uDDFA\uD83C\uDDE6 ✔️ Manfred Brands \uD83C\uDDE6\uD83C\uDDFA ✔️ ✔️ ✔️ Simon Cropp \uD83C\uDDE6\uD83C\uDDFA ✔️ Former members and honorable mentions (and there are multiple more, we'll add them as we find them) Chris Maddock \uD83C\uDDEC\uD83C\uDDE7"
  },
  "articles/legacy/index.html": {
    "href": "articles/legacy/index.html",
    "title": "Legacy (NUnit V2) Documentation | NUnit Docs",
    "summary": "Legacy (NUnit V2) Documentation NUnit 2.6.4 NUnit 2.6.3 NUnit 2.6.2 NUnit 2.6.1 NUnit 2.6 NUnit 2.5.10 NUnit 2.5.9 NUnit 2.5.8 NUnit 2.5.7 NUnit 2.5.6 NUnit 2.5.5 NUnit 2.5.4 NUnit 2.5.3 NUnit 2.5.2 NUnit 2.5.1 NUnit 2.5 NUnit 2.4.8 NUnit 2.4.7 NUnit 2.4.6 NUnit 2.4.5 NUnit 2.4.4 NUnit 2.4.3 NUnit 2.4.2 NUnit 2.4.1 NUnit 2.4 NUnit 2.2.10 NUnit 2.2.9 NUnit 2.2.8 NUnit 2.2.7 NUnit 2.2.6 NUnit 2.2.5 NUnit 2.2.4 NUnit 2.2.3 NUnit 2.2.2 NUnit 2.2.1 NUnit 2.2"
  },
  "articles/nunit-analyzers/NUnit-Analyzers.html": {
    "href": "articles/nunit-analyzers/NUnit-Analyzers.html",
    "title": "Overview of implemented NUnit diagnostics and code fixes | NUnit Docs",
    "summary": "Overview of implemented NUnit diagnostics and code fixes In the tables below we use the following symbols: \uD83D\uDD0D - whether the diagnostic is enabled by default or not \uD83D\uDCDD - the severity of the diagnostic \uD83D\uDCA1 - whether the diagnostic has an associated code fix or not The severity of a diagnostic can the one of the following (in increasing severity): \uD83D\uDCAD - indicates a severity of Hidden ℹ️ - indicates a severity of Info ⚠️ - indicates a severity of Warning ❗ - indicates a severity of Error Structure Rules (NUnit1001 - ) Rules which enforce structural requirements on the test code. Id Title \uD83D\uDD0D \uD83D\uDCDD \uD83D\uDCA1 NUnit1001 The individual arguments provided by a TestCaseAttribute must match the type of the corresponding parameter of the method ✅ ❗ ❌ NUnit1002 The TestCaseSource should use nameof operator to specify target ✅ ⚠️ ✅ NUnit1003 The TestCaseAttribute provided too few arguments ✅ ❗ ❌ NUnit1004 The TestCaseAttribute provided too many arguments ✅ ❗ ❌ NUnit1005 The type of the value specified via ExpectedResult must match the return type of the method ✅ ❗ ❌ NUnit1006 ExpectedResult must not be specified when the method returns void ✅ ❗ ❌ NUnit1007 The method has non-void return type, but no result is expected in ExpectedResult ✅ ❗ ❌ NUnit1008 Specifying ParallelScope.Self on assembly level has no effect ✅ ⚠️ ❌ NUnit1009 One may not specify ParallelScope.Children on a non-parameterized test method ✅ ❗ ❌ NUnit1010 One may not specify ParallelScope.Fixtures on a test method ✅ ❗ ❌ NUnit1011 The TestCaseSource argument does not specify an existing member ✅ ❗ ❌ NUnit1012 The async test method must have a non-void return type ✅ ❗ ❌ NUnit1013 The async test method must have a non-generic Task return type when no result is expected ✅ ❗ ❌ NUnit1014 The async test method must have a Task<T> return type when a result is expected ✅ ❗ ❌ NUnit1015 The source type does not implement I(Async)Enumerable ✅ ❗ ❌ NUnit1016 The source type does not have a default constructor ✅ ❗ ❌ NUnit1017 The specified source is not static ✅ ❗ ❌ NUnit1018 The number of parameters provided by the TestCaseSource does not match the number of parameters in the target method ✅ ❗ ❌ NUnit1019 The source specified by the TestCaseSource does not return an I(Async)Enumerable or a type that implements I(Async)Enumerable ✅ ❗ ❌ NUnit1020 The TestCaseSource provides parameters to a source - field or property - that expects no parameters ✅ ❗ ❌ NUnit1021 The ValueSource should use nameof operator to specify target ✅ ⚠️ ✅ NUnit1022 The specified source is not static ✅ ❗ ❌ NUnit1023 The target method expects parameters which cannot be supplied by the ValueSource ✅ ❗ ❌ NUnit1024 The source specified by the ValueSource does not return an I(Async)Enumerable or a type that implements I(Async)Enumerable ✅ ❗ ❌ NUnit1025 The ValueSource argument does not specify an existing member ✅ ❗ ❌ NUnit1026 The test or setup/teardown method is not public ✅ ❗ ✅ NUnit1027 The test method has parameters, but no arguments are supplied by attributes ✅ ❗ ❌ NUnit1028 The non-test method is public ✅ ℹ️ ✅ NUnit1029 The number of parameters provided by the TestCaseSource does not match the number of parameters in the Test method ✅ ❗ ❌ NUnit1030 The type of parameter provided by the TestCaseSource does not match the type of the parameter in the Test method ✅ ❗ ❌ NUnit1031 The individual arguments provided by a ValuesAttribute must match the type of the corresponding parameter of the method ✅ ❗ ❌ NUnit1032 An IDisposable field/property should be Disposed in a TearDown method ✅ ❗ ❌ NUnit1033 The Write methods on TestContext will be marked as Obsolete and eventually removed ✅ ⚠️ ✅ NUnit1034 Base TestFixtures should be abstract ✅ ⚠️ ✅ NUnit1035 The 'step' parameter to Range cannot be zero ✅ ❗ ❌ NUnit1036 The value for 'from' must be less than 'to' when 'step' is positive ✅ ❗ ❌ NUnit1037 The value for 'from' must be greater than 'to' when 'step' is negative ✅ ❗ ❌ NUnit1038 The type of the attribute values doesn't match the parameter type ✅ ❗ ❌ Assertion Rules (NUnit2001 - ) Rules which improve assertions in the test code. Id Title \uD83D\uDD0D \uD83D\uDCDD \uD83D\uDCA1 NUnit2001 Consider using Assert.That(expr, Is.False) instead of ClassicAssert.False(expr) ✅ ℹ️ ✅ NUnit2002 Consider using Assert.That(expr, Is.False) instead of ClassicAssert.IsFalse(expr) ✅ ℹ️ ✅ NUnit2003 Consider using Assert.That(expr, Is.True) instead of ClassicAssert.IsTrue(expr) ✅ ℹ️ ✅ NUnit2004 Consider using Assert.That(expr, Is.True) instead of ClassicAssert.True(expr) ✅ ℹ️ ✅ NUnit2005 Consider using Assert.That(actual, Is.EqualTo(expected)) instead of ClassicAssert.AreEqual(expected, actual) ✅ ⚠️ ✅ NUnit2006 Consider using Assert.That(actual, Is.Not.EqualTo(expected)) instead of ClassicAssert.AreNotEqual(expected, actual) ✅ ⚠️ ✅ NUnit2007 The actual value should not be a constant ✅ ⚠️ ✅ NUnit2008 Incorrect IgnoreCase usage ✅ ⚠️ ❌ NUnit2009 The same value has been provided as both the actual and the expected argument ✅ ⚠️ ❌ NUnit2010 Use EqualConstraint for better assertion messages in case of failure ✅ ℹ️ ✅ NUnit2011 Use ContainsConstraint for better assertion messages in case of failure ✅ ℹ️ ✅ NUnit2012 Use StartsWithConstraint for better assertion messages in case of failure ✅ ℹ️ ✅ NUnit2013 Use EndsWithConstraint for better assertion messages in case of failure ✅ ℹ️ ✅ NUnit2014 Use SomeItemsConstraint for better assertion messages in case of failure ✅ ℹ️ ✅ NUnit2015 Consider using Assert.That(actual, Is.SameAs(expected)) instead of ClassicAssert.AreSame(expected, actual) ✅ ⚠️ ✅ NUnit2016 Consider using Assert.That(expr, Is.Null) instead of ClassicAssert.Null(expr) ✅ ℹ️ ✅ NUnit2017 Consider using Assert.That(expr, Is.Null) instead of ClassicAssert.IsNull(expr) ✅ ℹ️ ✅ NUnit2018 Consider using Assert.That(expr, Is.Not.Null) instead of ClassicAssert.NotNull(expr) ✅ ℹ️ ✅ NUnit2019 Consider using Assert.That(expr, Is.Not.Null) instead of ClassicAssert.IsNotNull(expr) ✅ ℹ️ ✅ NUnit2020 Incompatible types for SameAs constraint ✅ ❗ ❌ NUnit2021 Incompatible types for EqualTo constraint ✅ ❗ ❌ NUnit2022 Missing property required for constraint ✅ ❗ ✅ NUnit2023 Invalid NullConstraint usage ✅ ❗ ❌ NUnit2024 Wrong actual type used with String Constraint ✅ ❗ ❌ NUnit2025 Wrong actual type used with ContainsConstraint ❌ \uD83D\uDCAD ❌ NUnit2026 Wrong actual type used with the SomeItemsConstraint with EqualConstraint ✅ ❗ ❌ NUnit2027 Consider using Assert.That(actual, Is.GreaterThan(expected)) instead of ClassicAssert.Greater(actual, expected) ✅ ℹ️ ✅ NUnit2028 Consider using Assert.That(actual, Is.GreaterThanOrEqualTo(expected)) instead of ClassicAssert.GreaterOrEqual(actual, expected) ✅ ℹ️ ✅ NUnit2029 Consider using Assert.That(actual, Is.LessThan(expected)) instead of ClassicAssert.Less(actual, expected) ✅ ℹ️ ✅ NUnit2030 Consider using Assert.That(actual, Is.LessThanOrEqualTo(expected)) instead of ClassicAssert.LessOrEqual(actual, expected) ✅ ℹ️ ✅ NUnit2031 Consider using Assert.That(actual, Is.Not.SameAs(expected)) instead of ClassicAssert.AreNotSame(expected, actual) ✅ ⚠️ ✅ NUnit2032 Consider using Assert.That(expr, Is.Zero) instead of ClassicAssert.Zero(expr) ✅ ℹ️ ✅ NUnit2033 Consider using Assert.That(expr, Is.Not.Zero) instead of ClassicAssert.NotZero(expr) ✅ ℹ️ ✅ NUnit2034 Consider using Assert.That(expr, Is.NaN) instead of ClassicAssert.IsNaN(expr) ✅ ℹ️ ✅ NUnit2035 Consider using Assert.That(collection, Is.Empty) instead of ClassicAssert.IsEmpty(collection) ✅ ℹ️ ✅ NUnit2036 Consider using Assert.That(collection, Is.Not.Empty) instead of ClassicAssert.IsNotEmpty(collection) ✅ ℹ️ ✅ NUnit2037 Consider using Assert.That(collection, Does.Contain(instance)) instead of ClassicAssert.Contains(instance, collection) ✅ ℹ️ ✅ NUnit2038 Consider using Assert.That(actual, Is.InstanceOf(expected)) instead of ClassicAssert.IsInstanceOf(expected, actual) ✅ ℹ️ ✅ NUnit2039 Consider using Assert.That(actual, Is.Not.InstanceOf(expected)) instead of ClassicAssert.IsNotInstanceOf(expected, actual) ✅ ℹ️ ✅ NUnit2040 Non-reference types for SameAs constraint ✅ ❗ ✅ NUnit2041 Incompatible types for comparison constraint ✅ ❗ ❌ NUnit2042 Comparison constraint on object ✅ ℹ️ ❌ NUnit2043 Use ComparisonConstraint for better assertion messages in case of failure ✅ ℹ️ ✅ NUnit2044 Non-delegate actual parameter ✅ ❗ ✅ NUnit2045 Use Assert.EnterMultipleScope or Assert.Multiple ✅ ℹ️ ✅ NUnit2046 Use CollectionConstraint for better assertion messages in case of failure ✅ ℹ️ ✅ NUnit2047 Incompatible types for Within constraint ✅ ⚠️ ✅ NUnit2048 Consider using Assert.That(...) instead of StringAssert(...) ✅ ⚠️ ✅ NUnit2049 Consider using Assert.That(...) instead of CollectionAssert(...) ✅ ⚠️ ✅ NUnit2050 NUnit 4 no longer supports string.Format specification ✅ ❗ ✅ NUnit2051 Consider using Assert.That(expr, Is.Positive) instead of ClassicAssert.Positive(expr) ✅ ℹ️ ✅ NUnit2052 Consider using Assert.That(expr, Is.Negative) instead of ClassicAssert.Negative(expr) ✅ ℹ️ ✅ NUnit2053 Consider using Assert.That(actual, Is.AssignableFrom(expected)) instead of ClassicAssert.IsAssignableFrom(expected, actual) ✅ ℹ️ ✅ NUnit2054 Consider using Assert.That(actual, Is.Not.AssignableFrom(expected)) instead of ClassicAssert.IsNotAssignableFrom(expected, actual) ✅ ℹ️ ✅ NUnit2055 Consider using Is.InstanceOf<T> constraint instead of an 'is T' expression ✅ ℹ️ ✅ NUnit2056 Consider using Assert.EnterMultipleScope statement instead of Assert.Multiple/Assert.MultipleAsync ✅ ℹ️ ✅ Suppressor Rules (NUnit3001 - ) Rules which suppress compiler errors based on context. Note that these rules are only available in the .NET Standard 2.0 builds (version 3.0.0 and above) which require Visual Studio 2019 (version 16.3) or newer. Id Title \uD83D\uDD0D \uD83D\uDCDD \uD83D\uDCA1 NUnit3001 Expression was checked in an ClassicAssert.NotNull, ClassicAssert.IsNotNull or Assert.That call ✅ ℹ️ ❌ NUnit3002 Field/Property is initialized in SetUp or OneTimeSetUp method ✅ ℹ️ ❌ NUnit3003 Class is an NUnit TestFixture and is instantiated using reflection ✅ ℹ️ ❌ NUnit3004 Field should be Disposed in TearDown or OneTimeTearDown method ✅ ℹ️ ❌ Style Rules (NUnit4001 - ) Rules which help you write concise and readable NUnit test code. Id Title \uD83D\uDD0D \uD83D\uDCDD \uD83D\uDCA1 NUnit4001 Simplify the Values attribute ✅ ℹ️ ✅ NUnit4002 Use Specific constraint ✅ ℹ️ ✅"
  },
  "articles/nunit-analyzers/NUnit1001.html": {
    "href": "articles/nunit-analyzers/NUnit1001.html",
    "title": "NUnit1001 | NUnit Docs",
    "summary": "NUnit1001 The individual arguments provided by a TestCaseAttribute must match the type of the corresponding parameter of the method Topic Value Id NUnit1001 Severity Error Enabled True Category Structure Code TestCaseUsageAnalyzer Description The individual arguments provided by a TestCaseAttribute must match the type of the corresponding parameter of the method. Motivation To prevent tests that will fail at runtime due to improper construction. How to fix violations Example Violation [TestCase(true)] public void SampleTest(int numberValue) { Assert.That(numberValue, Is.EqualTo(1)); } [TestCase<double>(42)] public void SampleTest(int numberValue) { Assert.That(numberValue, Is.EqualTo(1)); } Problem In the test case above, true in the test case indicates that numberValue should be a boolean. However, the test declares that numberValue is an integer. This will lead to a runtime failure. Fix Ensure that the type of the test case and the input matches. So, this fix would be acceptable: // TestCase input and parameter are both of type bool [TestCase(true)] public void SampleTest(bool booleanValue) { Assert.That(booleanValue, Is.True); } And this would also work: // TestCase input and parameter are both of type int [TestCase(1)] public void SampleTest(int numberValue) { Assert.That(numberValue, Is.EqualTo(1)); } Configure severity Via ruleset file Configure the severity per project, for more info see MSDN. Via .editorconfig file # NUnit1001: The individual arguments provided by a TestCaseAttribute must match the type of the corresponding parameter of the method dotnet_diagnostic.NUnit1001.severity = chosenSeverity where chosenSeverity can be one of none, silent, suggestion, warning, or error. Via #pragma directive #pragma warning disable NUnit1001 // The individual arguments provided by a TestCaseAttribute must match the type of the corresponding parameter of the method Code violating the rule here #pragma warning restore NUnit1001 // The individual arguments provided by a TestCaseAttribute must match the type of the corresponding parameter of the method Or put this at the top of the file to disable all instances. #pragma warning disable NUnit1001 // The individual arguments provided by a TestCaseAttribute must match the type of the corresponding parameter of the method Via attribute [SuppressMessage] [System.Diagnostics.CodeAnalysis.SuppressMessage(\"Structure\", \"NUnit1001:The individual arguments provided by a TestCaseAttribute must match the type of the corresponding parameter of the method\", Justification = \"Reason...\")]"
  },
  "articles/nunit-analyzers/NUnit1002.html": {
    "href": "articles/nunit-analyzers/NUnit1002.html",
    "title": "NUnit1002 | NUnit Docs",
    "summary": "NUnit1002 The TestCaseSource should use nameof operator to specify target Topic Value Id NUnit1002 Severity Warning Enabled True Category Structure Code TestCaseSourceUsesStringAnalyzer Description The TestCaseSource should use nameof operator to specify target. Motivation Prevent test rot by ensuring that future renames don't accidentally break tests in an unexpected way. nameof adds some compile-time support in these situations. How to fix violations Example Violation [TestCaseSource(\"MyTestSource\")] public void SampleTest(string stringValue) { Assert.That(stringValue.Length, Is.EqualTo(3)); } public static object[] MyTestSource() { return new object[] {\"One\", \"Two\"}; } Problem In this case, we're referring to \"MyTestSource\" as a string directly. This is brittle; should the name of the property change, the test case source would become invalid, and we would not know this until executing tests. Fix The fix is to use the C# nameof operator, which produces a string but references the field name. This way, when refactoring and changing the name of your test source, it would also update the name within the nameof() operator. The fix in action: [TestCaseSource(nameof(MyTestSource))] // using nameof public void SampleTest(string stringValue) { Assert.That(stringValue.Length, Is.EqualTo(3)); } public static object[] MyTestSource() { return new object[] {\"One\", \"Two\"}; } Configure severity Via ruleset file Configure the severity per project, for more info see MSDN. Via .editorconfig file # NUnit1002: The TestCaseSource should use nameof operator to specify target dotnet_diagnostic.NUnit1002.severity = chosenSeverity where chosenSeverity can be one of none, silent, suggestion, warning, or error. Via #pragma directive #pragma warning disable NUnit1002 // The TestCaseSource should use nameof operator to specify target Code violating the rule here #pragma warning restore NUnit1002 // The TestCaseSource should use nameof operator to specify target Or put this at the top of the file to disable all instances. #pragma warning disable NUnit1002 // The TestCaseSource should use nameof operator to specify target Via attribute [SuppressMessage] [System.Diagnostics.CodeAnalysis.SuppressMessage(\"Structure\", \"NUnit1002:The TestCaseSource should use nameof operator to specify target\", Justification = \"Reason...\")]"
  },
  "articles/nunit-analyzers/NUnit1003.html": {
    "href": "articles/nunit-analyzers/NUnit1003.html",
    "title": "NUnit1003 | NUnit Docs",
    "summary": "NUnit1003 The TestCaseAttribute provided too few arguments Topic Value Id NUnit1003 Severity Error Enabled True Category Structure Code TestCaseUsageAnalyzer Description The number of arguments provided by a TestCaseAttribute must match the number of parameters of the method. Motivation To prevent tests that will fail at runtime due to improper construction. How to fix violations Example Violation [TestCase(\"1\")] public void NUnit1003SampleTest(string parameter1, string parameter2) { Assert.That(parameter1, Is.EqualTo(\"1\")); Assert.That(parameter2, Is.EqualTo(\"2\")); } Explanation In the sample above, the test expects two parameters ((string parameter1, string parameter2)), but only one argument is supplied by the test case (TestCase(\"1\")). Fix Either add the additional argument: [TestCase(\"1\", \"2\")] public void NUnit1003SampleTest(string parameter1, string parameter2) { Assert.That(parameter1, Is.EqualTo(\"1\")); Assert.That(parameter2, Is.EqualTo(\"2\")); } Or remove the use of that parameter: [TestCase(\"1\")] public void NUnit1003SampleTest(string parameter1) { Assert.That(parameter1, Is.EqualTo(\"1\")); } Configure severity Via ruleset file Configure the severity per project, for more info see MSDN. Via .editorconfig file # NUnit1003: The TestCaseAttribute provided too few arguments dotnet_diagnostic.NUnit1003.severity = chosenSeverity where chosenSeverity can be one of none, silent, suggestion, warning, or error. Via #pragma directive #pragma warning disable NUnit1003 // The TestCaseAttribute provided too few arguments Code violating the rule here #pragma warning restore NUnit1003 // The TestCaseAttribute provided too few arguments Or put this at the top of the file to disable all instances. #pragma warning disable NUnit1003 // The TestCaseAttribute provided too few arguments Via attribute [SuppressMessage] [System.Diagnostics.CodeAnalysis.SuppressMessage(\"Structure\", \"NUnit1003:The TestCaseAttribute provided too few arguments\", Justification = \"Reason...\")]"
  },
  "articles/nunit-analyzers/NUnit1004.html": {
    "href": "articles/nunit-analyzers/NUnit1004.html",
    "title": "NUnit1004 | NUnit Docs",
    "summary": "NUnit1004 The TestCaseAttribute provided too many arguments Topic Value Id NUnit1004 Severity Error Enabled True Category Structure Code TestCaseUsageAnalyzer Description The number of arguments provided by a TestCaseAttribute must match the number of parameters of the method. Motivation To prevent tests that will fail at runtime due to improper construction. How to fix violations Example Violation [TestCase(\"1\", \"2\")] public void NUnit1004SampleTest(string parameter1) { Assert.That(parameter1, Is.EqualTo(\"1\")); } Explanation In the sample above, there are two arguments provided by test case (TestCase(\"1\", \"2\")), but only one parameter is being expected by the test itself ((string parameter1)). Fix Either make use of the additional argument: [TestCase(\"1\", \"2\")] public void NUnit1003SampleTest(string parameter1, string parameter2) { Assert.That(parameter1, Is.EqualTo(\"1\")); Assert.That(parameter2, Is.EqualTo(\"2\")); } Or remove it: [TestCase(\"1\")] public void NUnit1003SampleTest(string parameter1) { Assert.That(parameter1, Is.EqualTo(\"1\")); } Configure severity Via ruleset file Configure the severity per project, for more info see MSDN. Via .editorconfig file # NUnit1004: The TestCaseAttribute provided too many arguments dotnet_diagnostic.NUnit1004.severity = chosenSeverity where chosenSeverity can be one of none, silent, suggestion, warning, or error. Via #pragma directive #pragma warning disable NUnit1004 // The TestCaseAttribute provided too many arguments Code violating the rule here #pragma warning restore NUnit1004 // The TestCaseAttribute provided too many arguments Or put this at the top of the file to disable all instances. #pragma warning disable NUnit1004 // The TestCaseAttribute provided too many arguments Via attribute [SuppressMessage] [System.Diagnostics.CodeAnalysis.SuppressMessage(\"Structure\", \"NUnit1004:The TestCaseAttribute provided too many arguments\", Justification = \"Reason...\")]"
  },
  "articles/nunit-analyzers/NUnit1005.html": {
    "href": "articles/nunit-analyzers/NUnit1005.html",
    "title": "NUnit1005 | NUnit Docs",
    "summary": "NUnit1005 The type of the value specified via ExpectedResult must match the return type of the method Topic Value Id NUnit1005 Severity Error Enabled True Category Structure Code TestMethodUsageAnalyzer Description The type of the value specified via ExpectedResult must match the return type of the method. Otherwise, this will lead to an error at run-time. Motivation To prevent tests that will fail at runtime due to improper construction. How to fix violations Example Violation [TestCase(1, ExpectedResult = true)] public int NUnit1005SampleTest(int inputValue) { return inputValue; } Explanation The sample above uses NUnit's ExpectedResult syntax. It defines a result of true (a bool) but the return type of the method is int. Fix Either modify the TestCase parameter: [TestCase(1, ExpectedResult = 1)] public int NUnit1005SampleTest(int inputValue) { return inputValue; } Or modify the return type and logic of the method: [TestCase(1, ExpectedResult = true)] public bool NUnit1005SampleTest(int inputValue) { return inputValue > 0; } Configure severity Via ruleset file Configure the severity per project, for more info see MSDN. Via .editorconfig file # NUnit1005: The type of the value specified via ExpectedResult must match the return type of the method dotnet_diagnostic.NUnit1005.severity = chosenSeverity where chosenSeverity can be one of none, silent, suggestion, warning, or error. Via #pragma directive #pragma warning disable NUnit1005 // The type of the value specified via ExpectedResult must match the return type of the method Code violating the rule here #pragma warning restore NUnit1005 // The type of the value specified via ExpectedResult must match the return type of the method Or put this at the top of the file to disable all instances. #pragma warning disable NUnit1005 // The type of the value specified via ExpectedResult must match the return type of the method Via attribute [SuppressMessage] [System.Diagnostics.CodeAnalysis.SuppressMessage(\"Structure\", \"NUnit1005:The type of the value specified via ExpectedResult must match the return type of the method\", Justification = \"Reason...\")]"
  },
  "articles/nunit-analyzers/NUnit1006.html": {
    "href": "articles/nunit-analyzers/NUnit1006.html",
    "title": "NUnit1006 | NUnit Docs",
    "summary": "NUnit1006 ExpectedResult must not be specified when the method returns void Topic Value Id NUnit1006 Severity Error Enabled True Category Structure Code TestMethodUsageAnalyzer Description ExpectedResult must not be specified when the method returns void. This will lead to an error at run-time. Motivation To prevent tests that will fail at runtime due to improper construction. How to fix violations Example Violation [TestCase(1, ExpectedResult = \"1\")] public void NUnit1006SampleTest(int inputValue) { return; } Explanation An ExpectedResult was defined, but the return type of the method in our sample is of type void, meaning it does not return a result. Fix Either modify the TestCase to remove the ExpectedResult: [TestCase(1)] public void NUnit1006SampleTest(int inputValue) { Assert.That(inputValue, Is.EqualTo(1)); } Or modify the return type of the test method: [TestCase(1, ExpectedResult = \"1\")] public string NUnit1006SampleTest(int inputValue) { return inputValue.ToString(); } Configure severity Via ruleset file Configure the severity per project, for more info see MSDN. Via .editorconfig file # NUnit1006: ExpectedResult must not be specified when the method returns void dotnet_diagnostic.NUnit1006.severity = chosenSeverity where chosenSeverity can be one of none, silent, suggestion, warning, or error. Via #pragma directive #pragma warning disable NUnit1006 // ExpectedResult must not be specified when the method returns void Code violating the rule here #pragma warning restore NUnit1006 // ExpectedResult must not be specified when the method returns void Or put this at the top of the file to disable all instances. #pragma warning disable NUnit1006 // ExpectedResult must not be specified when the method returns void Via attribute [SuppressMessage] [System.Diagnostics.CodeAnalysis.SuppressMessage(\"Structure\", \"NUnit1006:ExpectedResult must not be specified when the method returns void\", Justification = \"Reason...\")]"
  },
  "articles/nunit-analyzers/NUnit1007.html": {
    "href": "articles/nunit-analyzers/NUnit1007.html",
    "title": "NUnit1007 | NUnit Docs",
    "summary": "NUnit1007 The method has non-void return type, but no result is expected in ExpectedResult Topic Value Id NUnit1007 Severity Error Enabled True Category Structure Code TestMethodUsageAnalyzer Description The method has non-void return type, but no result is expected in ExpectedResult. Motivation To prevent tests that will fail at runtime due to improper construction. How to fix violations Example Violation [TestCase(1)] public string NUnit1007SampleTest(int inputValue) { return \"\"; } Explanation No ExpectedResult was defined, but the return type of the method in our sample is of type string, meaning it does indeed return a result and we should use the ExpectedResult syntax in order to capture it. Fix Either modify the TestCase to add an ExpectedResult: [TestCase(1, ExpectedResult = \"\")] public string NUnit1007SampleTest(int inputValue) { return \"\"; } Or modify the return type of the test method to be void: [TestCase(1)] public void NUnit1007SampleTest(int inputValue) { return Assert.That(inputValue, Is.EqualTo(1)); } Configure severity Via ruleset file Configure the severity per project, for more info see MSDN. Via .editorconfig file # NUnit1007: The method has non-void return type, but no result is expected in ExpectedResult dotnet_diagnostic.NUnit1007.severity = chosenSeverity where chosenSeverity can be one of none, silent, suggestion, warning, or error. Via #pragma directive #pragma warning disable NUnit1007 // The method has non-void return type, but no result is expected in ExpectedResult Code violating the rule here #pragma warning restore NUnit1007 // The method has non-void return type, but no result is expected in ExpectedResult Or put this at the top of the file to disable all instances. #pragma warning disable NUnit1007 // The method has non-void return type, but no result is expected in ExpectedResult Via attribute [SuppressMessage] [System.Diagnostics.CodeAnalysis.SuppressMessage(\"Structure\", \"NUnit1007:The method has non-void return type, but no result is expected in ExpectedResult\", Justification = \"Reason...\")]"
  },
  "articles/nunit-analyzers/NUnit1008.html": {
    "href": "articles/nunit-analyzers/NUnit1008.html",
    "title": "NUnit1008 | NUnit Docs",
    "summary": "NUnit1008 Specifying ParallelScope.Self on assembly level has no effect Topic Value Id NUnit1008 Severity Warning Enabled True Category Structure Code ParallelizableUsageAnalyzer Description Specifying ParallelScope.Self on assembly level has no effect. Motivation Bring developers' attention to a scenario in which they may believe they are parallelizing something when in fact they are not and their efforts will have no effect. How to fix violations Example Violation In AssemblyInfo.cs: [assembly: Parallelizable(ParallelScope.Self)] Explanation ParallelScope.Self only applies to classes and methods, not to assemblies. Fix Either remove it or change to a valid option, such as: [assembly: Parallelizable(ParallelScope.Children)] Or: [assembly: Parallelizable(ParallelScope.Fixtures)] Configure severity Via ruleset file Configure the severity per project, for more info see MSDN. Via .editorconfig file # NUnit1008: Specifying ParallelScope.Self on assembly level has no effect dotnet_diagnostic.NUnit1008.severity = chosenSeverity where chosenSeverity can be one of none, silent, suggestion, warning, or error. Via #pragma directive #pragma warning disable NUnit1008 // Specifying ParallelScope.Self on assembly level has no effect Code violating the rule here #pragma warning restore NUnit1008 // Specifying ParallelScope.Self on assembly level has no effect Or put this at the top of the file to disable all instances. #pragma warning disable NUnit1008 // Specifying ParallelScope.Self on assembly level has no effect Via attribute [SuppressMessage] [System.Diagnostics.CodeAnalysis.SuppressMessage(\"Structure\", \"NUnit1008:Specifying ParallelScope.Self on assembly level has no effect\", Justification = \"Reason...\")]"
  },
  "articles/nunit-analyzers/NUnit1009.html": {
    "href": "articles/nunit-analyzers/NUnit1009.html",
    "title": "NUnit1009 | NUnit Docs",
    "summary": "NUnit1009 One may not specify ParallelScope.Children on a non-parameterized test method Topic Value Id NUnit1009 Severity Error Enabled True Category Structure Code ParallelizableUsageAnalyzer Description One may not specify ParallelScope.Children on a non-parameterized test method. Motivation To prevent tests that will fail at runtime due to improper construction. How to fix violations Example Violation [Parallelizable(ParallelScope.Children)] [Test] public void NUnit1009SampleTest() { Assert.Pass(); } Explanation In the sample above, the Parallelizable attribute is used with ParallelScope.Children. However, in a non-parameterized test, such as a [Test] and not a [TestCase], there will be no children generated, and thus this type of parallelization does not make sense. Fix Remove the attribute: [Test] public void NUnit1009SampleTest() { Assert.Pass(); } Or, turn the test into one that will have children generated, such as a TestCase: [Parallelizable(ParallelScope.Children)] // These will now run in parallel [TestCase(1)] [TestCase(2)] public void NUnit1009SampleTest(int numberValue) { Assert.That(numberValue, Is.GreaterThan(0)); } Configure severity Via ruleset file Configure the severity per project, for more info see MSDN. Via .editorconfig file # NUnit1009: One may not specify ParallelScope.Children on a non-parameterized test method dotnet_diagnostic.NUnit1009.severity = chosenSeverity where chosenSeverity can be one of none, silent, suggestion, warning, or error. Via #pragma directive #pragma warning disable NUnit1009 // One may not specify ParallelScope.Children on a non-parameterized test method Code violating the rule here #pragma warning restore NUnit1009 // One may not specify ParallelScope.Children on a non-parameterized test method Or put this at the top of the file to disable all instances. #pragma warning disable NUnit1009 // One may not specify ParallelScope.Children on a non-parameterized test method Via attribute [SuppressMessage] [System.Diagnostics.CodeAnalysis.SuppressMessage(\"Structure\", \"NUnit1009:One may not specify ParallelScope.Children on a non-parameterized test method\", Justification = \"Reason...\")]"
  },
  "articles/nunit-analyzers/NUnit1010.html": {
    "href": "articles/nunit-analyzers/NUnit1010.html",
    "title": "NUnit1010 | NUnit Docs",
    "summary": "NUnit1010 One may not specify ParallelScope.Fixtures on a test method Topic Value Id NUnit1010 Severity Error Enabled True Category Structure Code ParallelizableUsageAnalyzer Description One may not specify ParallelScope.Fixtures on a test method. Motivation To prevent tests that will fail at runtime due to improper construction. How to fix violations Example Violation [Parallelizable(ParallelScope.Fixtures)] [Test] public void NUnit1010SampleTest() { Assert.Pass(); } Explanation In the sample above, ParallelScope.Fixtures is specified. However, in the context of a test method, a scope of Fixtures does not make sense. This scope only applies at the assembly or class level. Fix Remove the attribute: [Test] public void NUnit1010SampleTest() { Assert.Pass(); } Or apply this attribute at the class level: [Parallelizable(ParallelScope.Fixtures)] public class MyTests { [Test] public void NUnit1010SampleTest() { Assert.Pass(); } } Or use a different attribute that applies at the test level: [Parallelizable(ParallelScope.Self)] [Test] public void NUnit1010SampleTest() { Assert.Pass(); } Configure severity Via ruleset file Configure the severity per project, for more info see MSDN. Via .editorconfig file # NUnit1010: One may not specify ParallelScope.Fixtures on a test method dotnet_diagnostic.NUnit1010.severity = chosenSeverity where chosenSeverity can be one of none, silent, suggestion, warning, or error. Via #pragma directive #pragma warning disable NUnit1010 // One may not specify ParallelScope.Fixtures on a test method Code violating the rule here #pragma warning restore NUnit1010 // One may not specify ParallelScope.Fixtures on a test method Or put this at the top of the file to disable all instances. #pragma warning disable NUnit1010 // One may not specify ParallelScope.Fixtures on a test method Via attribute [SuppressMessage] [System.Diagnostics.CodeAnalysis.SuppressMessage(\"Structure\", \"NUnit1010:One may not specify ParallelScope.Fixtures on a test method\", Justification = \"Reason...\")]"
  },
  "articles/nunit-analyzers/NUnit1011.html": {
    "href": "articles/nunit-analyzers/NUnit1011.html",
    "title": "NUnit1011 | NUnit Docs",
    "summary": "NUnit1011 The TestCaseSource argument does not specify an existing member Topic Value Id NUnit1011 Severity Error Enabled True Category Structure Code TestCaseSourceUsesStringAnalyzer Description The TestCaseSource argument does not specify an existing member. This will lead to an error at run-time. Motivation To prevent tests that will fail at runtime due to improper construction. How to fix violations Example Violation [TestCaseSource(\"MyIncorrectTestSource\")] public void NUnit1011SampleTest(string stringValue) { Assert.That(stringValue.Length, Is.EqualTo(3)); } public static object[] MyTestSource() { return new object[] {\"One\", \"Two\"}; } Explanation In the example above, the test case source is named MyIncorrectTestCaseSource, but the test case source is actually named MyTestSource. Because the names don't match, this will be an error. Fix Rename the TestCaseSource to match: [TestCaseSource(\"MyTestSource\")] public void NUnit1011SampleTest(string stringValue) { Assert.That(stringValue.Length, Is.EqualTo(3)); } public static object[] MyTestSource() { return new object[] {\"One\", \"Two\"}; } Or even better, use nameof so that the compiler may assist with mismatched names in the future: [TestCaseSource(nameof(MyTestSource))] public void NUnit1011SampleTest(string stringValue) { Assert.That(stringValue.Length, Is.EqualTo(3)); } public static object[] MyTestSource() { return new object[] {\"One\", \"Two\"}; } Configure severity Via ruleset file Configure the severity per project, for more info see MSDN. Via .editorconfig file # NUnit1011: The TestCaseSource argument does not specify an existing member dotnet_diagnostic.NUnit1011.severity = chosenSeverity where chosenSeverity can be one of none, silent, suggestion, warning, or error. Via #pragma directive #pragma warning disable NUnit1011 // The TestCaseSource argument does not specify an existing member Code violating the rule here #pragma warning restore NUnit1011 // The TestCaseSource argument does not specify an existing member Or put this at the top of the file to disable all instances. #pragma warning disable NUnit1011 // The TestCaseSource argument does not specify an existing member Via attribute [SuppressMessage] [System.Diagnostics.CodeAnalysis.SuppressMessage(\"Structure\", \"NUnit1011:The TestCaseSource argument does not specify an existing member\", Justification = \"Reason...\")]"
  },
  "articles/nunit-analyzers/NUnit1012.html": {
    "href": "articles/nunit-analyzers/NUnit1012.html",
    "title": "NUnit1012 | NUnit Docs",
    "summary": "NUnit1012 The async test method must have a non-void return type Topic Value Id NUnit1012 Severity Error Enabled True Category Structure Code TestMethodUsageAnalyzer Description The async test method must have a non-void return type. Motivation To prevent tests that will fail at runtime due to improper construction. How to fix violations Example Violation [Test] public async void NUnit1012SampleTest() { var result = await Task.FromResult(true); Assert.That(result, Is.True); } Explanation async methods should generally not return void in C#. For example if an exception is thrown (as they are in the case of an assertion violation), the exception is actually a part of the task object. If the return type is void, no such object exists, to the exception is effectively swallowed. Fix Make the async test method return a Task: [Test] public async Task NUnit1012SampleTest() { var result = await Task.FromResult(true); Assert.That(result, Is.True); } Or modify the test to not use async behavior: [Test] public void NUnit1012SampleTest() { var result = true; Assert.That(result, Is.True); } Configure severity Via ruleset file Configure the severity per project, for more info see MSDN. Via .editorconfig file # NUnit1012: The async test method must have a non-void return type dotnet_diagnostic.NUnit1012.severity = chosenSeverity where chosenSeverity can be one of none, silent, suggestion, warning, or error. Via #pragma directive #pragma warning disable NUnit1012 // The async test method must have a non-void return type Code violating the rule here #pragma warning restore NUnit1012 // The async test method must have a non-void return type Or put this at the top of the file to disable all instances. #pragma warning disable NUnit1012 // The async test method must have a non-void return type Via attribute [SuppressMessage] [System.Diagnostics.CodeAnalysis.SuppressMessage(\"Structure\", \"NUnit1012:The async test method must have a non-void return type\", Justification = \"Reason...\")]"
  },
  "articles/nunit-analyzers/NUnit1013.html": {
    "href": "articles/nunit-analyzers/NUnit1013.html",
    "title": "NUnit1013 | NUnit Docs",
    "summary": "NUnit1013 The async test method must have a non-generic Task return type when no result is expected Topic Value Id NUnit1013 Severity Error Enabled True Category Structure Code TestMethodUsageAnalyzer Description The async test method must have a non-generic Task return type when no result is expected. Motivation To prevent tests that will fail at runtime due to improper construction. How to fix violations Example Violation [TestCase(1)] public async Task<string> NUnit1013SampleTest(int numberValue) { return await ConvertNumber(numberValue); } public Task<string> ConvertNumber(int numberValue) { return Task.FromResult(numberValue.ToString()); } Explanation The NUnit ExpectedResult syntax is not used, so it's an error for this method to return something that isn't being checked. Fix Utilize the ExpectedResult syntax: [TestCase(1, ExpectedResult = \"1\")] public async Task<string> NUnit1013SampleTest(int numberValue) { return await ConvertNumber(numberValue); } public Task<string> ConvertNumber(int numberValue) { return Task.FromResult(numberValue.ToString()); } Or, use an assertion and a generic Task rather than Task<string>: [TestCase(1)] public async Task NUnit1013SampleTest(int numberValue) { var result = await ConvertNumber(numberValue); Assert.That(result, Is.EqualTo(\"1\")); } public Task<string> ConvertNumber(int numberValue) { return Task.FromResult(numberValue.ToString()); } Configure severity Via ruleset file Configure the severity per project, for more info see MSDN. Via .editorconfig file # NUnit1013: The async test method must have a non-generic Task return type when no result is expected dotnet_diagnostic.NUnit1013.severity = chosenSeverity where chosenSeverity can be one of none, silent, suggestion, warning, or error. Via #pragma directive #pragma warning disable NUnit1013 // The async test method must have a non-generic Task return type when no result is expected Code violating the rule here #pragma warning restore NUnit1013 // The async test method must have a non-generic Task return type when no result is expected Or put this at the top of the file to disable all instances. #pragma warning disable NUnit1013 // The async test method must have a non-generic Task return type when no result is expected Via attribute [SuppressMessage] [System.Diagnostics.CodeAnalysis.SuppressMessage(\"Structure\", \"NUnit1013:The async test method must have a non-generic Task return type when no result is expected\", Justification = \"Reason...\")]"
  },
  "articles/nunit-analyzers/NUnit1014.html": {
    "href": "articles/nunit-analyzers/NUnit1014.html",
    "title": "NUnit1014 | NUnit Docs",
    "summary": "NUnit1014 The async test method must have a Task<T> return type when a result is expected Topic Value Id NUnit1014 Severity Error Enabled True Category Structure Code TestMethodUsageAnalyzer Description The async test method must have a Task<T> return type when a result is expected. Motivation To prevent tests that will fail at runtime due to improper construction. How to fix violations Example Violation [TestCase(1, ExpectedResult = true)] public async Task NUnit1014SampleTest(int numberValue) { return; } Explanation The NUnit ExpectedResult syntax is used, so this method needs to return a type that matches the type of expected result you're looking for. Fix Remove the ExpectedResult syntax: [TestCase(1)] public async Task NUnit1014SampleTest(int numberValue) { Assert.Pass(); } Or, update the return task type to be what you're looking for, e.g. Task<bool> below: [TestCase(1, ExpectedResult = true)] public async Task<bool> NUnit1014SampleTest(int numberValue) { return Task.FromResult(true); } Configure severity Via ruleset file Configure the severity per project, for more info see MSDN. Via .editorconfig file # NUnit1014: The async test method must have a Task<T> return type when a result is expected dotnet_diagnostic.NUnit1014.severity = chosenSeverity where chosenSeverity can be one of none, silent, suggestion, warning, or error. Via #pragma directive #pragma warning disable NUnit1014 // The async test method must have a Task<T> return type when a result is expected Code violating the rule here #pragma warning restore NUnit1014 // The async test method must have a Task<T> return type when a result is expected Or put this at the top of the file to disable all instances. #pragma warning disable NUnit1014 // The async test method must have a Task<T> return type when a result is expected Via attribute [SuppressMessage] [System.Diagnostics.CodeAnalysis.SuppressMessage(\"Structure\", \"NUnit1014:The async test method must have a Task<T> return type when a result is expected\", Justification = \"Reason...\")]"
  },
  "articles/nunit-analyzers/NUnit1015.html": {
    "href": "articles/nunit-analyzers/NUnit1015.html",
    "title": "NUnit1015 | NUnit Docs",
    "summary": "NUnit1015 The source type does not implement I(Async)Enumerable Topic Value Id NUnit1015 Severity Error Enabled True Category Structure Code TestCaseSourceUsesStringAnalyzer Description The source type must implement I(Async)Enumerable in order to provide test cases. Motivation To prevent tests that will fail at runtime due to improper construction. How to fix violations Example Violation public class MyTestClass { [TestCaseSource(typeof(DivideCases))] public void DivideTest(int n, int d, int q) { ClassicAssert.AreEqual(q, n / d); } } class DivideCases { public IEnumerator GetData() { yield return new object[] { 12, 3, 4 }; yield return new object[] { 12, 2, 6 }; yield return new object[] { 12, 4, 3 }; } } Explanation In the sample above, the class DivideCases does not implement IEnumerable nor IAsyncEnumerable However, source types specified by TestCaseSource must implement IEnumerable or IAsyncEnumerable. Fix Make the source type implement IEnumerable or IAsyncEnumerable public class MyTestClass { [TestCaseSource(typeof(DivideCases))] public void DivideTest(int n, int d, int q) { ClassicAssert.AreEqual(q, n / d); } } class DivideCases : IEnumerable { public IEnumerator GetEnumerator() { yield return new object[] { 12, 3, 4 }; yield return new object[] { 12, 2, 6 }; yield return new object[] { 12, 4, 3 }; } } Configure severity Via ruleset file Configure the severity per project, for more info see MSDN. Via .editorconfig file # NUnit1015: The source type does not implement I(Async)Enumerable dotnet_diagnostic.NUnit1015.severity = chosenSeverity where chosenSeverity can be one of none, silent, suggestion, warning, or error. Via #pragma directive #pragma warning disable NUnit1015 // The source type does not implement I(Async)Enumerable Code violating the rule here #pragma warning restore NUnit1015 // The source type does not implement I(Async)Enumerable Or put this at the top of the file to disable all instances. #pragma warning disable NUnit1015 // The source type does not implement I(Async)Enumerable Via attribute [SuppressMessage] [System.Diagnostics.CodeAnalysis.SuppressMessage(\"Structure\", \"NUnit1015:The source type does not implement I(Async)Enumerable\", Justification = \"Reason...\")]"
  },
  "articles/nunit-analyzers/NUnit1016.html": {
    "href": "articles/nunit-analyzers/NUnit1016.html",
    "title": "NUnit1016 | NUnit Docs",
    "summary": "NUnit1016 The source type does not have a default constructor Topic Value Id NUnit1016 Severity Error Enabled True Category Structure Code TestCaseSourceUsesStringAnalyzer Description The source type must have a default constructor in order to provide test cases. Motivation To prevent tests that will fail at runtime due to improper construction. How to fix violations Example Violation public class MyTestClass { [TestCaseSource(typeof(DivideCases))] public void DivideTest(int n, int d, int q) { ClassicAssert.AreEqual(q, n / d); } } class DivideCases : IEnumerable { public DivideCases(int i) { } public IEnumerator GetEnumerator() { yield return new object[] { 12, 3, 4 }; yield return new object[] { 12, 2, 6 }; yield return new object[] { 12, 4, 3 }; } } Explanation In the sample above, the class DivideCases does not have a default constructor - i.e. a constructor with no parameters. However, source types specified by TestCaseSource must have a default constructor. Fix Add a default constructor to the source type (or remove the parameters from an existing constructor): public class MyTestClass { [TestCaseSource(typeof(DivideCases))] public void DivideTest(int n, int d, int q) { ClassicAssert.AreEqual(q, n / d); } } class DivideCases : IEnumerable { public DivideCases() { } public DivideCases(int i) { } public IEnumerator GetEnumerator() { yield return new object[] { 12, 3, 4 }; yield return new object[] { 12, 2, 6 }; yield return new object[] { 12, 4, 3 }; } } Configure severity Via ruleset file Configure the severity per project, for more info see MSDN. Via .editorconfig file # NUnit1016: The source type does not have a default constructor dotnet_diagnostic.NUnit1016.severity = chosenSeverity where chosenSeverity can be one of none, silent, suggestion, warning, or error. Via #pragma directive #pragma warning disable NUnit1016 // The source type does not have a default constructor Code violating the rule here #pragma warning restore NUnit1016 // The source type does not have a default constructor Or put this at the top of the file to disable all instances. #pragma warning disable NUnit1016 // The source type does not have a default constructor Via attribute [SuppressMessage] [System.Diagnostics.CodeAnalysis.SuppressMessage(\"Structure\", \"NUnit1016:The source type does not have a default constructor\", Justification = \"Reason...\")]"
  },
  "articles/nunit-analyzers/NUnit1017.html": {
    "href": "articles/nunit-analyzers/NUnit1017.html",
    "title": "NUnit1017 | NUnit Docs",
    "summary": "NUnit1017 The specified source is not static Topic Value Id NUnit1017 Severity Error Enabled True Category Structure Code TestCaseSourceUsesStringAnalyzer Description The specified source must be static. Motivation To prevent tests that will fail at runtime due to improper construction. How to fix violations Example Violation public class MyTestClass { [TestCaseSource(nameof(DivideCases))] public void DivideTest(int n, int d, int q) { ClassicAssert.AreEqual(q, n / d); } object[] DivideCases = { new object[] { 12, 3, 4 }, new object[] { 12, 2, 6 }, new object[] { 12, 4, 3 } }; } Explanation In the sample above, DivideCases is not a static field. However, sources specified by TestCaseSource must be static. Fix Make the source static: public class MyTestClass { [TestCaseSource(nameof(DivideCases))] public void DivideTest(int n, int d, int q) { ClassicAssert.AreEqual(q, n / d); } static object[] DivideCases = { new object[] { 12, 3, 4 }, new object[] { 12, 2, 6 }, new object[] { 12, 4, 3 } }; } Configure severity Via ruleset file Configure the severity per project, for more info see MSDN. Via .editorconfig file # NUnit1017: The specified source is not static dotnet_diagnostic.NUnit1017.severity = chosenSeverity where chosenSeverity can be one of none, silent, suggestion, warning, or error. Via #pragma directive #pragma warning disable NUnit1017 // The specified source is not static Code violating the rule here #pragma warning restore NUnit1017 // The specified source is not static Or put this at the top of the file to disable all instances. #pragma warning disable NUnit1017 // The specified source is not static Via attribute [SuppressMessage] [System.Diagnostics.CodeAnalysis.SuppressMessage(\"Structure\", \"NUnit1017:The specified source is not static\", Justification = \"Reason...\")]"
  },
  "articles/nunit-analyzers/NUnit1018.html": {
    "href": "articles/nunit-analyzers/NUnit1018.html",
    "title": "NUnit1018 | NUnit Docs",
    "summary": "NUnit1018 The number of parameters provided by the TestCaseSource does not match the number of parameters in the target method Topic Value Id NUnit1018 Severity Error Enabled True Category Structure Code TestCaseSourceUsesStringAnalyzer Description The number of parameters provided by the TestCaseSource must match the number of parameters in the target method. Motivation To prevent tests that will fail at runtime due to improper construction. How to fix violations Example Violation public class MyTestClass { [TestCaseSource(nameof(Strings), new object[] { \"Testing\" })] public void StringTest(string input) { Assert.That(input, Is.Not.Null); } static IEnumerable<string> Strings(string first, string second) { yield return first; yield return second; } } Explanation In the sample above, the method Strings expects two arguments, but the TestCaseSource only supplies one argument. Fix Either change Strings to only expect one argument or supply both from the TestCaseSource: public class MyTestClass { [TestCaseSource(nameof(Strings), new object[] { \"Testing\", \"TestCaseSource\" })] public void StringTest(string input) { Assert.That(input, Is.Not.Null); } static IEnumerable<string> Strings(string first, string second) { yield return first; yield return second; } } Configure severity Via ruleset file Configure the severity per project, for more info see MSDN. Via .editorconfig file # NUnit1018: The number of parameters provided by the TestCaseSource does not match the number of parameters in the target method dotnet_diagnostic.NUnit1018.severity = chosenSeverity where chosenSeverity can be one of none, silent, suggestion, warning, or error. Via #pragma directive #pragma warning disable NUnit1018 // The number of parameters provided by the TestCaseSource does not match the number of parameters in the target method Code violating the rule here #pragma warning restore NUnit1018 // The number of parameters provided by the TestCaseSource does not match the number of parameters in the target method Or put this at the top of the file to disable all instances. #pragma warning disable NUnit1018 // The number of parameters provided by the TestCaseSource does not match the number of parameters in the target method Via attribute [SuppressMessage] [System.Diagnostics.CodeAnalysis.SuppressMessage(\"Structure\", \"NUnit1018:The number of parameters provided by the TestCaseSource does not match the number of parameters in the target method\", Justification = \"Reason...\")]"
  },
  "articles/nunit-analyzers/NUnit1019.html": {
    "href": "articles/nunit-analyzers/NUnit1019.html",
    "title": "NUnit1019 | NUnit Docs",
    "summary": "NUnit1019 The source specified by the TestCaseSource does not return an I(Async)Enumerable or a type that implements I(Async)Enumerable Topic Value Id NUnit1019 Severity Error Enabled True Category Structure Code TestCaseSourceUsesStringAnalyzer Description The source specified by the TestCaseSource must return an I(Async)Enumerable or a type that implements I(Async)Enumerable. Motivation To prevent tests that will fail at runtime due to improper construction. How to fix violations Example Violation public class AnalyzeWhenSourceDoesProvideIEnumerable { private static readonly int testCases = 42; [TestCaseSource(nameof(testCases))] public void Test(int input) { } } Explanation In the sample above, the source specified by TestCaseSource - the field testCases - does not return an I(Async)Enumerable or a type that implements I(Async)Enumerable, instead it returns an int. However, sources specified by TestCaseSource must return an I(Async)Enumerable or a type that implements I(Async)Enumerable.. Fix Change testCases to return an I(Async)Enumerable or a type that implements I(Async)Enumerable: public class AnalyzeWhenSourceDoesProvideIEnumerable { private static readonly int[] testCases = new int[] { 1, 2, 42 }; [TestCaseSource(nameof(testCases))] public void Test(int input) { } } Configure severity Via ruleset file Configure the severity per project, for more info see MSDN. Via .editorconfig file # NUnit1019: The source specified by the TestCaseSource does not return an I(Async)Enumerable or a type that implements I(Async)Enumerable dotnet_diagnostic.NUnit1019.severity = chosenSeverity where chosenSeverity can be one of none, silent, suggestion, warning, or error. Via #pragma directive #pragma warning disable NUnit1019 // The source specified by the TestCaseSource does not return an I(Async)Enumerable or a type that implements I(Async)Enumerable Code violating the rule here #pragma warning restore NUnit1019 // The source specified by the TestCaseSource does not return an I(Async)Enumerable or a type that implements I(Async)Enumerable Or put this at the top of the file to disable all instances. #pragma warning disable NUnit1019 // The source specified by the TestCaseSource does not return an I(Async)Enumerable or a type that implements I(Async)Enumerable Via attribute [SuppressMessage] [System.Diagnostics.CodeAnalysis.SuppressMessage(\"Structure\", \"NUnit1019:The source specified by the TestCaseSource does not return an I(Async)Enumerable or a type that implements I(Async)Enumerable\", Justification = \"Reason...\")]"
  },
  "articles/nunit-analyzers/NUnit1020.html": {
    "href": "articles/nunit-analyzers/NUnit1020.html",
    "title": "NUnit1020 | NUnit Docs",
    "summary": "NUnit1020 The TestCaseSource provides parameters to a source - field or property - that expects no parameters Topic Value Id NUnit1020 Severity Error Enabled True Category Structure Code TestCaseSourceUsesStringAnalyzer Description The TestCaseSource must not provide any parameters when the source is a field or a property. Motivation To prevent tests that will fail at runtime due to improper construction. How to fix violations Example Violation public class MyTestClass { [TestCaseSource(nameof(DivideCases), new object[] { \"Testing\" })] public void DivideTest(int n, int d, int q) { ClassicAssert.AreEqual(q, n / d); } static object[] DivideCases = { new object[] { 12, 3, 4 }, new object[] { 12, 2, 6 }, new object[] { 12, 4, 3 } }; } Explanation In the sample above, DivideCases is a field, and as such does not accept any arguments, so the TestCaseSource should not supply any parameters. Fix Either remove the parameter from TestCaseSource or change the field into a method.: public class MyTestClass { [TestCaseSource(nameof(DivideCases), new object[] { \"Testing\" })] public void DivideTest(int n, int d, int q) { ClassicAssert.AreEqual(q, n / d); } static object[] DivideCases(string input) { return new object[] { new object[] { 12, 3, 4 }, new object[] { 12, 2, 6 }, new object[] { 12, 4, 3 } }; } } Configure severity Via ruleset file Configure the severity per project, for more info see MSDN. Via .editorconfig file # NUnit1020: The TestCaseSource provides parameters to a source - field or property - that expects no parameters dotnet_diagnostic.NUnit1020.severity = chosenSeverity where chosenSeverity can be one of none, silent, suggestion, warning, or error. Via #pragma directive #pragma warning disable NUnit1020 // The TestCaseSource provides parameters to a source - field or property - that expects no parameters Code violating the rule here #pragma warning restore NUnit1020 // The TestCaseSource provides parameters to a source - field or property - that expects no parameters Or put this at the top of the file to disable all instances. #pragma warning disable NUnit1020 // The TestCaseSource provides parameters to a source - field or property - that expects no parameters Via attribute [SuppressMessage] [System.Diagnostics.CodeAnalysis.SuppressMessage(\"Structure\", \"NUnit1020:The TestCaseSource provides parameters to a source - field or property - that expects no parameters\", Justification = \"Reason...\")]"
  },
  "articles/nunit-analyzers/NUnit1021.html": {
    "href": "articles/nunit-analyzers/NUnit1021.html",
    "title": "NUnit1021 | NUnit Docs",
    "summary": "NUnit1021 The ValueSource should use nameof operator to specify target Topic Value Id NUnit1021 Severity Warning Enabled True Category Structure Code ValueSourceUsageAnalyzer Description The ValueSource should use nameof operator to specify target. Motivation Prevent test rot by ensuring that future renames don't accidentally break tests in an unexpected way. nameof adds some compile-time support in these situations. How to fix violations Example Violation [Test] public void SampleTest([ValueSource(\"MyTestSource\")] string stringValue) { Assert.That(stringValue.Length, Is.EqualTo(3)); } public static object[] MyTestSource() { return new object[] {\"One\", \"Two\"}; } Problem In this case, we're referring to \"MyTestSource\" as a string directly. This is brittle; should the name of the property change, the test case source would become invalid, and we would not know this until executing tests. Fix The fix is to use the C# nameof operator, which produces a string but references the field name. This way, when refactoring and changing the name of your test source, it would also update the name within the nameof() operator. The fix in action: [Test] public void SampleTest([ValueSource(nameof(MyTestSource))] string stringValue) { Assert.That(stringValue.Length, Is.EqualTo(3)); } public static object[] MyTestSource() { return new object[] {\"One\", \"Two\"}; } Configure severity Via ruleset file Configure the severity per project, for more info see MSDN. Via .editorconfig file # NUnit1021: The ValueSource should use nameof operator to specify target dotnet_diagnostic.NUnit1021.severity = chosenSeverity where chosenSeverity can be one of none, silent, suggestion, warning, or error. Via #pragma directive #pragma warning disable NUnit1021 // The ValueSource should use nameof operator to specify target Code violating the rule here #pragma warning restore NUnit1021 // The ValueSource should use nameof operator to specify target Or put this at the top of the file to disable all instances. #pragma warning disable NUnit1021 // The ValueSource should use nameof operator to specify target Via attribute [SuppressMessage] [System.Diagnostics.CodeAnalysis.SuppressMessage(\"Structure\", \"NUnit1021:The ValueSource should use nameof operator to specify target\", Justification = \"Reason...\")]"
  },
  "articles/nunit-analyzers/NUnit1022.html": {
    "href": "articles/nunit-analyzers/NUnit1022.html",
    "title": "NUnit1022 | NUnit Docs",
    "summary": "NUnit1022 The specified source is not static Topic Value Id NUnit1022 Severity Error Enabled True Category Structure Code ValueSourceUsageAnalyzer Description The specified source must be static. Motivation To prevent tests that will fail at runtime due to improper construction. How to fix violations Example Violation public class MyTestClass { [Test] public void DivideTest([ValueSource(nameof(Numbers))] int n) { ClassicAssert.AreEqual(n, Is.GreaterThanOrEqualTo(0)); } object[] Numbers => new int[] { 1, 2, 3 }; } Explanation In the sample above, Numbers is not a static property. However, sources specified by ValueSource must be static. Fix Make the source static: public class MyTestClass { [Test] public void DivideTest([ValueSource(nameof(Numbers))] int n) { ClassicAssert.AreEqual(n, Is.GreaterThanOrEqualTo(0)); } static object[] Numbers => new int[] { 1, 2, 3 }; } Configure severity Via ruleset file Configure the severity per project, for more info see MSDN. Via .editorconfig file # NUnit1022: The specified source is not static dotnet_diagnostic.NUnit1022.severity = chosenSeverity where chosenSeverity can be one of none, silent, suggestion, warning, or error. Via #pragma directive #pragma warning disable NUnit1022 // The specified source is not static Code violating the rule here #pragma warning restore NUnit1022 // The specified source is not static Or put this at the top of the file to disable all instances. #pragma warning disable NUnit1022 // The specified source is not static Via attribute [SuppressMessage] [System.Diagnostics.CodeAnalysis.SuppressMessage(\"Structure\", \"NUnit1022:The specified source is not static\", Justification = \"Reason...\")]"
  },
  "articles/nunit-analyzers/NUnit1023.html": {
    "href": "articles/nunit-analyzers/NUnit1023.html",
    "title": "NUnit1023 | NUnit Docs",
    "summary": "NUnit1023 The target method expects parameters which cannot be supplied by the ValueSource Topic Value Id NUnit1023 Severity Error Enabled True Category Structure Code ValueSourceUsageAnalyzer Description The target method expects parameters which cannot be supplied by the ValueSource. Motivation To prevent tests that will fail at runtime due to improper construction. How to fix violations Example Violation public class MyTestClass { [Test] public void StringTest([ValueSource(nameof(Strings))] string input) { Assert.That(input, Is.Not.Null); } static IEnumerable<string> Strings(string first, string second) { yield return first; yield return second; } } Explanation In the sample above, the method Strings expects two arguments, but the ValueSource cannot supply arguments. Fix Change Strings so that it does not expect any arguments: public class MyTestClass { [Test] public void StringTest([ValueSource(nameof(Strings))] string input) { Assert.That(input, Is.Not.Null); } static IEnumerable<string> Strings() { yield return \"first\"; yield return \"second\"; } } Configure severity Via ruleset file Configure the severity per project, for more info see MSDN. Via .editorconfig file # NUnit1023: The target method expects parameters which cannot be supplied by the ValueSource dotnet_diagnostic.NUnit1023.severity = chosenSeverity where chosenSeverity can be one of none, silent, suggestion, warning, or error. Via #pragma directive #pragma warning disable NUnit1023 // The target method expects parameters which cannot be supplied by the ValueSource Code violating the rule here #pragma warning restore NUnit1023 // The target method expects parameters which cannot be supplied by the ValueSource Or put this at the top of the file to disable all instances. #pragma warning disable NUnit1023 // The target method expects parameters which cannot be supplied by the ValueSource Via attribute [SuppressMessage] [System.Diagnostics.CodeAnalysis.SuppressMessage(\"Structure\", \"NUnit1023:The target method expects parameters which cannot be supplied by the ValueSource\", Justification = \"Reason...\")]"
  },
  "articles/nunit-analyzers/NUnit1024.html": {
    "href": "articles/nunit-analyzers/NUnit1024.html",
    "title": "NUnit1024 | NUnit Docs",
    "summary": "NUnit1024 The source specified by the ValueSource does not return an I(Async)Enumerable or a type that implements I(Async)Enumerable Topic Value Id NUnit1024 Severity Error Enabled True Category Structure Code ValueSourceUsageAnalyzer Description The source specified by the ValueSource must return an I(Async)Enumerable or a type that implements I(Async)Enumerable. Motivation To prevent tests that will fail at runtime due to improper construction. How to fix violations Example Violation public class AnalyzeWhenSourceDoesProvideIEnumerable { private static readonly int testCases = 42; [Test] public void Test([ValueSource(nameof(testCases))] int input) { } } Explanation In the sample above, the source specified by ValueSource - the field testCases - does not return an I(Async)Enumerable or a type that implements I(Async)Enumerable, instead it returns an int. However, sources specified by ValueSource must return an I(Async)Enumerable or a type that implements I(Async)Enumerable.. Fix Change testCases to return an I(Async)Enumerable or a type that implements I(Async)Enumerable: public class AnalyzeWhenSourceDoesProvideIEnumerable { private static readonly int[] testCases = new int[] { 1, 2, 42 }; [Test] public void Test([ValueSource(nameof(testCases))] int input) { } } Configure severity Via ruleset file Configure the severity per project, for more info see MSDN. Via .editorconfig file # NUnit1024: The source specified by the ValueSource does not return an I(Async)Enumerable or a type that implements I(Async)Enumerable dotnet_diagnostic.NUnit1024.severity = chosenSeverity where chosenSeverity can be one of none, silent, suggestion, warning, or error. Via #pragma directive #pragma warning disable NUnit1024 // The source specified by the ValueSource does not return an I(Async)Enumerable or a type that implements I(Async)Enumerable Code violating the rule here #pragma warning restore NUnit1024 // The source specified by the ValueSource does not return an I(Async)Enumerable or a type that implements I(Async)Enumerable Or put this at the top of the file to disable all instances. #pragma warning disable NUnit1024 // The source specified by the ValueSource does not return an I(Async)Enumerable or a type that implements I(Async)Enumerable Via attribute [SuppressMessage] [System.Diagnostics.CodeAnalysis.SuppressMessage(\"Structure\", \"NUnit1024:The source specified by the ValueSource does not return an I(Async)Enumerable or a type that implements I(Async)Enumerable\", Justification = \"Reason...\")]"
  },
  "articles/nunit-analyzers/NUnit1025.html": {
    "href": "articles/nunit-analyzers/NUnit1025.html",
    "title": "NUnit1025 | NUnit Docs",
    "summary": "NUnit1025 The ValueSource argument does not specify an existing member Topic Value Id NUnit1025 Severity Error Enabled True Category Structure Code ValueSourceUsageAnalyzer Description The ValueSource argument does not specify an existing member. This will lead to an error at run-time. Motivation To prevent tests that will fail at runtime due to improper construction. How to fix violations Example Violation [Test] public void NUnit1011SampleTest([ValueSource(\"MyIncorrectTestSource\")] string stringValue) { Assert.That(stringValue.Length, Is.EqualTo(3)); } public static object[] MyTestSource() { return new object[] {\"One\", \"Two\"}; } Explanation In the example above, the test case source is named MyIncorrectTestCaseSource, but the test case source is actually named MyTestSource. Because the names don't match, this will be an error. Fix Rename the TestCaseSource to match: [Test] public void NUnit1011SampleTest([ValueSource(\"MyTestSource\")] string stringValue) { Assert.That(stringValue.Length, Is.EqualTo(3)); } public static object[] MyTestSource() { return new object[] {\"One\", \"Two\"}; } Or even better, use nameof so that the compiler may assist with mismatched names in the future: [Test] public void NUnit1011SampleTest([ValueSource(nameof(MyTestSource))] string stringValue) { Assert.That(stringValue.Length, Is.EqualTo(3)); } public static object[] MyTestSource() { return new object[] {\"One\", \"Two\"}; } Configure severity Via ruleset file Configure the severity per project, for more info see MSDN. Via .editorconfig file # NUnit1025: The ValueSource argument does not specify an existing member dotnet_diagnostic.NUnit1025.severity = chosenSeverity where chosenSeverity can be one of none, silent, suggestion, warning, or error. Via #pragma directive #pragma warning disable NUnit1025 // The ValueSource argument does not specify an existing member Code violating the rule here #pragma warning restore NUnit1025 // The ValueSource argument does not specify an existing member Or put this at the top of the file to disable all instances. #pragma warning disable NUnit1025 // The ValueSource argument does not specify an existing member Via attribute [SuppressMessage] [System.Diagnostics.CodeAnalysis.SuppressMessage(\"Structure\", \"NUnit1025:The ValueSource argument does not specify an existing member\", Justification = \"Reason...\")]"
  },
  "articles/nunit-analyzers/NUnit1026.html": {
    "href": "articles/nunit-analyzers/NUnit1026.html",
    "title": "NUnit1026 | NUnit Docs",
    "summary": "NUnit1026 The test or setup/teardown method is not public Topic Value Id NUnit1026 Severity Error Enabled True Category Structure Code TestMethodAccessibilityLevelAnalyzer Description The test or setup/teardown method is not public. Motivation To prevent tests that will fail at runtime, as NUnit only runs public test methods. How to fix violations Example Violation private int Value; [SetUp] void NUnit1026SetUp() { Value = 42; } [Test] void NUnit1026SampleTest() { Assert.That(Value, Is.GreaterThan(0)); } [TestCase(1)] private protected static void NUnit1026SampleTest2(int i) { Assert.Pass(); } Explanation In the example above, the test named NUnit1026SampleTest is not public - it has the default access modifier for a method, i.e. internal. NUnit1026SampleTest2 has the explicit access modifier private protected, which again is not public. NUnit only runs public methods, so neither test can be run. Fix The analyzer comes with a code fix that will change the access modifier to public. So the tests above will be changed into. private int Value; [SetUp] public void NUnit1026SetUp() { Value = 42; } [Test] public void NUnit1026SampleTest() { Assert.That(Value, Is.GreaterThan(0)); } [TestCase(1)] public static void NUnit1026SampleTest2(int i) { Assert.Pass(); } Configure severity Via ruleset file Configure the severity per project, for more info see MSDN. Via .editorconfig file # NUnit1026: The test or setup/teardown method is not public dotnet_diagnostic.NUnit1026.severity = chosenSeverity where chosenSeverity can be one of none, silent, suggestion, warning, or error. Via #pragma directive #pragma warning disable NUnit1026 // The test or setup/teardown method is not public Code violating the rule here #pragma warning restore NUnit1026 // The test or setup/teardown method is not public Or put this at the top of the file to disable all instances. #pragma warning disable NUnit1026 // The test or setup/teardown method is not public Via attribute [SuppressMessage] [System.Diagnostics.CodeAnalysis.SuppressMessage(\"Structure\", \"NUnit1026:The test or setup/teardown method is not public\", Justification = \"Reason...\")]"
  },
  "articles/nunit-analyzers/NUnit1027.html": {
    "href": "articles/nunit-analyzers/NUnit1027.html",
    "title": "NUnit1027 | NUnit Docs",
    "summary": "NUnit1027 The test method has parameters, but no arguments are supplied by attributes Topic Value Id NUnit1027 Severity Error Enabled True Category Structure Code TestMethodUsageAnalyzer Description The test method has parameters, but no arguments are supplied by attributes. Motivation To prevent tests that will fail at runtime due to improper construction. How to fix violations Example Violation [Test] public void SampleTest(int numberValue) { Assert.That(numberValue, Is.EqualTo(1)); } Problem In the test case above, the declares that it expects one integer parameter, but no argument is supplied by the attributes. This will lead to a runtime failure. Fix Ensure that the correct number of arguments - and of the correct type - is supplied to test methods that expect parameters. One possible fix to this problem would be to supply the argument using a TestCase: [TestCase(1)] public void SampleTest(int numberValue) { Assert.That(numberValue, Is.EqualTo(1)); } Another approach could be to supply the argument using an attribute on the argument - like Range [Test] public void SampleTest([Range(1, 10)] int numberValue) { Assert.That(numberValue, Is.EqualTo(1)); } Configure severity Via ruleset file Configure the severity per project, for more info see MSDN. Via .editorconfig file # NUnit1027: The test method has parameters, but no arguments are supplied by attributes dotnet_diagnostic.NUnit1027.severity = chosenSeverity where chosenSeverity can be one of none, silent, suggestion, warning, or error. Via #pragma directive #pragma warning disable NUnit1027 // The test method has parameters, but no arguments are supplied by attributes Code violating the rule here #pragma warning restore NUnit1027 // The test method has parameters, but no arguments are supplied by attributes Or put this at the top of the file to disable all instances. #pragma warning disable NUnit1027 // The test method has parameters, but no arguments are supplied by attributes Via attribute [SuppressMessage] [System.Diagnostics.CodeAnalysis.SuppressMessage(\"Structure\", \"NUnit1027:The test method has parameters, but no arguments are supplied by attributes\", Justification = \"Reason...\")]"
  },
  "articles/nunit-analyzers/NUnit1028.html": {
    "href": "articles/nunit-analyzers/NUnit1028.html",
    "title": "NUnit1028 | NUnit Docs",
    "summary": "NUnit1028 The non-test method is public Topic Value Id NUnit1028 Severity Info Enabled True Category Structure Code NonTestMethodAccessibilityLevelAnalyzer Description A fixture should not contain any public non-test methods. There are two exceptions: A public constructor and an IDisposable.Dispose method implementation. Motivation A fixture should be self-contained and not have methods callable by other classes. How to fix violations If the methods are purely for this class, mark them as 'private'. If the methods are used by other classes move these methods to a separate class used by the relevant test fixtures. Configure severity Via ruleset file Configure the severity per project, for more info see MSDN. Via .editorconfig file # NUnit1028: The non-test method is public dotnet_diagnostic.NUnit1028.severity = chosenSeverity where chosenSeverity can be one of none, silent, suggestion, warning, or error. Via #pragma directive #pragma warning disable NUnit1028 // The non-test method is public Code violating the rule here #pragma warning restore NUnit1028 // The non-test method is public Or put this at the top of the file to disable all instances. #pragma warning disable NUnit1028 // The non-test method is public Via attribute [SuppressMessage] [System.Diagnostics.CodeAnalysis.SuppressMessage(\"Structure\", \"NUnit1028:The non-test method is public\", Justification = \"Reason...\")]"
  },
  "articles/nunit-analyzers/NUnit1029.html": {
    "href": "articles/nunit-analyzers/NUnit1029.html",
    "title": "NUnit1029 | NUnit Docs",
    "summary": "NUnit1029 The number of parameters provided by the TestCaseSource does not match the number of parameters in the Test method Topic Value Id NUnit1029 Severity Error Enabled True Category Structure Code TestCaseSourceUsesStringAnalyzer Description The number of parameters provided by the TestCaseSource must match the number of parameters in the Test method. Note that the current implementation only works for single parameters. Motivation A TestCaseSourceAttribute is used to pass parameters to a test method, but the test method does not expect any or more parameters than supplied. private static readonly IEnumerable<string> NUnitNameSpaces = new[] { \".NUnit\", \".NUnitExtensions\" }; [TestCaseSource(nameof(NUnitNameSpaces))] public void IsNUnit() { } How to fix violations Match the number of parameters between the test data and the test method. Configure severity Via ruleset file Configure the severity per project, for more info see MSDN. Via .editorconfig file # NUnit1029: The number of parameters provided by the TestCaseSource does not match the number of parameters in the Test method dotnet_diagnostic.NUnit1029.severity = chosenSeverity where chosenSeverity can be one of none, silent, suggestion, warning, or error. Via #pragma directive #pragma warning disable NUnit1029 // The number of parameters provided by the TestCaseSource does not match the number of parameters in the Test method Code violating the rule here #pragma warning restore NUnit1029 // The number of parameters provided by the TestCaseSource does not match the number of parameters in the Test method Or put this at the top of the file to disable all instances. #pragma warning disable NUnit1029 // The number of parameters provided by the TestCaseSource does not match the number of parameters in the Test method Via attribute [SuppressMessage] [System.Diagnostics.CodeAnalysis.SuppressMessage(\"Structure\", \"NUnit1029:The number of parameters provided by the TestCaseSource does not match the number of parameters in the Test method\", Justification = \"Reason...\")]"
  },
  "articles/nunit-analyzers/NUnit1030.html": {
    "href": "articles/nunit-analyzers/NUnit1030.html",
    "title": "NUnit1030 | NUnit Docs",
    "summary": "NUnit1030 The type of parameter provided by the TestCaseSource does not match the type of the parameter in the Test method Topic Value Id NUnit1030 Severity Error Enabled True Category Structure Code TestCaseSourceUsesStringAnalyzer Description The type of parameters provided by the TestCaseSource must match the type of parameters in the Test method. Note that the current implementation only works for single parameters. Motivation A TestCaseSourceAttribute is used to pass parameters to a test method, but the test method expects a different type of parameter. private static readonly IEnumerable<string> NUnitNameSpaces = new[] { \".NUnit\", \".NUnitExtensions\" }; [TestCaseSource(nameof(NUnitNameSpaces))] public void IsNUnit(int n) { } How to fix violations Match the type of parameters between the test data and the test method. Configure severity Via ruleset file Configure the severity per project, for more info see MSDN. Via .editorconfig file # NUnit1030: The type of parameter provided by the TestCaseSource does not match the type of the parameter in the Test method dotnet_diagnostic.NUnit1030.severity = chosenSeverity where chosenSeverity can be one of none, silent, suggestion, warning, or error. Via #pragma directive #pragma warning disable NUnit1030 // The type of parameter provided by the TestCaseSource does not match the type of the parameter in the Test method Code violating the rule here #pragma warning restore NUnit1030 // The type of parameter provided by the TestCaseSource does not match the type of the parameter in the Test method Or put this at the top of the file to disable all instances. #pragma warning disable NUnit1030 // The type of parameter provided by the TestCaseSource does not match the type of the parameter in the Test method Via attribute [SuppressMessage] [System.Diagnostics.CodeAnalysis.SuppressMessage(\"Structure\", \"NUnit1030:The type of parameter provided by the TestCaseSource does not match the type of the parameter in the Test method\", Justification = \"Reason...\")]"
  },
  "articles/nunit-analyzers/NUnit1031.html": {
    "href": "articles/nunit-analyzers/NUnit1031.html",
    "title": "NUnit1031 | NUnit Docs",
    "summary": "NUnit1031 The individual arguments provided by a ValuesAttribute must match the type of the corresponding parameter of the method Topic Value Id NUnit1031 Severity Error Enabled True Category Structure Code ValuesUsageAnalyzer Description The individual arguments provided by a ValuesAttribute must match the type of the corresponding parameter of the method. Motivation To prevent tests that will fail at runtime due to improper construction. How to fix violations Example Violation [Test] public void SampleTest([Values(0.0, 1.0)] int numberValue) { Assert.That(numberValue, Is.AnyOf(0, 1)); } Problem In the test above, numberValue is declared as an integer. However, [Values(0.0, 1.0)] provides values as doubles. This will lead to a runtime failure. Fix Ensure that the type of the objects used by the ValuesAttribute matches that of the parameter. So, this fix would be acceptable: // Both use type int. [Test] public void SampleTest([Values(0, 1)] int numberValue) { Assert.That(numberValue, Is.AnyOf(0, 1)); } And this would also work: // Both use type double [Test] public void SampleTest([Values(0.0, 1.0)] double numberValue) { Assert.That(numberValue, Is.AnyOf(0, 1)); } Configure severity Via ruleset file Configure the severity per project, for more info see MSDN. Via .editorconfig file # NUnit1031: The individual arguments provided by a ValuesAttribute must match the type of the corresponding parameter of the method dotnet_diagnostic.NUnit1031.severity = chosenSeverity where chosenSeverity can be one of none, silent, suggestion, warning, or error. Via #pragma directive #pragma warning disable NUnit1031 // The individual arguments provided by a ValuesAttribute must match the type of the corresponding parameter of the method Code violating the rule here #pragma warning restore NUnit1031 // The individual arguments provided by a ValuesAttribute must match the type of the corresponding parameter of the method Or put this at the top of the file to disable all instances. #pragma warning disable NUnit1031 // The individual arguments provided by a ValuesAttribute must match the type of the corresponding parameter of the method Via attribute [SuppressMessage] [System.Diagnostics.CodeAnalysis.SuppressMessage(\"Structure\", \"NUnit1031:The individual arguments provided by a ValuesAttribute must match the type of the corresponding parameter of the method\", Justification = \"Reason...\")]"
  },
  "articles/nunit-analyzers/NUnit1032.html": {
    "href": "articles/nunit-analyzers/NUnit1032.html",
    "title": "NUnit1032 | NUnit Docs",
    "summary": "NUnit1032 An IDisposable field/property should be Disposed in a TearDown method Topic Value Id NUnit1032 Severity Error Enabled True Category Structure Code DisposeFieldsAndPropertiesInTearDownAnalyzer Description An IDisposable field/property should be Disposed in a TearDown method. This analyzer rule only applies to a TestFixture which is using the default NUnit SingleInstance life cycle where the class is instantiated once for all tests. If you are using LifeCycle.InstancePerTestCase you should dispose the fields/properties in the Dispose method of the test class. Motivation Not Disposing fields/properties can cause memory leaks or failing tests. How to fix violations LifeCycle.SingleInstance Dispose any fields/properties that are initialized in SetUp or Test methods in a TearDown method. Fields/Properties that are initialized in OneTimeSetUp, or with initializers or in constructors must be disposed in OneTimeTearDown. LifeCycle.InstancePerTestCase If you have IDisposable fields or properties, your class must implement the IDisposable interface. Dispose any fields/properties that are initialized at declaration or in the constructor in the Dispose method. The NUnit.Analyzer will not help you here as the functionality is available in Microsoft .NET Analyzers. These are the rules that will help you with this: CA1001 Types that own disposable fields should be disposable CA2213 Disposable fields should be disposed Unfortunately, those rules are not enabled by default, you can enable them in your project in a .editorconfig file using the following content: # CA1001: Types that own disposable fields should be disposable dotnet_diagnostic.CA1001.severity = warning # CA2213: Disposable fields should be disposed dotnet_diagnostic.CA2213.severity = warning Extending the list of names of disposing methods The analyzer considers the following list of method names to be disposing: Dispose, DisposeAsync, Close, and CloseAsync. It is possible to add method names to this list by using the configuration dotnet_diagnostic.NUnit1032.additional_dispose_methods in the .editorconfig. The configuration accepts a list of method names - separated by either comma, semicolon, or space. I.e. to add Quit and Exit to the list add the following line. dotnet_diagnostic.NUnit1032.additional_dispose_methods = Quit, Exit Configure severity Via ruleset file Configure the severity per project, for more info see MSDN. Via .editorconfig file # NUnit1032: An IDisposable field/property should be Disposed in a TearDown method dotnet_diagnostic.NUnit1032.severity = chosenSeverity where chosenSeverity can be one of none, silent, suggestion, warning, or error. Via #pragma directive #pragma warning disable NUnit1032 // An IDisposable field/property should be Disposed in a TearDown method Code violating the rule here #pragma warning restore NUnit1032 // An IDisposable field/property should be Disposed in a TearDown method Or put this at the top of the file to disable all instances. #pragma warning disable NUnit1032 // An IDisposable field/property should be Disposed in a TearDown method Via attribute [SuppressMessage] [System.Diagnostics.CodeAnalysis.SuppressMessage(\"Structure\", \"NUnit1032:An IDisposable field/property should be Disposed in a TearDown method\", Justification = \"Reason...\")]"
  },
  "articles/nunit-analyzers/NUnit1033.html": {
    "href": "articles/nunit-analyzers/NUnit1033.html",
    "title": "NUnit1033 | NUnit Docs",
    "summary": "NUnit1033 The Write methods on TestContext will be marked as Obsolete and eventually removed Topic Value Id NUnit1033 Severity Warning Enabled True Category Structure Code TestContextWriteIsObsoleteAnalyzer Description Direct Write calls should be replaced with Out.Write. Future version of NUnit will first mark the .Write methods on TestContext as Obsolete and eventually remove them. This rule allows updating your code before the methods are removed. Motivation The Write methods are simple wrappers calling Out.Write. There is no wrapper for Error which always required to use TestContext.Error.Write. Besides this being inconsistent, later versions of .NET added new overloads, e.g. for ReadOnlySpan<char> and async methods like WriteAsync. Instead of adding more and more dummy wrappers, it was decided that user code should use the Out property and then can use any Write overload available on TextWriter. How to fix violations Simply insert .Out between TestContext and .Write. TestContext.WriteLine(\"This isn't right\"); becomes TestContext.Out.WriteLine(\"This isn't right\"); Configure severity Via ruleset file Configure the severity per project, for more info see MSDN. Via .editorconfig file # NUnit1033: The Write methods on TestContext will be marked as Obsolete and eventually removed dotnet_diagnostic.NUnit1033.severity = chosenSeverity where chosenSeverity can be one of none, silent, suggestion, warning, or error. Via #pragma directive #pragma warning disable NUnit1033 // The Write methods on TestContext will be marked as Obsolete and eventually removed Code violating the rule here #pragma warning restore NUnit1033 // The Write methods on TestContext will be marked as Obsolete and eventually removed Or put this at the top of the file to disable all instances. #pragma warning disable NUnit1033 // The Write methods on TestContext will be marked as Obsolete and eventually removed Via attribute [SuppressMessage] [System.Diagnostics.CodeAnalysis.SuppressMessage(\"Structure\", \"NUnit1033:The Write methods on TestContext will be marked as Obsolete and eventually removed\", Justification = \"Reason...\")]"
  },
  "articles/nunit-analyzers/NUnit1034.html": {
    "href": "articles/nunit-analyzers/NUnit1034.html",
    "title": "NUnit1034 | NUnit Docs",
    "summary": "NUnit1034 Base TestFixtures should be abstract Topic Value Id NUnit1034 Severity Warning Enabled True Category Structure Code TestFixtureShouldBeAbstractAnalyzer Description Base TestFixtures should be abstract to prevent base class tests executing separately. Motivation When a base class is not abstract it will also be run as a standalone test which is most times not the intention. namespace Tests { internal class ParentFixture { [Test] public void ParentTest() { Assert.Pass($\"Run {nameof(ParentTest)} from class {GetType().Name}\"); } } internal class ChildFixture : ParentFixture { [Test] public void ChildTest() { Assert.Pass($\"Run {nameof(ChildTest)} from class {GetType().Name}\"); } } } As the Parent class is valid as a standalone TestFixture it will be instantiated and run separately. ChildTest: Run ChildTest from class ChildFixture ParentTest: Run ParentTest from class ChildFixture ParentTest: Run ParentTest from class ParentFixture This rule only fires when a class is found to be used as a base class in the current compilation. How to fix violations Mark any base class test fixture as abstract: internal abstract class Parent { [Test] public void ParentRun() { Assert.Pass($\"Run {nameof(ParentRun)} from {GetType().Name}\"); } } Configure severity Via ruleset file Configure the severity per project, for more info see MSDN. Via .editorconfig file # NUnit1034: Base TestFixtures should be abstract dotnet_diagnostic.NUnit1034.severity = chosenSeverity where chosenSeverity can be one of none, silent, suggestion, warning, or error. Via #pragma directive #pragma warning disable NUnit1034 // Base TestFixtures should be abstract Code violating the rule here #pragma warning restore NUnit1034 // Base TestFixtures should be abstract Or put this at the top of the file to disable all instances. #pragma warning disable NUnit1034 // Base TestFixtures should be abstract Via attribute [SuppressMessage] [System.Diagnostics.CodeAnalysis.SuppressMessage(\"Structure\", \"NUnit1034:Base TestFixtures should be abstract\", Justification = \"Reason...\")]"
  },
  "articles/nunit-analyzers/NUnit1035.html": {
    "href": "articles/nunit-analyzers/NUnit1035.html",
    "title": "NUnit1035 | NUnit Docs",
    "summary": "NUnit1035 The 'step' parameter to Range cannot be zero Topic Value Id NUnit1035 Severity Error Enabled True Category Structure Code RangeUsageAnalyzer Description The 'step' parameter to Range cannot be zero. Motivation The Range attribute is used to specify a range of values for a parameter in a test method. The step parameter defines the increment between each value in the range. If the step is zero, it would create an infinite loop of the same value. To prevent this NUnit will throw an exception at runtime. [TestFixture] public class MyTests { private const int Step = 10 / 100; // 10% step [Test] public void TestMethod([Range(0, 10, Step)] int value) { // Test code here } } How to fix violations Specify a non-zero value for the step parameter in the Range attribute. [TestFixture] public class MyTests { private const double Step = 10.0 / 100.0; // 10% step [Test] public void TestMethod([Range(0.0, 10.0, Step)] double value) { // Test code here } } Configure severity Via ruleset file Configure the severity per project, for more info see MSDN. Via .editorconfig file # NUnit1035: The 'step' parameter to Range cannot be zero dotnet_diagnostic.NUnit1035.severity = chosenSeverity where chosenSeverity can be one of none, silent, suggestion, warning, or error. Via #pragma directive #pragma warning disable NUnit1035 // The 'step' parameter to Range cannot be zero Code violating the rule here #pragma warning restore NUnit1035 // The 'step' parameter to Range cannot be zero Or put this at the top of the file to disable all instances. #pragma warning disable NUnit1035 // The 'step' parameter to Range cannot be zero Via attribute [SuppressMessage] [System.Diagnostics.CodeAnalysis.SuppressMessage(\"Structure\", \"NUnit1035:The 'step' parameter to Range cannot be zero\", Justification = \"Reason...\")]"
  },
  "articles/nunit-analyzers/NUnit1036.html": {
    "href": "articles/nunit-analyzers/NUnit1036.html",
    "title": "NUnit1036 | NUnit Docs",
    "summary": "NUnit1036 The value for 'from' must be less than 'to' when 'step' is positive Topic Value Id NUnit1036 Severity Error Enabled True Category Structure Code RangeUsageAnalyzer Description Ensure that 'to' is greater than 'from' when 'step' is positive. Motivation The Range attribute is used to specify a range of values for a parameter in a test method. If the from value is greater than the to value when the step is positive, this would result in no valid range. To prevent this NUnit will throw an exception at runtime. [Test] public void TestMethod([Range(10, 0, 2)] int value) { // Test code here } How to fix violations Either specify a to value that is greater than the from value, or use a negative step value if the intention is to generate values in reverse order. [Test] public void TestMethod([Range(0, 10, 2)] int value) { // Test code here } Configure severity Via ruleset file Configure the severity per project, for more info see MSDN. Via .editorconfig file # NUnit1036: The value for 'from' must be less than 'to' when 'step' is positive dotnet_diagnostic.NUnit1036.severity = chosenSeverity where chosenSeverity can be one of none, silent, suggestion, warning, or error. Via #pragma directive #pragma warning disable NUnit1036 // The value for 'from' must be less than 'to' when 'step' is positive Code violating the rule here #pragma warning restore NUnit1036 // The value for 'from' must be less than 'to' when 'step' is positive Or put this at the top of the file to disable all instances. #pragma warning disable NUnit1036 // The value for 'from' must be less than 'to' when 'step' is positive Via attribute [SuppressMessage] [System.Diagnostics.CodeAnalysis.SuppressMessage(\"Structure\", \"NUnit1036:The value for 'from' must be less than 'to' when 'step' is positive\", Justification = \"Reason...\")]"
  },
  "articles/nunit-analyzers/NUnit1037.html": {
    "href": "articles/nunit-analyzers/NUnit1037.html",
    "title": "NUnit1037 | NUnit Docs",
    "summary": "NUnit1037 The value for 'from' must be greater than 'to' when 'step' is negative Topic Value Id NUnit1037 Severity Error Enabled True Category Structure Code RangeUsageAnalyzer Description Ensure that 'from' is greater than 'to' when 'step' is negative. Motivation The Range attribute is used to specify a range of values for a parameter in a test method. If the from value is less than the to value when the step is negative, this would result in endless range. To prevent this NUnit will throw an exception at runtime. [Test] public void TestMethod([Range(0, 10, -1)] int value) { // Test code here } How to fix violations Either specify a to value that is less than the from value, or use a positive step value if the intention is to generate values in ascending order. [Test] public void TestMethod([Range(0, 10, 1)] int value) { // Test code here } Configure severity Via ruleset file Configure the severity per project, for more info see MSDN. Via .editorconfig file # NUnit1037: The value for 'from' must be greater than 'to' when 'step' is negative dotnet_diagnostic.NUnit1037.severity = chosenSeverity where chosenSeverity can be one of none, silent, suggestion, warning, or error. Via #pragma directive #pragma warning disable NUnit1037 // The value for 'from' must be greater than 'to' when 'step' is negative Code violating the rule here #pragma warning restore NUnit1037 // The value for 'from' must be greater than 'to' when 'step' is negative Or put this at the top of the file to disable all instances. #pragma warning disable NUnit1037 // The value for 'from' must be greater than 'to' when 'step' is negative Via attribute [SuppressMessage] [System.Diagnostics.CodeAnalysis.SuppressMessage(\"Structure\", \"NUnit1037:The value for 'from' must be greater than 'to' when 'step' is negative\", Justification = \"Reason...\")]"
  },
  "articles/nunit-analyzers/NUnit1038.html": {
    "href": "articles/nunit-analyzers/NUnit1038.html",
    "title": "NUnit1038 | NUnit Docs",
    "summary": "NUnit1038 The type of the attribute values doesn't match the parameter type Topic Value Id NUnit1038 Severity Error Enabled True Category Structure Code RangeUsageAnalyzer Description Ensure that the attribute and parameter types match. Motivation The Range attribute is used to specify a range of values for a parameter in a test method. The type of the range values must match the type of the parameter. If NUnit cannot match the types, it will throw an exception at runtime. NUnit rules are that an int can be assigned to any integral type or to a double or decimal. [Test] public void TestMethod([Range(1.0, 2.0, 0.1)] int value) { // Test code here } How to fix violations Ensure that the type of the range values matches the type of the parameter. [Test] public void TestMethod([Range(1.0, 2.0, 0.1)] double value) { // Test code here } Configure severity Via ruleset file Configure the severity per project, for more info see MSDN. Via .editorconfig file # NUnit1038: The type of the attribute values doesn't match the parameter type dotnet_diagnostic.NUnit1038.severity = chosenSeverity where chosenSeverity can be one of none, silent, suggestion, warning, or error. Via #pragma directive #pragma warning disable NUnit1038 // The type of the attribute values doesn't match the parameter type Code violating the rule here #pragma warning restore NUnit1038 // The type of the attribute values doesn't match the parameter type Or put this at the top of the file to disable all instances. #pragma warning disable NUnit1038 // The type of the attribute values doesn't match the parameter type Via attribute [SuppressMessage] [System.Diagnostics.CodeAnalysis.SuppressMessage(\"Structure\", \"NUnit1038:The type of the attribute values doesn't match the parameter type\", Justification = \"Reason...\")]"
  },
  "articles/nunit-analyzers/NUnit2001.html": {
    "href": "articles/nunit-analyzers/NUnit2001.html",
    "title": "NUnit2001 | NUnit Docs",
    "summary": "NUnit2001 Consider using Assert.That(expr, Is.False) instead of ClassicAssert.False(expr) Topic Value Id NUnit2001 Severity Info Enabled True Category Assertion Code ClassicModelAssertUsageAnalyzer Description Consider using the constraint model, Assert.That(expr, Is.False), instead of the classic model, ClassicAssert.False(expr). Motivation The classic Assert model contains less flexibility than the constraint model, so this analyzer marks usages of ClassicAssert.False from the classic Assert model. [Test] public void Test() { ClassicAssert.False(expression); } How to fix violations The analyzer comes with a code fix that will replace ClassicAssert.False(expression) with Assert.That(expression, Is.False). So the code block above will be changed into. [Test] public void Test() { Assert.That(expression, Is.False); } Configure severity Via ruleset file Configure the severity per project, for more info see MSDN. Via .editorconfig file # NUnit2001: Consider using Assert.That(expr, Is.False) instead of ClassicAssert.False(expr) dotnet_diagnostic.NUnit2001.severity = chosenSeverity where chosenSeverity can be one of none, silent, suggestion, warning, or error. Via #pragma directive #pragma warning disable NUnit2001 // Consider using Assert.That(expr, Is.False) instead of ClassicAssert.False(expr) Code violating the rule here #pragma warning restore NUnit2001 // Consider using Assert.That(expr, Is.False) instead of ClassicAssert.False(expr) Or put this at the top of the file to disable all instances. #pragma warning disable NUnit2001 // Consider using Assert.That(expr, Is.False) instead of ClassicAssert.False(expr) Via attribute [SuppressMessage] [System.Diagnostics.CodeAnalysis.SuppressMessage(\"Assertion\", \"NUnit2001:Consider using Assert.That(expr, Is.False) instead of ClassicAssert.False(expr)\", Justification = \"Reason...\")]"
  },
  "articles/nunit-analyzers/NUnit2002.html": {
    "href": "articles/nunit-analyzers/NUnit2002.html",
    "title": "NUnit2002 | NUnit Docs",
    "summary": "NUnit2002 Consider using Assert.That(expr, Is.False) instead of ClassicAssert.IsFalse(expr) Topic Value Id NUnit2002 Severity Info Enabled True Category Assertion Code ClassicModelAssertUsageAnalyzer Description Consider using the constraint model, Assert.That(expr, Is.False), instead of the classic model, ClassicAssert.IsFalse(expr). Motivation The classic Assert model contains less flexibility than the constraint model, so this analyzer marks usages of ClassicAssert.IsFalse from the classic Assert model. [Test] public void Test() { ClassicAssert.IsFalse(expression); } How to fix violations The analyzer comes with a code fix that will replace ClassicAssert.IsFalse(expression) with Assert.That(expression, Is.False). So the code block above will be changed into. [Test] public void Test() { Assert.That(expression, Is.False); } Configure severity Via ruleset file Configure the severity per project, for more info see MSDN. Via .editorconfig file # NUnit2002: Consider using Assert.That(expr, Is.False) instead of ClassicAssert.IsFalse(expr) dotnet_diagnostic.NUnit2002.severity = chosenSeverity where chosenSeverity can be one of none, silent, suggestion, warning, or error. Via #pragma directive #pragma warning disable NUnit2002 // Consider using Assert.That(expr, Is.False) instead of ClassicAssert.IsFalse(expr) Code violating the rule here #pragma warning restore NUnit2002 // Consider using Assert.That(expr, Is.False) instead of ClassicAssert.IsFalse(expr) Or put this at the top of the file to disable all instances. #pragma warning disable NUnit2002 // Consider using Assert.That(expr, Is.False) instead of ClassicAssert.IsFalse(expr) Via attribute [SuppressMessage] [System.Diagnostics.CodeAnalysis.SuppressMessage(\"Assertion\", \"NUnit2002:Consider using Assert.That(expr, Is.False) instead of ClassicAssert.IsFalse(expr)\", Justification = \"Reason...\")]"
  },
  "articles/nunit-analyzers/NUnit2003.html": {
    "href": "articles/nunit-analyzers/NUnit2003.html",
    "title": "NUnit2003 | NUnit Docs",
    "summary": "NUnit2003 Consider using Assert.That(expr, Is.True) instead of ClassicAssert.IsTrue(expr) Topic Value Id NUnit2003 Severity Info Enabled True Category Assertion Code ClassicModelAssertUsageAnalyzer Description Consider using the constraint model, Assert.That(expr, Is.True), instead of the classic model, ClassicAssert.IsTrue(expr). Motivation The classic Assert model contains less flexibility than the constraint model, so this analyzer marks usages of ClassicAssert.IsTrue from the classic Assert model. [Test] public void Test() { ClassicAssert.IsTrue(expression); } How to fix violations The analyzer comes with a code fix that will replace ClassicAssert.IsTrue(expression) with Assert.That(expression, Is.True). So the code block above will be changed into. [Test] public void Test() { Assert.That(expression, Is.True); } Configure severity Via ruleset file Configure the severity per project, for more info see MSDN. Via .editorconfig file # NUnit2003: Consider using Assert.That(expr, Is.True) instead of ClassicAssert.IsTrue(expr) dotnet_diagnostic.NUnit2003.severity = chosenSeverity where chosenSeverity can be one of none, silent, suggestion, warning, or error. Via #pragma directive #pragma warning disable NUnit2003 // Consider using Assert.That(expr, Is.True) instead of ClassicAssert.IsTrue(expr) Code violating the rule here #pragma warning restore NUnit2003 // Consider using Assert.That(expr, Is.True) instead of ClassicAssert.IsTrue(expr) Or put this at the top of the file to disable all instances. #pragma warning disable NUnit2003 // Consider using Assert.That(expr, Is.True) instead of ClassicAssert.IsTrue(expr) Via attribute [SuppressMessage] [System.Diagnostics.CodeAnalysis.SuppressMessage(\"Assertion\", \"NUnit2003:Consider using Assert.That(expr, Is.True) instead of ClassicAssert.IsTrue(expr)\", Justification = \"Reason...\")]"
  },
  "articles/nunit-analyzers/NUnit2004.html": {
    "href": "articles/nunit-analyzers/NUnit2004.html",
    "title": "NUnit2004 | NUnit Docs",
    "summary": "NUnit2004 Consider using Assert.That(expr, Is.True) instead of ClassicAssert.True(expr) Topic Value Id NUnit2004 Severity Info Enabled True Category Assertion Code ClassicModelAssertUsageAnalyzer Description Consider using the constraint model, Assert.That(expr, Is.True), instead of the classic model, ClassicAssert.True(expr). Motivation The classic Assert model contains less flexibility than the constraint model, so this analyzer marks usages of ClassicAssert.True from the classic Assert model. [Test] public void Test() { ClassicAssert.True(expression); } How to fix violations The analyzer comes with a code fix that will replace ClassicAssert.True(expression) with Assert.That(expression, Is.True). So the code block above will be changed into. [Test] public void Test() { Assert.That(expression, Is.True); } Configure severity Via ruleset file Configure the severity per project, for more info see MSDN. Via .editorconfig file # NUnit2004: Consider using Assert.That(expr, Is.True) instead of ClassicAssert.True(expr) dotnet_diagnostic.NUnit2004.severity = chosenSeverity where chosenSeverity can be one of none, silent, suggestion, warning, or error. Via #pragma directive #pragma warning disable NUnit2004 // Consider using Assert.That(expr, Is.True) instead of ClassicAssert.True(expr) Code violating the rule here #pragma warning restore NUnit2004 // Consider using Assert.That(expr, Is.True) instead of ClassicAssert.True(expr) Or put this at the top of the file to disable all instances. #pragma warning disable NUnit2004 // Consider using Assert.That(expr, Is.True) instead of ClassicAssert.True(expr) Via attribute [SuppressMessage] [System.Diagnostics.CodeAnalysis.SuppressMessage(\"Assertion\", \"NUnit2004:Consider using Assert.That(expr, Is.True) instead of ClassicAssert.True(expr)\", Justification = \"Reason...\")]"
  },
  "articles/nunit-analyzers/NUnit2005.html": {
    "href": "articles/nunit-analyzers/NUnit2005.html",
    "title": "NUnit2005 | NUnit Docs",
    "summary": "NUnit2005 Consider using Assert.That(actual, Is.EqualTo(expected)) instead of ClassicAssert.AreEqual(expected, actual) Topic Value Id NUnit2005 Severity Warning Enabled True Category Assertion Code ClassicModelAssertUsageAnalyzer Description Consider using the constraint model, Assert.That(actual, Is.EqualTo(expected)), instead of the classic model, ClassicAssert.AreEqual(expected, actual). Motivation The classic Assert model, ClassicAssert.AreEqual(expected, actual), makes it easy to mix the expected and the actual parameter, so this analyzer marks usages of ClassicAssert.AreEqual from the classic Assert model. [Test] public void Test() { ClassicAssert.AreEqual(expression1, expression2); } How to fix violations The analyzer comes with a code fix that will replace ClassicAssert.AreEqual(expression1, expression2) with Assert.That(expression2, Is.EqualTo(expression1)). So the code block above will be changed into. [Test] public void Test() { Assert.That(expression2, Is.EqualTo(expression1)); } Configure severity Via ruleset file Configure the severity per project, for more info see MSDN. Via .editorconfig file # NUnit2005: Consider using Assert.That(actual, Is.EqualTo(expected)) instead of ClassicAssert.AreEqual(expected, actual) dotnet_diagnostic.NUnit2005.severity = chosenSeverity where chosenSeverity can be one of none, silent, suggestion, warning, or error. Via #pragma directive #pragma warning disable NUnit2005 // Consider using Assert.That(actual, Is.EqualTo(expected)) instead of ClassicAssert.AreEqual(expected, actual) Code violating the rule here #pragma warning restore NUnit2005 // Consider using Assert.That(actual, Is.EqualTo(expected)) instead of ClassicAssert.AreEqual(expected, actual) Or put this at the top of the file to disable all instances. #pragma warning disable NUnit2005 // Consider using Assert.That(actual, Is.EqualTo(expected)) instead of ClassicAssert.AreEqual(expected, actual) Via attribute [SuppressMessage] [System.Diagnostics.CodeAnalysis.SuppressMessage(\"Assertion\", \"NUnit2005:Consider using Assert.That(actual, Is.EqualTo(expected)) instead of ClassicAssert.AreEqual(expected, actual)\", Justification = \"Reason...\")]"
  },
  "articles/nunit-analyzers/NUnit2006.html": {
    "href": "articles/nunit-analyzers/NUnit2006.html",
    "title": "NUnit2006 | NUnit Docs",
    "summary": "NUnit2006 Consider using Assert.That(actual, Is.Not.EqualTo(expected)) instead of ClassicAssert.AreNotEqual(expected, actual) Topic Value Id NUnit2006 Severity Warning Enabled True Category Assertion Code ClassicModelAssertUsageAnalyzer Description Consider using the constraint model, Assert.That(actual, Is.Not.EqualTo(expected)), instead of the classic model, ClassicAssert.AreNotEqual(expected, actual). Motivation The classic Assert model, ClassicAssert.AreNotEqual(expected, actual), makes it easy to mix the expected and the actual parameter, so this analyzer marks usages of ClassicAssert.AreNotEqual from the classic Assert model. [Test] public void Test() { ClassicAssert.AreNotEqual(expression1, expression2) } How to fix violations The analyzer comes with a code fix that will replace ClassicAssert.AreNotEqual(expression1, expression2) with Assert.That(expression2, Is.Not.EqualTo(expression1)). So the code block above will be changed into. [Test] public void Test() { Assert.That(expression2, Is.Not.EqualTo(expression1)); } Configure severity Via ruleset file Configure the severity per project, for more info see MSDN. Via .editorconfig file # NUnit2006: Consider using Assert.That(actual, Is.Not.EqualTo(expected)) instead of ClassicAssert.AreNotEqual(expected, actual) dotnet_diagnostic.NUnit2006.severity = chosenSeverity where chosenSeverity can be one of none, silent, suggestion, warning, or error. Via #pragma directive #pragma warning disable NUnit2006 // Consider using Assert.That(actual, Is.Not.EqualTo(expected)) instead of ClassicAssert.AreNotEqual(expected, actual) Code violating the rule here #pragma warning restore NUnit2006 // Consider using Assert.That(actual, Is.Not.EqualTo(expected)) instead of ClassicAssert.AreNotEqual(expected, actual) Or put this at the top of the file to disable all instances. #pragma warning disable NUnit2006 // Consider using Assert.That(actual, Is.Not.EqualTo(expected)) instead of ClassicAssert.AreNotEqual(expected, actual) Via attribute [SuppressMessage] [System.Diagnostics.CodeAnalysis.SuppressMessage(\"Assertion\", \"NUnit2006:Consider using Assert.That(actual, Is.Not.EqualTo(expected)) instead of ClassicAssert.AreNotEqual(expected, actual)\", Justification = \"Reason...\")]"
  },
  "articles/nunit-analyzers/NUnit2007.html": {
    "href": "articles/nunit-analyzers/NUnit2007.html",
    "title": "NUnit2007 | NUnit Docs",
    "summary": "NUnit2007 The actual value should not be a constant Topic Value Id NUnit2007 Severity Warning Enabled True Category Assertion Code ConstActualValueUsageAnalyzer Description The actual value should not be a constant. This indicates that the actual value and the expected value have switched places. Motivation Bring developers' attention to a scenario in which their test is most likely testing the wrong thing, or to cases where their actual and expected values may be accidentally swapped. How to fix violations Example Violation [Test] public void NUnit2007SampleTest() { var x = 5; Assert.That(5, Is.EqualTo(x)); ClassicAssert.AreEqual(x, 5); } Explanation Both asserts above will trigger this warning. That's because the actual value should be the value produced by your code, not a constant value that you're expecting (which should be in the place of the expected value). In the case of equality, etc. this might seem like no big deal, but it really comes into play in the exceptions that are raised by error messages. It's important that if your test fails, the message can correctly tell you what the expected and actual values are. As an aside, this is another reason why the Assert.That syntax is often preferred when asserting equality. Fix Flip the actual and expected values so that your expected value is the constant and your actual value has been generated by code. [Test] public void NUnit2007SampleTest() { var x = 5; Assert.That(x, Is.EqualTo(5)); ClassicAssert.AreEqual(5, x); } Configure severity Via ruleset file Configure the severity per project, for more info see MSDN. Via .editorconfig file # NUnit2007: The actual value should not be a constant dotnet_diagnostic.NUnit2007.severity = chosenSeverity where chosenSeverity can be one of none, silent, suggestion, warning, or error. Via #pragma directive #pragma warning disable NUnit2007 // The actual value should not be a constant Code violating the rule here #pragma warning restore NUnit2007 // The actual value should not be a constant Or put this at the top of the file to disable all instances. #pragma warning disable NUnit2007 // The actual value should not be a constant Via attribute [SuppressMessage] [System.Diagnostics.CodeAnalysis.SuppressMessage(\"Assertion\", \"NUnit2007:The actual value should not be a constant\", Justification = \"Reason...\")]"
  },
  "articles/nunit-analyzers/NUnit2008.html": {
    "href": "articles/nunit-analyzers/NUnit2008.html",
    "title": "NUnit2008 | NUnit Docs",
    "summary": "NUnit2008 Incorrect IgnoreCase usage Topic Value Id NUnit2008 Severity Warning Enabled True Category Assertion Code IgnoreCaseUsageAnalyzer Description The IgnoreCase modifier should only be used for string or char arguments. Using it on another type will not have any effect. Motivation To bring developers' attention to a scenario in which their code is actually having no effect and may reveal that their test is not doing what they expect. How to fix violations Example Violation [Test] public void NUnit2008SampleTest() { var date = DateTime.Now; Assert.That(date, Is.Not.EqualTo(date.AddDays(1)).IgnoreCase); } Explanation Using IgnoreCase here doesn't make any sense, because the types we're comparing don't have the concept of case. Therefore, it's only suitable to use on textual primitives (e.g. string and char). Fix Remove the errant call to IgnoreCase: [Test] public void NUnit2008SampleTest() { var date = DateTime.Now; Assert.That(date, Is.Not.EqualTo(date.AddDays(1))); } Or update the code to compare based on the primitives that are supported by IgnoreCase: [Test] public void NUnit2008SampleTest() { var date = DateTime.Now; Assert.That(date.ToString(), Is.Not.EqualTo(date.AddDays(1).ToString()).IgnoreCase); } Configure severity Via ruleset file Configure the severity per project, for more info see MSDN. Via .editorconfig file # NUnit2008: Incorrect IgnoreCase usage dotnet_diagnostic.NUnit2008.severity = chosenSeverity where chosenSeverity can be one of none, silent, suggestion, warning, or error. Via #pragma directive #pragma warning disable NUnit2008 // Incorrect IgnoreCase usage Code violating the rule here #pragma warning restore NUnit2008 // Incorrect IgnoreCase usage Or put this at the top of the file to disable all instances. #pragma warning disable NUnit2008 // Incorrect IgnoreCase usage Via attribute [SuppressMessage] [System.Diagnostics.CodeAnalysis.SuppressMessage(\"Assertion\", \"NUnit2008:Incorrect IgnoreCase usage\", Justification = \"Reason...\")]"
  },
  "articles/nunit-analyzers/NUnit2009.html": {
    "href": "articles/nunit-analyzers/NUnit2009.html",
    "title": "NUnit2009 | NUnit Docs",
    "summary": "NUnit2009 The same value has been provided as both the actual and the expected argument Topic Value Id NUnit2009 Severity Warning Enabled True Category Assertion Code SameActualExpectedValueAnalyzer Description The same value has been provided as both the actual and the expected argument. This indicates a coding error. Motivation To bring developers' attention to a situation in which their code may not be operating as expected and their test may not be testing what they expect. How to fix violations Sample Violation [Test] public void NUnit2009SampleTest() { var x = 1; Assert.That(x, Is.EqualTo(x)); } Explanation In the above example, the test will always be correct, because we're comparing the same value. That is to say, we're not actually testing anything. Fix Ensure the expected and actual values come from different places. [Test] public void NUnit2009SampleTest() { var x = 1; Assert.That(x, Is.EqualTo(1)); } Configure severity Via ruleset file Configure the severity per project, for more info see MSDN. Via .editorconfig file # NUnit2009: The same value has been provided as both the actual and the expected argument dotnet_diagnostic.NUnit2009.severity = chosenSeverity where chosenSeverity can be one of none, silent, suggestion, warning, or error. Via #pragma directive #pragma warning disable NUnit2009 // The same value has been provided as both the actual and the expected argument Code violating the rule here #pragma warning restore NUnit2009 // The same value has been provided as both the actual and the expected argument Or put this at the top of the file to disable all instances. #pragma warning disable NUnit2009 // The same value has been provided as both the actual and the expected argument Via attribute [SuppressMessage] [System.Diagnostics.CodeAnalysis.SuppressMessage(\"Assertion\", \"NUnit2009:The same value has been provided as both the actual and the expected argument\", Justification = \"Reason...\")]"
  },
  "articles/nunit-analyzers/NUnit2010.html": {
    "href": "articles/nunit-analyzers/NUnit2010.html",
    "title": "NUnit2010 | NUnit Docs",
    "summary": "NUnit2010 Use EqualConstraint for better assertion messages in case of failure Topic Value Id NUnit2010 Severity Info Enabled True Category Assertion Code EqualConstraintUsageAnalyzer Description Using EqualConstraint will lead to better assertion messages in case of failure. Motivation Using Is.EqualTo (or Is.Not.EqualTo) constraint will lead to better assertion messages in case of failure, so this analyzer marks all usages of == operator and Equals method where it is possible to replace with Is.EqualTo constraint. [Test] public void Test() { ClassicAssert.True(actual == expected); } How to fix violations The analyzer comes with a code fix that will replace ClassicAssert.True(actual == expected) with Assert.That(actual, Is.EqualTo(expected)). So the code block above will be changed into [Test] public void Test() { Assert.That(actual, Is.EqualTo(expected)); } Configure severity Via ruleset file Configure the severity per project, for more info see MSDN. Via .editorconfig file # NUnit2010: Use EqualConstraint for better assertion messages in case of failure dotnet_diagnostic.NUnit2010.severity = chosenSeverity where chosenSeverity can be one of none, silent, suggestion, warning, or error. Via #pragma directive #pragma warning disable NUnit2010 // Use EqualConstraint for better assertion messages in case of failure Code violating the rule here #pragma warning restore NUnit2010 // Use EqualConstraint for better assertion messages in case of failure Or put this at the top of the file to disable all instances. #pragma warning disable NUnit2010 // Use EqualConstraint for better assertion messages in case of failure Via attribute [SuppressMessage] [System.Diagnostics.CodeAnalysis.SuppressMessage(\"Assertion\", \"NUnit2010:Use EqualConstraint for better assertion messages in case of failure\", Justification = \"Reason...\")]"
  },
  "articles/nunit-analyzers/NUnit2011.html": {
    "href": "articles/nunit-analyzers/NUnit2011.html",
    "title": "NUnit2011 | NUnit Docs",
    "summary": "NUnit2011 Use ContainsConstraint for better assertion messages in case of failure Topic Value Id NUnit2011 Severity Info Enabled True Category Assertion Code StringConstraintUsageAnalyzer Description Using constraints instead of boolean methods will lead to better assertion messages in case of failure. Motivation Using Does.Contain (or Does.Not.Contain) constraint will lead to better assertion messages in case of failure, so this analyzer marks all usages of string Contains method where it is possible to replace with Does.Contain constraint. [Test] public void Test() { string actual = \"...\"; string expected = \"...\"; ClassicAssert.True(actual.Contains(expected)); } How to fix violations The analyzer comes with a code fix that will replace ClassicAssert.True(actual.Contains(expected)) with Assert.That(actual, Does.Contain(expected)). So the code block above will be changed into [Test] public void Test() { string actual = \"...\"; string expected = \"...\"; Assert.That(actual, Does.Contain(expected)); } Configure severity Via ruleset file Configure the severity per project, for more info see MSDN. Via .editorconfig file # NUnit2011: Use ContainsConstraint for better assertion messages in case of failure dotnet_diagnostic.NUnit2011.severity = chosenSeverity where chosenSeverity can be one of none, silent, suggestion, warning, or error. Via #pragma directive #pragma warning disable NUnit2011 // Use ContainsConstraint for better assertion messages in case of failure Code violating the rule here #pragma warning restore NUnit2011 // Use ContainsConstraint for better assertion messages in case of failure Or put this at the top of the file to disable all instances. #pragma warning disable NUnit2011 // Use ContainsConstraint for better assertion messages in case of failure Via attribute [SuppressMessage] [System.Diagnostics.CodeAnalysis.SuppressMessage(\"Assertion\", \"NUnit2011:Use ContainsConstraint for better assertion messages in case of failure\", Justification = \"Reason...\")]"
  },
  "articles/nunit-analyzers/NUnit2012.html": {
    "href": "articles/nunit-analyzers/NUnit2012.html",
    "title": "NUnit2012 | NUnit Docs",
    "summary": "NUnit2012 Use StartsWithConstraint for better assertion messages in case of failure Topic Value Id NUnit2012 Severity Info Enabled True Category Assertion Code StringConstraintUsageAnalyzer Description Using constraints instead of boolean methods will lead to better assertion messages in case of failure. Motivation Using Does.StartWith (or Does.Not.StartWith) constraint will lead to better assertion messages in case of failure, so this analyzer marks all usages of string StartsWith method where it is possible to replace with Does.StartWith constraint. [Test] public void Test() { string actual = \"...\"; string expected = \"...\"; ClassicAssert.True(actual.StartsWith(expected)); } How to fix violations The analyzer comes with a code fix that will replace ClassicAssert.True(actual.StartWith(expected)) with Assert.That(actual, Does.StartWith(expected)). So the code block above will be changed into [Test] public void Test() { string actual = \"...\"; string expected = \"...\"; Assert.That(actual, Does.StartWith(expected)); } Configure severity Via ruleset file Configure the severity per project, for more info see MSDN. Via .editorconfig file # NUnit2012: Use StartsWithConstraint for better assertion messages in case of failure dotnet_diagnostic.NUnit2012.severity = chosenSeverity where chosenSeverity can be one of none, silent, suggestion, warning, or error. Via #pragma directive #pragma warning disable NUnit2012 // Use StartsWithConstraint for better assertion messages in case of failure Code violating the rule here #pragma warning restore NUnit2012 // Use StartsWithConstraint for better assertion messages in case of failure Or put this at the top of the file to disable all instances. #pragma warning disable NUnit2012 // Use StartsWithConstraint for better assertion messages in case of failure Via attribute [SuppressMessage] [System.Diagnostics.CodeAnalysis.SuppressMessage(\"Assertion\", \"NUnit2012:Use StartsWithConstraint for better assertion messages in case of failure\", Justification = \"Reason...\")]"
  },
  "articles/nunit-analyzers/NUnit2013.html": {
    "href": "articles/nunit-analyzers/NUnit2013.html",
    "title": "NUnit2013 | NUnit Docs",
    "summary": "NUnit2013 Use EndsWithConstraint for better assertion messages in case of failure Topic Value Id NUnit2013 Severity Info Enabled True Category Assertion Code StringConstraintUsageAnalyzer Description Using constraints instead of boolean methods will lead to better assertion messages in case of failure. Motivation Using Does.EndWith (or Does.Not.EndWith) constraint will lead to better assertion messages in case of failure, so this analyzer marks all usages of string EndsWith method where it is possible to replace with Does.EndWith constraint. [Test] public void Test() { string actual = \"...\"; string expected = \"...\"; ClassicAssert.True(actual.EndsWith(expected)); } How to fix violations The analyzer comes with a code fix that will replace ClassicAssert.True(actual.EndsWith(expected)) with Assert.That(actual, Does.EndWith(expected)). So the code block above will be changed into [Test] public void Test() { string actual = \"...\"; string expected = \"...\"; Assert.That(actual, Does.EndWith(expected)); } Configure severity Via ruleset file Configure the severity per project, for more info see MSDN. Via .editorconfig file # NUnit2013: Use EndsWithConstraint for better assertion messages in case of failure dotnet_diagnostic.NUnit2013.severity = chosenSeverity where chosenSeverity can be one of none, silent, suggestion, warning, or error. Via #pragma directive #pragma warning disable NUnit2013 // Use EndsWithConstraint for better assertion messages in case of failure Code violating the rule here #pragma warning restore NUnit2013 // Use EndsWithConstraint for better assertion messages in case of failure Or put this at the top of the file to disable all instances. #pragma warning disable NUnit2013 // Use EndsWithConstraint for better assertion messages in case of failure Via attribute [SuppressMessage] [System.Diagnostics.CodeAnalysis.SuppressMessage(\"Assertion\", \"NUnit2013:Use EndsWithConstraint for better assertion messages in case of failure\", Justification = \"Reason...\")]"
  },
  "articles/nunit-analyzers/NUnit2014.html": {
    "href": "articles/nunit-analyzers/NUnit2014.html",
    "title": "NUnit2014 | NUnit Docs",
    "summary": "NUnit2014 Use SomeItemsConstraint for better assertion messages in case of failure Topic Value Id NUnit2014 Severity Info Enabled True Category Assertion Code SomeItemsConstraintUsageAnalyzer Description Using SomeItemsConstraint will lead to better assertion messages in case of failure. Motivation Using Does.Contain (or Does.Not.Contain) constraint will lead to better assertion messages in case of failure, so this analyzer marks all usages of string Contains method where it is possible to replace with Does.Contain constraint. [Test] public void Test() { var actual = new List<int> {1,2,3}; int expected = 1; ClassicAssert.True(actual.Contains(expected)); } How to fix violations The analyzer comes with a code fix that will replace ClassicAssert.True(actual.Contains(expected)) with Assert.That(actual, Does.Contain(expected)). So the code block above will be changed into [Test] public void Test() { var actual = new List<int> {1,2,3}; int expected = 1; Assert.That(actual, Does.Contain(expected)); } Configure severity Via ruleset file Configure the severity per project, for more info see MSDN. Via .editorconfig file # NUnit2014: Use SomeItemsConstraint for better assertion messages in case of failure dotnet_diagnostic.NUnit2014.severity = chosenSeverity where chosenSeverity can be one of none, silent, suggestion, warning, or error. Via #pragma directive #pragma warning disable NUnit2014 // Use SomeItemsConstraint for better assertion messages in case of failure Code violating the rule here #pragma warning restore NUnit2014 // Use SomeItemsConstraint for better assertion messages in case of failure Or put this at the top of the file to disable all instances. #pragma warning disable NUnit2014 // Use SomeItemsConstraint for better assertion messages in case of failure Via attribute [SuppressMessage] [System.Diagnostics.CodeAnalysis.SuppressMessage(\"Assertion\", \"NUnit2014:Use SomeItemsConstraint for better assertion messages in case of failure\", Justification = \"Reason...\")]"
  },
  "articles/nunit-analyzers/NUnit2015.html": {
    "href": "articles/nunit-analyzers/NUnit2015.html",
    "title": "NUnit2015 | NUnit Docs",
    "summary": "NUnit2015 Consider using Assert.That(actual, Is.SameAs(expected)) instead of ClassicAssert.AreSame(expected, actual) Topic Value Id NUnit2015 Severity Warning Enabled True Category Assertion Code ClassicModelAssertUsageAnalyzer Description Consider using the constraint model, Assert.That(actual, Is.SameAs(expected)), instead of the classic model, ClassicAssert.AreSame(expected, actual). Motivation The assert ClassicAssert.AreSame from the classic Assert model makes it easy to confuse the expected and the actual argument, so this analyzer marks usages of ClassicAssert.AreSame. [Test] public void Test() { ClassicAssert.AreSame(expected, actual); } How to fix violations The analyzer comes with a code fix that will replace ClassicAssert.AreSame(expected, actual) with Assert.That(actual, Is.SameAs(expected)). So the code block above will be changed into. [Test] public void Test() { Assert.That(actual, Is.SameAs(expected)); } Configure severity Via ruleset file Configure the severity per project, for more info see MSDN. Via .editorconfig file # NUnit2015: Consider using Assert.That(actual, Is.SameAs(expected)) instead of ClassicAssert.AreSame(expected, actual) dotnet_diagnostic.NUnit2015.severity = chosenSeverity where chosenSeverity can be one of none, silent, suggestion, warning, or error. Via #pragma directive #pragma warning disable NUnit2015 // Consider using Assert.That(actual, Is.SameAs(expected)) instead of ClassicAssert.AreSame(expected, actual) Code violating the rule here #pragma warning restore NUnit2015 // Consider using Assert.That(actual, Is.SameAs(expected)) instead of ClassicAssert.AreSame(expected, actual) Or put this at the top of the file to disable all instances. #pragma warning disable NUnit2015 // Consider using Assert.That(actual, Is.SameAs(expected)) instead of ClassicAssert.AreSame(expected, actual) Via attribute [SuppressMessage] [System.Diagnostics.CodeAnalysis.SuppressMessage(\"Assertion\", \"NUnit2015:Consider using Assert.That(actual, Is.SameAs(expected)) instead of ClassicAssert.AreSame(expected, actual)\", Justification = \"Reason...\")]"
  },
  "articles/nunit-analyzers/NUnit2016.html": {
    "href": "articles/nunit-analyzers/NUnit2016.html",
    "title": "NUnit2016 | NUnit Docs",
    "summary": "NUnit2016 Consider using Assert.That(expr, Is.Null) instead of ClassicAssert.Null(expr) Topic Value Id NUnit2016 Severity Info Enabled True Category Assertion Code ClassicModelAssertUsageAnalyzer Description Consider using the constraint model, Assert.That(expr, Is.Null), instead of the classic model, ClassicAssert.Null(expr). Motivation The classic Assert model contains less flexibility than the constraint model, so this analyzer marks usages of ClassicAssert.Null from the classic Assert model. [Test] public void Test() { object obj = null; ClassicAssert.Null(obj); } How to fix violations The analyzer comes with a code fix that will replace ClassicAssert.Null(expression) with Assert.That(expression, Is.Null). So the code block above will be changed into. [Test] public void Test() { object obj = null; Assert.That(obj, Is.Null); } Configure severity Via ruleset file Configure the severity per project, for more info see MSDN. Via .editorconfig file # NUnit2016: Consider using Assert.That(expr, Is.Null) instead of ClassicAssert.Null(expr) dotnet_diagnostic.NUnit2016.severity = chosenSeverity where chosenSeverity can be one of none, silent, suggestion, warning, or error. Via #pragma directive #pragma warning disable NUnit2016 // Consider using Assert.That(expr, Is.Null) instead of ClassicAssert.Null(expr) Code violating the rule here #pragma warning restore NUnit2016 // Consider using Assert.That(expr, Is.Null) instead of ClassicAssert.Null(expr) Or put this at the top of the file to disable all instances. #pragma warning disable NUnit2016 // Consider using Assert.That(expr, Is.Null) instead of ClassicAssert.Null(expr) Via attribute [SuppressMessage] [System.Diagnostics.CodeAnalysis.SuppressMessage(\"Assertion\", \"NUnit2016:Consider using Assert.That(expr, Is.Null) instead of ClassicAssert.Null(expr)\", Justification = \"Reason...\")]"
  },
  "articles/nunit-analyzers/NUnit2017.html": {
    "href": "articles/nunit-analyzers/NUnit2017.html",
    "title": "NUnit2017 | NUnit Docs",
    "summary": "NUnit2017 Consider using Assert.That(expr, Is.Null) instead of ClassicAssert.IsNull(expr) Topic Value Id NUnit2017 Severity Info Enabled True Category Assertion Code ClassicModelAssertUsageAnalyzer Description Consider using the constraint model, Assert.That(expr, Is.Null), instead of the classic model, ClassicAssert.IsNull(expr). Motivation The classic Assert model contains less flexibility than the constraint model, so this analyzer marks usages of ClassicAssert.IsNull from the classic Assert model. [Test] public void Test() { object obj = null; ClassicAssert.IsNull(obj); } How to fix violations The analyzer comes with a code fix that will replace ClassicAssert.IsNull(expression) with Assert.That(expression, Is.Null). So the code block above will be changed into. [Test] public void Test() { object obj = null; Assert.That(obj, Is.Null); } Configure severity Via ruleset file Configure the severity per project, for more info see MSDN. Via .editorconfig file # NUnit2017: Consider using Assert.That(expr, Is.Null) instead of ClassicAssert.IsNull(expr) dotnet_diagnostic.NUnit2017.severity = chosenSeverity where chosenSeverity can be one of none, silent, suggestion, warning, or error. Via #pragma directive #pragma warning disable NUnit2017 // Consider using Assert.That(expr, Is.Null) instead of ClassicAssert.IsNull(expr) Code violating the rule here #pragma warning restore NUnit2017 // Consider using Assert.That(expr, Is.Null) instead of ClassicAssert.IsNull(expr) Or put this at the top of the file to disable all instances. #pragma warning disable NUnit2017 // Consider using Assert.That(expr, Is.Null) instead of ClassicAssert.IsNull(expr) Via attribute [SuppressMessage] [System.Diagnostics.CodeAnalysis.SuppressMessage(\"Assertion\", \"NUnit2017:Consider using Assert.That(expr, Is.Null) instead of ClassicAssert.IsNull(expr)\", Justification = \"Reason...\")]"
  },
  "articles/nunit-analyzers/NUnit2018.html": {
    "href": "articles/nunit-analyzers/NUnit2018.html",
    "title": "NUnit2018 | NUnit Docs",
    "summary": "NUnit2018 Consider using Assert.That(expr, Is.Not.Null) instead of ClassicAssert.NotNull(expr) Topic Value Id NUnit2018 Severity Info Enabled True Category Assertion Code ClassicModelAssertUsageAnalyzer Description Consider using the constraint model, Assert.That(expr, Is.Not.Null), instead of the classic model, ClassicAssert.NotNull(expr). Motivation The classic Assert model contains less flexibility than the constraint model, so this analyzer marks usages of ClassicAssert.NotNull from the classic Assert model. [Test] public void Test() { object obj = null; ClassicAssert.NotNull(obj); } How to fix violations The analyzer comes with a code fix that will replace ClassicAssert.NotNull(expression) with Assert.That(expression, Is.Not.Null). So the code block above will be changed into. [Test] public void Test() { object obj = null; Assert.That(obj, Is.Not.Null); } Configure severity Via ruleset file Configure the severity per project, for more info see MSDN. Via .editorconfig file # NUnit2018: Consider using Assert.That(expr, Is.Not.Null) instead of ClassicAssert.NotNull(expr) dotnet_diagnostic.NUnit2018.severity = chosenSeverity where chosenSeverity can be one of none, silent, suggestion, warning, or error. Via #pragma directive #pragma warning disable NUnit2018 // Consider using Assert.That(expr, Is.Not.Null) instead of ClassicAssert.NotNull(expr) Code violating the rule here #pragma warning restore NUnit2018 // Consider using Assert.That(expr, Is.Not.Null) instead of ClassicAssert.NotNull(expr) Or put this at the top of the file to disable all instances. #pragma warning disable NUnit2018 // Consider using Assert.That(expr, Is.Not.Null) instead of ClassicAssert.NotNull(expr) Via attribute [SuppressMessage] [System.Diagnostics.CodeAnalysis.SuppressMessage(\"Assertion\", \"NUnit2018:Consider using Assert.That(expr, Is.Not.Null) instead of ClassicAssert.NotNull(expr)\", Justification = \"Reason...\")]"
  },
  "articles/nunit-analyzers/NUnit2019.html": {
    "href": "articles/nunit-analyzers/NUnit2019.html",
    "title": "NUnit2019 | NUnit Docs",
    "summary": "NUnit2019 Consider using Assert.That(expr, Is.Not.Null) instead of ClassicAssert.IsNotNull(expr) Topic Value Id NUnit2019 Severity Info Enabled True Category Assertion Code ClassicModelAssertUsageAnalyzer Description Consider using the constraint model, Assert.That(expr, Is.Not.Null), instead of the classic model, ClassicAssert.IsNotNull(expr). Motivation The classic Assert model contains less flexibility than the constraint model, so this analyzer marks usages of ClassicAssert.IsNotNull from the classic Assert model. [Test] public void Test() { object obj = null; ClassicAssert.IsNotNull(obj); } How to fix violations The analyzer comes with a code fix that will replace ClassicAssert.IsNotNull(expression) with Assert.That(expression, Is.Not.Null). So the code block above will be changed into. [Test] public void Test() { object obj = null; Assert.That(obj, Is.Not.Null); } Configure severity Via ruleset file Configure the severity per project, for more info see MSDN. Via .editorconfig file # NUnit2019: Consider using Assert.That(expr, Is.Not.Null) instead of ClassicAssert.IsNotNull(expr) dotnet_diagnostic.NUnit2019.severity = chosenSeverity where chosenSeverity can be one of none, silent, suggestion, warning, or error. Via #pragma directive #pragma warning disable NUnit2019 // Consider using Assert.That(expr, Is.Not.Null) instead of ClassicAssert.IsNotNull(expr) Code violating the rule here #pragma warning restore NUnit2019 // Consider using Assert.That(expr, Is.Not.Null) instead of ClassicAssert.IsNotNull(expr) Or put this at the top of the file to disable all instances. #pragma warning disable NUnit2019 // Consider using Assert.That(expr, Is.Not.Null) instead of ClassicAssert.IsNotNull(expr) Via attribute [SuppressMessage] [System.Diagnostics.CodeAnalysis.SuppressMessage(\"Assertion\", \"NUnit2019:Consider using Assert.That(expr, Is.Not.Null) instead of ClassicAssert.IsNotNull(expr)\", Justification = \"Reason...\")]"
  },
  "articles/nunit-analyzers/NUnit2020.html": {
    "href": "articles/nunit-analyzers/NUnit2020.html",
    "title": "NUnit2020 | NUnit Docs",
    "summary": "NUnit2020 Incompatible types for SameAs constraint Topic Value Id NUnit2020 Severity Error Enabled True Category Assertion Code SameAsIncompatibleTypesAnalyzer Description The SameAs constraint always fails because the actual and expected values have mutually exclusive types. Motivation class Foo { } class Bar { } var foo = new Foo(); var bar = new Bar(); Assert.That(foo, Is.SameAs(bar)); There is no way that the same instance can be of type Foo and type Bar, therefore such assertion will always fail. How to fix violations Fix your assertion (i.e. fix actual or expected value, or choose another constraint) Configure severity Via ruleset file Configure the severity per project, for more info see MSDN. Via .editorconfig file # NUnit2020: Incompatible types for SameAs constraint dotnet_diagnostic.NUnit2020.severity = chosenSeverity where chosenSeverity can be one of none, silent, suggestion, warning, or error. Via #pragma directive #pragma warning disable NUnit2020 // Incompatible types for SameAs constraint Code violating the rule here #pragma warning restore NUnit2020 // Incompatible types for SameAs constraint Or put this at the top of the file to disable all instances. #pragma warning disable NUnit2020 // Incompatible types for SameAs constraint Via attribute [SuppressMessage] [System.Diagnostics.CodeAnalysis.SuppressMessage(\"Assertion\", \"NUnit2020:Incompatible types for SameAs constraint\", Justification = \"Reason...\")]"
  },
  "articles/nunit-analyzers/NUnit2021.html": {
    "href": "articles/nunit-analyzers/NUnit2021.html",
    "title": "NUnit2021 | NUnit Docs",
    "summary": "NUnit2021 Incompatible types for EqualTo constraint Topic Value Id NUnit2021 Severity Error Enabled True Category Assertion Code EqualToIncompatibleTypesAnalyzer Description The EqualTo constraint always fails as the actual and the expected value cannot be equal. Motivation class Foo { } class Bar { } var foo = new Foo(); var bar = new Bar(); Assert.That(foo, Is.EqualTo(bar)); There is no way that instances of types Foo and Bar could be considered equal, therefore such assertion will always fail. How to fix violations Fix your assertion (i.e. fix actual or expected value, or choose another constraint). Configure severity Via ruleset file Configure the severity per project, for more info see MSDN. Via .editorconfig file # NUnit2021: Incompatible types for EqualTo constraint dotnet_diagnostic.NUnit2021.severity = chosenSeverity where chosenSeverity can be one of none, silent, suggestion, warning, or error. Via #pragma directive #pragma warning disable NUnit2021 // Incompatible types for EqualTo constraint Code violating the rule here #pragma warning restore NUnit2021 // Incompatible types for EqualTo constraint Or put this at the top of the file to disable all instances. #pragma warning disable NUnit2021 // Incompatible types for EqualTo constraint Via attribute [SuppressMessage] [System.Diagnostics.CodeAnalysis.SuppressMessage(\"Assertion\", \"NUnit2021:Incompatible types for EqualTo constraint\", Justification = \"Reason...\")]"
  },
  "articles/nunit-analyzers/NUnit2022.html": {
    "href": "articles/nunit-analyzers/NUnit2022.html",
    "title": "NUnit2022 | NUnit Docs",
    "summary": "NUnit2022 Missing property required for constraint Topic Value Id NUnit2022 Severity Error Enabled True Category Assertion Code MissingPropertyAnalyzer Description The actual argument should have the required property for the constraint. Motivation Using property constraints (e.g. Has.Count.EqualTo(1), Has.Property(\"Prop\").EqualTo(expected), etc) makes sense only when provided actual argument has those properties defined. [Test] public void Test() { var enumerable = new [] {1,2,3}.Where(i => i > 1); // Actual argument type 'IEnumerable<int>' has no property 'Count'. Assert.That(enumerable, Has.Count.EqualTo(2)); } How to fix violations Fix your property name, or use another constraint. Configure severity Via ruleset file Configure the severity per project, for more info see MSDN. Via .editorconfig file # NUnit2022: Missing property required for constraint dotnet_diagnostic.NUnit2022.severity = chosenSeverity where chosenSeverity can be one of none, silent, suggestion, warning, or error. Via #pragma directive #pragma warning disable NUnit2022 // Missing property required for constraint Code violating the rule here #pragma warning restore NUnit2022 // Missing property required for constraint Or put this at the top of the file to disable all instances. #pragma warning disable NUnit2022 // Missing property required for constraint Via attribute [SuppressMessage] [System.Diagnostics.CodeAnalysis.SuppressMessage(\"Assertion\", \"NUnit2022:Missing property required for constraint\", Justification = \"Reason...\")]"
  },
  "articles/nunit-analyzers/NUnit2023.html": {
    "href": "articles/nunit-analyzers/NUnit2023.html",
    "title": "NUnit2023 | NUnit Docs",
    "summary": "NUnit2023 Invalid NullConstraint usage Topic Value Id NUnit2023 Severity Error Enabled True Category Assertion Code NullConstraintUsageAnalyzer Description NullConstraint is allowed only for reference types or nullable value types. Motivation Non-nullable value types cannot have null value, therefore Is.Null assertions will always fail (or will always pass for Is.Not.Null). How to fix violations Use suitable constraint. Configure severity Via ruleset file Configure the severity per project, for more info see MSDN. Via .editorconfig file # NUnit2023: Invalid NullConstraint usage dotnet_diagnostic.NUnit2023.severity = chosenSeverity where chosenSeverity can be one of none, silent, suggestion, warning, or error. Via #pragma directive #pragma warning disable NUnit2023 // Invalid NullConstraint usage Code violating the rule here #pragma warning restore NUnit2023 // Invalid NullConstraint usage Or put this at the top of the file to disable all instances. #pragma warning disable NUnit2023 // Invalid NullConstraint usage Via attribute [SuppressMessage] [System.Diagnostics.CodeAnalysis.SuppressMessage(\"Assertion\", \"NUnit2023:Invalid NullConstraint usage\", Justification = \"Reason...\")]"
  },
  "articles/nunit-analyzers/NUnit2024.html": {
    "href": "articles/nunit-analyzers/NUnit2024.html",
    "title": "NUnit2024 | NUnit Docs",
    "summary": "NUnit2024 Wrong actual type used with String Constraint Topic Value Id NUnit2024 Severity Error Enabled True Category Assertion Code StringConstraintWrongActualTypeAnalyzer Description The type of the actual argument is not a string and hence cannot be used with a String Constraint. Motivation Assertions with string constraints and non-string actual value will fail with error. How to fix violations Fix actual value or use appropriate constraint. Configure severity Via ruleset file Configure the severity per project, for more info see MSDN. Via .editorconfig file # NUnit2024: Wrong actual type used with String Constraint dotnet_diagnostic.NUnit2024.severity = chosenSeverity where chosenSeverity can be one of none, silent, suggestion, warning, or error. Via #pragma directive #pragma warning disable NUnit2024 // Wrong actual type used with String Constraint Code violating the rule here #pragma warning restore NUnit2024 // Wrong actual type used with String Constraint Or put this at the top of the file to disable all instances. #pragma warning disable NUnit2024 // Wrong actual type used with String Constraint Via attribute [SuppressMessage] [System.Diagnostics.CodeAnalysis.SuppressMessage(\"Assertion\", \"NUnit2024:Wrong actual type used with String Constraint\", Justification = \"Reason...\")]"
  },
  "articles/nunit-analyzers/NUnit2025.html": {
    "href": "articles/nunit-analyzers/NUnit2025.html",
    "title": "NUnit2025 | NUnit Docs",
    "summary": "NUnit2025 Wrong actual type used with ContainsConstraint Topic Value Id NUnit2025 Severity Hidden Enabled False Category Assertion Code ContainsConstraintWrongActualTypeAnalyzer Description The ContainsConstraint requires the type of the actual value to be either a string or a collection of strings. Motivation Using a ContainsConstraint with an actual argument, which is neither a string nor a collection of strings, leads to an assertion error. How to fix violations Fix the actual value or use appropriate constraint. Configure severity Via ruleset file Configure the severity per project, for more info see MSDN. Via .editorconfig file # NUnit2025: Wrong actual type used with ContainsConstraint dotnet_diagnostic.NUnit2025.severity = chosenSeverity where chosenSeverity can be one of none, silent, suggestion, warning, or error. Via #pragma directive #pragma warning disable NUnit2025 // Wrong actual type used with ContainsConstraint Code violating the rule here #pragma warning restore NUnit2025 // Wrong actual type used with ContainsConstraint Or put this at the top of the file to disable all instances. #pragma warning disable NUnit2025 // Wrong actual type used with ContainsConstraint Via attribute [SuppressMessage] [System.Diagnostics.CodeAnalysis.SuppressMessage(\"Assertion\", \"NUnit2025:Wrong actual type used with ContainsConstraint\", Justification = \"Reason...\")]"
  },
  "articles/nunit-analyzers/NUnit2026.html": {
    "href": "articles/nunit-analyzers/NUnit2026.html",
    "title": "NUnit2026 | NUnit Docs",
    "summary": "NUnit2026 Wrong actual type used with the SomeItemsConstraint with EqualConstraint Topic Value Id NUnit2026 Severity Error Enabled True Category Assertion Code SomeItemsIncompatibleTypesAnalyzer Description The SomeItemsConstraint with EqualConstraint requires the actual argument to be a collection where the element type can match the type of the expected argument. Motivation Using Does.Contain or Contains.Item constraints with actual argument, which is either not a collection, or has wrong element type, leads to assertion error. How to fix violations Fix the actual value or use appropriate constraint. Configure severity Via ruleset file Configure the severity per project, for more info see MSDN. Via .editorconfig file # NUnit2026: Wrong actual type used with the SomeItemsConstraint with EqualConstraint dotnet_diagnostic.NUnit2026.severity = chosenSeverity where chosenSeverity can be one of none, silent, suggestion, warning, or error. Via #pragma directive #pragma warning disable NUnit2026 // Wrong actual type used with the SomeItemsConstraint with EqualConstraint Code violating the rule here #pragma warning restore NUnit2026 // Wrong actual type used with the SomeItemsConstraint with EqualConstraint Or put this at the top of the file to disable all instances. #pragma warning disable NUnit2026 // Wrong actual type used with the SomeItemsConstraint with EqualConstraint Via attribute [SuppressMessage] [System.Diagnostics.CodeAnalysis.SuppressMessage(\"Assertion\", \"NUnit2026:Wrong actual type used with the SomeItemsConstraint with EqualConstraint\", Justification = \"Reason...\")]"
  },
  "articles/nunit-analyzers/NUnit2027.html": {
    "href": "articles/nunit-analyzers/NUnit2027.html",
    "title": "NUnit2027 | NUnit Docs",
    "summary": "NUnit2027 Consider using Assert.That(actual, Is.GreaterThan(expected)) instead of ClassicAssert.Greater(actual, expected) Topic Value Id NUnit2027 Severity Info Enabled True Category Assertion Code ClassicModelAssertUsageAnalyzer Description Consider using the constraint model, Assert.That(actual, Is.GreaterThan(expected)), instead of the classic model, ClassicAssert.Greater(actual, expected). Motivation The assert ClassicAssert.Greater from the classic Assert model makes it easy to confuse the expected and the actual argument, so this analyzer marks usages of ClassicAssert.Greater. [Test] public void Test() { ClassicAssert.Greater(actual, expected); } How to fix violations The analyzer comes with a code fix that will replace ClassicAssert.Greater(actual, expected) with Assert.That(actual, Is.GreaterThan(expected)). So the code block above will be changed into. [Test] public void Test() { Assert.That(actual, Is.GreaterThan(expected)); } Configure severity Via ruleset file Configure the severity per project, for more info see MSDN. Via .editorconfig file # NUnit2027: Consider using Assert.That(actual, Is.GreaterThan(expected)) instead of ClassicAssert.Greater(actual, expected) dotnet_diagnostic.NUnit2027.severity = chosenSeverity where chosenSeverity can be one of none, silent, suggestion, warning, or error. Via #pragma directive #pragma warning disable NUnit2027 // Consider using Assert.That(actual, Is.GreaterThan(expected)) instead of ClassicAssert.Greater(actual, expected) Code violating the rule here #pragma warning restore NUnit2027 // Consider using Assert.That(actual, Is.GreaterThan(expected)) instead of ClassicAssert.Greater(actual, expected) Or put this at the top of the file to disable all instances. #pragma warning disable NUnit2027 // Consider using Assert.That(actual, Is.GreaterThan(expected)) instead of ClassicAssert.Greater(actual, expected) Via attribute [SuppressMessage] [System.Diagnostics.CodeAnalysis.SuppressMessage(\"Assertion\", \"NUnit2027:Consider using Assert.That(actual, Is.GreaterThan(expected)) instead of ClassicAssert.Greater(actual, expected)\", Justification = \"Reason...\")]"
  },
  "articles/nunit-analyzers/NUnit2028.html": {
    "href": "articles/nunit-analyzers/NUnit2028.html",
    "title": "NUnit2028 | NUnit Docs",
    "summary": "NUnit2028 Consider using Assert.That(actual, Is.GreaterThanOrEqualTo(expected)) instead of ClassicAssert.GreaterOrEqual(actual, expected) Topic Value Id NUnit2028 Severity Info Enabled True Category Assertion Code ClassicModelAssertUsageAnalyzer Description Consider using the constraint model, Assert.That(actual, Is.GreaterThanOrEqualTo(expected)), instead of the classic model, ClassicAssert.GreaterOrEqual(actual, expected). Motivation The assert ClassicAssert.GreaterOrEqual from the classic Assert model makes it easy to confuse the expected and the actual argument, so this analyzer marks usages of ClassicAssert.GreaterOrEqual. [Test] public void Test() { ClassicAssert.GreaterOrEqual(actual, expected); } How to fix violations The analyzer comes with a code fix that will replace ClassicAssert.GreaterOrEqual(actual, expected) with Assert.That(actual, Is.GreaterThanOrEqualTo(expected)). So the code block above will be changed into. [Test] public void Test() { Assert.That(actual, Is.GreaterThanOrEqualTo(expected)); } Configure severity Via ruleset file Configure the severity per project, for more info see MSDN. Via .editorconfig file # NUnit2028: Consider using Assert.That(actual, Is.GreaterThanOrEqualTo(expected)) instead of ClassicAssert.GreaterOrEqual(actual, expected) dotnet_diagnostic.NUnit2028.severity = chosenSeverity where chosenSeverity can be one of none, silent, suggestion, warning, or error. Via #pragma directive #pragma warning disable NUnit2028 // Consider using Assert.That(actual, Is.GreaterThanOrEqualTo(expected)) instead of ClassicAssert.GreaterOrEqual(actual, expected) Code violating the rule here #pragma warning restore NUnit2028 // Consider using Assert.That(actual, Is.GreaterThanOrEqualTo(expected)) instead of ClassicAssert.GreaterOrEqual(actual, expected) Or put this at the top of the file to disable all instances. #pragma warning disable NUnit2028 // Consider using Assert.That(actual, Is.GreaterThanOrEqualTo(expected)) instead of ClassicAssert.GreaterOrEqual(actual, expected) Via attribute [SuppressMessage] [System.Diagnostics.CodeAnalysis.SuppressMessage(\"Assertion\", \"NUnit2028:Consider using Assert.That(actual, Is.GreaterThanOrEqualTo(expected)) instead of ClassicAssert.GreaterOrEqual(actual, expected)\", Justification = \"Reason...\")]"
  },
  "articles/nunit-analyzers/NUnit2029.html": {
    "href": "articles/nunit-analyzers/NUnit2029.html",
    "title": "NUnit2029 | NUnit Docs",
    "summary": "NUnit2029 Consider using Assert.That(actual, Is.LessThan(expected)) instead of ClassicAssert.Less(actual, expected) Topic Value Id NUnit2029 Severity Info Enabled True Category Assertion Code ClassicModelAssertUsageAnalyzer Description Consider using the constraint model, Assert.That(actual, Is.LessThan(expected)), instead of the classic model, ClassicAssert.Less(actual, expected). Motivation The assert ClassicAssert.Less from the classic Assert model makes it easy to confuse the expected and the actual argument, so this analyzer marks usages of ClassicAssert.Less. [Test] public void Test() { ClassicAssert.Less(actual, expected); } How to fix violations The analyzer comes with a code fix that will replace ClassicAssert.Less(actual, expected) with Assert.That(actual, Is.LessThan(expected)). So the code block above will be changed into. [Test] public void Test() { Assert.That(actual, Is.LessThan(expected)); } Configure severity Via ruleset file Configure the severity per project, for more info see MSDN. Via .editorconfig file # NUnit2029: Consider using Assert.That(actual, Is.LessThan(expected)) instead of ClassicAssert.Less(actual, expected) dotnet_diagnostic.NUnit2029.severity = chosenSeverity where chosenSeverity can be one of none, silent, suggestion, warning, or error. Via #pragma directive #pragma warning disable NUnit2029 // Consider using Assert.That(actual, Is.LessThan(expected)) instead of ClassicAssert.Less(actual, expected) Code violating the rule here #pragma warning restore NUnit2029 // Consider using Assert.That(actual, Is.LessThan(expected)) instead of ClassicAssert.Less(actual, expected) Or put this at the top of the file to disable all instances. #pragma warning disable NUnit2029 // Consider using Assert.That(actual, Is.LessThan(expected)) instead of ClassicAssert.Less(actual, expected) Via attribute [SuppressMessage] [System.Diagnostics.CodeAnalysis.SuppressMessage(\"Assertion\", \"NUnit2029:Consider using Assert.That(actual, Is.LessThan(expected)) instead of ClassicAssert.Less(actual, expected)\", Justification = \"Reason...\")]"
  },
  "articles/nunit-analyzers/NUnit2030.html": {
    "href": "articles/nunit-analyzers/NUnit2030.html",
    "title": "NUnit2030 | NUnit Docs",
    "summary": "NUnit2030 Consider using Assert.That(actual, Is.LessThanOrEqualTo(expected)) instead of ClassicAssert.LessOrEqual(actual, expected) Topic Value Id NUnit2030 Severity Info Enabled True Category Assertion Code ClassicModelAssertUsageAnalyzer Description Consider using the constraint model, Assert.That(actual, Is.LessThanOrEqualTo(expected)), instead of the classic model, ClassicAssert.LessOrEqual(actual, expected). Motivation The assert ClassicAssert.LessOrEqual from the classic Assert model makes it easy to confuse the expected and the actual argument, so this analyzer marks usages of ClassicAssert.LessOrEqual. [Test] public void Test() { ClassicAssert.LessOrEqual(actual, expected); } How to fix violations The analyzer comes with a code fix that will replace ClassicAssert.LessOrEqual(actual, expected) with Assert.That(actual, Is.LessThanOrEqualTo(expected)). So the code block above will be changed into. [Test] public void Test() { Assert.That(actual, Is.SameAs(expected)); } Configure severity Via ruleset file Configure the severity per project, for more info see MSDN. Via .editorconfig file # NUnit2030: Consider using Assert.That(actual, Is.LessThanOrEqualTo(expected)) instead of ClassicAssert.LessOrEqual(actual, expected) dotnet_diagnostic.NUnit2030.severity = chosenSeverity where chosenSeverity can be one of none, silent, suggestion, warning, or error. Via #pragma directive #pragma warning disable NUnit2030 // Consider using Assert.That(actual, Is.LessThanOrEqualTo(expected)) instead of ClassicAssert.LessOrEqual(actual, expected) Code violating the rule here #pragma warning restore NUnit2030 // Consider using Assert.That(actual, Is.LessThanOrEqualTo(expected)) instead of ClassicAssert.LessOrEqual(actual, expected) Or put this at the top of the file to disable all instances. #pragma warning disable NUnit2030 // Consider using Assert.That(actual, Is.LessThanOrEqualTo(expected)) instead of ClassicAssert.LessOrEqual(actual, expected) Via attribute [SuppressMessage] [System.Diagnostics.CodeAnalysis.SuppressMessage(\"Assertion\", \"NUnit2030:Consider using Assert.That(actual, Is.LessThanOrEqualTo(expected)) instead of ClassicAssert.LessOrEqual(actual, expected)\", Justification = \"Reason...\")]"
  },
  "articles/nunit-analyzers/NUnit2031.html": {
    "href": "articles/nunit-analyzers/NUnit2031.html",
    "title": "NUnit2031 | NUnit Docs",
    "summary": "NUnit2031 Consider using Assert.That(actual, Is.Not.SameAs(expected)) instead of ClassicAssert.AreNotSame(expected, actual) Topic Value Id NUnit2031 Severity Warning Enabled True Category Assertion Code ClassicModelAssertUsageAnalyzer Description Consider using the constraint model, Assert.That(actual, Is.Not.SameAs(expected)), instead of the classic model, ClassicAssert.AreNotSame(expected, actual). Motivation The assert ClassicAssert.AreNotSame from the classic Assert model makes it easy to confuse the expected and the actual argument, so this analyzer marks usages of ClassicAssert.AreNotSame. [Test] public void Test() { ClassicAssert.AreNotSame(expected, actual); } How to fix violations The analyzer comes with a code fix that will replace ClassicAssert.AreNotSame(expected, actual) with Assert.That(actual, Is.Not.SameAs(expected)). So the code block above will be changed into. [Test] public void Test() { Assert.That(actual, Is.Not.SameAs(expected)); } Configure severity Via ruleset file Configure the severity per project, for more info see MSDN. Via .editorconfig file # NUnit2031: Consider using Assert.That(actual, Is.Not.SameAs(expected)) instead of ClassicAssert.AreNotSame(expected, actual) dotnet_diagnostic.NUnit2031.severity = chosenSeverity where chosenSeverity can be one of none, silent, suggestion, warning, or error. Via #pragma directive #pragma warning disable NUnit2031 // Consider using Assert.That(actual, Is.Not.SameAs(expected)) instead of ClassicAssert.AreNotSame(expected, actual) Code violating the rule here #pragma warning restore NUnit2031 // Consider using Assert.That(actual, Is.Not.SameAs(expected)) instead of ClassicAssert.AreNotSame(expected, actual) Or put this at the top of the file to disable all instances. #pragma warning disable NUnit2031 // Consider using Assert.That(actual, Is.Not.SameAs(expected)) instead of ClassicAssert.AreNotSame(expected, actual) Via attribute [SuppressMessage] [System.Diagnostics.CodeAnalysis.SuppressMessage(\"Assertion\", \"NUnit2031:Consider using Assert.That(actual, Is.Not.SameAs(expected)) instead of ClassicAssert.AreNotSame(expected, actual)\", Justification = \"Reason...\")]"
  },
  "articles/nunit-analyzers/NUnit2032.html": {
    "href": "articles/nunit-analyzers/NUnit2032.html",
    "title": "NUnit2032 | NUnit Docs",
    "summary": "NUnit2032 Consider using Assert.That(expr, Is.Zero) instead of ClassicAssert.Zero(expr) Topic Value Id NUnit2032 Severity Info Enabled True Category Assertion Code ClassicModelAssertUsageAnalyzer Description Consider using the constraint model, Assert.That(expr, Is.Zero), instead of the classic model, ClassicAssert.Zero(expr). Motivation The classic Assert model contains less flexibility than the constraint model, so this analyzer marks usages of ClassicAssert.Zero from the classic Assert model. [Test] public void Test() { ClassicAssert.Zero(expression); } How to fix violations The analyzer comes with a code fix that will replace ClassicAssert.Zero(expression) with Assert.That(expression, Is.Zero). So the code block above will be changed into. [Test] public void Test() { Assert.That(expression, Is.Zero); } Configure severity Via ruleset file Configure the severity per project, for more info see MSDN. Via .editorconfig file # NUnit2032: Consider using Assert.That(expr, Is.Zero) instead of ClassicAssert.Zero(expr) dotnet_diagnostic.NUnit2032.severity = chosenSeverity where chosenSeverity can be one of none, silent, suggestion, warning, or error. Via #pragma directive #pragma warning disable NUnit2032 // Consider using Assert.That(expr, Is.Zero) instead of ClassicAssert.Zero(expr) Code violating the rule here #pragma warning restore NUnit2032 // Consider using Assert.That(expr, Is.Zero) instead of ClassicAssert.Zero(expr) Or put this at the top of the file to disable all instances. #pragma warning disable NUnit2032 // Consider using Assert.That(expr, Is.Zero) instead of ClassicAssert.Zero(expr) Via attribute [SuppressMessage] [System.Diagnostics.CodeAnalysis.SuppressMessage(\"Assertion\", \"NUnit2032:Consider using Assert.That(expr, Is.Zero) instead of ClassicAssert.Zero(expr)\", Justification = \"Reason...\")]"
  },
  "articles/nunit-analyzers/NUnit2033.html": {
    "href": "articles/nunit-analyzers/NUnit2033.html",
    "title": "NUnit2033 | NUnit Docs",
    "summary": "NUnit2033 Consider using Assert.That(expr, Is.Not.Zero) instead of ClassicAssert.NotZero(expr) Topic Value Id NUnit2033 Severity Info Enabled True Category Assertion Code ClassicModelAssertUsageAnalyzer Description Consider using the constraint model, Assert.That(expr, Is.Not.Zero), instead of the classic model, ClassicAssert.NotZero(expr). Motivation The classic Assert model contains less flexibility than the constraint model, so this analyzer marks usages of ClassicAssert.NotZero from the classic Assert model. [Test] public void Test() { ClassicAssert.NotZero(expression); } How to fix violations The analyzer comes with a code fix that will replace ClassicAssert.NotZero(expression) with Assert.That(expression, Is.Not.Zero). So the code block above will be changed into. [Test] public void Test() { Assert.That(expression, Is.Not.Zero); } Configure severity Via ruleset file Configure the severity per project, for more info see MSDN. Via .editorconfig file # NUnit2033: Consider using Assert.That(expr, Is.Not.Zero) instead of ClassicAssert.NotZero(expr) dotnet_diagnostic.NUnit2033.severity = chosenSeverity where chosenSeverity can be one of none, silent, suggestion, warning, or error. Via #pragma directive #pragma warning disable NUnit2033 // Consider using Assert.That(expr, Is.Not.Zero) instead of ClassicAssert.NotZero(expr) Code violating the rule here #pragma warning restore NUnit2033 // Consider using Assert.That(expr, Is.Not.Zero) instead of ClassicAssert.NotZero(expr) Or put this at the top of the file to disable all instances. #pragma warning disable NUnit2033 // Consider using Assert.That(expr, Is.Not.Zero) instead of ClassicAssert.NotZero(expr) Via attribute [SuppressMessage] [System.Diagnostics.CodeAnalysis.SuppressMessage(\"Assertion\", \"NUnit2033:Consider using Assert.That(expr, Is.Not.Zero) instead of ClassicAssert.NotZero(expr)\", Justification = \"Reason...\")]"
  },
  "articles/nunit-analyzers/NUnit2034.html": {
    "href": "articles/nunit-analyzers/NUnit2034.html",
    "title": "NUnit2034 | NUnit Docs",
    "summary": "NUnit2034 Consider using Assert.That(expr, Is.NaN) instead of ClassicAssert.IsNaN(expr) Topic Value Id NUnit2034 Severity Info Enabled True Category Assertion Code ClassicModelAssertUsageAnalyzer Description Consider using the constraint model, Assert.That(expr, Is.NaN), instead of the classic model, ClassicAssert.IsNaN(expr). Motivation The classic Assert model contains less flexibility than the constraint model, so this analyzer marks usages of ClassicAssert.IsNaN from the classic Assert model. [Test] public void Test() { ClassicAssert.IsNaN(expression); } How to fix violations The analyzer comes with a code fix that will replace ClassicAssert.IsNaN(expression) with Assert.That(expression, Is.NaN). So the code block above will be changed into. [Test] public void Test() { Assert.That(expression, Is.NaN); } Configure severity Via ruleset file Configure the severity per project, for more info see MSDN. Via .editorconfig file # NUnit2034: Consider using Assert.That(expr, Is.NaN) instead of ClassicAssert.IsNaN(expr) dotnet_diagnostic.NUnit2034.severity = chosenSeverity where chosenSeverity can be one of none, silent, suggestion, warning, or error. Via #pragma directive #pragma warning disable NUnit2034 // Consider using Assert.That(expr, Is.NaN) instead of ClassicAssert.IsNaN(expr) Code violating the rule here #pragma warning restore NUnit2034 // Consider using Assert.That(expr, Is.NaN) instead of ClassicAssert.IsNaN(expr) Or put this at the top of the file to disable all instances. #pragma warning disable NUnit2034 // Consider using Assert.That(expr, Is.NaN) instead of ClassicAssert.IsNaN(expr) Via attribute [SuppressMessage] [System.Diagnostics.CodeAnalysis.SuppressMessage(\"Assertion\", \"NUnit2034:Consider using Assert.That(expr, Is.NaN) instead of ClassicAssert.IsNaN(expr)\", Justification = \"Reason...\")]"
  },
  "articles/nunit-analyzers/NUnit2035.html": {
    "href": "articles/nunit-analyzers/NUnit2035.html",
    "title": "NUnit2035 | NUnit Docs",
    "summary": "NUnit2035 Consider using Assert.That(collection, Is.Empty) instead of ClassicAssert.IsEmpty(collection) Topic Value Id NUnit2035 Severity Info Enabled True Category Assertion Code ClassicModelAssertUsageAnalyzer Description Consider using the constraint model, Assert.That(collection, Is.Empty), instead of the classic model, ClassicAssert.IsEmpty(collection). Motivation The classic Assert model contains less flexibility than the constraint model, so this analyzer marks usages of ClassicAssert.IsEmpty from the classic Assert model. [Test] public void Test() { ClassicAssert.IsEmpty(collection); } How to fix violations The analyzer comes with a code fix that will replace ClassicAssert.IsEmpty(collection) with Assert.That(collection, Is.Empty). So the code block above will be changed into. [Test] public void Test() { Assert.That(collection, Is.Empty); } Configure severity Via ruleset file Configure the severity per project, for more info see MSDN. Via .editorconfig file # NUnit2035: Consider using Assert.That(collection, Is.Empty) instead of ClassicAssert.IsEmpty(collection) dotnet_diagnostic.NUnit2035.severity = chosenSeverity where chosenSeverity can be one of none, silent, suggestion, warning, or error. Via #pragma directive #pragma warning disable NUnit2035 // Consider using Assert.That(collection, Is.Empty) instead of ClassicAssert.IsEmpty(collection) Code violating the rule here #pragma warning restore NUnit2035 // Consider using Assert.That(collection, Is.Empty) instead of ClassicAssert.IsEmpty(collection) Or put this at the top of the file to disable all instances. #pragma warning disable NUnit2035 // Consider using Assert.That(collection, Is.Empty) instead of ClassicAssert.IsEmpty(collection) Via attribute [SuppressMessage] [System.Diagnostics.CodeAnalysis.SuppressMessage(\"Assertion\", \"NUnit2035:Consider using Assert.That(collection, Is.Empty) instead of ClassicAssert.IsEmpty(collection)\", Justification = \"Reason...\")]"
  },
  "articles/nunit-analyzers/NUnit2036.html": {
    "href": "articles/nunit-analyzers/NUnit2036.html",
    "title": "NUnit2036 | NUnit Docs",
    "summary": "NUnit2036 Consider using Assert.That(collection, Is.Not.Empty) instead of ClassicAssert.IsNotEmpty(collection) Topic Value Id NUnit2036 Severity Info Enabled True Category Assertion Code ClassicModelAssertUsageAnalyzer Description Consider using the constraint model, Assert.That(collection, Is.Not.Empty), instead of the classic model, ClassicAssert.IsNotEmpty(collection). Motivation The classic Assert model contains less flexibility than the constraint model, so this analyzer marks usages of ClassicAssert.IsNotEmpty from the classic Assert model. [Test] public void Test() { ClassicAssert.IsNotEmpty(collection); } How to fix violations The analyzer comes with a code fix that will replace ClassicAssert.IsNotEmpty(collection) with Assert.That(collection, Is.Not.Empty). So the code block above will be changed into. [Test] public void Test() { Assert.That(collection, Is.Not.Empty); } Configure severity Via ruleset file Configure the severity per project, for more info see MSDN. Via .editorconfig file # NUnit2036: Consider using Assert.That(collection, Is.Not.Empty) instead of ClassicAssert.IsNotEmpty(collection) dotnet_diagnostic.NUnit2036.severity = chosenSeverity where chosenSeverity can be one of none, silent, suggestion, warning, or error. Via #pragma directive #pragma warning disable NUnit2036 // Consider using Assert.That(collection, Is.Not.Empty) instead of ClassicAssert.IsNotEmpty(collection) Code violating the rule here #pragma warning restore NUnit2036 // Consider using Assert.That(collection, Is.Not.Empty) instead of ClassicAssert.IsNotEmpty(collection) Or put this at the top of the file to disable all instances. #pragma warning disable NUnit2036 // Consider using Assert.That(collection, Is.Not.Empty) instead of ClassicAssert.IsNotEmpty(collection) Via attribute [SuppressMessage] [System.Diagnostics.CodeAnalysis.SuppressMessage(\"Assertion\", \"NUnit2036:Consider using Assert.That(collection, Is.Not.Empty) instead of ClassicAssert.IsNotEmpty(collection)\", Justification = \"Reason...\")]"
  },
  "articles/nunit-analyzers/NUnit2037.html": {
    "href": "articles/nunit-analyzers/NUnit2037.html",
    "title": "NUnit2037 | NUnit Docs",
    "summary": "NUnit2037 Consider using Assert.That(collection, Does.Contain(instance)) instead of ClassicAssert.Contains(instance, collection) Topic Value Id NUnit2037 Severity Info Enabled True Category Assertion Code ClassicModelAssertUsageAnalyzer Description Consider using the constraint model, Assert.That(collection, Does.Contain(instance)), instead of the classic model, ClassicAssert.Contains(instance, collection). Motivation The assert ClassicAssert.Contains from the classic Assert model makes it easy to confuse the instance and the collection argument, so this analyzer marks usages of ClassicAssert.Contains. [Test] public void Test() { ClassicAssert.Contains(instance, collection); } How to fix violations The analyzer comes with a code fix that will replace ClassicAssert.Contains(instance, collection) with Assert.That(collection, Does.Contain(instance)). So the code block above will be changed into. [Test] public void Test() { Assert.That(collection, Does.Contain(instance)); } Configure severity Via ruleset file Configure the severity per project, for more info see MSDN. Via .editorconfig file # NUnit2037: Consider using Assert.That(collection, Does.Contain(instance)) instead of ClassicAssert.Contains(instance, collection) dotnet_diagnostic.NUnit2037.severity = chosenSeverity where chosenSeverity can be one of none, silent, suggestion, warning, or error. Via #pragma directive #pragma warning disable NUnit2037 // Consider using Assert.That(collection, Does.Contain(instance)) instead of ClassicAssert.Contains(instance, collection) Code violating the rule here #pragma warning restore NUnit2037 // Consider using Assert.That(collection, Does.Contain(instance)) instead of ClassicAssert.Contains(instance, collection) Or put this at the top of the file to disable all instances. #pragma warning disable NUnit2037 // Consider using Assert.That(collection, Does.Contain(instance)) instead of ClassicAssert.Contains(instance, collection) Via attribute [SuppressMessage] [System.Diagnostics.CodeAnalysis.SuppressMessage(\"Assertion\", \"NUnit2037:Consider using Assert.That(collection, Does.Contain(instance)) instead of ClassicAssert.Contains(instance, collection)\", Justification = \"Reason...\")]"
  },
  "articles/nunit-analyzers/NUnit2038.html": {
    "href": "articles/nunit-analyzers/NUnit2038.html",
    "title": "NUnit2038 | NUnit Docs",
    "summary": "NUnit2038 Consider using Assert.That(actual, Is.InstanceOf(expected)) instead of ClassicAssert.IsInstanceOf(expected, actual) Topic Value Id NUnit2038 Severity Info Enabled True Category Assertion Code ClassicModelAssertUsageAnalyzer Description Consider using the constraint model, Assert.That(actual, Is.InstanceOf(expected)), instead of the classic model, ClassicAssert.IsInstanceOf(expected, actual). Motivation The assert ClassicAssert.IsInstanceOf from the classic Assert model makes it easy to confuse the expected and the actual argument, so this analyzer marks usages of ClassicAssert.IsInstanceOf. [Test] public void Test() { ClassicAssert.IsInstanceOf(expected, actual); } How to fix violations The analyzer comes with a code fix that will replace ClassicAssert.IsInstanceOf(expected, actual) with Assert.That(actual, Is.InstanceOf(expected)). So the code block above will be changed into. [Test] public void Test() { Assert.That(actual, Is.InstanceOf(expected)); } Configure severity Via ruleset file Configure the severity per project, for more info see MSDN. Via .editorconfig file # NUnit2038: Consider using Assert.That(actual, Is.InstanceOf(expected)) instead of ClassicAssert.IsInstanceOf(expected, actual) dotnet_diagnostic.NUnit2038.severity = chosenSeverity where chosenSeverity can be one of none, silent, suggestion, warning, or error. Via #pragma directive #pragma warning disable NUnit2038 // Consider using Assert.That(actual, Is.InstanceOf(expected)) instead of ClassicAssert.IsInstanceOf(expected, actual) Code violating the rule here #pragma warning restore NUnit2038 // Consider using Assert.That(actual, Is.InstanceOf(expected)) instead of ClassicAssert.IsInstanceOf(expected, actual) Or put this at the top of the file to disable all instances. #pragma warning disable NUnit2038 // Consider using Assert.That(actual, Is.InstanceOf(expected)) instead of ClassicAssert.IsInstanceOf(expected, actual) Via attribute [SuppressMessage] [System.Diagnostics.CodeAnalysis.SuppressMessage(\"Assertion\", \"NUnit2038:Consider using Assert.That(actual, Is.InstanceOf(expected)) instead of ClassicAssert.IsInstanceOf(expected, actual)\", Justification = \"Reason...\")]"
  },
  "articles/nunit-analyzers/NUnit2039.html": {
    "href": "articles/nunit-analyzers/NUnit2039.html",
    "title": "NUnit2039 | NUnit Docs",
    "summary": "NUnit2039 Consider using Assert.That(actual, Is.Not.InstanceOf(expected)) instead of ClassicAssert.IsNotInstanceOf(expected, actual) Topic Value Id NUnit2039 Severity Info Enabled True Category Assertion Code ClassicModelAssertUsageAnalyzer Description Consider using the constraint model, Assert.That(actual, Is.Not.InstanceOf(expected)), instead of the classic model, ClassicAssert.IsNotInstanceOf(expected, actual). Motivation The assert ClassicAssert.IsNotInstanceOf from the classic Assert model makes it easy to confuse the expected and the actual argument, so this analyzer marks usages of ClassicAssert.IsNotInstanceOf. [Test] public void Test() { ClassicAssert.IsNotInstanceOf(expected, actual); } How to fix violations The analyzer comes with a code fix that will replace ClassicAssert.IsNotInstanceOf(expected, actual) with Assert.That(actual, Is.Not.InstanceOf(expected)). So the code block above will be changed into. [Test] public void Test() { Assert.That(actual, Is.Not.InstanceOf(expected)); } Configure severity Via ruleset file Configure the severity per project, for more info see MSDN. Via .editorconfig file # NUnit2039: Consider using Assert.That(actual, Is.Not.InstanceOf(expected)) instead of ClassicAssert.IsNotInstanceOf(expected, actual) dotnet_diagnostic.NUnit2039.severity = chosenSeverity where chosenSeverity can be one of none, silent, suggestion, warning, or error. Via #pragma directive #pragma warning disable NUnit2039 // Consider using Assert.That(actual, Is.Not.InstanceOf(expected)) instead of ClassicAssert.IsNotInstanceOf(expected, actual) Code violating the rule here #pragma warning restore NUnit2039 // Consider using Assert.That(actual, Is.Not.InstanceOf(expected)) instead of ClassicAssert.IsNotInstanceOf(expected, actual) Or put this at the top of the file to disable all instances. #pragma warning disable NUnit2039 // Consider using Assert.That(actual, Is.Not.InstanceOf(expected)) instead of ClassicAssert.IsNotInstanceOf(expected, actual) Via attribute [SuppressMessage] [System.Diagnostics.CodeAnalysis.SuppressMessage(\"Assertion\", \"NUnit2039:Consider using Assert.That(actual, Is.Not.InstanceOf(expected)) instead of ClassicAssert.IsNotInstanceOf(expected, actual)\", Justification = \"Reason...\")]"
  },
  "articles/nunit-analyzers/NUnit2040.html": {
    "href": "articles/nunit-analyzers/NUnit2040.html",
    "title": "NUnit2040 | NUnit Docs",
    "summary": "NUnit2040 Non-reference types for SameAs constraint Topic Value Id NUnit2040 Severity Error Enabled True Category Assertion Code SameAsOnValueTypesAnalyzer Description The SameAs constraint always fails on value types as the actual and the expected value cannot be the same reference. Motivation var expected = Guid.Empty; var actual = expected; Assert.That(actual, Is.SameAs(expected)); As Guid is a struct, actual will be a copy of expected but not have the same reference. How to fix violations Replace Is.SameAs with Is.EqualTo. var expected = Guid.Empty; var actual = expected; Assert.That(actual, Is.EqualTo(expected)); Configure severity Via ruleset file Configure the severity per project, for more info see MSDN. Via .editorconfig file # NUnit2040: Non-reference types for SameAs constraint dotnet_diagnostic.NUnit2040.severity = chosenSeverity where chosenSeverity can be one of none, silent, suggestion, warning, or error. Via #pragma directive #pragma warning disable NUnit2040 // Non-reference types for SameAs constraint Code violating the rule here #pragma warning restore NUnit2040 // Non-reference types for SameAs constraint Or put this at the top of the file to disable all instances. #pragma warning disable NUnit2040 // Non-reference types for SameAs constraint Via attribute [SuppressMessage] [System.Diagnostics.CodeAnalysis.SuppressMessage(\"Assertion\", \"NUnit2040:Non-reference types for SameAs constraint\", Justification = \"Reason...\")]"
  },
  "articles/nunit-analyzers/NUnit2041.html": {
    "href": "articles/nunit-analyzers/NUnit2041.html",
    "title": "NUnit2041 | NUnit Docs",
    "summary": "NUnit2041 Incompatible types for comparison constraint Topic Value Id NUnit2041 Severity Error Enabled True Category Assertion Code ComparableTypesAnalyzer Description The comparison constraint always fails as the actual and the expected value are not comparable. Motivation class Foo { } class Bar { } var foo = new Foo(); var bar = new Bar(); Assert.That(foo, Is.GreaterThan(bar)); There is no comparisons defined between instances of types Foo and Bar, therefore such assertion will always fail. How to fix violations Fix your assertion (i.e. fix actual or expected value) or implement IComparable<Bar> on Foo. Configure severity Via ruleset file Configure the severity per project, for more info see MSDN. Via .editorconfig file # NUnit2041: Incompatible types for comparison constraint dotnet_diagnostic.NUnit2041.severity = chosenSeverity where chosenSeverity can be one of none, silent, suggestion, warning, or error. Via #pragma directive #pragma warning disable NUnit2041 // Incompatible types for comparison constraint Code violating the rule here #pragma warning restore NUnit2041 // Incompatible types for comparison constraint Or put this at the top of the file to disable all instances. #pragma warning disable NUnit2041 // Incompatible types for comparison constraint Via attribute [SuppressMessage] [System.Diagnostics.CodeAnalysis.SuppressMessage(\"Assertion\", \"NUnit2041:Incompatible types for comparison constraint\", Justification = \"Reason...\")]"
  },
  "articles/nunit-analyzers/NUnit2042.html": {
    "href": "articles/nunit-analyzers/NUnit2042.html",
    "title": "NUnit2042 | NUnit Docs",
    "summary": "NUnit2042 Comparison constraint on object Topic Value Id NUnit2042 Severity Info Enabled True Category Assertion Code ComparableTypesAnalyzer Description The comparison constraint might fail as the actual and the expected value might not implement IComparable. Motivation public static void ShouldBeGreaterThan(this object actual, object expected, string? message = null) { Assert.That(actual, Is.GreaterThan(expected), message); } In the above function it is assumed that every instance of object is comparable. The function works if the types actually are comparable, but will result in NUnit runtime errors if they are not. How to fix violations Change the type to IComparable. This way you will get compilation failures if called with types that do not implement IComparable. A similar solution can be created which works for types implementing the generic IComparable<T>. public static void ShouldBeGreaterThan(this IComparable actual, IComparable expected, string? message = null) { Assert.That(actual, Is.GreaterThan(expected), message); } public static void ShouldBeGreaterThan<T>(this T actual, T expected, string? message = null) where T : IComparable<T> { Assert.That(actual, Is.GreaterThan(expected), message); } Configure severity Via ruleset file Configure the severity per project, for more info see MSDN. Via .editorconfig file # NUnit2042: Comparison constraint on object dotnet_diagnostic.NUnit2042.severity = chosenSeverity where chosenSeverity can be one of none, silent, suggestion, warning, or error. Via #pragma directive #pragma warning disable NUnit2042 // Comparison constraint on object Code violating the rule here #pragma warning restore NUnit2042 // Comparison constraint on object Or put this at the top of the file to disable all instances. #pragma warning disable NUnit2042 // Comparison constraint on object Via attribute [SuppressMessage] [System.Diagnostics.CodeAnalysis.SuppressMessage(\"Assertion\", \"NUnit2042:Comparison constraint on object\", Justification = \"Reason...\")]"
  },
  "articles/nunit-analyzers/NUnit2043.html": {
    "href": "articles/nunit-analyzers/NUnit2043.html",
    "title": "NUnit2043 | NUnit Docs",
    "summary": "NUnit2043 Use ComparisonConstraint for better assertion messages in case of failure Topic Value Id NUnit2043 Severity Info Enabled True Category Assertion Code ComparisonConstraintUsageAnalyzer Description Using ComparisonConstraint will lead to better assertion messages in case of failure. Motivation Using Is.GreaterThan constraint will lead to better assertion messages in case of failure, so this analyzer marks all usages of a comparison operators >, >=, < and <= where it is possible to replace with the appropriate comparison constraint. [Test] public void Test() { ClassicAssert.True(actual > expected); } How to fix violations The analyzer comes with a code fix that will replace ClassicAssert.True(actual > expected) with Assert.That(actual, Is.GreaterThan(expected)). So the code block above will be changed into [Test] public void Test() { Assert.That(actual, Is.GreaterThan(expected)); } Configure severity Via ruleset file Configure the severity per project, for more info see MSDN. Via .editorconfig file # NUnit2043: Use ComparisonConstraint for better assertion messages in case of failure dotnet_diagnostic.NUnit2043.severity = chosenSeverity where chosenSeverity can be one of none, silent, suggestion, warning, or error. Via #pragma directive #pragma warning disable NUnit2043 // Use ComparisonConstraint for better assertion messages in case of failure Code violating the rule here #pragma warning restore NUnit2043 // Use ComparisonConstraint for better assertion messages in case of failure Or put this at the top of the file to disable all instances. #pragma warning disable NUnit2043 // Use ComparisonConstraint for better assertion messages in case of failure Via attribute [SuppressMessage] [System.Diagnostics.CodeAnalysis.SuppressMessage(\"Assertion\", \"NUnit2043:Use ComparisonConstraint for better assertion messages in case of failure\", Justification = \"Reason...\")]"
  },
  "articles/nunit-analyzers/NUnit2044.html": {
    "href": "articles/nunit-analyzers/NUnit2044.html",
    "title": "NUnit2044 | NUnit Docs",
    "summary": "NUnit2044 Non-delegate actual parameter Topic Value Id NUnit2044 Severity Error Enabled True Category Assertion Code DelegateRequiredAnalyzer Description The actual argument needs to be evaluated by the Assert to catch any exceptions. Motivation In order for the Assert.That to catch an exception or a timeout, the code must be a delegate so it can be evaluated by the method. If the parameter is not a delegate, it will be evaluated before the call to Assert.That and stop further execution. How to fix violations Convert the call into a delegate using a lambda expression or method group. Configure severity Via ruleset file Configure the severity per project, for more info see MSDN. Via .editorconfig file # NUnit2044: Non-delegate actual parameter dotnet_diagnostic.NUnit2044.severity = chosenSeverity where chosenSeverity can be one of none, silent, suggestion, warning, or error. Via #pragma directive #pragma warning disable NUnit2044 // Non-delegate actual parameter Code violating the rule here #pragma warning restore NUnit2044 // Non-delegate actual parameter Or put this at the top of the file to disable all instances. #pragma warning disable NUnit2044 // Non-delegate actual parameter Via attribute [SuppressMessage] [System.Diagnostics.CodeAnalysis.SuppressMessage(\"Assertion\", \"NUnit2044:Non-delegate actual parameter\", Justification = \"Reason...\")]"
  },
  "articles/nunit-analyzers/NUnit2045.html": {
    "href": "articles/nunit-analyzers/NUnit2045.html",
    "title": "NUnit2045 | NUnit Docs",
    "summary": "NUnit2045 Use Assert.EnterMultipleScope or Assert.Multiple Topic Value Id NUnit2045 Severity Info Enabled True Category Assertion Code UseAssertMultipleAnalyzer Description Hosting Asserts inside an Assert.EnterMultipleScope or Assert.Multiple allows detecting more than one failure. Motivation When independent Assert statements are called from an Assert.EnterMultipleScope or Assert.Multiple they all will run. This allows detecting more than one failure in a single test run. Note that Assert.EnterMultipleScope is the preferred method, but this functionality was released in NUnit 4.2. On older NUnit versions one can use Assert.Multiple. Without the Assert.EnterMultipleScope the below code will stop executing after the first failure and the second violation won't be detected until the next run when the first one has been corrected. Assert.That(instance.Property1, Is.EqualTo(expectedProperty1Value)); Assert.That(instance.Property2, Is.EqualTo(expectedProperty2Value)); How to fix violations Add an Assert.EnterMultipleScope using block surrounding the Assert statements. using (Assert.EnterMultipleScope()) { Assert.That(instance.Property1, Is.EqualTo(expectedProperty1Value)); Assert.That(instance.Property2, Is.EqualTo(expectedProperty2Value)); }; Using Assert.Multiple then the fix would look like this - where all the independent Assert statements are called from inside the lambda parameter. Assert.Multiple(() => { Assert.That(instance.Property1, Is.EqualTo(expectedProperty1Value)); Assert.That(instance.Property2, Is.EqualTo(expectedProperty2Value)); }); Configure severity Via ruleset file Configure the severity per project, for more info see MSDN. Via .editorconfig file # NUnit2045: Use Assert.EnterMultipleScope or Assert.Multiple dotnet_diagnostic.NUnit2045.severity = chosenSeverity where chosenSeverity can be one of none, silent, suggestion, warning, or error. Via #pragma directive #pragma warning disable NUnit2045 // Use Assert.EnterMultipleScope or Assert.Multiple Code violating the rule here #pragma warning restore NUnit2045 // Use Assert.EnterMultipleScope or Assert.Multiple Or put this at the top of the file to disable all instances. #pragma warning disable NUnit2045 // Use Assert.EnterMultipleScope or Assert.Multiple Via attribute [SuppressMessage] [System.Diagnostics.CodeAnalysis.SuppressMessage(\"Assertion\", \"NUnit2045:Use Assert.EnterMultipleScope or Assert.Multiple\", Justification = \"Reason...\")]"
  },
  "articles/nunit-analyzers/NUnit2046.html": {
    "href": "articles/nunit-analyzers/NUnit2046.html",
    "title": "NUnit2046 | NUnit Docs",
    "summary": "NUnit2046 Use CollectionConstraint for better assertion messages in case of failure Topic Value Id NUnit2046 Severity Info Enabled True Category Assertion Code UseCollectionConstraintAnalyzer Description Use Has.Length/Has.Count/Is.Empty instead of testing property directly. Motivation Consider the difference in error message between the following pairs of Asserts: int[] array = { 1, 2 }; Assert.That(array.Length, Is.EqualTo(1)); Assert.That(array, Has.Length.EqualTo(1)); The first gives: Expected: 1, But was: 2, the second: Expected: property Length equal to 1, But was: 2 making it clear we talking about number of elements, not just a number. The next example: int[] array = { 1, 2 }; Assert.That(array.Length, Is.EqualTo(0)); Assert.That(array, Is.Empty); This results in Expected: 0, But was: 2 in the first case and Expected: <empty>, But was: < 1, 2 > in the second. int[] array = Array.Empty<int>(); Assert.That(array.Length, Is.GreaterThanOrEqualTo(1)); Assert.That(array, Is.Not.Empty); This would change: Expected: greater than or equal to 1, But was: 0 into Expected: not <empty>, But was: <empty> How to fix violations Replace test on explicit .Length or .Count properties with Has.Length and Has.Count respectively. If testing against the value 0 use Is.Empty or Is.Not.Empty instead. Configure severity Via ruleset file Configure the severity per project, for more info see MSDN. Via .editorconfig file # NUnit2046: Use CollectionConstraint for better assertion messages in case of failure dotnet_diagnostic.NUnit2046.severity = chosenSeverity where chosenSeverity can be one of none, silent, suggestion, warning, or error. Via #pragma directive #pragma warning disable NUnit2046 // Use CollectionConstraint for better assertion messages in case of failure Code violating the rule here #pragma warning restore NUnit2046 // Use CollectionConstraint for better assertion messages in case of failure Or put this at the top of the file to disable all instances. #pragma warning disable NUnit2046 // Use CollectionConstraint for better assertion messages in case of failure Via attribute [SuppressMessage] [System.Diagnostics.CodeAnalysis.SuppressMessage(\"Assertion\", \"NUnit2046:Use CollectionConstraint for better assertion messages in case of failure\", Justification = \"Reason...\")]"
  },
  "articles/nunit-analyzers/NUnit2047.html": {
    "href": "articles/nunit-analyzers/NUnit2047.html",
    "title": "NUnit2047 | NUnit Docs",
    "summary": "NUnit2047 Incompatible types for Within constraint Topic Value Id NUnit2047 Severity Warning Enabled True Category Assertion Code WithinUsageAnalyzer Description The Within modifier should only be used for numeric or Date/Time arguments or tuples containing only these element types. Using it on other types will not have any effect. Motivation To bring developers' attention to a scenario in which their code is actually having no effect and may reveal that their test is not doing what they expect. How to fix violations Example Violation [Test] public void RecordsEqualsMismatch() { var a = new Data(1, 1.0); var b = new Data(1, 1.1); Assert.That(a, Is.EqualTo(b).Within(0.2), $\"{a} != {b}\"); } private sealed record Data(int number, double Value); Explanation Using Within here doesn't make any sense, because NUnit cannot apply comparison with tolerance to the types we're comparing. Fix Remove the errant call to Within: [Test] public void RecordsEqualsMismatch() { var a = new Data(1, 1.0); var b = new Data(1, 1.1); Assert.That(a, Is.EqualTo(b), $\"{a} != {b}\"); } private sealed record Data(int number, double Value); Configure severity Via ruleset file Configure the severity per project, for more info see MSDN. Via .editorconfig file # NUnit2047: Incompatible types for Within constraint dotnet_diagnostic.NUnit2047.severity = chosenSeverity where chosenSeverity can be one of none, silent, suggestion, warning, or error. Via #pragma directive #pragma warning disable NUnit2047 // Incompatible types for Within constraint Code violating the rule here #pragma warning restore NUnit2047 // Incompatible types for Within constraint Or put this at the top of the file to disable all instances. #pragma warning disable NUnit2047 // Incompatible types for Within constraint Via attribute [SuppressMessage] [System.Diagnostics.CodeAnalysis.SuppressMessage(\"Assertion\", \"NUnit2047:Incompatible types for Within constraint\", Justification = \"Reason...\")]"
  },
  "articles/nunit-analyzers/NUnit2048.html": {
    "href": "articles/nunit-analyzers/NUnit2048.html",
    "title": "NUnit2048 | NUnit Docs",
    "summary": "NUnit2048 Consider using Assert.That(...) instead of StringAssert(...) Topic Value Id NUnit2048 Severity Warning Enabled True Category Assertion Code StringAssertUsageAnalyzer Description Consider using the constraint model, Assert.That(actual, {0}(expected)), instead of the classic model, StringAssert.{1}(expected, actual). Motivation The classic Assert model contains less flexibility than the constraint model and makes it easy to mix the expected and the actual parameter, so this analyzer marks usages of all StringAssert methods from the classic Assert model. [Test] public void Test() { StringAssert.Contains(expected, actual); StringAssert.DoesNotContain(expected, actual); StringAssert.StartsWith(expected, actual); StringAssert.DoesNotStartWith(expected, actual); StringAssert.EndsWith(expected, actual); StringAssert.DoesNotEndWith(expected, actual); StringAssert.AreEqualIgnoreCase(expected, actual); StringAssert.AreNotEqualIgnoreCase(expected, actual); StringAssert.IsMatch(expected, actual); StringAssert.DoesNotMatch(expected, actual); } How to fix violations The analyzer comes with a code fix that will replace StringAssert.<method>(expected, actual) with Assert.That(actual, <constraint>(expected)). So the code block above will be changed into. [Test] public void Test() { Assert.That(actual, Does.Contain(expected)); Assert.That(actual, Does.Not.Contain(expected)); Assert.That(actual, Does.StartWith(expected)); Assert.That(actual, Does.Not.StartWith(expected)); Assert.That(actual, Does.EndWith(expected)); Assert.That(actual, Does.Not.EndWith(expected)); Assert.That(actual, Is.EqualTo(expected).IgnoreCase); Assert.That(actual, Is.Not.EqualTo(expected).IgnoreCase); Assert.That(actual, Does.Match(expected)); Assert.That(actual, Does.Not.Match(expected)); } Configure severity Via ruleset file Configure the severity per project, for more info see MSDN. Via .editorconfig file # NUnit2048: Consider using Assert.That(...) instead of StringAssert(...) dotnet_diagnostic.NUnit2048.severity = chosenSeverity where chosenSeverity can be one of none, silent, suggestion, warning, or error. Via #pragma directive #pragma warning disable NUnit2048 // Consider using Assert.That(...) instead of StringAssert(...) Code violating the rule here #pragma warning restore NUnit2048 // Consider using Assert.That(...) instead of StringAssert(...) Or put this at the top of the file to disable all instances. #pragma warning disable NUnit2048 // Consider using Assert.That(...) instead of StringAssert(...) Via attribute [SuppressMessage] [System.Diagnostics.CodeAnalysis.SuppressMessage(\"Assertion\", \"NUnit2048:Consider using Assert.That(...) instead of StringAssert(...)\", Justification = \"Reason...\")]"
  },
  "articles/nunit-analyzers/NUnit2049.html": {
    "href": "articles/nunit-analyzers/NUnit2049.html",
    "title": "NUnit2049 | NUnit Docs",
    "summary": "NUnit2049 Consider using Assert.That(...) instead of CollectionAssert(...) Topic Value Id NUnit2049 Severity Warning Enabled True Category Assertion Code CollectionAssertUsageAnalyzer Description Consider using the constraint model, Assert.That(actual, {0}(expected)), instead of the classic model, CollectionAssert.{1}(expected, actual). Motivation The classic Assert model contains less flexibility than the constraint model and makes it easy to mix the order of the parameters, so this analyzer marks usages of all CollectionAssert methods from the classic Assert model. [Test] public void Test() { CollectionAssert.AllItemsAreInstancesOfType(collection, expected); CollectionAssert.AllItemsAreNotNull(collection); CollectionAssert.AllItemsAreUnique(collection); CollectionAssert.AreEqual(expected, actual); CollectionAssert.AreEquivalent(expected, actual); CollectionAssert.AreNotEqual(expected, actual); CollectionAssert.AreNotEquivalent(expected, actual); CollectionAssert.Contains(collection, expected); CollectionAssert.DoesNotContain(collection, expected); CollectionAssert.IsNotSubsetOf(subset, superset); CollectionAssert.IsSubsetOf(subset, superset); CollectionAssert.IsNotSupersetOf(superset, subset); CollectionAssert.IsSupersetOf(superset, subset); CollectionAssert.IsEmpty(collection); CollectionAssert.IsNotEmpty(collection); CollectionAssert.IsOrdered(collection); } How to fix violations The analyzer comes with a code fix that will replace StringAssert.<method>(expected, actual) with Assert.That(actual, <constraint>(expected)). So the code block above will be changed into. [Test] public void Test() { Assert.That(collection, Is.All.InstanceOf(expected)); Assert.That(collection, Is.All.Not.Null); Assert.That(collection, Is.Unique); Assert.That(actual, Is.EqualTo(expected).AsCollection); Assert.That(actual, Is.EquivalentTo(expected)); Assert.That(actual, Is.Not.EqualTo(expected).AsCollection); Assert.That(actual, Is.Not.EquivalentTo(expected)); Assert.That(collection, Has.Member(expected)); Assert.That(collection, Has.No.Member(expected)); Assert.That(subset, Is.Not.SubsetOf(superset)); Assert.That(subset, Is.SubsetOf(superset)); Assert.That(superset, Is.Not.SupersetOf(subset)); Assert.That(superset, Is.SupersetOf(subset)); Assert.That(collection, Is.Empty); Assert.That(collection, Is.Not.Empty); Assert.That(collection, Is.Ordered); } Configure severity Via ruleset file Configure the severity per project, for more info see MSDN. Via .editorconfig file # NUnit2049: Consider using Assert.That(...) instead of CollectionAssert(...) dotnet_diagnostic.NUnit2049.severity = chosenSeverity where chosenSeverity can be one of none, silent, suggestion, warning, or error. Via #pragma directive #pragma warning disable NUnit2049 // Consider using Assert.That(...) instead of CollectionAssert(...) Code violating the rule here #pragma warning restore NUnit2049 // Consider using Assert.That(...) instead of CollectionAssert(...) Or put this at the top of the file to disable all instances. #pragma warning disable NUnit2049 // Consider using Assert.That(...) instead of CollectionAssert(...) Via attribute [SuppressMessage] [System.Diagnostics.CodeAnalysis.SuppressMessage(\"Assertion\", \"NUnit2049:Consider using Assert.That(...) instead of CollectionAssert(...)\", Justification = \"Reason...\")]"
  },
  "articles/nunit-analyzers/NUnit2050.html": {
    "href": "articles/nunit-analyzers/NUnit2050.html",
    "title": "NUnit2050 | NUnit Docs",
    "summary": "NUnit2050 NUnit 4 no longer supports string.Format specification Topic Value Id NUnit2050 Severity Error Enabled True Category Assertion Code UpdateStringFormatToInterpolatableStringAnalyzer Description Replace format specification with interpolated string. Motivation In order to get better failure messages, NUnit4 uses CallerArgumentExpression to include the expression passed in for the actual and constraint parameters. These are parameters automatically supplied by the compiler. To facilitate this, we needed to drop support for composite formatting. All NUnit4 asserts only allow a single message parameter which can be either a simple string literal or a interpolatable string. This analyzer needs to be run when still building against NUnit3 as otherwise your code won't compile. When usages of the new methods with params are detected, the associated CodeFix will convert the format specification into an interpolated string. The affected methods are: Assert.Pass Assert.Fail Assert.Warn Assert.Ignore Assert.Inconclusive Assert.That Assume.That Once you moved to NUnit4 the analyzer has some limited functionality as there are a few cases with Assert.That or Assume.That where your NUnit3 code will compile on NUnit4, but not the way you want it. Here what you think are parameters to a format specification are actually interpreted as the actual and constraint expression strings. Unfortunately you only find that out when the test fails, which could be never. How to fix violations The following code, valid in NUnit3: [TestCase(4)] public void MustBeMultipleOf3(int value) { Assert.That(value % 3, Is.Zero, \"Expected value ({0}) to be multiple of 3\", value); } Will fail with the following message: Expected value (4) to be multiple of 3 Expected: 0 But was: 1 The associated CodeFix for this Analyzer rule will convert the test into: [TestCase(4)] public void MustBeMultipleOf3(int value) { Assert.That(value % 3, Is.Zero, $\"Expected value ({value}) to be multiple of 3\"); } The failure message for NUnit4 becomes: Expected value (4) to be multiple of 3 Assert.That(value % 3, Is.Zero) Expected: 0 But was: 1 As the [CallerMemberExpression] parameters are string, some of NUnit 3.x code compiles, but when failing show the wrong message: [TestCase(\"NUnit 4\", \"NUnit 3\")] public void TestMessage(string actual, string expected) { Assert.That(actual, Is.EqualTo(expected), \"Expected '{0}', but got: '{1}'\", expected, actual); } When using NUnit3, this results in: Expected 'NUnit 3', but got: 'NUnit 4' String lengths are both 7. Strings differ at index 6. Expected: \"NUnit 3\" But was: \"NUnit 4\" -----------------^ But when using NUnit4, we get: Message: Expected '{0}', but got: '{1}' Assert.That(NUnit 3, NUnit 4) String lengths are both 7. Strings differ at index 6. Expected: \"NUnit 3\" But was: \"NUnit 4\" -----------------^ Where the format string is treated as the message and its arguments are interpreted as the actual and expected expressions! After applying the code fix the code looks like: [TestCase(\"NUnit 4\", \"NUnit 3\")] public void TestMessage(string actual, string expected) { Assert.That(actual, Is.EqualTo(expected), $\"Expected '{expected}', but got: '{actual}'\"); } and the output: Message: Expected 'NUnit 3', but got: 'NUnit 4' Assert.That(actual, Is.EqualTo(expected)) String lengths are both 7. Strings differ at index 6. Expected: \"NUnit 3\" But was: \"NUnit 4\" -----------------^ Configure severity Via ruleset file Configure the severity per project, for more info see MSDN. Via .editorconfig file # NUnit2050: NUnit 4 no longer supports string.Format specification dotnet_diagnostic.NUnit2050.severity = chosenSeverity where chosenSeverity can be one of none, silent, suggestion, warning, or error. Via #pragma directive #pragma warning disable NUnit2050 // NUnit 4 no longer supports string.Format specification Code violating the rule here #pragma warning restore NUnit2050 // NUnit 4 no longer supports string.Format specification Or put this at the top of the file to disable all instances. #pragma warning disable NUnit2050 // NUnit 4 no longer supports string.Format specification Via attribute [SuppressMessage] [System.Diagnostics.CodeAnalysis.SuppressMessage(\"Assertion\", \"NUnit2050:NUnit 4 no longer supports string.Format specification\", Justification = \"Reason...\")]"
  },
  "articles/nunit-analyzers/NUnit2051.html": {
    "href": "articles/nunit-analyzers/NUnit2051.html",
    "title": "NUnit2051 | NUnit Docs",
    "summary": "NUnit2051 Consider using Assert.That(expr, Is.Positive) instead of ClassicAssert.Positive(expr) Topic Value Id NUnit2051 Severity Info Enabled True Category Assertion Code ClassicModelAssertUsageAnalyzer Description Consider using the constraint model, Assert.That(expr, Is.Positive), instead of the classic model, ClassicAssert.Positive(expr). Motivation The classic Assert model contains less flexibility than the constraint model, so this analyzer marks usages of ClassicAssert.Positive from the classic Assert model. [Test] public void Test() { ClassicAssert.Positive(expression); } How to fix violations The analyzer comes with a code fix that will replace ClassicAssert.Positive(expression) with Assert.That(expression, Is.Positive). So the code block above will be changed into. [Test] public void Test() { Assert.That(expression, Is.Positive); } Configure severity Via ruleset file Configure the severity per project, for more info see MSDN. Via .editorconfig file # NUnit2051: Consider using Assert.That(expr, Is.Positive) instead of ClassicAssert.Positive(expr) dotnet_diagnostic.NUnit2051.severity = chosenSeverity where chosenSeverity can be one of none, silent, suggestion, warning, or error. Via #pragma directive #pragma warning disable NUnit2051 // Consider using Assert.That(expr, Is.Positive) instead of ClassicAssert.Positive(expr) Code violating the rule here #pragma warning restore NUnit2051 // Consider using Assert.That(expr, Is.Positive) instead of ClassicAssert.Positive(expr) Or put this at the top of the file to disable all instances. #pragma warning disable NUnit2051 // Consider using Assert.That(expr, Is.Positive) instead of ClassicAssert.Positive(expr) Via attribute [SuppressMessage] [System.Diagnostics.CodeAnalysis.SuppressMessage(\"Assertion\", \"NUnit2051:Consider using Assert.That(expr, Is.Positive) instead of ClassicAssert.Positive(expr)\", Justification = \"Reason...\")]"
  },
  "articles/nunit-analyzers/NUnit2052.html": {
    "href": "articles/nunit-analyzers/NUnit2052.html",
    "title": "NUnit2052 | NUnit Docs",
    "summary": "NUnit2052 Consider using Assert.That(expr, Is.Negative) instead of ClassicAssert.Negative(expr) Topic Value Id NUnit2052 Severity Info Enabled True Category Assertion Code ClassicModelAssertUsageAnalyzer Description Consider using the constraint model, Assert.That(expr, Is.Negative), instead of the classic model, ClassicAssert.Negative(expr). Motivation The classic Assert model contains less flexibility than the constraint model, so this analyzer marks usages of ClassicAssert.Negative from the classic Assert model. [Test] public void Test() { ClassicAssert.Negative(expression); } How to fix violations The analyzer comes with a code fix that will replace ClassicAssert.Negative(expression) with Assert.That(expression, Is.Negative). So the code block above will be changed into. [Test] public void Test() { Assert.That(expression, Is.Negative); } Configure severity Via ruleset file Configure the severity per project, for more info see MSDN. Via .editorconfig file # NUnit2052: Consider using Assert.That(expr, Is.Negative) instead of ClassicAssert.Negative(expr) dotnet_diagnostic.NUnit2052.severity = chosenSeverity where chosenSeverity can be one of none, silent, suggestion, warning, or error. Via #pragma directive #pragma warning disable NUnit2052 // Consider using Assert.That(expr, Is.Negative) instead of ClassicAssert.Negative(expr) Code violating the rule here #pragma warning restore NUnit2052 // Consider using Assert.That(expr, Is.Negative) instead of ClassicAssert.Negative(expr) Or put this at the top of the file to disable all instances. #pragma warning disable NUnit2052 // Consider using Assert.That(expr, Is.Negative) instead of ClassicAssert.Negative(expr) Via attribute [SuppressMessage] [System.Diagnostics.CodeAnalysis.SuppressMessage(\"Assertion\", \"NUnit2052:Consider using Assert.That(expr, Is.Negative) instead of ClassicAssert.Negative(expr)\", Justification = \"Reason...\")]"
  },
  "articles/nunit-analyzers/NUnit2053.html": {
    "href": "articles/nunit-analyzers/NUnit2053.html",
    "title": "NUnit2053 | NUnit Docs",
    "summary": "NUnit2053 Consider using Assert.That(actual, Is.AssignableFrom(expected)) instead of ClassicAssert.IsAssignableFrom(expected, actual) Topic Value Id NUnit2053 Severity Info Enabled True Category Assertion Code ClassicModelAssertUsageAnalyzer Description Consider using the constraint model, Assert.That(actual, Is.AssignableFrom(expected)), instead of the classic model, ClassicAssert.IsAssignableFrom(expected, actual). Motivation The assert ClassicAssert.IsAssignableFrom from the classic Assert model makes it easy to confuse the expected and the actual argument, so this analyzer marks usages of ClassicAssert.IsAssignableFrom. [Test] public void Test() { ClassicAssert.IsAssignableFrom(expected, actual); } How to fix violations The analyzer comes with a code fix that will replace ClassicAssert.IsAssignableFrom(expected, actual) with Assert.That(actual, Is.AssignableFrom(expected)). So the code block above will be changed into. [Test] public void Test() { Assert.That(actual, Is.AssignableFrom(expected)); } Configure severity Via ruleset file Configure the severity per project, for more info see MSDN. Via .editorconfig file # NUnit2053: Consider using Assert.That(actual, Is.AssignableFrom(expected)) instead of ClassicAssert.IsAssignableFrom(expected, actual) dotnet_diagnostic.NUnit2053.severity = chosenSeverity where chosenSeverity can be one of none, silent, suggestion, warning, or error. Via #pragma directive #pragma warning disable NUnit2053 // Consider using Assert.That(actual, Is.AssignableFrom(expected)) instead of ClassicAssert.IsAssignableFrom(expected, actual) Code violating the rule here #pragma warning restore NUnit2053 // Consider using Assert.That(actual, Is.AssignableFrom(expected)) instead of ClassicAssert.IsAssignableFrom(expected, actual) Or put this at the top of the file to disable all instances. #pragma warning disable NUnit2053 // Consider using Assert.That(actual, Is.AssignableFrom(expected)) instead of ClassicAssert.IsAssignableFrom(expected, actual) Via attribute [SuppressMessage] [System.Diagnostics.CodeAnalysis.SuppressMessage(\"Assertion\", \"NUnit2053:Consider using Assert.That(actual, Is.AssignableFrom(expected)) instead of ClassicAssert.IsAssignableFrom(expected, actual)\", Justification = \"Reason...\")]"
  },
  "articles/nunit-analyzers/NUnit2054.html": {
    "href": "articles/nunit-analyzers/NUnit2054.html",
    "title": "NUnit2054 | NUnit Docs",
    "summary": "NUnit2054 Consider using Assert.That(actual, Is.Not.AssignableFrom(expected)) instead of ClassicAssert.IsNotAssignableFrom(expected, actual) Topic Value Id NUnit2054 Severity Info Enabled True Category Assertion Code ClassicModelAssertUsageAnalyzer Description Consider using the constraint model, Assert.That(actual, Is.Not.AssignableFrom(expected)), instead of the classic model, ClassicAssert.IsNotAssignableFrom(expected, actual). Motivation The assert ClassicAssert.IsNotAssignableFrom from the classic Assert model makes it easy to confuse the expected and the actual argument, so this analyzer marks usages of ClassicAssert.IsNotAssignableFrom. [Test] public void Test() { ClassicAssert.IsNotAssignableFrom(expected, actual); } How to fix violations The analyzer comes with a code fix that will replace ClassicAssert.IsNotAssignableFrom(expected, actual) with Assert.That(actual, Is.Not.AssignableFrom(expected)). So the code block above will be changed into. [Test] public void Test() { Assert.That(actual, Is.Not.AssignableFrom(expected)); } Configure severity Via ruleset file Configure the severity per project, for more info see MSDN. Via .editorconfig file # NUnit2054: Consider using Assert.That(actual, Is.Not.AssignableFrom(expected)) instead of ClassicAssert.IsNotAssignableFrom(expected, actual) dotnet_diagnostic.NUnit2054.severity = chosenSeverity where chosenSeverity can be one of none, silent, suggestion, warning, or error. Via #pragma directive #pragma warning disable NUnit2054 // Consider using Assert.That(actual, Is.Not.AssignableFrom(expected)) instead of ClassicAssert.IsNotAssignableFrom(expected, actual) Code violating the rule here #pragma warning restore NUnit2054 // Consider using Assert.That(actual, Is.Not.AssignableFrom(expected)) instead of ClassicAssert.IsNotAssignableFrom(expected, actual) Or put this at the top of the file to disable all instances. #pragma warning disable NUnit2054 // Consider using Assert.That(actual, Is.Not.AssignableFrom(expected)) instead of ClassicAssert.IsNotAssignableFrom(expected, actual) Via attribute [SuppressMessage] [System.Diagnostics.CodeAnalysis.SuppressMessage(\"Assertion\", \"NUnit2054:Consider using Assert.That(actual, Is.Not.AssignableFrom(expected)) instead of ClassicAssert.IsNotAssignableFrom(expected, actual)\", Justification = \"Reason...\")]"
  },
  "articles/nunit-analyzers/NUnit2055.html": {
    "href": "articles/nunit-analyzers/NUnit2055.html",
    "title": "NUnit2055 | NUnit Docs",
    "summary": "NUnit2055 Consider using Is.InstanceOf<T> constraint instead of an 'is T' expression Topic Value Id NUnit2055 Severity Info Enabled True Category Assertion Code InstanceOfAnalyzer Description Consider using Is.InstanceOf<T> instead of 'is T' expression for better assertion messages. Motivation Using the Is.InstanceOf<T> (or Is.Not.InstanceOf<T>) constraint will lead to better assertion messages when a test fails. This analyzer identifies usages of the is operator that can be replaced with Is.InstanceOf<T> to improve the quality of assertion messages. [Test] public void Test() { Assert.That(instance1 is SomeType); Assert.That(instance2 is AnotherType, Is.True); Assert.That(instance3 is ThirdType, Is.False); } How to fix violations The analyzer comes with a code fix that will replace Assert.That(instance is SomeType, Is.True) and Assert.That(instance is SomeType) into Assert.That(instance, Is.InstanceOf<SomeType>()) and similarly replace Assert.That(instance is SomeType, Is.False) into Assert.That(instance, Is.Not.InstanceOf<SomeType>()). So the code block above will be changed into [Test] public void Test() { Assert.That(instance1, Is.InstanceOf<SomeType>()); Assert.That(instance2, Is.InstanceOf<AnotherType>()); Assert.That(instance3, Is.Not.InstanceOf<ThirdType>()); } Configure severity Via ruleset file Configure the severity per project, for more info see MSDN. Via .editorconfig file # NUnit2055: Consider using Is.InstanceOf<T> constraint instead of an 'is T' expression dotnet_diagnostic.NUnit2055.severity = chosenSeverity where chosenSeverity can be one of none, silent, suggestion, warning, or error. Via #pragma directive #pragma warning disable NUnit2055 // Consider using Is.InstanceOf<T> constraint instead of an 'is T' expression Code violating the rule here #pragma warning restore NUnit2055 // Consider using Is.InstanceOf<T> constraint instead of an 'is T' expression Or put this at the top of the file to disable all instances. #pragma warning disable NUnit2055 // Consider using Is.InstanceOf<T> constraint instead of an 'is T' expression Via attribute [SuppressMessage] [System.Diagnostics.CodeAnalysis.SuppressMessage(\"Assertion\", \"NUnit2055:Consider using Is.InstanceOf<T> constraint instead of an 'is T' expression\", Justification = \"Reason...\")]"
  },
  "articles/nunit-analyzers/NUnit2056.html": {
    "href": "articles/nunit-analyzers/NUnit2056.html",
    "title": "NUnit2056 | NUnit Docs",
    "summary": "NUnit2056 Consider using Assert.EnterMultipleScope statement instead of Assert.Multiple/Assert.MultipleAsync Topic Value Id NUnit2056 Severity Info Enabled True Category Assertion Code UseAssertEnterMultipleScopeAnalyzer Description Consider using Assert.EnterMultipleScope statement instead of Assert.Multiple/Assert.MultipleAsync. Motivation Prior to NUnit 4.2, developers used two separate methods to group multiple assertions into a single logical assertion: Assert.Multiple for synchronous code Assert.MultipleAsync for asynchronous code This approach, while functional, had limitations — in particular around unnecessary context capture and limited static analysis due to the use of lambda expressions. With the release of NUnit 4.2, a new API was introduced: Assert.EnterMultipleScope. This method unifies the handling of multiple assertions for both sync and async code and avoids the problems above. For more information on EnterMultipleScope see the discussion in this Feature Request [Test] public void TestMultiple() { Assert.Multiple(() => { var i = 4; var j = 67; Assert.That(i, Is.EqualTo(j)); }); } and [Test] public async Task TestMultipleAsync() { await Assert.MultipleAsync(async () => { var i = await GetInt(); var j = await GetInt(); Assert.That(i, Is.EqualTo(j)); }); } How to fix violations The analyzer comes with a code fix that will replace Assert.Multiple and Assert.MultipleAsync with using (Assert.EnterMultipleScope()) and keep the body of the methods as body of the using statement. So the methods above will be changed into. [Test] public void TestMultiple() { using (Assert.EnterMultipleScope()) { var i = 4; var j = 67; Assert.That(i, Is.EqualTo(j)); } } and [Test] public async Task TestMultipleAsync() { using (Assert.EnterMultipleScope()) { var i = await GetInt(); var j = await GetInt(); Assert.That(i, Is.EqualTo(j)); } } Configure severity Via ruleset file Configure the severity per project, for more info see MSDN. Via .editorconfig file # NUnit2056: Consider using Assert.EnterMultipleScope statement instead of Assert.Multiple/Assert.MultipleAsync dotnet_diagnostic.NUnit2056.severity = chosenSeverity where chosenSeverity can be one of none, silent, suggestion, warning, or error. Via #pragma directive #pragma warning disable NUnit2056 // Consider using Assert.EnterMultipleScope statement instead of Assert.Multiple/Assert.MultipleAsync Code violating the rule here #pragma warning restore NUnit2056 // Consider using Assert.EnterMultipleScope statement instead of Assert.Multiple/Assert.MultipleAsync Or put this at the top of the file to disable all instances. #pragma warning disable NUnit2056 // Consider using Assert.EnterMultipleScope statement instead of Assert.Multiple/Assert.MultipleAsync Via attribute [SuppressMessage] [System.Diagnostics.CodeAnalysis.SuppressMessage(\"Assertion\", \"NUnit2056:Consider using Assert.EnterMultipleScope statement instead of Assert.Multiple/Assert.MultipleAsync\", Justification = \"Reason...\")]"
  },
  "articles/nunit-analyzers/NUnit3001.html": {
    "href": "articles/nunit-analyzers/NUnit3001.html",
    "title": "NUnit3001 | NUnit Docs",
    "summary": "NUnit3001 Expression was checked in an ClassicAssert.NotNull, ClassicAssert.IsNotNull or Assert.That call Topic Value Id NUnit3001 Severity Info Enabled True Category Suppressor Code DereferencePossiblyNullReferenceSuppressor Description This rule check diagnostics reported by the CS8601-CS8607 and CS8629 compiler errors: CS8602: Dereference of a possibly null reference. It then checks the previous statements for one of: ClassicAssert.NotNull(...) ClassicAssert.IsNotNull(...) Assert.That(..., Is.Not.Null) For the same expression as the one that raised the original compiler error. If found, the compiler error is suppressed. The rule also covers CS8629: Nullable value type may be null In this case, the previous statement is allowed to be one of: Assert.That(...HasValue) Assert.That(...HasValue, Is.True) ClassicAssert.True(...HasValue) ClassicAssert.IsTrue(...HasValue) The exception is that if the statement is part of an Assert.Multiple it is not suppressed, as in this case the statement containing the compiler error will be executed. Motivation [TestFixture] internal sealed class SomeClassFixture { private SomeClass instance; [SetUp] public void Setup() { instance = new SomeClass(); } [Test] public void Test() { string? result = instance.MethodUnderTest(); Assert.That(result, Is.Not.Null); Assert.That(result.Length, Is.GreaterThan(0)); } [Test] public void TestMultiple() { string? result = instance.MethodUnderTest(); Assert.Multiple(() => { Assert.That(result, Is.Not.Null); Assert.That(result.Length, Is.GreaterThan(0)); }); } } In the above fixture the compiler would give a warnings because result can be null and the compiler knows nothing about the Assert.That(result, Is.Not.Null); statement. The first occurrence - in the Test method - will be suppressed, the second - in the TestMultiple - will not. How to fix violations Ensure that the reference is not null before dereferencing it. This can be done using regular C# language constructs or NUnit assertions. Configure severity The rule has no severity, but can be disabled. Via ruleset file To disable the rule for a project, you need to add a ruleset file <?xml version=\"1.0\" encoding=\"utf-8\"?> <RuleSet Name=\"NUnit.Analyzer Suppressions\" Description=\"DiagnosticSuppression Rules\" ToolsVersion=\"12.0\"> <Rules AnalyzerId=\"DiagnosticSuppressors\" RuleNamespace=\"NUnit.NUnitAnalyzers\"> <Rule Id=\"NUnit3001\" Action=\"Info\" /> <!-- Possible Null Reference --> <Rule Id=\"NUnit3002\" Action=\"Info\" /> <!-- NonNullableField/Property is Uninitialized --> <Rule Id=\"NUnit3003\" Action=\"Info\" /> <!-- Avoid Uninstantiated Internal Classes --> <Rule Id=\"NUnit3004\" Action=\"Info\" /> <!-- Types that own disposable fields should be disposable --> </Rules> </RuleSet> and add it to the project like: <PropertyGroup> <CodeAnalysisRuleSet>NUnit.Analyzers.Suppressions.ruleset</CodeAnalysisRuleSet> </PropertyGroup> For more info about rulesets see MSDN. Via .editorconfig file This is currently not working. Waiting for Roslyn # NUnit3001: Expression was checked in an ClassicAssert.NotNull, ClassicAssert.IsNotNull or Assert.That call dotnet_diagnostic.NUnit3001.severity = none"
  },
  "articles/nunit-analyzers/NUnit3002.html": {
    "href": "articles/nunit-analyzers/NUnit3002.html",
    "title": "NUnit3002 | NUnit Docs",
    "summary": "NUnit3002 Field/Property is initialized in SetUp or OneTimeSetUp method Topic Value Id NUnit3002 Severity Info Enabled True Category Suppressor Code NonNullableFieldOrPropertyIsUninitializedSuppressor Description This rule check diagnostics reported by the CS8618 compiler error: CS8618: Non-nullable field '_name_' must contain a non-null value when exiting constructor. Consider declaring the field as nullable. CS8618: Non-nullable property '_Name_' must contain a non-null value when exiting constructor. Consider declaring the property as nullable. If the violating field/property is set in the SetUp or OneTimeSetUp method. The rule suppresses the error. This allows for non-nullable fields/properties to be used in a TestFixture. The rule does detect indirect calls, when the field is set in a method called by the SetUp or OneTimeSetUp methods. Motivation [TestFixture] internal sealed class SomeClassFixture { private SomeClass instance; [SetUp] public void Setup() { instance = new SomeClass(); } [Test] public void Test() { Assert.That(instance.MethodUnderTest(), Is.True) } } In the above fixture the compiler would give a warning because instance is not set in the constructor. The suggestion to mark instance as nullable would mean that we have to test for null in all Test methods or use the null suppression operator (!) everywhere. How to fix violations Initialize the field in the SetUp or OneTimeSetUp methods. Configure severity The rule has no severity, but can be disabled. Via ruleset file To disable the rule for a project, you need to add a ruleset file <?xml version=\"1.0\" encoding=\"utf-8\"?> <RuleSet Name=\"NUnit.Analyzer Suppressions\" Description=\"DiagnosticSuppression Rules\" ToolsVersion=\"12.0\"> <Rules AnalyzerId=\"DiagnosticSuppressors\" RuleNamespace=\"NUnit.NUnitAnalyzers\"> <Rule Id=\"NUnit3001\" Action=\"Info\" /> <!-- Possible Null Reference --> <Rule Id=\"NUnit3002\" Action=\"Info\" /> <!-- NonNullableField/Property is Uninitialized --> <Rule Id=\"NUnit3003\" Action=\"Info\" /> <!-- Avoid Uninstantiated Internal Classes --> <Rule Id=\"NUnit3004\" Action=\"Info\" /> <!-- Types that own disposable fields should be disposable --> </Rules> </RuleSet> and add it to the project like: <PropertyGroup> <CodeAnalysisRuleSet>NUnit.Analyzers.Suppressions.ruleset</CodeAnalysisRuleSet> </PropertyGroup> For more info about rulesets see MSDN. Via .editorconfig file This is currently not working. Waiting for Roslyn # NUnit3002: Field/Property is initialized in SetUp or OneTimeSetUp method dotnet_diagnostic.NUnit3002.severity = none"
  },
  "articles/nunit-analyzers/NUnit3003.html": {
    "href": "articles/nunit-analyzers/NUnit3003.html",
    "title": "NUnit3003 | NUnit Docs",
    "summary": "NUnit3003 Class is an NUnit TestFixture and is instantiated using reflection Topic Value Id NUnit3003 Severity Info Enabled True Category Suppressor Code AvoidUninstantiatedInternalClassSuppressor Description Class is a NUnit TestFixture and called by reflection Motivation The default roslyn analyzer has rule CA1812 which warns about internal classes not being used. That analyzer doesn't know about NUnit test classes. This suppressor catches the error, verifies the class is an NUnit TestFixture and if so suppresses the error. Configure severity The rule has no severity, but can be disabled. Via ruleset file To disable the rule for a project, you need to add a ruleset file <?xml version=\"1.0\" encoding=\"utf-8\"?> <RuleSet Name=\"NUnit.Analyzer Suppressions\" Description=\"DiagnosticSuppression Rules\" ToolsVersion=\"12.0\"> <Rules AnalyzerId=\"DiagnosticSuppressors\" RuleNamespace=\"NUnit.NUnitAnalyzers\"> <Rule Id=\"NUnit3001\" Action=\"Info\" /> <!-- Possible Null Reference --> <Rule Id=\"NUnit3002\" Action=\"Info\" /> <!-- NonNullableField/Property is Uninitialized --> <Rule Id=\"NUnit3003\" Action=\"Info\" /> <!-- Avoid Uninstantiated Internal Classes --> <Rule Id=\"NUnit3004\" Action=\"Info\" /> <!-- Types that own disposable fields should be disposable --> </Rules> </RuleSet> and add it to the project like: <PropertyGroup> <CodeAnalysisRuleSet>NUnit.Analyzers.Suppressions.ruleset</CodeAnalysisRuleSet> </PropertyGroup> For more info about rulesets see MSDN. Via .editorconfig file This is currently not working. Waiting for Roslyn # NUnit3003: Class is an NUnit TestFixture and is instantiated using reflection dotnet_diagnostic.NUnit3003.severity = none"
  },
  "articles/nunit-analyzers/NUnit3004.html": {
    "href": "articles/nunit-analyzers/NUnit3004.html",
    "title": "NUnit3004 | NUnit Docs",
    "summary": "NUnit3004 Field should be Disposed in TearDown or OneTimeTearDown method Topic Value Id NUnit3004 Severity Info Enabled True Category Suppressor Code TypesThatOwnDisposableFieldsShouldBeDisposableSuppressor Description Field/Property is Disposed in TearDown or OneTimeTearDown method Motivation The Roslyn analyzer fires CA1001 for classes that have IDisposable members, but itself is not IDisposable. Many NUnit tests initialize fields in tests or a SetUp method and then Dispose them in the TearDown method. How to fix violations Ensure that all IDisposable fields have a Dispose call in the TearDown method. Configure severity The rule has no severity, but can be disabled. Via ruleset file To disable the rule for a project, you need to add a ruleset file <?xml version=\"1.0\" encoding=\"utf-8\"?> <RuleSet Name=\"NUnit.Analyzer Suppressions\" Description=\"DiagnosticSuppression Rules\" ToolsVersion=\"12.0\"> <Rules AnalyzerId=\"DiagnosticSuppressors\" RuleNamespace=\"NUnit.NUnitAnalyzers\"> <Rule Id=\"NUnit3001\" Action=\"Info\" /> <!-- Possible Null Reference --> <Rule Id=\"NUnit3002\" Action=\"Info\" /> <!-- NonNullableField/Property is Uninitialized --> <Rule Id=\"NUnit3003\" Action=\"Info\" /> <!-- Avoid Uninstantiated Internal Classes --> <Rule Id=\"NUnit3004\" Action=\"Info\" /> <!-- Types that own disposable fields should be disposable --> </Rules> </RuleSet> and add it to the project like: <PropertyGroup> <CodeAnalysisRuleSet>NUnit.Analyzers.Suppressions.ruleset</CodeAnalysisRuleSet> </PropertyGroup> For more info about rulesets see MSDN. Via .editorconfig file This is currently not working. Waiting for Roslyn # NUnit3004: Field should be Disposed in TearDown or OneTimeTearDown method dotnet_diagnostic.NUnit3004.severity = none"
  },
  "articles/nunit-analyzers/NUnit4001.html": {
    "href": "articles/nunit-analyzers/NUnit4001.html",
    "title": "NUnit4001 | NUnit Docs",
    "summary": "NUnit4001 Simplify the Values attribute Topic Value Id NUnit4001 Severity Info Enabled True Category Style Code SimplifyValuesAnalyzer Description Consider removing unnecessary parameters from the ValuesAttribute. Motivation When used without any arguments, the [Values] attribute on a (nullable) boolean or an (nullable) enum parameter will automatically include all possible values. Therefore the Values attribute like [Test] public void MyBoolTest([Values(true, false)] bool value) { /* ... */ } can be simplified to [Test] public void MyBoolTest([Values] bool value) { /* ... */ } How to fix violations Remove all arguments of the Values attribute. Configure severity Via ruleset file Configure the severity per project, for more info see MSDN. Via .editorconfig file # NUnit4001: Simplify the Values attribute dotnet_diagnostic.NUnit4001.severity = chosenSeverity where chosenSeverity can be one of none, silent, suggestion, warning, or error. Via #pragma directive #pragma warning disable NUnit4001 // Simplify the Values attribute Code violating the rule here #pragma warning restore NUnit4001 // Simplify the Values attribute Or put this at the top of the file to disable all instances. #pragma warning disable NUnit4001 // Simplify the Values attribute Via attribute [SuppressMessage] [System.Diagnostics.CodeAnalysis.SuppressMessage(\"Style\", \"NUnit4001:Simplify the Values attribute\", Justification = \"Reason...\")]"
  },
  "articles/nunit-analyzers/NUnit4002.html": {
    "href": "articles/nunit-analyzers/NUnit4002.html",
    "title": "NUnit4002 | NUnit Docs",
    "summary": "NUnit4002 Use Specific constraint Topic Value Id NUnit4002 Severity Info Enabled True Category Style Code UseSpecificConstraintAnalyzer Description Replace 'EqualTo' with a keyword in the corresponding specific constraint. Motivation Sometimes constraints can be written more concisely using the inbuilt constraints provided by NUnit - e.g. Is.True instead of Is.EqualTo(true). Also, from NUnit version 4.3.0 where new overloads of Is.EqualTo were introduced, it is sometimes not possible to uniquely determine default when provided as the expected value - e.g. in Is.EqualTo(default). Again, in such cases, it is better to use the inbuilt constraint provided by NUnit. Some examples of constraints that can be be simplified by using a more specific constraint can be seen below. [Test] public void Test() { Assert.That(actualFalse, Is.EqualTo(false)); Assert.That(actualTrue, Is.EqualTo(true)); Assert.That(actualObject, Is.EqualTo(null)); Assert.That(actualObject, Is.EqualTo(default)); Assert.That(actualInt, Is.EqualTo(default)); } How to fix violations The analyzer comes with a code fix that will replace the constraint Is.EqualTo(x) with the matching Is.X constraint (for some x). So the code block above will be changed into [Test] public void Test() { Assert.That(actualFalse, Is.False); Assert.That(actualTrue, Is.True); Assert.That(actualObject, Is.Null); Assert.That(actualObject, Is.Null); Assert.That(actualInt, Is.Default); } Configure severity Via ruleset file Configure the severity per project, for more info see MSDN. Via .editorconfig file # NUnit4002: Use Specific constraint dotnet_diagnostic.NUnit4002.severity = chosenSeverity where chosenSeverity can be one of none, silent, suggestion, warning, or error. Via #pragma directive #pragma warning disable NUnit4002 // Use Specific constraint Code violating the rule here #pragma warning restore NUnit4002 // Use Specific constraint Or put this at the top of the file to disable all instances. #pragma warning disable NUnit4002 // Use Specific constraint Via attribute [SuppressMessage] [System.Diagnostics.CodeAnalysis.SuppressMessage(\"Style\", \"NUnit4002:Use Specific constraint\", Justification = \"Reason...\")]"
  },
  "articles/nunit-engine/Getting-Started.html": {
    "href": "articles/nunit-engine/Getting-Started.html",
    "title": "Getting Started with the NUnit Engine | NUnit Docs",
    "summary": "Getting Started with the NUnit Engine Building your own test runner? This guide covers the basics of getting up and running. Fundamentals The engine is designed to be accessed through the methods exposed in the nunit.engine.api assembly - which is the only assembly which should be referenced by runners wishing to use the engine. The API exposed through this assembly will be maintained in a backwards-compatible way wherever possible. The actual engine itself is contained within the nunit.engine assembly, and its dependencies. This assembly should not be referenced by the runners, as methods exposed here could be subject to changes in future versions. Instead, the API should be used to locate and load an appropriate version of the engine, which will return an instance of the ITestEngine interface to the runner. Packages The NUnit Engine can be found in the NUnit.Engine NuGet Package. It is also included within the .zip file found in nunit-console repository releases. Using the API The TestEngineActivator class is first used to obtain an instance of the engine. Tests are specified inside a TestPackage, which can contain one or many different test assemblies. Settings related to how the tests should be run are attached to the test package. Once a test package has been created, the engine can generate an instance of an ITestRunner, which will be constructed to reflect the structure of your test package. Finally, Run can be called on the ITestRunner, to run tests in the specified package. This will return an XmlNode which contains the results of the test run, in the standard NUnit Test Results format. The following example shows the simplest path of how to get a copy of the engine, create a runner and run tests using the interfaces: // Get an interface to the engine ITestEngine engine = TestEngineActivator.CreateInstance(); // Create a simple test package - one assembly, no special settings TestPackage package = new TestPackage(\"my.test.assembly.dll\"); // Get a runner for the test package ITestRunner runner = engine.GetRunner(package); // Run all the tests in the assembly XmlNode testResult = runner.Run(listener: null, TestFilter.Empty); For further details of what can be achieved with the Engine, see the Test Engine API Page."
  },
  "articles/nunit-engine/Index.html": {
    "href": "articles/nunit-engine/Index.html",
    "title": "NUnit Engine | NUnit Docs",
    "summary": "NUnit Engine The NUnit Engine is the component used as the foundation of any test runner. It contains all the logic required to run tests built against both NUnit 3.X and other frameworks, and exposes an API allowing test runners to interact with the engine and run tests as required. Note The NUnit Engine is a component targeted at advanced users of NUnit, who are building their own test runner, rather than using one of the many existing test runners in the ecosystem. If you are looking to simply run tests that you have written, see the running tests section. The engine exposes an API designed to be used by test runners, which will be maintained in a backwards-compatible fashion wherever possible. The engine also hosts various extension points, to allow further customization."
  },
  "articles/nunit-engine/Test-Engine-API.html": {
    "href": "articles/nunit-engine/Test-Engine-API.html",
    "title": "Test Engine API | NUnit Docs",
    "summary": "Test Engine API The NUnit Test Engine API is our published API for discovering, exploring and executing tests programmatically. Third-party test runners should use the Engine API as the supported method to execute NUnit tests. Overview The static class TestEngineActivator is used to get an interface to the engine. Its CreateInstance member has two overloads, depending on whether a particular minimum version of the engine is required. public static ITestEngine CreateInstance(bool unused = false); public static ITestEngine CreateInstance(Version minVersion, bool unused = false); (The unused bool parameter previously allowed users to indicate if wished to restrict usage of global NUnit Engine installations. The latter functionality is no longer available.) The TestEngineActivator searches for an engine to load in two places. First, the current App Domain Base Directory is searched, and then any path set as the App Domain's RelativeSearchPath. Key Interfaces The runner deals with the engine through a set of interfaces. These are quite general because we hope to avoid many changes to this API. ITestEngine This is the primary interface to the engine. namespace NUnit.Engine { /// <summary> /// ITestEngine represents an instance of the test engine. /// Clients wanting to discover, explore or run tests start /// require an instance of the engine, which is generally /// acquired from the TestEngineActivator class. /// </summary> public interface ITestEngine : IDisposable { /// <summary> /// Gets the IServiceLocator interface, which gives access to /// certain services provided by the engine. /// </summary> IServiceLocator Services { get; } /// <summary> /// Gets and sets the directory path used by the engine for saving files. /// Some services may ignore changes to this path made after initialization. /// The default value is the current directory. /// </summary> string WorkDirectory { get; set; } /// <summary> /// Gets and sets the InternalTraceLevel used by the engine. Changing this /// setting after initialization will have no effect. The default value /// is the value saved in the NUnit settings. /// </summary> InternalTraceLevel InternalTraceLevel { get; set; } /// <summary> /// Initialize the engine. This includes setting the trace level and /// creating the standard set of services used in the Engine. /// /// This interface is not recommended to be called by user code. The TestEngineActivator /// will provide a pre-initialized engine, which should be used as provided. /// </summary> void Initialize(); /// <summary> /// Returns a test runner instance for use by clients in discovering, /// exploring and executing tests. /// </summary> /// <param name=\"package\">The TestPackage for which the runner is intended.</param> /// <returns>An ITestRunner.</returns> ITestRunner GetRunner(TestPackage package); } } The normal sequence of calls for initially acquiring this interface is: ITestEngine engine = TestEngineActivator.CreateInstance(...); engine.WorkDirectory = ...; // Defaults to the current directory engine.InternalTraceLevel = ...; // Defaults to off The engine provides a number of services, some internal and some public. Public services are those for which the interface is publicly defined in the nunit.engine.api assembly, listed later in this document. The final and probably most frequently used method on the interface is GetRunner. It takes a TestPackage and returns an ITestRunner that is appropriate for the options specified. ITestRunner This interface allows loading test assemblies, exploring the tests contained in them and running the tests. namespace NUnit.Engine { /// <summary> /// Interface implemented by all test runners. /// </summary> public interface ITestRunner : IDisposable { /// <summary> /// Get a flag indicating whether a test is running /// </summary> bool IsTestRunning { get; } /// <summary> /// Load a TestPackage for possible execution /// </summary> /// <returns>An XmlNode representing the loaded package.</returns> /// <remarks> /// This method is normally optional, since Explore and Run call /// it automatically when necessary. The method is kept in order /// to make it easier to convert older programs that use it. /// </remarks> XmlNode Load(); /// <summary> /// Unload any loaded TestPackage. If none is loaded, /// the call is ignored. /// </summary> void Unload(); /// <summary> /// Reload the current TestPackage /// </summary> /// <returns>An XmlNode representing the loaded package.</returns> XmlNode Reload(); /// <summary> /// Count the test cases that would be run under /// the specified filter. /// </summary> /// <param name=\"filter\">A TestFilter</param> /// <returns>The count of test cases</returns> int CountTestCases(TestFilter filter); /// <summary> /// Run the tests in the loaded TestPackage and return a test result. The tests /// are run synchronously and the listener interface is notified as it progresses. /// </summary> /// <param name=\"listener\">The listener that is notified as the run progresses</param> /// <param name=\"filter\">A TestFilter used to select tests</param> /// <returns>An XmlNode giving the result of the test execution</returns> XmlNode Run(ITestEventListener listener, TestFilter filter); /// <summary> /// Start a run of the tests in the loaded TestPackage. The tests are run /// asynchronously and the listener interface is notified as it progresses. /// </summary> /// <param name=\"listener\">The listener that is notified as the run progresses</param> /// <param name=\"filter\">A TestFilter used to select tests</param> /// <returns></returns> ITestRun RunAsync(ITestEventListener listener, TestFilter filter); /// <summary> /// Cancel the ongoing test run. If no test is running, the call is ignored. /// </summary> /// <param name=\"force\">If true, cancel any ongoing test threads, otherwise wait for them to complete.</param> void StopRun(bool force); /// <summary> /// Explore a loaded TestPackage and return information about the tests found. /// </summary> /// <param name=\"filter\">The TestFilter to be used in selecting tests to explore.</param> /// <returns>An XmlNode representing the tests found.</returns> XmlNode Explore(TestFilter filter); } } For the most common use cases, it isn't necessary to call Load, Unload or Reload. Calling either Explore, Run or RunAsync will cause the tests to be loaded automatically. The Explore methods returns an XmlNode containing the description of all tests found. The Run method returns an XmlNode containing the results of every test. The XML format for results is the same as that for the exploration of tests, with additional nodes added to indicate the outcome of the test. RunAsync returns an ITestRun interface, which allows retrieving the XML result when it is complete. The progress of a run is reported to the ITestEventListener passed to the run methods. Notifications received on this interface are strings in XML format, rather than XmlNodes, so that they may be passed directly across a Remoting interface. Engine Services The engine Services property exposes the IServiceLocator interface, which allows the runner to use public services of the engine. namespace NUnit.Engine { /// <summary> /// IServiceLocator allows clients to locate any NUnit services /// for which the interface is referenced. In normal use, this /// limits it to those services using interfaces defined in the /// nunit.engine.api assembly. /// </summary> public interface IServiceLocator { /// <summary> /// Return a specified type of service /// </summary> T GetService<T>() where T : class; /// <summary> /// Return a specified type of service /// </summary> object GetService(Type serviceType); } } The following services are available publicly. Service Interface Function ExtensionService IExtensionService Manages engine extensions RecentFilesService IRecentFiles Provides information about recently opened files ResultService IResultService Produces test result output in various formats SettingsService ISettings Provides access to user settings TestFilterService ITestFilterService Creates properly formed test filters for use by runners LoggingService ILogging Provides centralized internal trace logging for both the engine and runners (Not Yet Implemented) The following services are used internally by the engine but are not currently exposed publicly. They potentially could be in the future: Service Function TestRunnerFactory Creates test runners based on the TestPackage content DomainManager Creates and manages AppDomains used to run tests DriverService Provides the runner with a framework driver suitable for a given assembly ProjectService Is able to load assemblies referenced in various project formats RuntimeFrameworkSelector Determines the runtime framework to be used in running a test TestAgency Creates and manages Processes used to run tests Extensibility Interfaces The API also contains various interfaces used by engine extensions. More information on these can be found in the Engine Extensions section."
  },
  "articles/nunit-engine/extensions/AvailableExtensions.html": {
    "href": "articles/nunit-engine/extensions/AvailableExtensions.html",
    "title": "Available NUnit Engine Extensions | NUnit Docs",
    "summary": "Available NUnit Engine Extensions The NUnit team provides several extensions for the engine. They are all available individually as packages for installation through NuGet and also as Chocolatey packages. Some extensions are also bundled with specific distributions of the Console runner. V2 Result Writer The V2 Result writer makes it possible to save test results in the older NUnit V2 format, for use with report programs and integration servers that require that format. Installation NuGet: Reference package NUnit.Extension.NUnitV2ResultWriter in your project Chocolatey: choco install nunit-extension-nunit-v2-result-writer Also bundled with the NUnit.Console NuGet and MSI packages. Usage Specify nunit2 format with the console runner --result or --explore options. V2 Framework Driver The V2 Framework Driver allows the engine to run NUnit V2 tests, which is not normally possible. Installation NuGet: Reference package NUnit.Extension.NUnitV2.Driver in your project Chocolatey: choco install nunit-extension-nunit-v2-driver Also bundled with the NUnit.Console NuGet and MSI packages. Usage If installed, it is used automatically when V2 tests are being run. NUnit Project Loader The NUnit Project Loader allows the engine to run NUnit projects, which have a file extension of .nunit. If it is not installed, the runner will give an error indicating the file type is unrecognized. Installation NuGet: Reference package NUnit.Extension.NUnitProjectLoader in your project Chocolatey: choco install nunit-extension-nunit-project-loader Also bundled with the NUnit.Console NuGet and MSI packages. Usage Create the project in any editor, following the NUnit project format specification. You may also use the NUnit Project Editor, a legacy V2 program, since the format has not changed in NUnit 3. Visual Studio Project Loader The VS Project Loader allows the engine to load tests from a Visual Studio project or solution. Note When used with a solution file, the extension tries to avoid loading assemblies that do not contain tests, through the use of heuristics. This may fail in certain circumstances. Installation NuGet: Reference package NUnit.Extension.VSProjectLoader in your project Chocolatey: choco install nunit-extension-vs-project-loader Also bundled with the NUnit.Console NuGet and MSI packages. Usage If installed, it is used automatically when V2 tests are being run. Teamcity Test Listener The Teamcity Test Listener is used to run NUnit under TeamCity, providing special output messages, which TeamCity is able to interpret. Installation NuGet: Reference package NUnit.Extension.TeamCityEventListener in your project Chocolatey: choco install nunit-extension-teamcity-event-listener Also bundled with the NUnit.Console NuGet and MSI packages. Warning We plan to stop bundling the TeamCity extension with the release of NUnit 4.0. When that happens, individual installation will be required in order to use it. Usage This extension must be activated for a particular test run. When running under the NUnit 3 Console runner, use the --teamcity option to activate it."
  },
  "articles/nunit-engine/extensions/Index.html": {
    "href": "articles/nunit-engine/extensions/Index.html",
    "title": "NUnit Engine Extensions | NUnit Docs",
    "summary": "NUnit Engine Extensions NUnit has several extensions to the engine currently available. We've also made it possible to create your own. Once you obtain or create an extension, you'll need to install the extension into the engine."
  },
  "articles/nunit-engine/extensions/Installing-Extensions.html": {
    "href": "articles/nunit-engine/extensions/Installing-Extensions.html",
    "title": "Installing Engine Extensions | NUnit Docs",
    "summary": "Installing Engine Extensions Extensions are located by the engine by use of an .addins file. For certain package managers, default .addins have been created such that when both engine and extensions are installed from the same package manager, all extensions are installed automatically. Currently, this includes NuGet and Chocolatey. In other cases, the user may need to create a new .addins file, or edit an existing one. The behavior of the .addins file is covered below. The .addins file .addins files are used to locate engine extensions. Either a single .addins file can be used to list all extensions and directories to be searched, or multiple files. .addins files can also be chained together -- allowing multiple levels of redirection. Each line of the .addins file contains the path of an extension assembly or a directory containing assemblies. Wildcards may be used for assembly entries and relative paths are interpreted based on the location of the .addins file. The following is an example of a possible .addins file, with comments indicating what each line does: # This line is a comment and is ignored. The next (blank) line is ignored as well. *.dll # include all dlls in the same directory addins/*.dll # include all dlls in the addins directory too special/myassembly.dll # include a specific dll in a special directory /some/other/directory/ # process another directory, which may contain its own addins file # note that an absolute path is allowed, but is probably not a good idea # in most cases Any assemblies specified in a .addins file will be scanned fully, looking for addins and extensions. Any directories specified will be browsed, first looking for any .addins files. If one or more files are found, the content of the files will direct all further browsing. If no such file is found, then all .dll files in the directory will be scanned, just as if a .addins file contained \"*.dll.\" Note that if a specific assembly is listed in the .addins file which is found not to be a valid extension, an exception will be thrown by the engine. This exception is suppressed in the cases of wildcard paths, where it is considered valid to find no extensions under the path."
  },
  "articles/nunit-engine/extensions/creating-extensions/Event-Listeners.html": {
    "href": "articles/nunit-engine/extensions/creating-extensions/Event-Listeners.html",
    "title": "Event Listeners | NUnit Docs",
    "summary": "Event Listeners Event Listeners are extensions that respond to specific events occurring during the running of a test. They implement the ITestEventListener interface. NUnit itself makes extensive use of this interface when running tests. By creating an extension, user code may also respond to test events. The definition of an Event Listener extension will look something like this: [Extension(EngineVersion=\"3.4\")] public class MyEventListener : ITestEventListener { /* ... */ } Note The EngineVersion property is used to document the fact that the event listener extension point was only added to the engine with version 3.4. Its function here is purely documentary because the EngineVersion property itself was also added in version 3.4. Event listeners should not be installed with earlier versions. The ITestEventListener interface is defined as follows: /// <summary> /// The ITestListener interface is used to receive notices of significant /// events while a test is running. Its single method accepts an Xml string, /// which may represent any event generated by the test framework, the driver /// or any of the runners internal to the engine. Use of Xml means that /// any driver and framework may add additional events and the engine will /// simply pass them on through this interface. /// </summary> [TypeExtensionPoint( Description = \"Allows an extension to process progress reports and other events from the test.\")] public interface ITestEventListener { /// <summary> /// Handle a progress report or other event. /// </summary> /// <param name=\"report\">An XML progress report.</param> void OnTestEvent(string report); } The argument to OnTestEvent is an XML-formatted string, with a different top-level element for each potential event. Start of run - <start-run...> End of run - <test-run...> Start of a test suite - <start-suite...> End of a test suite - <test-suite...> Start of a test case - <start-test...> End of a test case - <test-case...> The XML report signalling the end of a test case contains all available information, including the result. The start events only provide basic identifying information. See XML Formats for a full description of each report"
  },
  "articles/nunit-engine/extensions/creating-extensions/Framework-Drivers.html": {
    "href": "articles/nunit-engine/extensions/creating-extensions/Framework-Drivers.html",
    "title": "Framework Drivers | NUnit Docs",
    "summary": "Framework Drivers Framework Drivers are extensions that know how to create a driver for a particular framework. These allow the NUnit Engine to run tests for multiple different test frameworks. The NUnit engine provides drivers for both NUnit 3.x, whilst a separate extension can be installed to run NUnit 2.x frameworks. Third parties may provide drivers for other frameworks by creating extensions. Implementation Details The framework driver API is encapsulated in the IDriverFactory and IFrameworkDriver interfaces, which must be implemented by all framework driver extensions to the engine. IDriverFactory The IDriverFactory interface is called by the engine to determine if a particular extension is able to create a driver for a particular framework assembly. The engine passes the AssemblyName of each assembly referenced by the test assembly to the factory to see if it is a supported framework. If it finds one, then it uses that driver. If not, it goes on to check the next driver extension. The ExtensionPoint for framework drivers uses the Path \"NUnit.Engine.DriverService\" and accepts an extension of Type NUnit.Engine.Extensibility.IDriverFactory. The definition of a driver factory might look like this: [Extension] public class MyOwnFrameworkDriverFactory : IDriverFactory { /* ... */ } The IDriverFactory interface is defined as follows: public interface IDriverFactory { // Gets a flag indicating whether the provided assembly name and version // represent a test framework supported by this factory bool IsSupportedTestFramework(string assemblyName, Version version); // Gets a driver for use with the specified framework assembly name and version IFrameworkDriver GetDriver(AppDomain domain, string assemblyName, Version version); } IFrameworkDriver The IFrameworkDriver interface is returned from IDriverFactory and is the key interface for actually loading, exploring and running the tests in the test assembly. In theory, a single driver factory could return different drivers in different situations, but we expect a one-to-one mapping of factories to drivers to be most commonly used. As designed, the IFrameworkDriver interface maps most directly to the requirements of the NUnit 3 framework. Drivers for other frameworks need to function as an adapter to run tests and return understandable results to the engine. The IFrameworkDriver interface is defined as follows: public interface IFrameworkDriver { // Gets and sets the unique identifer for this driver string ID { get; set; } // Loads the tests in an assembly string Load(string testAssemblyPath, IDictionary<string, object> settings); // Counts the test cases that would be executed int CountTestCases(string filter); // Executes the tests in an assembly string Run(ITestEventListener listener, string filter); // Returns information about the tests in an assembly string Explore(string filter); // Cancels an ongoing test run. void StopRun(bool force); The strings returned by Run and Explore are XML representations and the filter is also in XML format. See the source code for NUnit3FrameworkDriver and NUnit2FrameworkDriver for sample code. The filter argument passed to several of the interface methods is an XML string representing the filter. See Test Filters for a description of the format, which is directly understood by the NUnit 3 framework, but which must be converted by the driver to something that is understood by other frameworks. ITestEventListener The ITestEventListener interface is implemented by the Engine and used by each driver to report significant events during the execution of tests. namespace NUnit.Engine { /// <summary> /// The ITestEventListener interface is used to receive notices of significant /// events while a test is running. Its single method accepts an Xml string, /// which may represent any event generated by the test framework, the driver /// or any of the runners internal to the engine. Use of Xml means that /// any driver and framework may add additional events and the engine will /// simply pass them on through this interface. /// </summary> [TypeExtensionPoint(Description = \"Allows an extension to process progress reports and other events from the test.\")] public interface ITestEventListener { /// <summary> /// Handle a progress report or other event. /// </summary> /// <param name=\"report\">An XML progress report.</param> void OnTestEvent(string report); } }"
  },
  "articles/nunit-engine/extensions/creating-extensions/Index.html": {
    "href": "articles/nunit-engine/extensions/creating-extensions/Index.html",
    "title": "Creating Engine Extensions | NUnit Docs",
    "summary": "Creating Engine Extensions The NUnit Test Engine uses a plugin architecture that allows users and third parties to add new functionality to the engine. The extensibility model defines a number of Extension Points to which Extensions may be added. There are currently four extension points: Project Loaders Result Writers Framework Drivers Event Listeners Extensions are generally created in their own assemblies, with some shared characteristics described in Writing Engine Extensions. They then need to be installed to the engine, which is covered in Installing Engine Extensions."
  },
  "articles/nunit-engine/extensions/creating-extensions/Project-Loaders.html": {
    "href": "articles/nunit-engine/extensions/creating-extensions/Project-Loaders.html",
    "title": "Project Loaders | NUnit Docs",
    "summary": "Project Loaders Project Loaders are extensions that know how to load a project in a particular format and create a package suitable for running tests under NUnit. The NUnit Organization itself provides two of them: NUnitProjectLoader VisualStudioProjectLoader The extension point for project loaders accepts extensions that implement the NUnit.Engine.Extensibility.IProjectLoader interface. The definition of a project loader extension might look something like the following... [Extension] [ExtensionProperty(\"FileExtension\", \".xxx\")] [ExtensionProperty(\"FileExtension\", \".yyy\")] public class SomeProjectLoader : IProjectLoader { /* ... */ } The engine will only load the extension if it encounters a potential project file using the indicated file extensions. The IProjectLoader interface is defined as follows: /// <summary> /// The IProjectLoader interface is implemented by any class /// that knows how to load projects in a specific format. /// </summary> [TypeExtensionPoint( Description = \"Recognizes and loads assemblies from various types of project formats.\")] public interface IProjectLoader { /// <summary> /// Returns true if the file indicated is one that this /// loader knows how to load. /// </summary> /// <param name=\"path\">The path of the project file</param> /// <returns>True if the loader knows how to load this file, otherwise false</returns> bool CanLoadFrom(string path); /// <summary> /// Loads a project of a known format. /// </summary> /// <param name=\"path\">The path of the project file</param> /// <returns>An IProject interface to the loaded project or null if the project cannot be loaded</returns> IProject LoadFrom(string path); } An IProject, which is returned by LoadFrom is defined as: /// <summary> /// Interface for the various project types that the engine can load. /// </summary> public interface IProject { /// <summary> /// Gets the path to the file storing this project, if any. /// If the project has not been saved, this is null. /// </summary> string ProjectPath { get; } /// <summary> /// Gets the active configuration, as defined /// by the particular project. /// </summary> string ActiveConfigName { get; } /// <summary> /// Gets a list of the configs for this project /// </summary> IList<string> ConfigNames { get; } /// <summary> /// Gets a test package for the primary or active /// configuration within the project. The package /// includes all the assemblies and any settings /// specified in the project format. /// </summary> /// <returns>A TestPackage</returns> TestPackage GetTestPackage(); /// <summary> /// Gets a TestPackage for a specific configuration /// within the project. The package includes all the /// assemblies and any settings specified in the /// project format. /// </summary> /// <param name=\"configName\">The name of the config to use</param> /// <returns>A TestPackage for the named configuration.</returns> TestPackage GetTestPackage(string configName); } TestPackage is defined in the nunit.engine.api assembly and includes a list of assemblies together with a dictionary of settings used by the package."
  },
  "articles/nunit-engine/extensions/creating-extensions/Result-Writers.html": {
    "href": "articles/nunit-engine/extensions/creating-extensions/Result-Writers.html",
    "title": "Result Writers | NUnit Docs",
    "summary": "Result Writers Result Writers take the result of a test run, in NUnit 3 XML format, and use it to create a result file in some other format. The NUnit Organization itself provides a two result writers, one to create output in NUnit V2 format and another to write test cases to the console. The definition of a result writer extension might look something like this: [Extension] [ExtensionProperty(\"Format\", \"custom\")] public class CustomResultWriterFactory : IResultWriter { /* ... */ } An ExtensionPropertyAttribute must be provided giving the name of the format you support. Users would access the format from the NUnit Console command-line by using that name in a result specification, such as: nunit-console test.dll --result=CustomResult.xml;format=custom The IResultWriter interface which must be implemented, is defined as follows: /// <summary> /// Common interface for objects that process and write out test results /// </summary> [TypeExtensionPoint( Description = \"Supplies a writer to write the result of a test to a file using a specific format.\")] public interface IResultWriter { /// <summary> /// Checks if the output path is writable. If the output is not /// writable, this method should throw an exception. /// </summary> /// <param name=\"outputPath\">Path to test</param> void CheckWritability(string outputPath); /// <summary> /// Writes result to the specified output path. /// </summary> /// <param name=\"resultNode\">XmlNode for the result</param> /// <param name=\"outputPath\">Path to which it should be written</param> void WriteResultFile(XmlNode resultNode, string outputPath); /// <summary> /// Writes result to a TextWriter. /// </summary> /// <param name=\"resultNode\">XmlNode for the result</param> /// <param name=\"writer\">TextWriter to which it should be written</param> void WriteResultFile(XmlNode resultNode, TextWriter writer); } The engine calls the CheckWritability method at the start of the run, before executing any tests. The WriteResultFile method is called after the run is complete. The writer may check writability in any way desired, including writing an abbreviated output file, which it will later overwrite."
  },
  "articles/nunit-engine/extensions/creating-extensions/Writing-Engine-Extensions.html": {
    "href": "articles/nunit-engine/extensions/creating-extensions/Writing-Engine-Extensions.html",
    "title": "Writing Engine Extensions | NUnit Docs",
    "summary": "Writing Engine Extensions This page gives general information that applies to all types of extensions you may want to write. The individual pages for each type of extension give specific details. Extension structure Every extension is implemented by a class with specific characteristics: Has a default constructor so that NUnit can create an instance. Implements some interface that varies according to the particular extension. Is marked with the ExtensionAttribute so that NUnit can recognize it as an extension. As an example, the code for an IProjectLoader extension might look like this: [Extension] public class MyExtension : IProjectLoader { public MyExtenions() { /* ... */ } /* ... */ } Extension Attribute The ExtensionAttribute has four named properties, all optional: Path This is a string that uniquely identifies the extension point to which the extension applies. It is only rarely needed, since NUnit can usually deduce the type of extension based on what interface is implemented by the extension class. Description An optional description of what the extension does. Enabled A boolean flag indicating whether the extension is enabled. This defaults to true. The setting is used by advanced extensions with functionality that is turned on and off depending on user input. EngineVersion The minimum engine version supported by the extension. Although optional, you should use this property if your extension will not work with all versions of the engine. If you don't use it and your extension requires engine services that are not present, then it might throw an exception or cause other errors. Note Only engine versions 3.4 or later check the EngineVersion property. The only way to avoid errors in the case of lower engine versions is to not install such extensions. ExtensionPropertyAttribute The ExtensionPropertyAttribute is used to provide additional meta-data to the engine, without the need for the engine to load each extension. The usages of ExtensionPropertyAttribute differ per type of extension. Below is an example of how the attribute would be used for an IProjectLoader extension: [Extension] [ExtensionProperty(\"FileExtension\", \".nunit\")] public class NUnitProjectLoader : IProjectLoader { /* ... */ } By use of the ExtensionPropertyAttribute NUnit is able to postpone loading the extension until the user actually uses a file of type .nunit. If the extension is never needed, then it won't be loaded at all. For information about what properties are used by each extension point, see the individual pages for each type of extension. Note Extensions are usually created each in their own assembly for efficiency. It's possible to have several related extensions in the same assembly, but they will all be loaded into memory as soon as one is used."
  },
  "articles/nunit-engine/release-notes.html": {
    "href": "articles/nunit-engine/release-notes.html",
    "title": "Console and Engine Release Notes | NUnit Docs",
    "summary": "Console and Engine Release Notes NUnit Console & Engine 3.17.0 - January 4, 2024 This release adds support for .net 8 by adding a missing agent. Enhancement #1374 Add .NET 8 build for nunit-agent Note that the release is based on the 3.15.5 version. NUnit Console and Engine 3.15.5 - September 26, 2023 Enhancement #1362 Updating Testcentric.Metadata NUnit Console and Engine 3.15.4 - May 27, 2023 A version of the 3.15 series supporting NUnit 4. This is also required for having an engine for a corresponding adapter release. Enhancement #1339 Support NUnit 4 NUnit Console & Engine 3.16.3 - February 21, 2023 Bugs #1307 NUnit3TestAdapter integration: Exception when using NUnit.Engine 3.16.2 #1317 Fix assembly dependencies resolver for .NET Core #1320 Add support for .Net 8.0 NUnit Console & Engine 3.16.2 - January 11, 2023 Bug #1300 Error when running x86 test test under .NET Core Build #1294 Use pre-installed .NET 7.0 on AppVeyor #1296 Use NUNIT prefix for API_KEY environment variables NUnit Console & Engine 3.16.1 - January 4, 2023 This release fixes several critical or high-priority bugs in the 3.16.0 release. Bugs #1271 Install dotnet tool failed #1274 NUnit Console won't run unless .NET Desktop and ASP.NET Runtimes are installed #1275 Missing assembly in NUnit.Engine nuget package #1277 NUnit does not work without .NET Core Build #1284 Restore ability to debug packages NUnit Console & Engine 3.16.0 - November 14, 2022 Further releases in the 3.x series were not anticipated after 3.15. However, since a number of new features and enhancements have been implemented, we are releasing version 3.16 of the engine and console runner. This release incorporates support for executing tests under .NET 7.0. The runner itself is now built for .NET 4.6.2 rather than .NET 2.0. Substantial changes have been made in the location of dependencies when running under .NET Core. Bugs #291 Error running tests from assembly built using VS2017 csproj file format #299 Attempting to target too low a framework throws exception #1130 v3.14 fails with target framework net461 ... net48 on linux (ArgumentException: The net-4.6.1 framework is not available.), but v3.12 works well #1176 Exception when targeting .NET Framework with .NET 7 installed #1178 Running tests with nunit3-console version 3.15.0 generates empty log files #1180 NUnit Engine 3.15.0 cannot load the test assembly #1182 Running tests using the VS Solution results in an exception if any projects target .NET Standard #1183 Build hangs when test spawns processes which do not terminate properly #1185 3.15.0 - MSI package is unable to acquire remote process agent #1203 NUnit Console 3.15.2: Could not load file or assembly \"System.Windows.Forms\" #1206 NUnit.Engine.NUnitEngineException when spaces in agent file path #1208 Inconsistencies between nunit3-console and running the project via Visual Studio #1217 Assembly loading deduplication #1225 Restore netcoreapp3.1 build to the engine package Build #1118 Reorganize build output (bin) directories #1244 Upgrade Cake.Tool to 2.3.0 #1246 Reduce build targets for nunit.engine.core assembly #1254 Get Linux build working under Azure - tests still not run #1255 Get MacOS build working in Azure #1257 Enable testing under MacOS on Azure Enhancements #941 Allow netcoreapp agent to work with non-standard dotnet install locations #1223 Exception when previously unknown .NET Core runtime is found on machine #1224 Change name of NUnit Net Core Runner executable #1243 Upgrade our .Net 7.0 assemblies to RC 2 Features #1216 Add .NET 7.0 Agent #1232 Stop building console runner with .NET 2.0 #1265 Update .NET 7.0 Support from RC-2 to Final Release NUnit Console & Engine 3.15.2 - June 30, 2022 Release primarily to correct a critical bug arising when .NET 7.0 is installed. Note: There is no 3.15.1 release because a 3.15.1 package identical to 3.15.0 was accidentally uploaded to NuGet.org when 3.15 was released. Bugs #1178 Running tests with nunit3-console version 3.15.0 generates empty log files #1193 Prevent Crash under .NET 7.0 in 3.15.1 build #1196 Modify build script to support continued version 3 releases where needed NUnit Console & Engine 3.15 - February 10, 2022 Final Release of NUnit ConsoleRunner 3.15.0. No changes from the beta1 Release. Version 3.15.0 is expected to be the final release in the 3.x series. NUnit Console & Engine 3.15 Beta 1 - February 6, 2022 Beta release of version 3.15.0 of the Console Runner. Both the standard runner and the dotnet CLI command are now able to run tests under .Net 6.0. #1017 Should we change 'master' to 'main'? #1026 Make NUnit.Engine.Internal.Tests.PathUtilTests_Windows.SamePathOrUnder work under ubuntu-latest #1044 Agent for .NET 6.0 #1050 More discrete logging #1087 Switch all engine tests to NUnitLite #1094 CreateDraftRelease command should run locally without a release branch #1095 Allow single-letter options for cake script #1096 Symbol package validation failing for NUnit.ConsoleRunner.NetCore #1108 Generate AssemblyInfo files from csproj #1112 Use VS2022 for CI Build #1123 NETCORE Console Runner should target .NET 6.0 #1125 Save results of each package test separately NUnit Console & Engine 3.14 - January 15, 2022 This release features a new agent for tests targeting .NET 5.0. In addition, automation of our publication and release process is now complete from creation of a draft release through releasing to production on GitHub. While this doesn't impact users directly, it will allow us to speed up the introduction of new features in coming releases. 570 Where are the checksums for your downloads? 1012 Automatically roll-forward if no .NET Core 3.1 runtime available 1048 Agent for Net 5.0 1057 Automate all package publication and release 1075 Separate nunit.engine.core.tests from nunit.engine.tests 1084 Eliminate Packaging on Azure 1090 Test of --debug-agent option fails under linux Debug configuration NUnit Console & Engine 3.13 - November 30, 2021 This is the first release of the NUnit Console Runner, nunit3-console.exe, which allows running of both .NET Framework and .NET Core tests, either separately or in combination. The nunit3-console.exe runner executes under the .NET Framework but is able to launch .NET Core agents and communicate with them over a TCP connection. A second major feature in this release is engine support for preemptive cancellation when the normal approach of requesting the test run to self-terminate doesn't work. This is an engine feature, available to any runners supporting cancellation. 382 Only 1 agent running with multiple projects and --process=Multiple 418 <TestAssembly.dll>.config files not loaded when using an .nunit project file and --process=Multiple 551 Make engine easier to Debug 609 Run after Reload reports assemblies multiple times 642 Engine needs preemptive cancellation 726 Remove .NET Standard 1.6 build 764 Error: Found two different objects associated with the same URI, /xxxxx/TestAgency 789 DirectoryFinder.GetDirectories throws for a path with the drive specified 803 Remove CHANGES.TXT to simplify release process 828 Reported issues with dependency loading in .NET Core Console 852 No tests of .NET Core 3.1 packages 855 Improved testability of DirectoryFinder 869 Link to release notes on docs and Review uses of CHANGES.TXT 892 Implement Package tests for engine and console runner 895 Make sure AssemblyDefinitions are disposed after use. 898 Removed support for .NET Core 1.1 904 The test-run element is missing a count of warnings 908 Known Vulnerability in System.Xml.XPath.XmlDocument 915 StackOverflowException in console-runner when addins-file contains \"./\" or \".\" 923 Agent communication layer 933 Update TestCentric MetaData dependency 943 Remove Travis CI 947 Make default TestAgency URI unique per run (v2) 949 nunit.engine.tests are failing to unload on master branch 956 fix for test assembly loading failure in NUnit.ConsoleRunner.NetCore 957 Include pdbs with nuget and zip packages and publish source code 964 Update Code of Conduct 1014 GetClrVersionForFramework throws if .Net6.0 is installed 1025 chore(pipeline): Use ubuntu-latest 1031 Fix incorrect MyGet push URL 1033 Update to current version of TestCentric.Metadata package 1037 Eliminate End of Life Check in builds 1039 Stop re-publishing deprecated packages with each new release NUnit Console & Engine 3.12 - January 17, 2021 .NET Core NUnit Console 3.12 Beta 2 - January 17, 2021 This release contains various improvements to running tests on .NET Core and Mono, and changes to extension loading logic to allow the Engine to better support extensions which target multiple platforms. There are additionally a number of fixes to issues that were identified with 3.12 Beta 1. Please also be aware that this will be the last version of the NUnit Engine to support .NET Standard 1.6. The .NET Core Console remains in Beta due to some unresolved dependency loading and framework targeting issues - contributions to fix these issues would be very welcome! Code contributions in this release were included from Charlie Poole, Chris Maddock, Christian Bay, Eberhard Beilharz, Ed Ball, Joseph Musser, Manohar Singh, Mattias Cavigelli and Mikkel Nylander Bundgaard. Thank you to all those who contributed both in code, and otherwise. Please note the below list includes only issues resolved between 3.12.0 Beta 1 and the final release. For those upgrading from 3.11.1 or earlier, please also see the Beta release notes. 511 [Build] Improve detection of installed .NET Core Runtimes 718 Eliminate use of Mono.Cecil 810 Build NUnit.ConsoleRunner.NetCore as a .NET Core Tool. 811 Use readonly modifier where possible 818 Remove redundant dependency on Microsoft.DotNet.InternalAbstractions for platforms other than .NET Standard 1.6 825 Revert change to increment nunit.engine.api assembly version 829 Revert change made to IExtensionService in nunit.engine.api 830 [CI] Test on .NET 5.0 837 Fully remove Microsoft.Dotnet.InternalAbstractions dependency 844 .NET Core console runner fails to load extensions when netfx and netstandard versions conflict 847 [Build] Specify .NET 2.0 version of extensions for msi 853 [Build] Allow local build to succeed even if all runtimes are not installed 863 [Build] Use released version of NUnit Framework 3.13.0 NUnit Console & Engine 3.12 Beta 1 - August 1, 2020 This is the first beta release of the NUnit Console able to run .NET Core Tests. In addition to this, this release also contains a number of bug fixes, improvements when running on Mono and significant refactoring work towards the goal of creating an engine able to run tests on a wider range of .NET platforms. We're particularly interested in this beta release being tested by users of the .NET Core console and users running tests on Mono. Please feedback any issues to the nunit-console repository. The .NET Core Console is a separate executable to the original version, and can be found in either the .zip file download, or the new NUnit.ConsoleRunner.NetCore NuGet package. Our longer-term aim is to create a single console which is able to run both .NET Core and .NET Framework tests. Code contributions in this release were included from Charlie Poole, Chris Maddock, Christian Bay, Eberhard Beilharz, Joseph Musser, Manohar Singh and Mikkel Nylander Bundgaard. Thank you to all those who contributed both in code, and other ways! 391 Provide useful error message when agent crashes with a stack overflow exception 475 Create .NET Core Console Runner 662 Mono: Stacktrace missing files and line numbers 710 .NET Core engine only works when located in same directory as test assembly 733 iconUrl is deprecated in NuGet packages 740 Create separate agents for .NET 2.0-3.5 and .NET 4.x 747 [CI] Change macOS image version 748 Make Project config information available to runners 750 .NET Core Console Packaging 751 Minor updates to Contributing.MD 757 Unable to test net 3.5 assembly if there's incompatible extension installed 758 Carry CurrentDirectory over to agent Processes 761 Revert accidental debug message change 762 Simplify agent communication in preparation for new wire protocol 765 Split RuntimeFramework package setting into two: Requested and Target 768 Test run exits with an exit code of 0 if a multiple of 256 tests fail 775 Extension loading broken on Linux when installed from nuget package 777 Remove unused code to locate engine from registry keys 778 Add .NET Core 3.1 build of engine to access APIs for loading .NET Core assemblies correctly 779 [CI] Revert to running .NET Standard Engine Tests via NUnitLite 783 Refactor XMLTransformResultWriterTests to avoid initializing entire engine 784 Fix DirectTestRunner to not give all drivers the same ID. 790 Fix agent debug logging 800 TypeLoadException thrown when changes are made to the API assembly, with multiple versions of the engine available 801 Begin incrementing EngineApiVersion with every release, as per Engine version NUnit Console & Engine 3.11.1 - February 15, 2020 This hotfix fixes a problem with NUnit Project file settings being ignored. 730 NUnit project file settings are ignored 732 Upgrade Cake Build to fix Linux CI NUnit Console 3.11 - January 26, 2020 This release fixes a range of minor bugs, and includes a significant amount of internal restructuring work. In future, this will enable improved .NET Standard support in the engine, and a .NET Core build of the console. 22 Engine modifies TestPackage 53 Add project element to top-level sub-project before merging 181 XSLT Transform not honoring --encoding value 336 Should legacyCorruptedStateExceptionsPolicy enabled=true in nunit3-console.exe.config? 386 nUnit project loader does not work when --inprocess is set 453 build-mono-docker.ps1 fails to run out the box 514 Add higher-level unit tests for structure of TestRunners 586 Create Separate Addin File for the Engine NuGet Package 588 licenseUrl in NuGet packages are deprecated 591 Release 3.10 merge 592 Add status badge from Azure pipelines 594 Fixed typos in release notes 595 Clean extension dir before running FetchExtensions task 603 Engine returns assembly-level test-suite event twice 605 Trailing \\ in --work argument causes agent to crash 607 Unload + Load changes TestPackage IDs 611 Set DisableImplicitNuGetFallbackFolder and bump Ubuntu on Travis 612 Fix logging when including exception 617 Consider expanding projects before building ITestRunner structure 625 [Feature] Extend start-run data for ITestEventListener 628 [Question] Possible to set both labels=After and labels=Before 634 Remove unnecessary stream creation in XML Transform writer 635 Remove all #regions from codebase 636 Labels option: Rename On as OnOutputOnly, and deprecate On and All 637 Refactor RunnerSelectionTests 639 Engine initializes DriverService too early 667 Console Runner loads wrong .NET framework version when executing tests from multiple assemblies at once 669 nunit.console-runner-with-extensions.nuspec: Remove outdated release notes 671 Manually updated .NET Core SDK on Linux build 681 Display path and version of extension assemblies 683 Safely encapsulating the atomic agent database operations 684 Split engine into upper and lower parts 691 Sign NuGet Packages and msi 693 Update Engine tests to run on LTS .NET Core version 696 Minimal compilation/test of .NET Core Console 698 Update NUnit v2 driver extension in combined packages 703 Update Console options for .NET Core Console build 704 Agent in nupkg should not be referenced and causes warnings in consuming projects 706 build.cake maintenance 707 Set agent to reference core and not full engine 713 Engine will not recognize .NET Framework versions beyond 4.5 NUnit Console 3.10 - March 24, 2019 This release merges the .NET Standard version of the engine back into the nunit.engine NuGet package and adds a .NET Standard 2.0 version of the engine that re-enables most services and extensions. This deprecates the nunit.engine.netstandard NuGet package. Any test runners using the old .NET Standard version of the engine should switch to this release. The --params command line option which took multiple test parameters separated by a semicolon is now deprecated in favor of the new --testparam command line option. One of the most common uses for test parameters was to pass connection strings into tests but this required workarounds to handle the semicolons. Now you must pass in each test parameter separately using a --testparam or --tp option for each. Issues Resolved 8 TempResourceFile.Dispose causes run to hang 23 In nunit3-console you cannot pass parameters containing ';' because they always get split 178 Add date and time to console output 282 \"Execution terminated after first error\" does not fail the console runner 388 Merge .NET Standard Engine back into the main solution 389 Update Mono.Cecil to latest 433 All messages from EventListenerTextWriter goes to console output independent on stream name 454 Misc improvements to ExtensionServiceTests 455 Remove CF, Silverlight and PORTABLE functionality 464 NUnit Console Reports Successful Exit Code When there is an Exception on Dispose 473 ArgumentException: DTD is prohibited in this XML document 476 .NET Standard engine to load extensions 479 Merge .NET Standard Engine code back into the main solution 483 Error in SetUpFixture does not result in non-zero exit code 485 Invalid integer arguments do not display properly in error message 493 Correct order of params to Guard.ArgumentValid() 498 Reset console colors after Ctrl-C 501 Create result directory if it does not exist 502 Remove unused method from build.cake 506 Dogfood NUnit.Analyzers via the nunit-console tests 508 Re-Enable OSX CI tests 515 Appveyor CI failing on master 518 Correct Refactoring Error 519 Break up multiple console error messages with color 523 Reloading multiple files causes exception 524 .NET Standard 2.0 engine crashes when .NET Framework extensions are in Global NuGet Cache 525 Separate NuGet Restore for Appveyor build 531 Building a forked master branch results in publishing artifacts 533 Duplicate ids when loading a project 544 Deprecate nunit.netstandard.engine NuGet package 546 Cannot run a project file using --process:Separate 547 --labels=Before ignores --nocolor 556 Appveyor CI failing due to nuget restore 557 Disable CliFallbackFolder as a nuget source 562 Fix typo in comment 563 ProjectService is incorrectly initialized in agents 565 Eliminate -dbg suffix from version 566 SettingsService is not needed in agents 567 Unnecessary call to IProjectService 571 Space characters in the work directory path are not properly handled 583 NUnit Console NuGet Package Doesn't Load Extensions 587 Disable new MSBuild GenerateSupportedRuntime functionality, which breaks framework targeting NUnit Console 3.9 - September 5, 2018 This release should stop the dreaded SocketException problem on shutdown. The console also no longer returns -5 when AppDomains fail to unload at the end of a test run. These fixes should make CI runs much more stable and predictable. For developers working on the NUnit Console and Engine project, Visual Studio 2017 update 5 or newer is now required to compile on the command line. This does not effect developers using NUnit or the NUnit Console, both of which support building and running your tests in any IDE and on any .NET Framework back to .NET 2.0. Issues Resolved 103 The switch statement does not cover all values of the 'RuntimeType' enum: NetCF. 218 Move Distribution back into the nunit-console project. 253 Master Chocolatey issue 255 SocketException thrown during console run 312 CI failure: SocketException 360 CommandLineOption --err does not write error input to ErrorFile 367 nunit3-console loads nunit.framework with partial name 370 Nunit.Console 3.8 - Socket Exception 371 Remove -5 exit code on app domain unload failures 394 Multi-targeted Engine Extensions 399 Fix minor document issues 411 Make output received when providing user friendly messages unloading the domain more user friendly 412 Extensions not detected for version 3.9.0-dev-03997 436 NUnitEngineException : Unable to acquire remote process agent 446 Output CI version info to console 448 Update vs-project-loader extension to 3.8.0 450 Update NUnit.Extension.VSProjectLoader to 3.8.0 456 NuGet Package : Add repository metadata. 461 Use MSBuild /restore NUnit Console 3.8 - January 27, 2018 This release includes several fixes when unloading AppDomains and better error reporting. The aggregate NuGet packages also include updated versions of several extensions. Issues Resolved 6 TypeLoadException in nunit3-console 3.0.1 93 Update Readme with information about the NuGet packages 111 Provide better info when AppDomain won't unload 116 NUnit 3.5.0 defaults to single agent process when using an nunit project file 191 Exception encountered unloading AppDomain 228 System.Reflection.TargetInvocationException with nunit3-console --debug on Mono 246 No way to specify app.config with console runner 256 Rewrite ConsoleRunnerTests.ThrowsNUnitEngineExceptionWhenTestResultsAreNotWriteable() 259 NUnit3 agent hangs after encountering an \"CannotUnloadAppDomainException\" 262 Transform file existence check should check current directory instead of WorkDirectory 267 Fix possible NRE 273 Insufficient error handling message in ProcessRunner -> RunTests method 275 Integrate chocolatey packages with build script 284 NUnit3: An exception occured in the driver while loading tests... bei NUnit.Engine.Runners.ProcessRunner.RunTests(ITestEventListener listener, TestFilter filter) 285 ColorConsoleWriter.WriteLabel causes NullReferenceException 289 Warnings not displayed 298 Invalid --framework option throws exception 300 Agents do not respect the Console WORK parameter when writing log file 304 Catch agent debugger launch exceptions, and improve agent crash handling 309 No driver found if framework assembly reference has uppercase characters 314 Update NUnit.Extension.VSProjectLoader to 3.7.0 318 Update NUnit.Extension.TeamCityEventListener to 1.0.3 320 Return error code -5 when AppDomain fails to unload 323 Assertion should not be ordered in AgentDatabaseTests 343 Superfluous unload error shown in console 349 Get all TestEngine tests running under NUnitAdapter apart from those . 350 Invalid assemblies no longer give an error message 355 NuGet package links to outdated license NUnit Console 3.7 - July 13, 2017 Engine Creates a .NET Standard version of the engine for use in the Visual Studio Adapter Fixes several issues that caused the runner to exit with a SocketException Issues Resolved 10 Create a .NET Standard version of the Engine 11 insufficient info on driver reflection exception 12 Upgrade Cake build to latest version 24 Update --labels switch with option to show real-time pass/fail results in console runner 31 Nunit 3.4.1 NUnit.Engine.Runners 72 TestContext.Progress.Write writes new line 82 Remove unused repository paths from repositories.config 99 Remove unused --verbose and --full command line options 126 Resolve differences between NUnit Console and NUnitLite implementations of @filename 162 Add namespace keyword to Test Selection Language 171 Socket Exception when stopping Remote Agent 172 Limit Language level to C#6 193 Settings are stored with invariant culture but retrieved with CurrentCulture 194 Better logging or error handling in SettingsStore.SaveSettings 196 Allow comments in @FILE files 200 Remove obsolete warnings from build script 206 Remove reference to removed noxml option 207 Create Chocolatey package(s) for the console 208 Explore flags test update 213 Master build failing after merging .NET Standard Engine 216 Compiling mock-assembly in Visual Studio 2017 fails 217 NUnit .NET Standard NuGet package missing some values 219 Runtime.Remoting.RemotingException in NUnit.Engine.Runners.ProcessRunner.Dispose 221 Added missing nuget package info 222 Improve missing agent error message 225 SocketException thrown by nunit3-console.exe --explore option 248 Agent TestEngine contains duplicate services 252 Console crashes when specifying both format and transform for result 254 Correct misprint \".con\" -> \".com\" NUnit Console 3.6.1 - March 6, 2017 Engine This hotfix release addresses a race condition in the Engine that caused tests to intermittently fail. Issues Resolved 168 Intermittent errors while running tests after updating to 3.6 NUnit Console 3.6 - January 14, 2017 Console Runner Added command line option --skipnontestassemblies to skip assemblies that do not contain tests without raising an error and to skip assemblies that contain the NUnit.Framework.NonTestAssemblyAttribute. Messages from the new Multiple Assert blocks will be displayed individually Warnings from the new Warn.If, Warn.Unless and Assert.Warn are now displayed Engine NUnit agents now monitor the running engine process and will terminate themselves if the parent runner process is killed or dies Issues Resolved 16 NUnit Engine Tests fail if not run from test directory 18 Invalid file type is shown in XML as type=\"Assembly\" 23 In nunit3-console you cannot pass parameters containing ';' because they always get split 37 NUnit 3 console should produce xml events for ITestEventListener which contain unique id in the scope of all test agents for NUnit 2 tests 58 System.Configuration.ConfigurationErrorsException thrown in multiple domain mode. 62 NUnit3 Fails on DLL with no Tests, Unlike NUnit2 100 Class NUnit.Engine.Services.ResultWriters.Tests.SchemaValidator is never used 101 Method NUnit.Options.OptionSet.Unprocessed always returns \"false\" 104 Type of variable enumerated in 'foreach' is not guaranteed to be cast-able 110 Writability check could give a friendlier message. 113 Add task descriptions to Build.cake 127 Modify console runner to display multiple assert information 128 Terminate agent if main process has terminated 133 NUnit downloadable packages zip file naming is confusing and non-intuitive 136 Handle early termination of multiple assert block 138 Report Warnings in console runner 145 MasterTestRunner.RunAsync no longer provides start-run and test-run events 151 Unexpected behavior from --framework flag 153 Remove some settings used by the engine 156 Use high-quality icon for nuspecs 157 Fix Detection of invalid framework when --inprocess 159 Update extension versions in the NuSpec Files Earlier Releases Release Notes for NUnit 2.9.1 through 3.5. Release Notes for NUnit 2.6 through 2.6.4 Release Notes for NUnit 2.5 through 2.5.10 Release Notes for NUnit 2.4 through 2.4.8 Release Notes for NUnit 2.0 through 2.2.10"
  },
  "articles/nunit/Towards-NUnit4.html": {
    "href": "articles/nunit/Towards-NUnit4.html",
    "title": "Towards NUnit Version 4 | NUnit Docs",
    "summary": "Towards NUnit Version 4 NUnit 4 has been long-awaited, and we are now starting to see its outline taking shape. With the introduction of NUnit 4, we are also making changes to the release cadence, shifting towards a Semver based versioning scheme. This entails aiming to release version 4 as soon as possible and subsequently accelerating the pace of new major releases compared to previous versions. We'd like to bring your attention to several interesting aspects of NUnit 4. First and foremost, there is a crucial NUnit 4 planning issue that we want to highlight. Additionally, we have an upcoming release notes page, currently in the form of a PR (Pull Request). If you're interested in changes related to supported frameworks and assert messages, we've compiled a list of issues for your reference. We have also created a Migration Guide starting with 4.x that we hope will assist in navigating any breaking changes. Moreover, we have created a milestone for version 4, which you can find a list of open issues for here. This milestone could be useful in tracking the progress and development of version 4. Now to some highlights -- not necessarily in chronological order. Improved Assert Result Messages Failure result messages now include the Assert statement that was used. Earlier code like: [TestCase(42)] public void TestInt(int val) { Assert.That(val, Is.EqualTo(4)); } resulted in: Message: Expected: 4 But was: 42 Not a very descriptive message. In version 4 this is improved to also include the assert statement itself. The result will then be: Message: Assert.That(val, Is.EqualTo(4)) Expected: 4 But was: 42 This also handles more complex statements, like for the following code: [Test] public void TestDouble() { var sut = new Math(); Assert.That(sut.Add(4.0, 2.0), Is.EqualTo(42.0).Within(0.1d), \"Add double failed\"); } which then results in: Message: Add double failed Assert.That(sut.Add(4.0, 2.0), Is.EqualTo(42.0).Within(0.1d)) Expected: 42.0d +/- 0.10000000000000001d But was: 6.0d Off by: 36.0d Note that the custom message is added before the Assert statement Including the Assert statement that caused the failure becomes particularly valuable in scenarios involving Multiple Asserts. In such cases, with a list of results from various asserts, it can be challenging to determine precisely which assert is responsible for each message. The improved result messages now offer clearer insights, making it easier to identify the specific assert that led to each failure. Given the code: [Test] public void TestMultiple() { var x = 2; Assert.Multiple(() => { Assert.That(x*2, Is.EqualTo(42)); Assert.That(x*1+40, Is.EqualTo(42)); Assert.That(x*3+42, Is.EqualTo(42)); }); } which in version 3 results in: Message: Multiple failures or warnings in test: 1) Expected: 42 But was: 4 2) Expected: 42 But was: 48 This is with only 3 asserts hard to figure out, but with version 4 we get: Message: Multiple failures or warnings in test: 1) Assert.That(x*2, Is.EqualTo(42)) Expected: 42 But was: 4 2) Assert.That(x*3+42, Is.EqualTo(42)) Expected: 42 But was: 48 Breaking change Please be aware of a breaking change regarding assert messages in NUnit. The previous format with params args is no longer supported. If you require a similar message format, it is now necessary to convert it to an interpolated string. Developer details The improved result messages have been implemented using the new CallerArgumentExpression together with using a FormattableString as the class for the message. Proper async/await, you can now await the Asserts NUnit 3 has implemented async functionality using a pattern called 'sync-over-async.' This approach allowed for its implementation without requiring significant underlying changes. In version 4 proper async/await has been implemented with a series of new assert methods, Assert.ThatAsync which can be await'ed. [Test] public async Task AssertionPasses_CompletedTaskWithResult_EqualsResult() { await Assert.ThatAsync(() => Task.FromResult(42), Is.EqualTo(42)); } Version 4 also introduces a new feature called Assert.MultipleAsync, which allows you to mix async and sync asserts within the same block. This enables you to perform multiple assertions, both asynchronous and synchronous, in a more concise and streamlined manner. Moreover, it's important to note that Assert.MultipleAsync is awaitable, providing flexibility in handling asynchronous operations and assertions. [Test] public async Task AssertMultipleAsyncSucceeds() { await Assert.MultipleAsync(async () => { await Assert.ThatAsync(() => Task.FromResult(42), Is.EqualTo(42)); Assert.That(\"hello\", Is.EqualTo(\"hello\")); await Assert.ThatAsync(() => Task.FromException(new ArgumentNullException)), Throws.ArgumentNullException); }); } Cooperative Cancellation For later versions of .NET it is not possible to abort a hanging thread -- and even though it's technically allowed in the classic .NET Framework, it prevents finally clauses and other cleanup routines from running. Cancellation is supposed to be done in a cooperative way. To achieve this in NUnit v4, we introduce a CancelAfter Attribute Nullability Version 4 has implemented stricter nullability throughout the codebase. While there are still some areas that require fixing, overall, it should now conform to the nullability requirements. See 3376 for details. These changes, along with the improved assert messages, have resulted in null values no longer being allowed for messages. As a consequence, code like the example below will not compile and will result in CS0121): It's important to update such code to use valid non-null message strings Platform support The lowest framework platforms support in Version 4 are .net framework 4.6.2 and .net 6.0. Classic/Legacy asserts The classic/legacy asserts, like Assert.AreEqual, have now been moved into their own project, and will later be released as a separate package. They are now in the namespace NUnit.Framework.Legacy, and the Assert class has been renamed to ClassicAssert. In the early V4 versions they will be delivered in the standard NUnit package. This means that the default assertion syntax going forward will be the \"constraint-based\" asserts. See Assertions for more details. Testing it out We have development packages deployed to a Myget feed, and now we have also added a github packages feed. If you're using the latter you need to authenticate yourself, once that is done anyone can grab from that feed. Myget If you add our Myget source to your app's nuget feeds, you can try out the new features yourself. Add or modify your nuget.config to add the package resources such as below: <?xml version=\"1.0\" encoding=\"utf-8\"?> <configuration> <packageSources> <clear/> <add key=\"nuget\" value=\"https://api.nuget.org/v3/index.json\" /> <add key=\"Myget\" value=\"https://www.myget.org/F/nunit/api/v3/index.json\" /> </packageSources> </configuration> Then, replace your current NUnit PackageReference with: <PackageReference Include=\"NUnit\" Version=\"4.0.0-dev-07984\" /> Github packages Add or modify your nuget.config to add the package resources such as below: <?xml version=\"1.0\" encoding=\"utf-8\"?> <configuration> <packageSources> <clear/> <add key=\"nuget\" value=\"https://api.nuget.org/v3/index.json\" /> <add key=\"Github\" value=\"https://nuget.pkg.github.com/nunit/index.json\" /> </packageSources> </configuration> Then, replace your current NUnit PackageReference with: <PackageReference Include=\"NUnit\" Version=\"4.0.0-alpha-8-g46eb5c5a1-pr-unknown\" /> Note: The versions should be the same, we're working on aligning the version numbers. Feedback We do appreciate feedback on these version 4 features. You can join in on the discussion here, comment in our slack channel, or if it is a bug or suggestion for improvement you can also raise an issue in our github repo."
  },
  "articles/nunit/extending-nunit/Action-Attributes.html": {
    "href": "articles/nunit/extending-nunit/Action-Attributes.html",
    "title": "Action Attributes | NUnit Docs",
    "summary": "Action Attributes Note Action Attributes are a feature of NUnit V2, designed to better enable composability of test logic. They are carried over to NUnit 3, but are not the recommended approach for most new work. Instead, for most problems of extensibility, NUnit 3 Custom Attributes are a better approach and are more likely to be supported in future releases. However, at this time, Action Attributes provide the only approach that allows placing an attribute on a higher-level element and having it affect the behavior of lower-level elements. The rest of this page describes Action Attribute usage in NUnit 3. Often when writing unit tests we have logic that we want to run upon certain events in the test cycle (e.g. SetUp, TearDown, FixtureSetUp, FixtureTearDown, etc.). NUnit has had the ability to execute code upon these events by decorating fixture classes and methods with the appropriate NUnit- provided attributes. Action Attributes allow the user to create custom attributes to encapsulate specific actions for use before or after any test is run. The Problem of Composability Suppose we have some tests in multiple fixtures that need the same in-memory test database to be created and destroyed on each test run. We could create a base fixture class and derive each fixture that depends on the test from that class. Alternatively, we could create a SetUpFixture class at the level of a common namespace shared by each fixture. This works fine, until we need some other reusable functionality, say the ability to configure or reset a ServiceLocator. We could put that functionality in the base fixture class or setup fixture, but now we're mixing two different responsibilities into the base class. In the case of a setup fixture, this only works if all classes requiring both features are located in a common namespace. In some cases we may not want the test database, but we do want ServiceLocator configuration; and sometimes we want the opposite. Still other times we'll want both - so we'd have to make the base class configurable. If we now discover a third piece of functionality we need to reuse, like configuring the Thread's CurrentPrincipal in arbitrary ways, the complexity of the solution very quickly. We've violated the Single Responsibility Principle and are suffering for it. What we really want is the ability to separate the different pieces of reusable test logic and compose them together as our tests need them. Resolving the Problem Action Attributes get us out of our bind. Consider this example: [TestFixture, ResetServiceLocator] public class MyTests { [Test, CreateTestDatabase] public void Test1() { /* ... */ } [Test, CreateTestDatabase, AsAdministratorPrincipal] public void Test2() { /* ... */ } [Test, CreateTestDatabase, AsNamedPrincipal(\"charlie.poole\")] public void Test3() { /* ... */ } [Test, AsGuestPrincipal] public void Test4() { /* ... */ } } Here we have used user-defined attributes to identify five different actions that we want to compose together in different ways for different tests: ResetServiceLocator CreateTestDatabase AsAdministratorPrincipal AsNamedPrincipal AsGuestPrincipal We can reuse these actions in other test fixtures, simply by decorating them with the appropriate attributes.without having to inherit from a base class. We can even develop and distribute a library of common test actions. Implementing an Action Attribute Action attributes are defined by the programmer. They implement the ITestAction interface, which is defined as follows: public interface ITestAction { void BeforeTest(ITest test); void AfterTest(ITest test); ActionTargets Targets { get; } } For convenience, you may derive your own action attribute from NUnit's TestActionAttribute, an abstract class with virtual implementations of each member of the interface. Alternatively, you may derive from System.Attribute and implement the interface directly. Action Targets The value returned from the Targets property determines when the BeforeTest and AfterTest methods will be called. The ActionTargets enum is defined as follows: [Flags] public enum ActionTargets { Default = 0, Test = 1, Suite = 2 } When an attribute that returns ActionTargets.Suite is applied to either a class or a parameterized method, NUnit will execute the attribute's BeforeTest method prior to executing the test suite and then execute the AfterTest method after the test suite has finished executing. This is similar to how the OneTimeSetUp and OneTimeTearDown attributes work. On the other hand, when an attribute that returns ActionTargets.Test is used in the same situations, NUnit will execute the attribute's BeforeTest method prior to each contained test case and the AfterTest method after each test case. This is similar to how the SetUp and TearDown attributes work. Action attributes that return ActionTargets.Default target the particular code item to which they are attached. When attached to a method, they behave as if ActionTargets.Test had been specified. When attached to a class or assembly, they behave as if ActionTargets.Suite was returned. ITest Interface The BeforeTest and AfterTest methods are provided with information about the test that is about to run (before) or has just run (after). The ITest interface is an internal NUnit interface to the representation of a test, which may be either a test case or a suite. The before and after methods may use the interface to decide what actions to take or retrieve information about the test. public interface ITest : IXmlNodeBuilder { // Gets the id of the test int Id { get; } // Gets the name of the test string Name { get; } // Gets the fully qualified name of the test string FullName { get; } // Gets the Type of the test fixture, if applicable, or // null if no fixture type is associated with this test. Type FixtureType { get; } // Gets a MethodInfo for the method implementing this test. // Returns null if the test is not implemented as a method. MethodInfo Method { get; } // Gets the RunState of the test, indicating whether it can be run. RunState RunState { get; } // Count of the test cases (1 if this is a test case) int TestCaseCount { get; } // Gets the properties of the test IPropertyBag Properties { get; } // Gets the parent test, if any. ITest Parent { get; } // Returns true if this is a test suite bool IsSuite { get; } // Gets a bool indicating whether the current test // has any descendant tests. bool HasChildren { get; } // Gets this test's child tests System.Collections.Generic.IList<ITest> Tests { get; } } Examples The examples that follow all use the following sample Action Attribute: [AttributeUsage(AttributeTargets.Method | AttributeTargets.Class | AttributeTargets.Interface | AttributeTargets.Assembly, AllowMultiple = true)] public class ConsoleActionAttribute : Attribute, ITestAction { private string _Message; public ConsoleActionAttribute(string message) { _Message = message; } public void BeforeTest(ITest test) { WriteToConsole(\"Before\", test); } public void AfterTest(ITest test) { WriteToConsole(\"After\", test); } public ActionTargets Targets { get { return ActionTargets.Test | ActionTargets.Suite; } } private void WriteToConsole(string eventMessage, ITest details) { Console.WriteLine(\"{0} {1}: {2}, from {3}.{4}.\", eventMessage, details.IsSuite ? \"Suite\" : \"Case\", _Message, details.FixtureType != null ? details.FixtureType.Name : \"{no fixture}\", details.Method != null ? details.Method.Name : \"{no method}\"); } } Note that the above Action Attribute returns the union of ActionTargets.Test and ActionTargets.Suite. This is permitted, but will probably not be the normal case. It is done here so we can reuse the attribute in multiple examples. The attribute takes a single constructor argument, a message, that will be used to write output to the console. All of the Before and After methods write output via the WriteToConsole method. Method Attached Actions Example 1 (applied to simple test method) [TestFixture] public class ActionAttributeSampleTests { [Test][ConsoleAction(\"Hello\")] public void SimpleTest() { Console.WriteLine(\"Test ran.\"); } } Console Output Before Case: Hello, from ActionAttributeSampleTests.SimpleTest. Test ran. After Case: Hello, from ActionAttributeSampleTests.SimpleTest. Example 2 (applied action twice to test method) [TestFixture] public class ActionAttributeSampleTests { [Test] [ConsoleAction(\"Hello\")] [ConsoleAction(\"Greetings\")] public void SimpleTest() { Console.WriteLine(\"Test run.\"); } } Console Output Before Case: Greetings, from ActionAttributeSampleTests.SimpleTest. Before Case: Hello, from ActionAttributeSampleTests.SimpleTest. Test run. After Case: Hello, from ActionAttributeSampleTests.SimpleTest. After Case: Greetings, from ActionAttributeSampleTests.SimpleTest. Remarks You are permitted to apply the same attribute multiple times. Note that the order in which attributes are applied is indeterminate, although it will generally be stable for a single release of .NET. Example 3 (applied to a test method with test cases) [TestFixture] public class ActionAttributeSampleTests { [Test] [ConsoleAction(\"Hello\")] [TestCase(\"02\")] [TestCase(\"01\")] public void SimpleTest(string number) { Console.WriteLine(\"Test run {0}.\", number); } } Console Output Before Suite: Hello, from ActionAttributeSampleTests.SimpleTest. Before Case: Hello, from ActionAttributeSampleTests.SimpleTest. Test run 01. After Case: Hello, from ActionAttributeSampleTests.SimpleTest. Before Case: Hello, from ActionAttributeSampleTests.SimpleTest. Test run 02. After Case: Hello, from ActionAttributeSampleTests.SimpleTest. After Suite: Hello, from ActionAttributeSampleTests.SimpleTest. Remarks When one or more [TestCase] attributes are applied to a method, NUnit treats the method as a test suite. You'll notice that BeforeTest was run once before the suite and AfterTest was run once after it. In addition, BeforeTest and AfterTest are run again for each individual test case. Note that the order in which test cases are executed is indeterminate. Type Attached Actions Example 1 [TestFixture] [ConsoleAction(\"Hello\")] public class ActionAttributeSampleTests { [Test] public void SimpleTestOne() { Console.WriteLine(\"Test One.\"); } [Test] public void SimpleTestTwo() { Console.WriteLine(\"Test Two.\"); } } Console Output Before Suite: Hello, from ActionAttributeSampleTests.{no method}. Before Case: Hello, from ActionAttributeSampleTests.SimpleTestOne. Test One. After Case: Hello, from ActionAttributeSampleTests.SimpleTestOne. Before Case: Hello, from ActionAttributeSampleTests.SimpleTestTwo. Test Two. After Case: Hello, from ActionAttributeSampleTests.SimpleTestTwo. After Suite: Hello, from ActionAttributeSampleTests.{no method}. Remarks In this case, the class is the test suite. BeforeTest and AfterTest are run once each for this class and then again for each test. Example 2 (attached to interface) [ConsoleAction(\"Hello\")] public interface IHaveAnAction { } [TestFixture] public class ActionAttributeSampleTests : IHaveAnAction { [Test] public void SimpleTest() { Console.WriteLine(\"Test run.\"); } } Console Output Before Suite: Hello, from ActionAttributeSampleTests.{no method}. Before Case: Hello, from ActionAttributeSampleTests.SimpleTest. Test run. After Case: Hello, from ActionAttributeSampleTests.SimpleTest. After Suite: Hello, from ActionAttributeSampleTests.{no method}. Remarks Action attributes can be applied to an interface. If a class marked with [TestFixture] implements an interface that has an action attribute applied to the interface, the class inherits the action attribute from the interface. It behaves as if you applied the action attribute to the class itself. Example 3 (action attribute is applied to interface and attribute uses interface to provide data to tests) [AttributeUsage(AttributeTargets.Interface)] public class InterfaceAwareActionAttribute : TestActionAttribute { private readonly string _Message; public InterfaceAwareActionAttribute(string message) { _Message = message; } public override void BeforeTest(ITest details) { IHaveAnAction obj = details.Fixture as IHaveAnAction; if(obj != null) obj.Message = _Message; } public override ActionTargets Targets { get { return ActionTargets.Test; } } } [InterfaceAwareAction(\"Hello\")] public interface IHaveAnAction { string Message { get; set; } } [TestFixture] public class ActionAttributeSampleTests : IHaveAnAction { [Test] public void SimpleTest() { Console.WriteLine(\"{0}, World!\", Message); } public string Message { get; set; } } Console Output Hello, World! Remarks Here we see a new action attribute, InterfaceAwareAction. This attribute uses the Fixture property of the TestDetails passed into BeforeTest and casts it to an interface, IHaveAnAction. If the fixture implements the IHaveAnAction interface, the attribute sets the Message property to the string passed into the constructor of the attribute. Since the attribute is applied to the interface, any class that implements this interface gets its Message property set to the string provided to the constructor of the attribute. This is useful when the action attribute provides some data or service to the tests. Note that this attribute inherits from TestActionAttribute. It uses the default (do-nothing) implementation of AfterTest and overrides both BeforeTest and Target. Assembly Attached Action Example 1 [assembly: ConsoleAction(\"Hello\")] [TestFixture] public class ActionAttributeSampleTests { [Test] public void SimpleTest() { Console.WriteLine(\"Test run.\"); } } Console Output Before Suite: Hello, from {no fixture}.{no method}. Before Case: Hello, from ActionAttributeSampleTests.SimpleTest. Test run. After Case: Hello, from ActionAttributeSampleTests.SimpleTest. After Suite: Hello, from {no fixture}.{no method}. Remarks The ConsoleAction attribute in this example is applied to the entire assembly. NUnit treats an assembly as a test suite (in fact, a suite of suites). Since the ConsoleAction attribute implements both ITestSuiteAction and ITestCaseAction, NUnit will run BeforeTest once before any tests are run in the assembly, and AfterTest after all tests are run in the assembly. Additionally, BeforeTest and AfterTest will be run for every test case in the assembly. It is unlikely that action attributes are applied to assemblies often. However, it is useful to build action attributes that ensure state gets cleaned up before and after each tests to prevent individual tests from affecting the outcome of other test. For example, if you have any static or cached data or services, an action attribute can be used to clean them up for each test."
  },
  "articles/nunit/extending-nunit/Custom-Attributes.html": {
    "href": "articles/nunit/extending-nunit/Custom-Attributes.html",
    "title": "Custom Attributes | NUnit Docs",
    "summary": "Custom Attributes NUnit 3 implements a great deal of its functionality in its attributes. This functionality is accessed through a number of standard interfaces, which are implemented by the attributes. Users may create their own attributes by implementing these interfaces. For ease of understanding, the interfaces are grouped according to the stage in the life-cycle of a test at which they are used. The two primary stages in the life of a test are Load-Time and Execution-Time. Load-Time Interfaces Loading tests means loading the assembly into memory and examining its content to discover the classes and fixtures that represent tests. The internal structures that represent tests are built at this time. If requested by the application, information about the tests may be returned for display, as is done in the NUnit GUI runner. The following interfaces are called at load time. Interface Used By IFixtureBuilder Attributes that know how to build a fixture from a test class ITestBuilder Attributes that know how to build one or more parameterized test cases for a method ISimpleTestBuilder Attributes that know how to build a single non-parameterized test case for a method IParameterDataSource Attributes that supply values for a single parameter for use in generating test cases IImplyFixture Attributes used on a method to signal that the defining class should be treated as a fixture IApplyToTest Attributes that make modifications to a test immediately after it is constructed Execution-Time Interfaces At execution-time, some or all of the tests that were previously loaded are actually run. Their results are returned and made available to the application. The following interfaces are called at execution time. Interface Used By IApplyToContext Attributes that set up the context prior to execution ICommandWrapper Attributes that can wrap a TestCommand with another command"
  },
  "articles/nunit/extending-nunit/Custom-Constraints.html": {
    "href": "articles/nunit/extending-nunit/Custom-Constraints.html",
    "title": "Custom Constraints | NUnit Docs",
    "summary": "Custom Constraints Note Page Under Development You can implement your own custom constraints by creating a class that inherits from the Constraint abstract class, which supports performing a test on an actual value and generating appropriate messages. Constraint Abstract Class Implementations must override the one abstract method ApplyTo<TActual> which evaluates the previously stored expected value (if any) against the method's parameter, the actual value. There are also several virtual methods that may be overridden to change some default behaviors. The relevant portions of the Constraint class are represented below. namespace NUnit.Framework.Constraints { public abstract class Constraint { protected Constraint(params object[] args) {} public abstract ConstraintResult ApplyTo<TActual>(TActual actual); /* ... */ public virtual ConstraintResult ApplyTo<TActual>(ActualValueDelegate<TActual> del) {} public virtual ConstraintResult ApplyTo<TActual>(ref TActual actual) {} protected virtual object GetTestObject<TActual>(ActualValueDelegate<TActual> del) {} public virtual string Description { get; protected set; } protected virtual string GetStringRepresentation() {} } } Constraint Constructor The Constraint constructor accepts zero or more arguments and saves them to be used in the printed description later. Constraints like NullConstraint or UniqueItemsConstraint take no arguments and simply state some condition about the actual value supplied. Constraints with a single argument usually treat it as the expected value resulting from some operation. Multiple arguments can be provided where the semantics of the constraint call for it. ApplyTo Implementation The ApplyTo<TActual>(TActual actual) method must be overridden and provides for the core implementation of the custom constraint. Whatever logic defines pass or fail of the constraint and actual/expected values goes into the ApplyTo<TActual>(TActual actual) method. For example, a very naive implementation of a reference equality constraint might look like this: public override ConstraintResult ApplyTo<TActual>(TActual actual) { return new ConstraintResult(this, actual, ReferenceEquals(actual, Arguments[0])); } The key here is there needs to be some evaluation of the constraint logic, and the return value must be a ConstraintResult or subclass thereof. Custom subclasses of ConstraintResult may be used to further customize the message provided upon failure, as described below. ApplyTo Overloads Constraints may be called with a delegate to return the actual value instead of the actual value itself. This serves to delay evaluation of the value. The default implementation of ApplyTo<TActual>(ActualValueDelegate<TActual> del) waits for the delegate to complete if it's an async operation, other immediately calls the delegate if synchronous, and then calls the abstract ApplyTo<TActual>(TActual actual) method with the value. Another overload also exists, ApplyTo<TActual>(ref TActual actual). The default implementation dereferences the value and then calls the abstract ApplyTo<TActual>(TActual actual) method with the value. This public virtual method is available by use from calling code but currently is not used from any framework calls within NUnit itself. GetTestObject Optional Override The default implementation of ApplyTo<TActual>(ActualValueDelegate<TActual> del) does not simply execute the delegate but actually calls out to another virtual method, GetTestObject<TActual>(ActualValueDelegate<TActual> del). This method can be overridden to keep the default behavior of ApplyTo<TActual>(ActualValueDelegate<TActual> del) while still customizing how the actual value delegate is invoked. Description Property This virtual property is used to provide a description of the constraint for messages. Simple constant values can be set in the custom constraint's constructor. If more complex logic is needed, override the property and provide a custom implementation of get. Here are a few simple examples from built-in constraints. public class FalseConstraint : Constraint { public FalseConstraint() { this.Description = \"False\"; } } public class NullConstraint : Constraint { public NullConstraint() { this.Description = \"null\"; } } Here are a few complex examples from built-in constraints. public class AndConstraint : BinaryConstraint { public override string Description { get { return Left.Description + \" and \" + Right.Description; } } } public abstract class PrefixConstraint : Constraint { public override string Description { get { return string.Format( baseConstraint is EqualConstraint ? \"{0} equal to {1}\" : \"{0} {1}\", descriptionPrefix, baseConstraint.Description); } } } GetStringRepresentation Method NUnit calls the GetStringRepresentation method to return a string representation of the constraint, including the expected value(s). The default implementation returns the lowercase display name of the constraint followed by all expected values, separated by a space. For example, a custom constraint ReferenceEqualsConstraint with an instance of a custom MyObject class as expected value would result in a default string representation of <referenceequals MyObject>. You can override the initial display name only by setting DisplayName in your constructor. This public property cannot be overridden, but the Constraint base class sets it in the base constructor to be the name of the class, minus the \"Constraint\" suffix and minus any generic suffixes. Custom Constraint Usage Syntax Having written a custom constraint class, you can use it directly through its constructor: Assert.That(myObject, new CustomConstraint()); You may also use it in expressions through NUnit's Matches syntax element: Assert.That(myObject, Is.Not.Null.And.Matches(new CustomConstraint()); The direct construction approach is not very convenient or easy to read. For its built-in constraints, NUnit includes classes that implement a special constraint syntax, allowing you to write things like... Assert.That(actual, Is.All.InRange(1, 100)); Custom constraints can support this syntax by providing a static helper class and extension method on ConstraintExpression, such as this. public static class CustomConstraintExtensions { public static ContentsEqualConstraint ContentsEqual(this ConstraintExpression expression, object expected) { var constraint = new ContentsEqualConstraint(expected); expression.Append(constraint); return constraint; } } To fully utilize your custom constraint the same way built-in constraints are used, you'll need to implement two additional classes (which can cover all your constraints, not for each custom constraint). Provide a static class patterned after NUnit's Is class, with properties or methods that construct your custom constructor. If you like, you can even call it Is and extend NUnit's Is, provided you place it in your own namespace and avoid any conflicts. This allows you to write things like: Assert.That(actual, Is.Custom(x, y)); with this sample implementation: public class Is : NUnit.Framework.Is { public static CustomConstraint Custom(object expected) { return new CustomConstraint(expected); } } Provide an extension method for NUnit's ConstraintExpression, allowing you to write things like: Assert.That(actual, Is.Not.Custom(x, y)); with this sample implementation: public static class CustomConstraintExtensions { public static CustomConstraint Custom(this ConstraintExpression expression, object expected) { var constraint = new CustomConstraint(expected); expression.Append(constraint); return constraint; } }"
  },
  "articles/nunit/extending-nunit/Framework-Extensibility.html": {
    "href": "articles/nunit/extending-nunit/Framework-Extensibility.html",
    "title": "Framework Extensibility | NUnit Docs",
    "summary": "Framework Extensibility The NUnit Framework is the part of NUnit that is referenced by user tests. It contains the definition of all of NUnit's Attributes, Constraints and Asserts as well as the code that discovers and executes tests. Most extensions to exactly how tests are recognized and how they execute are Framework extensions. In this documentation, we refer to three different types of Framework extension: Custom Attributes allow creation of new types of tests and suites, new sources of data and modification of the environment in which a test runs as well as its final result. Action Attributes are an NUnit V2 feature, still supported in NUnit 3. They were designed to better enable composability of test logic by creating attributes that encapsulate specific actions to be taken before or after a test is run. For most work, Custom Attributes are the way to go, but Action Attributes continue to be the only way to apply an attribute at a higher level and have it apply to many tests. Custom Constraints allow the user to define new constraints for use in tests along with the associated fluent syntax that allows them to be used with Assert.That. Links to Blog Posts On Custom constraints How to extend the NUnit constraints"
  },
  "articles/nunit/extending-nunit/IApplyToContext-Interface.html": {
    "href": "articles/nunit/extending-nunit/IApplyToContext-Interface.html",
    "title": "IApplyToContext Interface | NUnit Docs",
    "summary": "IApplyToContext Interface NUnit tests run within a context, known as the TestExecutionContext. The context for a test case is nested within the context for its containing suite and so on, up to the assembly level. Attributes that implement IApplyToContext are called immediately after the context is created and before the test is run in order to make changes to the context. Once the test execution has completed, the context is discarded so that - effectively - any changes are reverted to their original values. The IApplyToContext interface is defined as follows: public interface IApplyToContext { void ApplyToContext(TestExecutionContext context); } An example of the use of the context may be helpful. One item in the TestExecutionContext is the default timeout value for test cases. When any test is marked with [Timeout(nnn)] the context value is replaced by the supplied argument. The new timeout applies for any test case it appears on and any test case that is contained in a suite that it appears on. When the test or suite completes, the new value is discarded and the value contained in the original context is once against used. Custom attributes that implement IApplyToContext should modify the TestExecutionContext in accordance with the arguments supplied to them. They are not called after the test is run and have no cleanup to perform. The NUnit attributes that implement IApplyToContext are as follows: DefaultFloatingPointToleranceAttribute ParallelizableAttribute SetCultureAttribute SetUICultureAttribute SingleThreadedAttribute TimeoutAttribute"
  },
  "articles/nunit/extending-nunit/IApplyToTest-Interface.html": {
    "href": "articles/nunit/extending-nunit/IApplyToTest-Interface.html",
    "title": "IApplyToTest Interface | NUnit Docs",
    "summary": "IApplyToTest Interface The IApplyToTest interface is used to make modifications to a test immediately after it is constructed. It is defined as follows: public interface IApplyToTest { void ApplyToTest(Test test); } The Test Type is quite general and the argument may represent a suite or an individual test case. If the distinction is important, then you must code the attribute to examine the argument and react accordingly. The interface may appear on the same attribute that is used to construct the test or on a separate attribute. In either case, it will only be called after the test is built. The order in which ApplyToTest is called on multiple attributes is indeterminate. If two attributes make completely independent changes to a test, then the order is not relevant. But if they both change the same property, or related properties, then it may necessary to make tests in the attribute code to ensure that the correct value 'wins'. The most common example of this is for attributes that change the RunState of a test. If one attribute is trying to set it to RunState.Ignore, while the other wants it to be RunState.NotRunnable, we would normally expect the 'worst' value to win and for the test to be non-runnable. We can achieve that by code like the following: // In the attribute setting NotRunnable test.RunState = RunState.NotRunnable; /* ... */ // In the attribute setting Ignore if (test.RunState != RunState.NotRunnable) test.RunState = RunState.Ignore; The following NUnit attributes implement IApplyToTest: CategoryAttribute CombiningStrategyAttribute CultureAttribute ExplicitAttribute IgnoreAttribute OrderAttribute PlatformAttribute PropertyAttribute (and, through it, a large number of derived attributes) RequiresThreadAttribute TestAttribute TestFixtureAttribute"
  },
  "articles/nunit/extending-nunit/ICommandWrapper-Interface.html": {
    "href": "articles/nunit/extending-nunit/ICommandWrapper-Interface.html",
    "title": "ICommandWrapper Interface | NUnit Docs",
    "summary": "ICommandWrapper Interface In NUnit 3, test execution is done using command objects, which are constructed for each test case. Execution of a single test case will generally require multiple nested commands. Some attributes placed on a test method are able to contribute to the chain of commands. For example, MaxTimeAttribute adds a command, which examines the elapsed time to complete a test and fails it if a specified maximum was exceeded. Attributes add to the command chain by implementing one of the two interfaces that derive from the ICommandWrapper interface. The interfaces are defined as follows: public interface ICommandWrapper { TestCommand Wrap(TestCommand command); } public interface IWrapTestMethod : ICommandWrapper { } public interface IWrapSetUpTearDown : ICommandWrapper { } Attributes should not implement the ICommandWrapper interface directly but should select one of the derived interfaces. NUnit applies the IWrapSetUpTearDown interface before SetUp and after TearDown. It applies the IWrapTestMethod interface after SetUp and before the test is run. Attributes implementing one of these interfaces must be placed on a test method. Otherwise, they have no effect. The Wrap method should return an appropriate command in which the original command has been nested. For an example, see the implementation of MaxTimeAttribute. The following NUnit attributes implement the IWrapSetUpTearDown interface: MaxTimeAttribute RepeatAttribute RetryAttribute The IWrapTestMethodinterface is not currently used by any NUnit attributes."
  },
  "articles/nunit/extending-nunit/IFixtureBuilder-Interface.html": {
    "href": "articles/nunit/extending-nunit/IFixtureBuilder-Interface.html",
    "title": "IFixtureBuilder Interface | NUnit Docs",
    "summary": "IFixtureBuilder Interface This interface is used by attributes that know how to build a fixture from a user class. IFixtureBuilder is defined as follows: public interface IFixtureBuilder { TestSuite BuildFrom(ITypeInfo type); } Custom fixture builders should examine the provided ITypeInfo and return an appropriate type of fixture based on it. If the fixture is intended to be an NUnit TestFixture, then the helper class NUnitTestFixtureBuilder may be used to create it. The following NUnit attributes currently implement this interface: TestFixtureAttribute TestFixtureSourceAttribute SetUpFixtureAttribute Notes: ITypeInfo is an internal interface used by NUnit to wrap a Type. See source code for details. It would make more sense for this interface method to return TestFixture rather than TestSuite. We use TestSuite because it is the common base for both TestFixture and SetupFixture. In a future version, we will try to adjust the hierarchy so that all suites based on a class are derived from TestFixture."
  },
  "articles/nunit/extending-nunit/IImplyFixture-Interface.html": {
    "href": "articles/nunit/extending-nunit/IImplyFixture-Interface.html",
    "title": "IImplyFixture Interface | NUnit Docs",
    "summary": "IImplyFixture Interface The IImplyFixture interface is an empty interface, used solely as a marker: public interface IImplyFixture { } If a class contains any method with an attribute that implements this interface, that class is treated as an NUnit TestFixture without any TestFixture attribute being specified. The following NUnit attributes currently implement this interface: TestAttribute TestCaseAttribute TestCaseSourceAttribute TheoryAttribute"
  },
  "articles/nunit/extending-nunit/IParameterDataSource-Interface.html": {
    "href": "articles/nunit/extending-nunit/IParameterDataSource-Interface.html",
    "title": "IParameterDataSource Interface | NUnit Docs",
    "summary": "IParameterDataSource Interface The IParameterDataSource interface is implemented by attributes that provide data for use as an argument to a single parameter. Other attributes and test builders combine the values in various ways to produce test cases. The interface is defined as follows: public interface IParameterDataSource { IEnumerable GetData(IParameterInfo parameter); } IParameterInfo is an NUnit internal class used to wrap a ParameterInfo. See the source code for more info. A custom attribute implementing this interface should examine the IParameterInfo and return data values that are compatible with the parameter. The attribute has no control over how this data is combined with other arguments - that's up to other attributes and ultimately NUnit itself. The following NUnit attributes currently implement IParameterDataSource: RandomAttribute ValuesAttribute, with the derived class RangeAttribute ValueSourceAttribute"
  },
  "articles/nunit/extending-nunit/ISimpleTestBuilder-Interface.html": {
    "href": "articles/nunit/extending-nunit/ISimpleTestBuilder-Interface.html",
    "title": "ISimpleTestBuilder | NUnit Docs",
    "summary": "ISimpleTestBuilder This interface is used by attributes that know how to build a single, non-parameterized test from a MethodInfo. ISimpleTestBuilder is defined as follows: public interface ISimpleTestBuilder { TestMethod BuildFrom(IMethodInfo method, Test suite); } IMethodInfo is an NUnit internal class used to wrap a MethodInfo. See the source code for more info. The suite argument is the test suite that contains the method in question. Custom attributes implementing ISimpleTestFixture should examine the IMethodInfo provided and return a single TestMethod instance, as appropriate to that method. The BuildFrom method should never return null, even if the specified method is not valid for a test. In that case, it should return a TestMethod with a RunState of NonRunnable, in order to provide feedback to the user who placed the attribute on the method. NUnit treats attributes implementing this interface specially. They are ignored if any other attributes are present that implement ITestBuilder. This allows, for example, use of [Test] on a method that also has [Combinatorial] specified, without any error arising. Such usage has existed in NUnit for some time and this special handling of the interface allows us to preserve it. In the current build, only TestAttribute implements this interface."
  },
  "articles/nunit/extending-nunit/ITestBuilder-Interface.html": {
    "href": "articles/nunit/extending-nunit/ITestBuilder-Interface.html",
    "title": "ITestBuilder Interface | NUnit Docs",
    "summary": "ITestBuilder Interface This interface is used by attributes that know how to build one or more parameterized TestMethod instances from a MethodInfo. ITestMethodBuilder is defined as follows: public interface ITestBuilder { IEnumerable<TestMethod> BuildFrom(IMethodInfo method, Test suite); } IMethodInfo is an NUnit internal class used to wrap a MethodInfo. See the source code for more info. The suite argument is the test suite that contains the method in question. A custom attribute implementing this interface should examine the IMethodInfo and return as many TestMethod instances as it is able to construct, using the parameters available to it. Some attributes will only return a single test, just as TestCaseAttribute does. Others, working like TheoryAttribute may return multiple tests. If no data is available to create tests, an empty collection should be returned. If the returned tests are standard NUnit TestMethods, the helper class NUnitTestCaseBuilder may be used to create them. The following NUnit attributes currently implement ITestBuilder: CombiningStrategyAttribute, with the following derived classes: CombinatorialAttribute PairwiseAttribute SequentialAttribute TestCaseAttribute TestCaseSourceAttribute TheoryAttribute"
  },
  "articles/nunit/extending-nunit/Index.html": {
    "href": "articles/nunit/extending-nunit/Index.html",
    "title": "Extending NUnit | NUnit Docs",
    "summary": "Extending NUnit NUnit is intended to be extensible. We can't do everything for everybody but we want to make it reasonably easy to extend NUnit. In many cases, users will be able to implement a special feature outside of our scope by simply creating a new attribute that embeds the required logic. In other cases, particularly in extending the engine, we rely on a plugin-architecture. Types of Extensibility Framework Extensibility Engine Extensibility"
  },
  "articles/nunit/getting-started/dotnet-core-and-dotnet-standard.html": {
    "href": "articles/nunit/getting-started/dotnet-core-and-dotnet-standard.html",
    "title": ".NET Core | NUnit Docs",
    "summary": ".NET Core More information and getting started tutorials are available for NUnit and .NET Core targeting C#, F# and Visual Basic in the .NET Core documentation's Unit Testing in .NET Core page. The other information on this page is older documentation. If you follow the instructions in the Installation section your project will work with .NET Core. The test projects have to be .NET (Core) or .NET Framework; .NET Standard can't be used as a test project, since it can't be run on its own, but any code in a .NET Standard library can be tested from a .NET (Core) or .NET Framework test project. TL;DR Adding the adapter and Microsoft.NET.Test.Sdk version 17.8.0 or greater to your NUnit test projects will also enable the dotnet test command for .NET Core projects. Any tests using the new style CSPROJ format, either .NET Core or .NET 4.x, need to add a PackageReference to the NuGet package Microsoft.NET.Test.Sdk. Your test assemblies must also be .NET Core or .NET 4.x, not .NET Standard. You can create a new NUnit test project using dotnet new nunit. It will create an ItemGroup in the csproj file with the necessary references. The .csproj will look similar to below. <Project Sdk=\"Microsoft.NET.Sdk\"> <PropertyGroup> <TargetFrameworks>net8.0</TargetFrameworks> <ImplicitUsings>enable</ImplicitUsings> <Nullable>enable</Nullable> <IsPackable>false</IsPackable> </PropertyGroup> <ItemGroup> <PackageReference Include=\"Microsoft.NET.Test.Sdk\" Version=\"17.14.1\" /> <PackageReference Include=\"NUnit\" Version=\"4.4.0\" /> <PackageReference Include=\"NUnit3TestAdapter\" Version=\"5.1.0\" /> <PackageReference Include=\"NUnit.Analyzers\" Version=\"4.10.0\"> <PrivateAssets>all</PrivateAssets> <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets> </PackageReference> <PackageReference Include=\"coverlet.collector\" Version=\"6.0.4\"> <PrivateAssets>all</PrivateAssets> <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets> </PackageReference> </ItemGroup> </Project> .NET Core test can be run on the command line with dotnet test, for example, From the solution root folder dotnet test or from the test project folder dotnet test Or you can specify the csproj file you want to test dotnet test .\\test\\NetCore10Tests\\NetCore10Tests.csproj For a more complete walk-through, please see Testing .NET Core with NUnit in Visual Studio 2017 Using the NUnit project templates The NUnit test project templates come included with dotnet. You can run dotnet new nunit to create an NUnit test project. FAQ Why can't my tests target .NET Standard Visual Studio and VSTest require that the tests target a specific platform. .NET Standard is like a Portable library in that it does not target any specific platform, but can run on any supported platform. Microsoft decided that your tests should be compiled to target a platform so they know which platform to run your tests under and you get the behavior you expect for the platform you are targeting. You can however target multiple platforms in your tests and compile and run each from the command line. It still only runs one platform from Visual Studio, but I would hope that is being worked on. I haven't tested 15.3 yet. It is similar to a console application, it cannot be .NET Standard, it must target a platform, .NET Core or .NET Framework. This limitation is the same for all test adapters including xUnit and MSTest2. My tests aren't showing up in Visual Studio 2022 or later Are you using the NuGet adapter package? Are you using version 4.5.0 or newer of the NuGet adapter package? Do your tests target .NET Core or the full .NET Framework? (see above) Have you added a Package Reference to Microsoft.NET.Test.Sdk? Have you restarted Visual Studio? It is still a bit temperamental. Are you doing integration testing with Asp.Net Core WebApplicationFactory and using minimal API, and it complains about missing testhost.deps.json? Then you're accessing the wrong Program class in your WebApplicationFactory. Fix it by adding a code line at the end of the Program.cs file, and verify that your WebApplicationFactory is actually using this Program class: public partial class Program { } The reason for this is that the generated/hidden Minimal API (Top Level statement) Program class is internal. By declaring the partial part, it is changed to public. See Microsoft docs for more info, and some alternatives. My tests multi-target .NET Core and .NET Framework, why can't I run both in Visual Studio This was a limitation in earlier versions of Visual Studio, but is fixed in Visual Studio 2022. If you must run an earlier version and have this issue, you can run specific tests using the --framework command line option of dotnet test How do I produce a test results file dotnet test can generate an NUnit3 test result file by adding a runsettings property. The property to add is TestOutputXml. This generation is done using the NUnit Engine report service, and produce the same result as the NUnit3-console. This is available through the NUnit3TestAdapter. You run it by adding the setting on the command line (or in a runsettings file): dotnet test -- NUnit.TestOutputXml=yourfoldername The folder is relative to a base folder determined by the OutputXmlFolder settings, or you can use an absolute path. The latter is useful in CI scenarios. Alternatively, there is a 3rd party package, NUnitXml.TestLogger which also produces a NUnit3 xml format. Details for use see here. Note that this is a re-implementation of the NUnit3 format, and may differ."
  },
  "articles/nunit/getting-started/installation.html": {
    "href": "articles/nunit/getting-started/installation.html",
    "title": "Installation | NUnit Docs",
    "summary": "Installation To install NUnit, you can use various installation approaches, depending upon your preferred development environment and preferences. I'm using Visual Studio as my development tool You can add a NUnit project from the Add New Project dialog. Search for NUnit and choose the NUnit Test Project template. This will add a new project to your solution, containing a single test class and a single test method. Your project file will have the necessary references to NUnit, the NUnit Test Adapter, the NUnit Analyzer, Microsoft Test SDK and the coverlet code coverage package. Note Be aware that the templates behind this may be out of date, so always go to the Manage NuGet Packages dialog and update to the latest version of all packages there. I'm using Visual Studio Code as my development tool Ensure you have the C# Dev Kit installed. Then Shift+CTRL+P, type New and select New Project. Select NUnit 3 Test Project and follow the prompts. The results will be exactly the same as if you had used Visual Studio. I'm using Rider as my development tool This is the same procedure as for Visual Studio: Add New Project, select the NUnit Test Project template, and follow the prompts. The results will be exactly the same as if you had used Visual Studio. Rider has built-in support for NUnit, and is using the same template, so you'll achieve the same result. I prefer to do this using the command line or any of the built-in terminals From your solution folder, run dotnet new nunit -o TestProject1 to create a new NUnit test project in the folder TestProject1. The results will be exactly the same as if you had used Visual Studio. Examples of what you get All of the above will create a new project with the following structure, after updating the packages to the latest versions (as of Sept 2023): <Project Sdk=\"Microsoft.NET.Sdk\"> <PropertyGroup> <TargetFramework>net8.0</TargetFramework> <ImplicitUsings>enable</ImplicitUsings> <Nullable>enable</Nullable> <IsPackable>false</IsPackable> </PropertyGroup> <ItemGroup> <PackageReference Include=\"Microsoft.NET.Test.Sdk\" Version=\"17.7.2\" /> <PackageReference Include=\"NUnit\" Version=\"3.13.3\" /> <PackageReference Include=\"NUnit3TestAdapter\" Version=\"4.5.0\" /> <PackageReference Include=\"NUnit.Analyzers\" Version=\"3.7.0\"> <PrivateAssets>all</PrivateAssets> <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets> </PackageReference> <PackageReference Include=\"coverlet.collector\" Version=\"6.0.0\"> <PrivateAssets>all</PrivateAssets> <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets> </PackageReference> </ItemGroup> </Project> It will create a UnitTest1.cs file with the following contents: namespace TestProject1; public class Tests { [SetUp] public void Setup() { } [Test] public void Test1() { Assert.Pass(); } } and a Usings.cs file: global using NUnit.Framework; Adding NUnit to an existing test project If you need to update an existing test project to use NUnit -- perhaps a .NET class lib you want to convert to a test project, or adding NUnit to a project that already has XUnit or MSTest -- you can do that by adding the ItemGroup in the .csproj file above to your project file, and then the appropriate using NUnit.Framework; in your code. Also note that multiple different test frameworks (XUnit, MSTest, NUnit) can co-exist in the same test project, preferably in different files to avoid name clashes. See this blog post for details. TL;DR All of the above ways to create a new NUnit project will result in the same structure, the same test class and methods, and the same packages being installed. That means you can do it any way you like, you can start with one tool and continue with another. The template used is maintained as part of .NET and will be upgraded when .NET updates. All the above pick the template from .NET, which is why the end result is the same. I want to do it the old and hard way This is from the older documentation, and is still valid, but we recommend you use the above methods. Full NUnit install via NuGet. NUnitLite install via NuGet. Zip and/or MSI file download. Combined Approach Using NuGet Packages and the NUnit Console In Visual Studio, from the Tools menu, select NuGet Package Manager | Manage NuGet packages for solution... Open the Browser tab, and Scroll or use search to locate the NUnit and NUnit.Console packages. NUnit and NUnit.Console Install both packages. The NUnit package should be referenced by each of your test assemblies, but not by any others. Locate nunit3-console in the packages\\NUnit.ConsoleRunner.3.X.X\\tools (or your configured package directory of choice) directory under your solution. This is the location from which you must run nunit3-console when if you would like to run NUnit3 from console. We recommend you only use this approach when running under the control of a script on your build server. See here for more details of using the NUnit Console app. NUnit3TestAdapter If you want to automate the running of NUnit tests on a clean machine without any installations (e.g. Azure DevOps or GitHub Actions build agents) - and you're using Visual Studio 2012 or later, use this package. See the Visual Studio Test Adapter for details. Note If you have used any of the above 4 approaches, you already have this package installed, and it will work on any CI build system. Using NuGet NUnitLite Package The NUnitLite approach provides a way to run NUnit tests without a full install of the NUnit runner and test engine assemblies. Only the framework and a small runner program are installed. If you want to experiment with NUnit or debug something in NUnit, this can be a helpful choice. Follow the instructions for NUnitLite to install the package and create a test assembly. You will need to add a reference to the NUnitLite package in your test assembly. To run your tests, simply run your executable test assembly. No other runner is needed. Note that since this approach includes a Program.cs it can not be combined with the ordinary unit test project, as that would create two entry points, which would confuse the compiler. Downloading the Zip File -- Not Recommended Download the latest binary zip of the NUnit Framework from our Download page. Unzip the file into any convenient directory. You can also download the latest binary zip or an MSI installer of the NUnit Console from GitHub. Unzip the file or install the MSI and then if you would like be able to run nunit3-console from the command line, put the bin directory, containing nunit3-console.exe on your path. In your test assemblies, add a reference to nunit.framework.dll, using the copy in the subdirectory for the appropriate runtime version. For example, if you are targeting .NET 4.0, you should reference the framework assembly in the net-4.0 subdirectory. Run nunit3-console from the command line, giving it the path to your test assembly. To run NUnit's own framework tests from within the NUnit bin directory, enter: nunit3-console net-2.0/nunit.framework.tests.dll Combined Approach This approach is useful if you would like to use a single copy of nunit3-console with individual copies of the framework in each project. Simply follow the zip file procedure to get a central copy of NUnit on your system. Then install the NUnit Version 3 NuGet package in each of your test assemblies. For desktop use by developers, this approach may give you the best of both worlds."
  },
  "articles/nunit/getting-started/samples.html": {
    "href": "articles/nunit/getting-started/samples.html",
    "title": "Samples | NUnit Docs",
    "summary": "Samples Samples of NUnit usage are available in each of the languages listed below. C# Samples VB.NET Samples F# Samples C++ Samples"
  },
  "articles/nunit/getting-started/upgrading.html": {
    "href": "articles/nunit/getting-started/upgrading.html",
    "title": "Upgrading | NUnit Docs",
    "summary": "Upgrading Upgrading from NUnit 3.X to NUnit 4.X See the Migration Guide for information on upgrading from NUnit 3.x to NUnit 4.x. Also see the Release Notes for version 4.0.0 for information on breaking and other changes to see if any of these may affect your tests. Upgrading from NUnit 2.6.4 to NUnit 3.0 This section assumes you are upgrading to NUnit 3.0 from NUnit 2.6 or later. While it's possible to upgrade from an earlier version, you will need to take into account many additional changes in NUnit, which are not described here. If this is your situation, be sure to check the release notes for earlier versions of NUnit as well. Review Breaking Changes The Breaking Changes page lists missing and changed functionality in NUnit 3.0. You should review this page to see which items are likely to affect your own tests. Update Your Code In many cases, the items being removed have been deprecated for some time and an alternate approach may already be available in your current release of NUnit. If that is the case, it will probably save you time and effort if you modify the code in your current environment before switching to NUnit 3.0. For example, NUnit 3.0 no longer supports ExpectedExceptionAttribute. However, preferred alternatives Assert.Throws and the ThrowsConstraint have been available for several years. If you remove the attribute from your tests and use one of the alternatives instead, you can verify that they work in your present environment and they will continue to work after conversion.** Switch to NUnit 3.0 Remove references to your old version of NUnit and replace them with references to NUnit 3.0. In the case of NUnitLite executable tests, you will need to reference both the nunit.framework and NUnitLite assemblies. Compile your code. It's possible that you will find compiler errors due to breaking changes in NUnit 3.0, which you missed in the prior step. Make the necessary changes until it all works. Make the Tests Pass Hopefully, you aren't converting tests that were not passing when you started! If all goes well, they will continue to pass under NUnit 3.0. If not, investigate each case and make necessary changes. If something isn't working as advertised, please let us know."
  },
  "articles/nunit/intro.html": {
    "href": "articles/nunit/intro.html",
    "title": "NUnit Documentation | NUnit Docs",
    "summary": "NUnit Documentation This documentation covers NUnit 3.0 and higher. Where applicable, we have marked sections with the version in which a feature first appeared. If you are new to NUnit, we suggest you begin by reading the Getting Started section of this site. Those who have used earlier releases may want to begin with the Upgrading section. See the Release Notes for more information on each release."
  },
  "articles/nunit/license.html": {
    "href": "articles/nunit/license.html",
    "title": "NUnit License | NUnit Docs",
    "summary": "NUnit License Copyright (c) 2004-2021 Charlie Poole, Rob Prouse and Contributors. Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE."
  },
  "articles/nunit/release-notes/Nunit4.0-MigrationGuide.html": {
    "href": "articles/nunit/release-notes/Nunit4.0-MigrationGuide.html",
    "title": "Migration Guidance | NUnit Docs",
    "summary": "Migration Guidance Compatibility Ensure you use a compatible runner for NUnit Version 4. Runner Minimum Version Comments NUnit3TestAdapter 4.5.0 Used by Visual Studio and dotnet test NUnit.Console 3.15.5 Note: The 3.16.X series don't work with NUnit version 4 Rider/Resharper 2023.3 Dec 5, 2023, is in EAP, due to release RSN 3.x -> 4.x NUnit 4.0 has a few breaking changes making it neither binary nor source code compatible with NUnit 3.14.0 Change to Classic Asserts Removal of Assert.That overloads with format specification and params. Classic Assert migration There are different ways to migrate these to NUnit 4.0 Convert Classic Assert to the Constraint model Update source code to new namespace and class name Using global using aliases In own source file In project file or Directory.Build.props In the sections below we use the following simple test as an example: public class Tests { [Test] public void TestSomeCalculation() { int actual = SomeCalculation(); Assert.AreEqual(42, actual, \"Expected {0} to be 42\", actual); StringAssert.StartsWith(\"42\", actualText, \"Expected '{0}' to start with '42'\", actualText); } private static int SomeCalculation() => 42; } Convert Classic Assert to Constraint Model Although the code can be converted manually, that is a lot of work. Luckily, the NUnit.Analyzer has had rules and associated code fixes for a while now. Version 3.10.0 knows about the 2nd non-backward compatible change and will convert the format specification and params into a FormattableString. Note Caveat: The analyzers only run when the code compiles, so execute and act on the analyzer before upgrading nunit to version 4.0.0! In our example code, the analyzer will flag the Assert.AreEqual as shown below: Running the associated Transform to constraint model code fix in Visual Studio will convert the code into: public class Tests { [Test] public void TestSomeCalculation() { int actual = SomeCalculation(); Assert.That(actual, Is.EqualTo(42), $\"Expected {actual} to be 42\"); } private static int SomeCalculation() => 42; } The analyzer code fix supports Batch Fixing: This allows changing all corresponding Assert usages for a document, project or a complete solution. There are many classic asserts and most of these come with a separate code analyzer rule and code fix. Although it allows full configuration to what classic asserts to keep or convert, it means that a developer has to repeat this process multiple times, once for each assert method. NUnit.Analyzer also has code fixers for CollectionAssert and StringAssert. string actualText = actual.ToString(); StringAssert.StartsWith(\"42\", actualText, \"Expected '{0}' to start with '42'\", actualText); Will be converted into: string actualText = actual.ToString(); Assert.That(actualText, Does.StartWith(\"42\"), $\"Expected '{actualText}' to start with '42'\"); There are no code fixers for FileAssert and DirectoryAssert. They could be added, but we don't expect these to be used too much. Should you be migrating a larger number of repositories to the constraint model the following script can be used as a good starting point: #!/bin/bash # This script automates the process of adding and configuring the NUnit.Analyzers package to .NET projects. # It performs the following steps: # - Checks if a directory is provided as an argument, and defaults to the current directory if not. # - Changes to the target directory to ensure all operations are performed within the correct git repository. # - Creates a dedicated branch that will contain the changes # - Searches for Directory.Packages.props in the target directory and its subdirectories. # - Fails the script when multiple are found # - If one is found it adds the NUnit.Analyzer there and makes sure the modifications to the project files follow the nomenclature # for centralized packages # - Searches for all .csproj files in the target directory. # - For each .csproj file: # - Checks if NUnit.Analyzers is already referenced, skipping if it is. # - Adds NUnit.Analyzers after the NUnit reference if not already present. # - Skips the .csproj file if no NUnit reference is found. # - Stages the modified .csproj and/or Directory.Packages.props files for commit and prompts the user to review before committing. # - Restores NuGet packages for all .sln files found in the directory. # - Applies each diagnostic rule sequantially to the projects in parallel: # - Checks for NUnit.Analyzers reference, and creates or modifies .editor_config for each .csproj file. # - Applies the formatting using dotnet format for each diagnostic. # - Discards or deletes changes to .editor_config. # - Commits the changes for each diagnostic. # - Returns to the original directory after completing the operations. # # Usage: # chmod +x nunit-analyzer-automation.sh # ./nunit-analyzer-automation.sh target/directory/path # # Requirements: # - sed # - git # - gh # # Installation Requirements MacOS: # - brew install gnused # - Make it the default sed as outlined in the hints in the installation step of the brew package or replaced \"sed\" with \"gsed\" in the script in case you don't want to override the default sed of MacOS # - brew install gh # - gh auth login # The gh client needs to be authenticated # - gh auth refresh -s project # The gh client requires project scope # Check if a directory is provided as an argument, if not, use the current directory TARGET_DIR=\"${1:-.}\" PACKAGE_NAME=\"NUnit.Analyzers\" PACKAGE_VERSION=\"4.3.0\" # Replace with the desired version BRANCH_NAME=\"nunit-assertions-migration\" PROJECT_ID=\"XXX\" ORG=\"ZZZ\" # Define the XML snippet to insert INSERT_SNIPPET_CSPROJ=\" <PackageReference Include=\\\"$PACKAGE_NAME\\\" Version=\\\"$PACKAGE_VERSION\\\" />\" INSERT_SNIPPET_CSPROJ_PROPS=\" <PackageReference Include=\\\"$PACKAGE_NAME\\\" />\" INSERT_SNIPPET_PROPS=\" <PackageVersion Include=\\\"$PACKAGE_NAME\\\" Version=\\\"$PACKAGE_VERSION\\\" />\" # Change to the TARGET_DIR to ensure all commands are executed in the context of its git repository pushd \"$TARGET_DIR\" || { echo \"Failed to change directory to $TARGET_DIR\"; exit 1; } git checkout -b $BRANCH_NAME # Find all Directory.Packages.props files in the target directory and its subdirectories prop_files=($(find . -name \"Directory.Packages.props\")) prop_file= # Check if there are multiple Directory.Packages.props files if [ ${#prop_files[@]} -gt 1 ]; then echo \"Error: Multiple Directory.Packages.props files found. The script cannot proceed.\" exit 1 elif [ ${#prop_files[@]} -eq 1 ]; then prop_file=\"${prop_files[0]}\" echo \"Found Directory.Packages.props: $prop_file\" # Check if the project already has NUnit.Analyzers if grep -qi \"<PackageVersion Include=\\\"$PACKAGE_NAME\\\"\" \"$prop_file\"; then echo \"Skipping $prop_file - $PACKAGE_NAME already present\" else echo \"Adding $PACKAGE_NAME to $prop_file\" # Insert the PackageReference after the NUnit reference to preserve the item groups that got added sed -i \"/<PackageVersion Include=\\\"NUnit\\\"/Ia\\\\ $INSERT_SNIPPET_PROPS\" \"$prop_file\" INSERT_SNIPPET_CSPROJ=$INSERT_SNIPPET_CSPROJ_PROPS fi else echo \"No Directory.Packages.props found\" fi # Find all .csproj files in the target directory find . -name \"*.csproj\" | while read -r csproj; do # Check if the project already has NUnit.Analyzers if grep -qi \"<PackageReference Include=\\\"$PACKAGE_NAME\\\"\" \"$csproj\"; then echo \"Skipping $csproj - $PACKAGE_NAME already present\" # Check if the project references NUnit and add NUnit.Analyzers if not already present elif grep -qi '<PackageReference Include=\"NUnit\"' \"$csproj\"; then echo \"Adding $PACKAGE_NAME to $csproj\" # Insert the PackageReference after the NUnit reference to preserve the item groups that got added sed -i \"/<PackageReference Include=\\\"NUnit\\\"/Ia\\\\ $INSERT_SNIPPET_CSPROJ\" \"$csproj\" else echo \"Skipping $csproj - No NUnit reference found\" fi done # Stage .csproj files for commit git add \"*.csproj\" if [ -f \"$prop_file\" ]; then git add \"$prop_file\" fi echo \"Verify the changes and do the necessary resets with git. For example test projects that are shipped should either not have the analzyer or the the PrivateAssets set to All. Hit any key to commit the staged files\" read -sn1 git commit -m \"Add Nunit.Analyzer to test projects\" # Restore NuGet packages for all .sln files find . -name \"*.sln\" | while read -r solution; do echo \"Restoring nuget packages in $solution\" dotnet restore $solution done nunit_analyzer_diagnostics=($(seq -f \"NUnit%g\" 2001 2050)) # For manual purposes use the explicitely declared diagnostic IDs # nunit_analyzer_diagnostics=( # \"NUnit2001\" \"NUnit2002\" \"NUnit2003\" \"NUnit2004\" \"NUnit2005\" # \"NUnit2006\" \"NUnit2007\" \"NUnit2008\" \"NUnit2009\" \"NUnit2010\" # \"NUnit2011\" \"NUnit2012\" \"NUnit2013\" \"NUnit2014\" \"NUnit2015\" # \"NUnit2016\" \"NUnit2017\" \"NUnit2018\" \"NUnit2019\" \"NUnit2020\" # \"NUnit2021\" \"NUnit2022\" \"NUnit2023\" \"NUnit2024\" \"NUnit2025\" # \"NUnit2026\" \"NUnit2027\" \"NUnit2028\" \"NUnit2029\" \"NUnit2030\" # \"NUnit2031\" \"NUnit2032\" \"NUnit2033\" \"NUnit2034\" \"NUnit2035\" # \"NUnit2036\" \"NUnit2037\" \"NUnit2038\" \"NUnit2039\" \"NUnit2040\" # \"NUnit2041\" \"NUnit2042\" \"NUnit2043\" \"NUnit2044\" \"NUnit2045\" # \"NUnit2046\" \"NUnit2047\" \"NUnit2048\" \"NUnit2049\" \"NUnit2050\" # ) for diagnostic in ${nunit_analyzer_diagnostics[@]}; do echo \"Applying rule $diagnostic\" formatting_jobs=() while IFS= read -r csproj; do ( # Check if the project already has NUnit.Analyzers if grep -q \"<PackageReference Include=\\\"$PACKAGE_NAME\\\"\" \"$csproj\"; then csproj_dir=$(dirname \"$csproj\") editor_config=\"$csproj_dir/.editorconfig\" if [ ! -f \"$editor_config\" ]; then echo \"Creating .editor_config in $editor_config\" touch \"$editor_config\" echo \"[*.cs]\" >> \"$editor_config\" fi echo \"Appending to $editor_config\" echo -e \"\\ndotnet_diagnostic.$diagnostic.severity = warning\" >> \"$editor_config\" echo \"Formatting $csproj with diagnostic $diagnostic\" dotnet format analyzers $csproj --diagnostics $diagnostic --severity info --no-restore --verbosity diagnostic else echo \"Skipping $csproj - No NUnit.Analyzer reference found\" fi ) & formatting_jobs+=($!) done < <(find . -name \"*.csproj\") echo \"Waiting for formatting jobs to complete\" for formatting_job in \"${formatting_jobs[@]}\"; do wait $formatting_job done echo \"Committing formatting changes\" git add \"*.cs\" git commit -m \"Autoformat of test projects for $diagnostic\" echo \"Discarding all unrelated changes\" git reset --hard git clean -f formatting_jobs=() done echo \"Pushing the branch upstream\" git push --set-upstream origin $BRANCH_NAME echo \"Creating the pull request\" pull_request_url=$(gh pr create --title \"Migrate NUnit assertions to the constraint model in preparation of the NUnit 4 upgrade\" --body \" This PR contains all changes related to assertion model according to the [constraint assertion model](https://docs.nunit.org/articles/nunit/writing-tests/assertions/assertion-models/constraint.html). Using a script, we apply all [assertion rules](https://docs.nunit.org/articles/nunit-analyzers/NUnit-Analyzers.html#assertion-rules-nunit2001---) provided by the NUnit.Analyzers package. In addition, some manual interventions are done when applicable. ## Plan of action - [ ] ⚠️ Build the solution and resolve any remaining errors or warnings - [ ] ✅ Review the assertions commit by commit - [ ] \uD83D\uDC40 Invite another pair of eyes to re-review \" --assignee \"@me\" --head $BRANCH_NAME) gh project item-add $PROJECT_ID --owner $ORG --url $pull_request_url gh pr merge $pull_request_url --auto --squash popd The script is provided as is and might require further tweaks to the specific use cases. It was written assuming a few structural conventions that might not apply to every use case. Updating from Classic Asserts in NUnit 4.x If you want to keep the Classic Asserts and not convert them to the constraint model -- but do want to use the new NUnit 4.x naming -- you'll need to update the code manually. The NUnit.Analyzer can't help here as the code either doesn't compile before the change or after, depending on what version of nunit you are compiling with. If you only use classic asserts, you can get away with a couple of global substitutes: Convert using NUnit.Framework; into both using NUnit.Framework;using NUnit.Framework.Legacy; Depending on your editor you can automatically insert a newline between the two using statements. Convert Assert into ClassicAssert. This global substitute will also convert those asserts that have not changed. You can narrow the scope of this substitute to do only the asserts that need converting, but there are quite a lot. Convert Assert.AreEqual into ClassicAssert.AreEqual. Convert Assert.True into ClassicAssert.True. Similar for IsTrue, False, IsFalse, Greater, Less, ... Depending on what is less work, alternatively you can reverse the substitution of those that shouldn't have been changed: Convert ClassicAssert.That into Assert.That. Convert ClassicAssert.Fail into Assert.Fail. Convert ClassicAssert.Throws into Assert.Throws. Etc. Or if you use Visual Studio, it will raise an IDE0002 with a code fix that can convert all of those that are not considered classic back to assert in one swoop: Use global using aliases If you use SDK 6.0 or newer that supports C#10, you can upgrade without modifying any actual tests by adding the following aliases to GlobalUsings.cs global using Assert = NUnit.Framework.Legacy.ClassicAssert; global using CollectionAssert = NUnit.Framework.Legacy.CollectionAssert; global using StringAssert = NUnit.Framework.Legacy.StringAssert; global using DirectoryAssert = NUnit.Framework.Legacy.DirectoryAssert; global using FileAssert = NUnit.Framework.Legacy.FileAssert; Note that this doesn't mean you have to target .NET 6.0. This also works if targeting .NET Framework as it is purely done on the source code level. If you have to do this for multiple projects in a repository, this is not handy. It seems somebody else thought of that and it is now possible to add global usings in a Directory.Build.props file which will be used by all projects in a repository: <ItemGroup> <Using Include=\"NUnit.Framework.Legacy.ClassicAssert\" Alias=\"Assert\" /> <Using Include=\"NUnit.Framework.Legacy.CollectionAssert\" Alias=\"CollectionAssert\" /> <Using Include=\"NUnit.Framework.Legacy.StringAssert\" Alias=\"StringAssert\" /> <Using Include=\"NUnit.Framework.Legacy.DirectoryAssert\" Alias=\"DirectoryAssert\" /> <Using Include=\"NUnit.Framework.Legacy.FileAssert\" Alias=\"FileAssert\" /> </ItemGroup> The build process now automatically creates a ${Project}.GlobalUsings.g.cs file for each project with a contents similar to the one shown above. Assert.That with format specification and params overload conversion These overloads were removed to allow for better messages in case of failure. See The \"Towards NUnit 4\" article for more information. NUnit 4.x has been optimized such that these formattable strings only get formatted in case the test is failing. int actual = SomeCalculation(); Assert.That(actual, Is.EqualTo(42), \"Expected {0} to be 42\", actual); Needs to be converted into: int actual = SomeCalculation(); Assert.That(actual, Is.EqualTo(42), $\"Expected {actual} to be 42\"); To make this transition easier, the Nunit.Analyzer has been updated with a new rule and corresponding code-fix: Using NUnit Extension libraries If your code doesn't call nunit asserts directly but uses a local NUnitExtension library or a 3rd party one then that dependency needs to be upgraded before you can upgrade your own code. If the library is not NUnit 4.0 compliant, you will get error messages like: System.MissingMethodException : Method not found: 'Void NUnit.Framework.Assert.That(!!0, NUnit.Framework.Constraints.IResolveConstraint, System.String, System.Object[])'."
  },
  "articles/nunit/release-notes/Pre-3.5-Release-Notes.html": {
    "href": "articles/nunit/release-notes/Pre-3.5-Release-Notes.html",
    "title": "Pre 3.5 Release Notes | NUnit Docs",
    "summary": "Pre 3.5 Release Notes Note Combined Release Notes for the NUnit framework, console and engine, up to version 3.5. For later releases, see: Framework Release Notes Console Release Notes NUnit 3.5 - October 3, 2016 This is the last version of NUnit where the framework, console runner, engine and extensions are being released together. From this point forward, the NUnit Framework will be released on its own schedule that is not bound to that of any other NUnit project and version numbers may diverge over time. This is also the first release where the NUnit Framework will not be included in the installer. Only the console runner, engine and extensions will be available as an MSI installer. We recommend that you use the NUnit NuGet packages for the framework, but a ZIP file with the binaries will also be available. Framework Added Assert.Zero and Assert.NotZero methods You can now pass a Func<string> to Asserts to lazily evaluate exception messages Added the ability to Assert on the order of multiple properties in a collection Tests with a Timeout will no longer timeout while you are debugging Issues Resolved 144 Pass a Func<string> to lazily evaluate an exception message 995 Enable Warning as Error 1106 Move various Assembly Info files under Properties for CF 1334 Add Assert.Zero and Assert.NotZero 1479 Don't enforce [Timeout] when debugger is attached 1540 Remove old .NET Core Projects 1553 Allow ordering tests to be done in multiple properties 1575 Escaping control chars in custom message 1596 Eliminate code sharing across projects to be split 1598 Split framework and console/engine into separate projects 1610 Refactor dependencies in build.cake 1615 AppVeyor error in TestCF 1621 Remove console and command-line option files from common 1640 When submitting only part of optional parameters, all are overridden by defaults 1641 Create OSX CI Build on Travis 1663 Find way to hide NUnit.Compatibility.Path from intellisense 1681 NUnitLite under .net core doesn't support TeamCity output 1683 Existence of SerializableAttribute in .NET Core 1693 2 unit tests fail due to localization 1716 Move installer to new repository 1717 Change suffix for master builds 1723 Remove Cake target TestAll 1739 Create separate copies of MockAssembly for framework, engine and extensions 1751 Serializable attribute exists in both System.Runtime.Serialization.Formatters and nunit.framework 1775 Support NUnit assertions in partial trust code. 1800 Remove Console/Engine projects from nunit.linux.sln 1805 Error message \"arguments provided for method not taking any\" seems incomplete / doesn't make much sense 1815 Prevent NullReferenceException in SubPathConstraint NUnit 3.4.1 - June 30, 2016 Console Runner A new option, --list-extensions, will display all the engine extensions that have been installed by the engine. Issues Resolved 1623 NUnit 3.4 is not integrated with TeamCity 1626 NUnit.ConsoleRunner is not picking up NUnit.Extension.NUnitV2ResultWriter 1628 Agent's process stays in memory when it was failed to unload AppDomain 1635 Console option to list loaded extensions NUnit 3.4 - June 25, 2016 Framework Improvements in comparing equality using IEquatable<T> Test case names will only be truncated if the runner requests it or it is overridden on the command line with the --test-name-format option The .NET 2.0 version of the framework now includes LINQ. If your tests target .NET 2.0, you can now use LINQ queries in your tests Engine The TeamCity event listener has been separated out into an engine extension Fixed numerous issues around thread safety of parallel test runs Additional fixes to reduce memory usage Fixes for Mono 4.4 Console Runner There is a new --params command line option that allows you to pass parameters to your tests which can be retrieved using TestContext.Parameters Another new command line option --loaduserprofile causes the User Profile to be loaded into the NUnit Agent process. Issues Resolved 329 (CLI) Runner does not report AppDomain unloading timeout 720 Need a way to get test-specific command-line arguments at runtime 1010 Need to control engine use of extensions 1139 NUnit3 console doesn't show test output continuously 1225 The --teamcity option should really be an extension 1241 Make TestDirectory accessible when TestCaseSource attributes are evaluated 1366 Classname for inherited test is not correct 1371 Support dotnet test in .NET CLI and .NET Core 1379 Console returns 0 for invalid fixtures 1422 Include TestListWithEmptyLine.tst in ZIP Package 1423 SingleThreaded attribute should raise an error if a thread is required 1425 Lazy initialization of OutWriter in TestResult is not thread safe 1427 Engine extensions load old packages 1430 TestObjects are retained for lifetime of test run, causing high memory usage 1432 NUnit hangs when reporting to TeamCity 1434 TestResult class needs to be thread-safe 1435 Parallel queue creation needs to be thread-safe 1436 CurrentFramework and Current Platform need to be more thread-safe 1439 EqualConstraint does Not use Equals Override on the Expected Object 1441 Add Linq for use internally in .NET 2.0 code 1446 TestOrderAttributeTests is not public 1450 SilverLight detection doesn't work when building on 32-bit OS 1457 Set the 2.0 build to ignore missing xml documentation 1463 Should TestResult.AssertCount have a public setter? 1464 TNode.EscapeInvalidXmlCharacters recreates Regex continually 1470 Make EventQueue and associated classes lock-less and thread safe 1476 Examine need for \"synchronous\" events in event queue 1481 TestCase with generic return type causes NullReferenceException 1483 Remoting exceptions during test execution 1484 Comparing Equality using IEquatable<T> Should Use Most Specific Method 1493 NUnit 2 test results report ParameterizedMethod but should be ParameterizedTest 1507 NullReferenceException when null arguments are used in TestFixtureAttribute 1513 Add new TeamCity extension to packages 1518 NUnit does not send the \"testStarted\" TeamCity service message when exception was thrown from SetUp/OneTimeSetUp 1520 Detect Portable, SilverLight and Compact and give error message 1528 Use of Sleep(0) in NUnit 1543 Blank name attribute in nunit2-formatted XML result file test-run element 1547 Create separate assembly for System.Linq compatibility classes 1548 Invalid Exception when engine is in a 32-bit process 1549 Changing default behavior for generating test case names 1551 Path in default .addins file for ConsoleRunner package may not exist 1555 EndsWith calls in Constraint constructor can cause major perf issues 1560 Engine writes setting file unnecessarily 1573 Move NUnit.Portable.Agent to new Repo 1579 NUnit v3 dangerously overrides COMPLUS_Version environment variable 1582 Mono 4.4.0 Causes Test Failures 1593 NUnit Console Runner 3.2.1 and Mono 4.4 throws RemotingException 1597 Move Portable agent to its own repository 1605 TeamCity package has no pre-release suffix 1607 nunit.nuget.addins discovery pattern is wrong then restored through project.json 1617 Load user profile on test runners NUnit 3.2.1 - April 19, 2016 Framework The output and error files are now thread safe when running tests in parallel Added a .NET 3.5 build of the framework preventing conflicts with the compatibility classes in the 2.0 framework Added a SingleThreadedAttribute to be added to a TestFixture to indicate all child tests should run on the same thread Engine Unless required, run all tests within a fixture on the same thread Added an EventListener extension point Reduced memory usage Console Runner No longer probes for newer versions of the engine, instead uses the engine that is included with the console Issues Resolved 1413 Switch console to use a local engine 1410 Make OutFile and ErrFile stream writers synchronized 1406 TextCapture is not thread-safe but is used to intercept calls that are expected to be thread-safe 1405 ITestRunner.StopRun throws exception of type 'System.MissingMethodException' 1399 Fixed NullReference issue introduced by the fix for #681 1390 --testlist with file with blank first line causes IndexOutOfRangeException 1386 Bug when using Assert.Equals() with types that explicitly implement IEquatable<T> 1383 Skip SilverLight build if SDK not installed 1359 Compilation error in NUnitPortableDriverTests.cs 1352 Tests losing data setup on thread 1349 Collision on System.Func from nunit.framework with System.Core in .Net 3.5 (CS0433) 1338 BUILDING.txt is outdated 1333 Single Thread per Worker 1329 Unable to build without Compact Framework 1327 TestCaseSource in NUnit 3 converts an argument declared as String[] to String 1318 NUnit console runner fails with error code -100 1317 Getting CF framework unit tests running on CI build 1302 Create EventListener ExtensionPoint for the Engine 1266 SetCultureAttribute does not work if set on assembly level 1247 Potential memory issue 1231 Build may silently fail some tests 1208 Apartment on assembly level broken 1161 NUnit3-Console should disallow the combination of --inprocess and --x86, giving an error message 1141 Explicit Tests get run when using --where with some filters 773 Upgrade Travis CI from Legacy Infrastructure 640 Keep CF Build (and other future builds) in Sync 332 Add CF to the AppVeyor CI build NUnit 3.2 - March 5, 2016 Framework Added an Order attribute that defines the order in which tests are run Added Assert.ThrowsAsync for testing if async methods throw an exception You can now compare unlike collections using Is.EquivalentTo().Using(...) Added the ability to add custom message formatters to MsgUtils TestCaseSourceAttribute now optionally takes an array of parameters that can be passed to the source method Added Is.Zero and Is.Not.Zero to the fluent syntax as a shorter option for Is.EqualTo(0) and Is.Not.EqualTo(0) Engine Engine extensions can be installed via NuGet packages Issues Resolved 170 Test Order Attribute 300 Create an NUnit Visual Studio Template 464 Async delegate assertions 532 Batch runner for SilverLight tests 533 Separate NUnitLite runner and auto-runner 681 NUnit agent cannot resolve test dependency assemblies when mixed mode initialization runs in the default AppDomain 793 Replace CoreEngine by use of Extensions 907 Console report tests are too fragile 922 Wrap Console in NUnitLite 930 Switch from MSBuild based build system to Cake 981 Define NUnit Versioning for post-3.0 Development 1004 Poor formatting of results for Assert.AreEqual(DateTimeOffset, DateTimeOffset) 1018 ArgumentException when 2.x version of NUnit Framework is in the bin directory 1022 Support Comparing Unlike Collections using Is.EquivalentTo().Using(...) 1044 Re-order Test Summary Errors/Failures 1066 ApartmentAttribute and TestCaseAttribute(s) do not work together 1103 Can't use TestCaseData from base class 1109 NullReferenceException when using inherited property for ValueSource 1113 Console runner and xml output consistency 1117 Fix misbehavior of Throws.Exception with non-void returning functions 1120 NUnitProject should parse .nunit project files containing Xml Declarations 1121 Usage of field set to null as value source leads to somewhat cryptic error 1122 Region may be disposed before test delegate is executed 1133 Provide a way to install extensions as nuget packages 1136 Don't allow V2 framework to update in V2 driver tests 1171 A bug when using Assert.That() with Is.Not.Empty 1185 Engine finds .NET 4.0 Client Profile twice 1187 ITestAssemblyRunner.StopRun as implemented by NUnitTestAssemblyRunner 1195 name attribute in test-suite and test-results element of output xml is different to nunit 2.6.4 using nunit2-format 1196 Custom value formatter for v3 via MsgUtils 1210 Available runtimes issues 1230 Add ability for testcasedatasource to have parameters passed to methods 1233 Add TestAssemblyRunner tests to both portable and SilverLight builds 1234 Have default NUnitLite Runner Program.cs return exit code 1236 Make AppVeyor NuGet feed more useable 1246 Introduce Is.Zero syntax to test for zero 1252 Exception thrown when any assembly is not found 1261 TypeHelper.GetDisplayName generates the wrong name for generic types with nested classes 1278 Fix optional parameters in TestCaseAttribute 1282 TestCase using Params Behaves Oddly 1283 Engine should expose available frameworks. 1286 value of the time attribute in nunit2 outputs depends on the machine culture 1297 NUnit.Engine nuget package improvements 1301 Assert.AreNotSame evaluates ToString unnecessarily NUnit 3.0.1 (3.0.5813) - December 1, 2015 Console Runner The NUnit.Runners NuGet package was updated to become a meta-package that pulls in the NUnit.Console package Reinstated the --pause command line option that will display a message box allowing you to attach a debugger if the --debug option does not work Issues Resolved 994 Add max number of Agents to the NUnit project file 1014 Ensure NUnit API assembly updates with MSI installs 1024 Added --pause flag to console runner 1030 Update NUnit.Runners package to 3.0 1033 \"No arguments were provided\" with Theory and Values combination 1035 Check null arguments 1037 Async tests not working on Windows 10 Universal 1041 NUnit2XmlResult Writer is reporting Success when test fails 1042 NUnit2 reports on 3.0 is different than 2.6.4 1046 FloatingPointNumerics.AreAlmostEqualUlps throws OverflowException 1049 Cannot select Generic tests from command line 1050 Do not expose System.Runtime.CompilerServices.ExtensionAttribute to public 1054 Create nuget feeds for CI builds on AppVeyor 1055 nunit3 console runner --where option does not return error on invalid selection string 1060 Remove \"Version 3\" from NUnit Nuget Package 1061 Nunit30Settings.xml becomes corrupted 1062 Console.WriteLine statements in \"OneTimeSetUp\" and \"OneTimeTearDown\" annotated methods are not directed to the console when using nunit3-console.exe runner 1063 Error in Random Test NUnit 3.0.0 Final Release (3.0.5797) - November 15, 2015 Issues Resolved 635 Mono 4.0 Support NUnit 3.0.0 Release Candidate 3 (3.0.5795) - November 13, 2015 Engine The engine now only sets the config file for project.nunit to project.config if project.config exists. Otherwise, each assembly uses its own config, provided it is run in a separate AppDomain by itself. Note It is not possible for multiple assemblies in the same AppDomain to use different configs. This is not an NUnit limitation, it's just how configs work! Issues Resolved 856 Extensions support for third party runners in NUnit 3.0 1003 Delete TeamCityEventHandler as it is not used 1015 Specifying .nunit project and --framework on command line causes crash 1017 Remove Assert.Multiple from framework NUnit 3.0.0 Release Candidate 2 (3.0.5790) - November 8, 2015 Engine The IDriverFactory extensibility interface has been modified. Issues Resolved 970 Define PARALLEL in CF build of NUnitLite 978 It should be possible to determine version of NUnit using nunit console tool 983 Inconsistent return codes depending on ProcessModel 986 Update docs for parallel execution 988 Don't run portable tests from NUnit Console 990 V2 driver is passing invalid filter elements to NUnit 991 Mono.Options should not be exposed to public directly 993 Give error message when a regex filter is used with NUnit V2 997 Add missing XML Documentation 1008 NUnitLite namespace not updated in the NuGet Packages NUnit 3.0.0 Release Candidate (3.0.5783) - November 1, 2015 Framework The portable build now supports ASP.NET 5 and the new Core CLR. Note The nunit3-console runner cannot run tests that reference the portable build. You may run such tests using NUnitLite or a platform-specific runner. TestCaseAttribute and TestCaseData now allow modifying the test name without replacing it entirely. The SilverLight packages for are now separate downloads. NUnitLite The NUnitLite runner now produces the same output display and XML results as the console runner. Engine The format of the XML result file has been finalized and documented. Console Runner The console runner program is now called nunit3-console. Console runner output has been modified so that the summary comes at the end, to reduce the need for scrolling. Issues Resolved 59 Length of generated test names should be limited 68 Customization of test case name generation 404 Split tests between SilverLight.runner and nunit.framework 575 Add support for ASP.NET 5 and the new Core CLR 783 Package separately for SilverLight 833 Intermittent failure of WorkItemQueueTests.StopQueue_WithWorkers 859 NUnit-Console output - move Test Run Summary to end 867 Remove Warnings from Ignored tests 868 Review skipped tests 887 Move environment and settings elements to the assembly suite in the result file 899 Colors for ColorConsole on grey background are too light 904 InternalPreserveStackTrace is not supported on all Portable platforms 914 Unclear error message from console runner when assembly has no tests 916 Console runner dies when test agent dies 918 Console runner --where parameter is case sensitive 920 Remove addins\\nunit.engine.api.dll from NuGet package 929 Rename nunit-console.exe 931 Remove beta warnings from NuGet packages 936 Explicit skipped tests not displayed 939 Installer complains about .NET even if already installed 940 Confirm or modify list of packages for release 947 Breaking API change in ValueSourceAttribute 949 Update copyright in NUnit Console 954 NUnitLite XML output is not consistent with the engine's 955 NUnitLite does not display the where clause 959 Restore filter options for NUnitLite portable build 960 Intermittent failure of CategoryFilterTests 967 Run Settings Report is not being displayed. NUnit 3.0.0 Beta 5 (3.0.5767) - October 16, 2015 Framework Parameterized test cases now support nullable arguments. The NUnit framework may now be built for the .NET Core framework. Note that this is only available through building the source code. A binary will be available in the next release. Engine The engine now runs multiple test assemblies in parallel by default The output XML now includes more information about the test run, including the text of the command used, any engine settings and the filter used to select tests. Extensions may now specify data in an identifying attribute, for use by the engine in deciding whether to load that extension. Console Runner The console now displays all settings used by the engine to run tests as well as the filter used to select tests. The console runner accepts a new option --maxagents. If multiple assemblies are run in separate processes, this value may be used to limit the number that are executed simultaneously in parallel. The console runner no longer accepts the --include and --exclude options. Instead, the new --where option provides a more general way to express which tests will be executed, such as --where \"cat==Fast && Priority==High\". See the docs for details of the syntax. The new --debug option causes NUnit to break in the debugger immediately before tests are run. This simplifies debugging, especially when the test is run in a separate process. Issues Resolved 41 Check for zeroes in Assert messages 254 Finalize XML format for test results 275 NUnitEqualityComparer fails to compare IEquatable<T> where second object is derived from T 304 Run test Assemblies in parallel 374 New syntax for selecting tests to be run 515 OSPlatform.IsMacOSX doesn't work 573 nunit-console hangs on Mac OS X after all tests have run 669 TeamCity service message should have assembly name as a part of test name. 689 The TeamCity service message \"testFinished\" should have an integer value in the \"duration\" attribute 713 Include command information in XML 719 We have no way to configure tests for several assemblies using NUnit project file and the common installation from msi file 735 Workers number in xml report file cannot be found 784 Build Portable Framework on Linux 790 Allow Extensions to provide data through an attribute 794 Make it easier to debug tests as well as NUnit itself 801 NUnit calls Dispose multiple times 814 Support nullable types with TestCase 818 Possible error in Merge Pull Request #797 821 Wrapped method results in loss of result information 822 Test for Debugger in NUnitTestAssemblyRunner probably should not be in CF build 824 Remove unused System.Reflection using statements 826 Randomizer uniqueness tests fail randomly! 828 Merge pull request #827 (issue 826) 830 Add ability to report test results synchronously to test runners 837 Enumerators not disposed when comparing IEnumerables 840 Add missing copyright notices 844 Pull Request #835 (Issue #814) does not build in CF 847 Add new --process:inprocess and --inprocess options 850 Test runner fails if test name contains invalid xml characters 851 Exclude' console option is not working in NUnit Lite 853 Cannot run NUnit Console from another directory 860 Use CDATA section for message, stack-trace and output elements of XML 863 Eliminate core engine 865 Intermittent failures of StopWatchTests 869 Tests that use directory separator char to determine platform misreport Linux on MaxOSX 870 NUnit Console Runtime Environment misreports on MacOSX 874 Add .NET Core Framework 878 Cannot exclude MacOSX or XBox platforms when running on CF 892 Fixed test runner returning early when executing more than one test run. 894 Give nunit.engine and nunit.engine.api assemblies strong names 896 NUnit 3.0 console runner not placing test result xml in --work directory NUnit 3.0.0 Beta 4 (3.0.5715) - August 25, 2015 Framework A new RetryAttribute allows retrying of failing tests. New SupersetConstraint and Is.SupersetOf syntax complement SubsetConstraint. Tests skipped due to ExplicitAttribute are now reported as skipped. Engine We now use Cecil to examine assemblies prior to loading them. Extensions are no longer based on Mono.Addins but use our own extension framework. Issues Resolved 125 3rd-party dependencies should be downloaded on demand 283 What should we do when a user extension does something bad? 585 RetryAttribute 642 Restructure MSBuild script 649 Change how we zip packages 654 ReflectionOnlyLoad and ReflectionOnlyLoadFrom 664 Invalid \"id\" attribute in the report for case \"test started\" 685 In the some cases when tests cannot be started NUnit returns exit code \"0\" 728 Missing Assert.That overload 741 Explicit Tests get run when using --exclude 746 Framework should send events for all tests 747 NUnit should apply attributes even if test is non-runnable 749 Review Use of Mono.Addins for Engine Extensibility 750 Include Explicit Tests in Test Results 753 Feature request: Is.SupersetOf() assertion constraint 755 TimeOut attribute doesn't work with TestCaseSource Attribute 757 Implement some way to wait for execution to complete in ITestEngineRunner 760 Packaging targets do not run on Linux 766 Added overloads for True()/False() accepting booleans 778 Build and build.cmd scripts invoke nuget.exe improperly 780 TeamCity fix 782 No sources for 2.6.4 NUnit 3.0.0 Beta 3 (3.0.5674) - July 15, 2015 Framework The RangeAttribute has been extended to support more data types including uint, long and ulong Added platform support for Windows 10 and fixed issues with Windows 8 and 8.1 support Added async support to the portable version of NUnit Framework The named members of the TestCaseSource and ValueSource attributes must now be static. RandomAttribute has been extended to add support for new data types including uint, long, ulong, short, ushort, float, byte and sbyte TestContext.Random has also been extended to add support for new data types including uint, long, ulong, short, ushort, float, byte, sbyte and decimal Removed the dependency on Microsoft.Bcl.Async from the NUnit Framework assembly targeting .NET 4.0. If you want to write async tests in .NET 4.0, you will need to reference the NuGet package yourself. Added a new TestFixtureSource attribute which is the equivalent to TestCaseSource but provides for instantiation of fixtures. Significant improvements have been made in how NUnit deduces the type arguments of generic methods based on the arguments provided. Engine If the target framework is not specified, test assemblies that are compiled to target .NET 4.5 will no longer run in .NET 4.0 compatibility mode Console If the console is run without arguments, it will now display help Issues Resolved 47 Extensions to RangeAttribute 237 System.Uri .ctor works not properly under NUnit 244 NUnit should properly distinguish between .NET 4.0 and 4.5 310 Target framework not specified on the AppDomain when running against .Net 4.5 321 Rationalize how we count tests 472 Overflow exception and DivideByZero exception from the RangeAttribute 524 int and char do not compare correctly? 539 Truncation of string arguments 544 AsyncTestMethodTests for 4.5 Framework fails frequently on Travis CI 656 Unused parameter in Console.WriteLine found 670 Failing Tests in TeamCity Build 673 Ensure proper disposal of engine objects 674 Engine does not release test assemblies 679 Windows 10 Support 682 Add Async Support to Portable Framework 683 Make FrameworkController available in portable build 687 TestAgency does not launch agent process correctly if runtime type is not specified (i.e. v4.0) 692 PlatformAttribute_OperatingSystemBitNess fails when running in 32-bit process 693 Generic Test<T> Method cannot determine type arguments for fixture when passed as IEnumerable<T> 698 Require TestCaseSource and ValueSource named members to be static 703 TeamCity non-equal flowid for 'testStarted' and 'testFinished' messages 712 Extensions to RandomAttribute 715 Provide a data source attribute at TestFixture Level 718 RangeConstraint gives error with from and two args of differing types 723 Does nunit.nuspec require dependency on Microsoft.Bcl.Async? 724 Adds support for Nullable<bool> to Assert.IsTrue and Assert.IsFalse 734 Console without parameters doesn't show help NUnit 3.0.0 Beta 2 (3.0.5610) - May 12, 2015 Framework The Compact Framework version of the framework is now packaged separately and will be distributed as a ZIP file and as a NuGet package. The NUnit 2.x RepeatAttribute was added back into the framework. Added Throws.ArgumentNullException Added GetString methods to NUnit.Framework.Internal.RandomGenerator to create repeatable random strings for testing When checking the equality of DateTimeOffset, you can now use the WithSameOffset modifier Some classes intended for internal usage that were public for testing have now been made internal. Additional classes will be made internal for the final 3.0 release. Engine Added a core engine which is a non-extensible, minimal engine for use by devices and similar situations where reduced functionality is compensated for by reduced size and simplicity of usage. Issues Resolved 22 Add OSArchitecture Attribute to Environment node in result xml 24 Assert on Dictionary Content 48 Explicit seems to conflict with Ignore 168 Create NUnit 3.0 documentation 196 Compare DateTimeOffsets including the offset in the comparison 217 New icon for the 3.0 release 316 NUnitLite TextUI Runner 320 No Tests found: Using parameterized Fixture and TestCaseSource 360 Better exception message when using non-BCL class in property 454 Rare registry configurations may cause NUnit to fail 478 RepeatAttribute 481 Testing multiple assemblies in NUnitLite 538 Potential bug using TestContext in constructors 546 Enable Parallel in NUnitLite/CF (or more) builds 551 TextRunner not passing the NumWorkers option to the ITestAssemblyRunner 556 Executed tests should always return a non-zero duration 559 Fix text of NuGet packages 560 Fix PackageVersion property on wix install projects 562 Program.cs in NUnitLite NuGet package is incorrect 564 NUnitLite Nuget package is Beta 1a, Framework is Beta 1 565 NUnitLite Nuget package adds Program.cs to a VB Project 568 Isolate packaging from building 570 ThrowsConstraint failure message should include stack trace of actual exception 576 Throws.ArgumentNullException would be nice 577 Documentation on some members of Throws falsely claims that they return TargetInvocationException constraints 579 No documentation for recommended usage of TestCaseSourceAttribute 580 TeamCity Service Message Uses Incorrect Test Name with NUnit2Driver 582 Test Ids Are Not Unique 583 TeamCity service messages to support parallel test execution 584 Non-runnable assembly has incorrect ResultState 609 Add support for integration with TeamCity 611 Remove unused --teamcity option from CF build of NUnitLite 612 MaxTime doesn't work when used for TestCase 621 Core Engine 622 nunit-console fails when use --output 628 Modify IService interface and simplify ServiceContext 631 Separate packaging for the compact framework 646 ConfigurationManager.AppSettings Params Return Null under Beta 1 NUnit 3.0.0 Beta 1 (3.0.5562) - March 25, 2015 General There is now a master windows installer for the framework, engine and console runner. Framework We no longer create a separate framework build for .NET 3.5. The 2.0 and 3.5 builds were essentially the same, so the former should now be used under both runtimes. A new Constraint, DictionaryContainsKeyConstraint, may be used to test that a specified key is present in a dictionary. LevelOfParallelizationAttribute has been renamed to LevelOfParallelismAttribute. The SilverLight runner now displays output in color and includes any text output created by the tests. The class and method names of each test are included in the output xml where applicable. String arguments used in test case names are now truncated to 40 rather than 20 characters. Engine The engine API has now been finalized. It permits specifying a minimum version of the engine that a runner is able to use. The best installed version of the engine will be loaded. Third-party runners may override the selection process by including a copy of the engine in their installation directory and specifying that it must be used. The V2 framework driver now uses the event listener and test listener passed to it by the runner. This corrects several outstanding issues caused by events not being received and allows selecting V2 tests to be run from the command-line, in the same way that V3 tests are selected. Console The console now defaults to not using shadowcopy. There is a new option --shadowcopy to turn it on if needed. Issues Resolved 224 SilverLight Support 318 TestActionAttribute: Retrieving the TestFixture 428 Add ExpectedExceptionAttribute to C# samples 440 Automatic selection of Test Engine to use 450 Create master install that includes the framework, engine and console installs 477 Assert does not work with ArraySegment 482 nunit-console has multiple errors related to -framework option 483 Adds constraint for asserting that a dictionary contains a particular key 484 Missing file in NUnit.Console nuget package 485 Can't run v2 tests with nunit-console 3.0 487 NUnitLite can't load assemblies by their file name 488 Async setup and teardown still don't work 497 Framework installer should register the portable framework 504 Option --workers:0 is ignored 508 Travis builds with failure in engine tests show as successful 509 Under linux, not all mono profiles are listed as available 512 Drop the .NET 3.5 build 517 V2 FrameworkDriver does not make use of passed in TestEventListener 523 Provide an option to disable shadowcopy in NUnit v3 528 V2 FrameworkDriver does not make use of passed in TestFilter 530 Color display for SilverLight runner 531 Display text output from tests in SilverLight runner 534 Add classname and methodname to test result xml 541 Console help doesn't indicate defaults NUnit 3.0.0 Alpha 5 (3.0.5509) - January 30, 2015 General A Windows installer is now included in the release packages. Framework TestCaseAttribute now allows arguments with default values to be omitted. Additionally, it accepts IncludePlatform and ExcludePlatform properties to specify the platforms on which the test case should be run. TestFixture and TestCase attributes now enforce the requirement that a reason needs to be provided when ignoring a test. SetUp, TearDown, OneTimeSetUp and OneTimeTearDown methods may now be async. String arguments over 20 characters in length are truncated when used as part of a test name. Engine The engine is now extensible using Mono.Addins. In this release, extension points are provided for FrameworkDrivers, ProjectLoaders and OutputWriters. The following addins are bundled as a part of NUnit: A FrameworkDriver that allows running NUnit V2 tests under NUnit 3.0. ProjectLoaders for NUnit and Visual Studio projects. An OutputWriter that creates XML output in NUnit V2 format. DomainUsage now defaults to Multiple if not specified by the runner Console New options supported: --testlist provides a list of tests to run in a file --stoponerror indicates that the run should terminate when any test fails. Issues Resolved 20 TestCaseAttribute needs Platform property. 60 NUnit should support async setup, teardown, fixture setup and fixture teardown. 257 TestCaseAttribute should not require parameters with default values to be specified. 266 Pluggable framework drivers. 368 Create addin model. 369 Project loader addins 370 OutputWriter addins 403 Move ConsoleOptions.cs and Options.cs to Common and share... 419 Create Windows Installer for NUnit. 427 [TestFixture(Ignore=true)] should not be allowed. 437 Errors in tests under Linux due to hard-coded paths. 441 NUnit-Console should support --testlist option 442 Add --stoponerror option back to nunit-console. 456 Fix memory leak in RuntimeFramework. 459 Remove the Mixed Platforms build configuration. 468 Change default domain usage to multiple. 469 Truncate string arguments in test names in order to limit the length. NUnit 3.0.0 Alpha 4 (3.0.5476) - December 30, 2014 Framework ApartmentAttribute has been added, replacing STAAttribute and MTAAttribute. Unnecessary overloads of Assert.That and Assume.That have been removed. Multiple SetUpFixtures may be specified in a single namespace. The Pairwise strategy test case generation algorithm has been improved. Engine A driver is now included, which allows running NUnit 2.x tests under NUnit 3.0. The engine can now load and run tests specified in a number of project formats: NUnit (.nunit) Visual Studio C# projects (.csproj) Visual Studio F# projects (.vjsproj) Visual Studio Visual Basic projects (.vbproj) Visual Studio solutions (.sln) Legacy C++ and Visual JScript projects (.csproj and .vjsproj) are also supported Support for the current C++ format (.csxproj) is not yet available Creation of output files like TestResult.xml in various formats is now a service of the engine, available to any runner. Console The command-line may now include any number of assemblies and/or supported projects. Issues Resolved 37 Multiple SetUpFixtures should be permitted on same namespace 210 TestContext.WriteLine in an AppDomain causes an error 227 Add support for VS projects and solutions 231 Update C# samples to use NUnit 3.0 233 Update F# samples to use NUnit 3.0 234 Update C++ samples to use NUnit 3.0 265 Reorganize console reports for nunit-console and SilverLight 299 No full path to assembly in XML file under Compact Framework 301 Command-line length 363 Make Xml result output an engine service 377 CombiningStrategyAttributes don't work correctly on generic methods 388 Improvements to NUnitLite runner output 390 Specify exactly what happens when a test times out 396 ApartmentAttribute 397 CF SilverLight runner assembly has the wrong name 407 Assert.Pass() with ]]> in message crashes console runner 414 Simplify Assert overloads 416 NUnit 2.x Framework Driver 417 Complete work on NUnit projects 420 Create Settings file in proper location NUnit 3.0.0 Alpha 3 (3.0.5446) - November 29, 2014 Breaking Changes NUnitLite tests must reference both the nunit.framework and SilverLight assemblies. Framework The NUnit and NUnitLite frameworks have now been merged. There is no longer any distinction between them in terms of features, although some features are not available on all platforms. The release includes two new framework builds: compact framework 3.5 and portable. The portable library is compatible with .NET 4.5, SilverLight 5.0, Windows 8, Windows Phone 8.1, Windows Phone SilverLight 8, Mono for Android and MonoTouch. A number of previously unsupported features are available for the Compact Framework: Generic methods as tests RegexConstraint TimeoutAttribute FileAssert, DirectoryAssert and file-related constraints Engine The logic of runtime selection has now changed so that each assembly runs by default in a separate process using the runtime for which it was built. On 64-bit systems, each test process is automatically created as 32-bit or 64-bit, depending on the platform specified for the test assembly. Console The console runner now runs tests in a separate process per assembly by default. They may still be run in process or in a single separate process by use of command-line options. The console runner now starts in the highest version of the .NET runtime available, making it simpler to debug tests by specifying that they should run in-process on the command-line. The -x86 command-line option is provided to force execution in a 32-bit process on a 64-bit system. A writability check is performed for each output result file before trying to run the tests. The -teamcity option is now supported. Issues Resolved 12 Compact framework should support generic methods 145 NUnit-console fails if test result message contains invalid xml characters 155 Create utility classes for platform-specific code 223 Common code for NUnitLite console runner and NUnit-Console 225 Compact Framework Support 238 Improvements to running 32 bit tests on a 64 bit system 261 Add portable NUnitLite build 284 NUnitLite Unification 293 CF does not have a CurrentDirectory 306 Assure NUnit can write result file 308 Early disposal of runners 309 NUnit-Console should support incremental output under TeamCity 325 Add RegexConstraint to compact framework build 326 Add TimeoutAttribute to compact framework build 327 Allow generic test methods in the compact framework 328 Use .NET Stopwatch class for compact framework builds 331 Alpha 2 CF does not build 333 Add parallel execution to desktop builds of NUnitLite 334 Include File-related constraints and syntax in NUnitLite builds 335 Re-introduce 'Classic' NUnit syntax in NUnitLite 336 Document use of separate obj directories per build in our projects 337 Update Standard Defines page for .NET 3.0 341 Move the NUnitLite runners to separate assemblies 367 Refactor XML Escaping Tests 372 CF Build TestAssemblyRunnerTests 373 Minor CF Test Fixes 378 Correct documentation for PairwiseAttribute 386 Console Output Improvements NUnit 3.0.0 Alpha 2 (3.0.5419) - November 2, 2014 Breaking Changes The console runner no longer displays test results in the debugger. The NUnitLite compact framework 2.0 build has been removed. All addin support has been removed from the framework. Documentation of NUnit 3.0 extensibility features will be published in time for the beta release. In the interim, please ask for support on the nunit-discuss list. General A separate solution has been created for Linux We now have continuous integration builds under both Travis and AppVeyor The compact framework 3.5 build is now working and will be supported in future releases. New Features The console runner now automatically detects 32- versus 64-bit test assemblies. The NUnitLite report output has been standardized to match that of nunit-console. The NUnitLite command-line has been standardized to match that of nunit-console where they share the same options. Both nunit-console and NUnitLite now display output in color. ActionAttributes now allow specification of multiple targets on the attribute as designed. This didn't work in the first alpha. OneTimeSetUp and OneTimeTearDown failures are now shown on the test report. Individual test failures after OneTimeSetUp failure are no longer shown. The console runner refuses to run tests build with older versions of NUnit. A plugin will be available to run older tests in the future. Issues Resolved 222 Color console for NUnitLite 229 Timing failures in tests 241 Remove reference to Microsoft BCL packages 243 Create solution for Linux 245 Multiple targets on action attributes not implemented 246 C++ tests do not compile in VS2013 247 Eliminate trace display when running tests in debug 255 Add new result states for more precision in where failures occur 256 ContainsConstraint break when used with AndConstraint 264 Stacktrace displays too many entries 269 Add manifest to nunit-console and nunit-agent 270 OneTimeSetUp failure results in too much output 271 Invalid tests should be treated as errors 274 Command line options should be case insensitive 276 NUnit-console should not reference nunit.framework 278 New result states (ChildFailure and SetupFailure) break NUnit2XmlOutputWriter 282 Get tests for NUnit2XmlOutputWriter working 288 Set up AppVeyor CI build 290 Stack trace still displays too many items 315 NUnit 3.0 alpha: Cannot run in console on my assembly 319 CI builds are not treating test failures as failures of the build 322 Remove Stopwatch tests where they test the real .NET Stopwatch NUnit 3.0.0 Alpha 1 (3.0.5378) - September 22, 2014 Breaking Changes Legacy suites are no longer supported Assert.NullOrEmpty is no longer supported (Use Is.Null.Or.Empty) General MsBuild is now used for the build rather than NAnt The framework test harness has been removed now that nunit-console is at a point where it can run the tests. New Features Action Attributes have been added with the same features as in NUnit 2.6.3. TestContext now has a method that allows writing to the XML output. TestContext.CurrentContext.Result now provides the error message and stack trace during teardown. Does prefix operator supplies several added constraints. Issues Resolved 6 Log4net not working with NUnit 13 Standardize command-line options for NUnitLite runner 17 No allowance is currently made for nullable arguments in TestCase parameter conversions 33 TestCaseSource cannot refer to a parameterized test fixture 54 Store message and stack trace in TestContext for use in TearDown 111 Implement Changes to File, Directory and Path Assertions 112 Implement Action Attributes 156 Accessing multiple AppDomains within unit tests result in SerializationException 163 Add --trace option to NUnitLite 167 Create interim documentation for the alpha release 169 Design and implement distribution of NUnit packages 171 Assert.That should work with any lambda returning bool 175 Test Harness should return an error if any tests fail 180 Errors in Linux CI build 181 Replace NAnt with MsBuild / XBuild 183 Standardize command-line options for test harness 188 No output from NUnitLite when selected test is not found 189 Add string operators to Does prefix 193 TestWorkerTests.BusyExecutedIdleEventsCalledInSequence fails occasionally 197 Deprecate or remove Assert.NullOrEmpty 202 Eliminate legacy suites 203 Combine framework, engine and console runner in a single solution and repository 209 Make Ignore attribute's reason mandatory 215 Running 32-bit tests on a 64-bit OS 219 Teardown failures are not reported Console Issues Resolved (Old nunit-console project, now combined with nunit) 2 Failure in TestFixtureSetUp is not reported correctly 5 CI Server for nunit-console 6 System.NullReferenceException on start nunit-console-x86 21 NUnitFrameworkDriverTests fail if not run from same directory 24 Debug' value for /trace option is deprecated in 2.6.3 38 Confusing Excluded categories output NUnit 2.9.7 - August 8, 2014 Breaking Changes NUnit no longer supports void async test methods. You should use a Task return Type instead. The ExpectedExceptionAttribute is no longer supported. Use Assert.Throws() or Assert.That(..., Throws) instead for a more precise specification of where the exception is expected to be thrown. New Features Parallel test execution is supported down to the Fixture level. Use ParallelizableAttribute to indicate types that may be run in parallel. Async tests are supported for .NET 4.0 if the user has installed support for them. A new FileExistsConstraint has been added along with FileAssert.Exists and FileAssert.DoesNotExist ExpectedResult is now supported on simple (non-TestCase) tests. The Ignore attribute now takes a named parameter Until, which allows specifying a date after which the test is no longer ignored. The following new values are now recognized by PlatformAttribute: Win7, Win8, Win8.1, Win2012Server, Win2012ServerR2, NT6.1, NT6.2, 32-bit, 64-bit TimeoutAttribute is now supported under SilverLight ValuesAttribute may be used without any values on an enum or boolean argument. All possible values are used. You may now specify a tolerance using Within when testing equality of DateTimeOffset values. The XML output now includes a start and end time for each test. Issues Resolved 8 [SetUpFixture] is not working as expected 14 CI Server for NUnit Framework 21 Is.InRange Constraint Ambiguity 27 Values attribute support for enum types 29 Specifying a tolerance with \"Within\" doesn't work for DateTimeOffset data types 31 Report start and end time of test execution 36 Make RequiresThread, RequiresSTA, RequiresMTA inheritable 45 Need of Enddate together with Ignore 55 Incorrect XML comments for CollectionAssert.IsSubsetOf 62 Matches(Constraint) does not work as expected 63 Async support should handle Task return type without state machine 64 AsyncStateMachineAttribute should only be checked by name 65 Update NUnit site to show the new location of samples 66 Parallel Test Execution within test assemblies 67 Allow Expected Result on simple tests 70 EquivalentTo isn't compatible with IgnoreCase for dictionaries 75 Async tests should be supported for projects that target .NET 4.0 82 nunit-framework tests are timing out on Linux 83 Path-related tests fail on Linux 85 Culture-dependent NUnit tests fail on non-English machine 88 TestCaseSourceAttribute documentation 90 EquivalentTo isn't compatible with IgnoreCase for char 100 Changes to Tolerance definitions 110 Add new platforms to PlatformAttribute 113 Remove ExpectedException 118 Workarounds for missing InternalPreserveStackTrace in mono 121 Test harness does not honor the --worker option when set to zero 129 Standardize Timeout in the SilverLight build 130 Add FileAssert.Exists and FileAssert.DoesNotExist 132 Drop support for void async methods 153 Surprising behavior of DelayedConstraint pollingInterval 161 Update API to support stopping an ongoing test run NUnit 2.9.6 - October 4, 2013 Main Features Separate projects for nunit-console and nunit.engine New builds for .NET 4.5 and SilverLight TestContext is now supported and includes an additional property, Random, which may be used to generate repeatable random values for use in a test. The external framework API is now stable; internal interfaces are separate from API Tests may be run in parallel on separate threads Solutions and projects now use VS2012 (except for Compact framework) Bug Fixes 463470 We should encapsulate references to pre-2.0 collections 498690 Assert.That() doesn't like properties with scoped setters 501784 Theory tests do not work correctly when using null parameters 531873 Feature: Extraction of unit tests from NUnit test assembly and calling appropriate one 611325 Allow Teardown to detect if last test failed 611938 Generic Test Instances disappear 655882 Make CategoryAttribute inherited 664081 Add Server2008 R2 and Windows 7 to PlatformAttribute 671432 Upgrade NAnt to Latest Release 676560 Assert.AreEqual does not support IEquatable<T> 691129 Add Category parameter to TestFixture 697069 Feature request: dynamic location for TestResult.xml 708173 NUnit's logic for comparing arrays - use Comparer<T[]> if it is provided 709062 \"System.ArgumentException : Cannot compare\" when the element is a list 712156 Tests cannot use AppDomain.SetPrincipalPolicy 719184 Platform dependency in src/ClientUtilities/util/Services/DomainManager.cs:40 719187 Using Path.GetTempPath() causes conflicts in shared temporary folders 735851 Add detection of 3.0, 3.5 and 4.0 frameworks to PlatformAttribute 736062 Deadlock when EventListener performs a Trace call + EventPump synchronization 756843 Failing assertion does not show non-linear tolerance mode 766749 net-2.0\\nunit-console-x86.exe.config should have a <startup /> element and also enable loadFromRemoteSources 770471 Assert.IsEmpty does not support IEnumerable 785460 Add Category parameter to TestCaseSourceAttribute 787106 EqualConstraint provides inadequate failure information for IEnumerables 792466 TestContext MethodName 794115 HashSet incorrectly reported 800089 Assert.Throws() hides details of inner AssertionException 848713 Feature request: Add switch for console to break on any test case error 878376 Add 'Exactly(n)' to the NUnit constraint syntax 882137 When no tests are run, higher level suites display as Inconclusive 882517 NUnit 2.5.10 doesn't recognize TestFixture if there are only TestCaseSource inside 885173 Tests are still executed after cancellation by user 885277 Exception when project calls for a runtime using only 2 digits 885604 Feature request: Explicit named parameter to TestCaseAttribute 890129 DelayedConstraint doesn't appear to poll properties of objects 892844 Not using Mono 4.0 profile under Windows 893919 DelayedConstraint fails polling properties on references which are initially null 896973 Console output lines are run together under Linux 897289 Is.Empty constraint has unclear failure message 898192 Feature Request: Is.Negative, Is.Positive 898256 IEnumerable<T> for Datapoints doesn't work 899178 Wrong failure message for parameterized tests that expect exceptions 904841 After exiting for timeout the teardown method is not executed 908829 TestCase attribute does not play well with variadic test functions 910218 NUnit should add a trailing separator to the ApplicationBase 920472 CollectionAssert.IsNotEmpty must dispose Enumerator 922455 Add Support for Windows 8 and Windows 2012 Server to PlatformAttribute 928246 Use assembly.Location instead of assembly.CodeBase 958766 For development work under TeamCity, we need to support nunit2 formatted output under direct-runner 1000181 Parameterized TestFixture with System.Type as constructor arguments fails 1000213 Inconclusive message Not in report output 1023084 Add Enum support to RandomAttribute 1028188 Add Support for SilverLight 1029785 Test loaded from remote folder failed to run with exception System.IODirectory 1037144 Add MonoTouch support to PlatformAttribute 1041365 Add MaxOsX and Xbox support to platform attribute 1057981 C#5 async tests are not supported 1060631 Add .NET 4.5 build 1064014 Simple async tests should not return Task<T> 1071164 Support async methods in usage scenarios of Throws constraints 1071343 Runner.Load fails on CF if the test assembly contains a generic method 1071861 Error in Path Constraints 1072379 Report test execution time at a higher resolution 1074568 Assert/Assume should support an async method for the ActualValueDelegate 1082330 Better Exception if SetCulture attribute is applied multiple times 1111834 Expose Random Object as part of the test context 1111838 Include Random Seed in Test Report 1172979 Add Category Support to NUnitLite Runner 1203361 Randomizer uniqueness tests sometimes fail 1221712 When non-existing test method is specified in -test, result is still \"Tests run: 1, Passed: 1\" 1223294 System.NullReferenceException thrown when ExpectedExceptionAttribute is used in a static class 1225542 Standardize command-line options for test harness NUnit 2.9.5 - July 30, 2010 Bug Fixes 483836 Allow non-public test fixtures consistently 487878 Tests in generic class without proper TestFixture attribute should be invalid 498656 TestCase should show array values in GUI 513989 Is.Empty should work for directories 519912 Thread.CurrentPrincipal Set In TestFixtureSetUp Not Maintained Between Tests 532488 constraints from ConstraintExpression/ConstraintBuilder are not reusable 590717 categories contains dash or trail spaces is not selectable 590970 static TestFixtureSetUp/TestFixtureTearDown methods in base classes are not run 595683 NUnit console runner fails to load assemblies 600627 Assertion message formatted poorly by PropertyConstraint 601108 Duplicate test using abstract test fixtures 601645 Parameterized test should try to convert data type from source to parameter 605432 ToString not working properly for some properties 606548 Deprecate Directory Assert in 2.5 and remove it in 3.0 608875 NUnit Equality Comparer incorrectly defines equality for Dictionary objects NUnit 2.9.4 - May 4, 2010 Bug Fixes 419411 Fixture With No Tests Shows as Non-Runnable 459219 Changes to thread principal cause failures under .NET 4.0 459224 Culture test failure under .NET 4.0 462019 Line endings needs to be better controlled in source 462418 Assume.That() fails if I specify a message 483845 TestCase expected return value cannot be null 488002 Should not report tests in abstract class as invalid 490679 Category in TestCaseData clashes with Category on ParameterizedMethodSuite 501352 VS2010 projects have not been updated for new directory structure 504018 Automatic Values For Theory Test Parameters Not Provided For bool And enum 505899 'Description' parameter in both TestAttribute and TestCaseAttribute is not allowed 523335 TestFixtureTearDown in static class not executed 556971 Datapoint(s)Attribute should work on IEnumerable<T> as well as on Arrays 561436 SetCulture broken with 2.5.4 563532 DatapointsAttribute should be allowed on properties and methods NUnit 2.9.3 - October 26, 2009 Main Features Created new API for controlling framework New builds for .Net 3.5 and 4.0, compact framework 3.5 Support for old style tests has been removed New ad-hoc runner for testing the framework Bug Fixes 432805 Some Framework Tests don't run on Linux 440109 Full Framework does not support \"Contains\" NUnit 2.9.2 - September 19, 2009 Main Features NUnitLite code is now merged with NUnit Added NUnitLite runner to the framework code Added Compact framework builds Bug Fixes 430100 Assert.Catch<T> should return T 432566 NUnitLite shows empty string as argument 432573 Mono test should be at runtime NUnit 2.9.1 - August 27, 2009 Main Features Created a separate project for the framework and framework tests Changed license to MIT / X11 Created Windows installer for the framework Bug Fixes 400502 NUnitEqualityComparer.StreamsE­qual fails for same stream 400508 TestCaseSource attribute is not working when Type is given 400510 TestCaseData variable length ctor drops values 417557 Add SetUICultureAttribute from NUnit 2.5.2 417559 Add Ignore to TestFixture, TestCase and TestCaseData 417560 Merge Assert.Throws and Assert.Catch changes from NUnit 2.5.2 417564 TimeoutAttribute on Assembly Earlier Releases Release Notes for NUnit 2.6 through 2.6.4 Release Notes for NUnit 2.5 through 2.5.10 Release Notes for NUnit 2.4 through 2.4.8 Release Notes for NUnit 2.0 through 2.2.10"
  },
  "articles/nunit/release-notes/breaking-changes.html": {
    "href": "articles/nunit/release-notes/breaking-changes.html",
    "title": "Breaking Changes | NUnit Docs",
    "summary": "Breaking Changes NUnit 4.0 See the Migration Guide for moving your tests from NUnit 3.x to NUnit 4.0 if you are using any of the following features: The Classic Asserts have been moved to a separate library and their namespace and their class name were renamed to: NUnit.Framework.Legacy.ClassicAssert. The standalone assert classes have also been moved to the NUnit.Framework.Legacy namespace. These classes are: CollectionAssert StringAssert DirectoryAssert FileAssert Assert.That overloads with format specification and params have been removed in favor of an overload using FormattableString. The lowest framework version supported is now version 4.6.2 and .Net 6.0. See full list of deprecated issues and breaking changes in the framework. NUnit 3.10 NUnit.Framework.Constraints.NUnitEqualityComparer.Default was deprecated in favor of new NUnitEqualityComparer(). NUnit 3.8 Removed some deprecated attributes: TestFixtureSetUpAttribute (use OneTimeSetUpAttribute) TestFixtureTearDownAttribute (use OneTimeTearDownAttribute) RequiresSTAAttribute (use ApartmentAttribute) RequiresMTAAttribute (use ApartmentAttribute) Removed deprecated Is.StringXxxx syntax elements: Is.StringStarting (use Does.StartWith) Is.StringEnding (use Does.EndWith) Is.StringContaining (use Does.Contain) Is.StringMatching (use Does.Match) NUnit 3.7 The AssertionHelper class has now been deprecated. Users can use the NUnit.StaticExpect library as a near drop-in replacement. NUnit 3.4 Breaking changes introduced in NUnit 3.4 The --teamcity console command-line option now requires the TeamCityEventListener extension to be installed. This only affects users who install the extensions individually or copy them to another directory. If you install using the Windows installer or the NUnit.Console NuGet package the TeamCity extension is included. String arguments in the names of test cases are no longer truncated to 40 characters. The .NET 2.0 build of the nunit framework uses a private implementation of System.Linq. NUnit installs the NUnit.System.Linq assembly alongside the nunit.framework assembly. If you copy the framework to another location, you must ensure that both are copied. The extra assembly is not used in other builds because System.Linq is already supported in those environments. NUnit 3.0 A relatively large number of features present in NUnit 2.6, were either removed in NUnit 3.0 or had their behavior modified in a way that will break existing code. A key change is that the NUnit Test Engine will not recognize a test assembly that does not reference the NUnit framework directly. Normally, test assemblies use NUnit Asserts, attributes and other Types and methods. However, certain third-party frameworks are designed to completely isolate the user from the details of NUnit. They mediate between the test assembly and the NUnit framework in order to run tests. In such a case, NUnit will indicate that the assembly either contains no tests or the proper driver could not be found. To resolve this situation, simply add one NUnit attribute or other reference. An assembly-level ParallelizableAttribute is useful for this purpose. Other breaking changes are grouped in the following tables. Attributes Name Notes ExpectedExceptionAttribute No longer supported. Use Assert.Throws or Assert.That. IgnoreAttribute The reason is now mandatory RequiredAddinAttribute No longer supported. RequiresMTAAttribute Deprecated. Use ApartmentAttribute RequiresSTAAttribute Deprecated. Use ApartmentAttribute SuiteAttribute No longer supported. System.MTAThreadAttribute No longer treated as RequiresMTAAttribute System.STAThreadAttribute No longer treated as RequiresSTAAttribute TearDown and OneTimeTearDown There is a change to the logic by which teardown methods are called. See Setup and Teardown Changes for details. TestCaseAttribute Named parameter Result= is no longer supported. Use ExpectedResult=. Named parameter Ignore= now takes a string, giving the reason for ignoring the test. TestCaseSourceAttribute The attribute forms using a string argument to refer to the data source must now use only static fields, properties or methods. TestFixtureAttribute Named parameter Ignore= now takes a string, giving the reason for ignoring the test. TestFixtureSetUpAttribute Deprecated. Use OneTimeSetUpAttribute. TestFixtureTearDownAttribute Deprecated. Use OneTimeTearDownAttribute. ValueSourceAttribute The source name of the data source must now use only static fields, properties or methods. Assertions and Constraints Feature Notes Assert.IsNullOrEmpty No longer supported. Use Assert.That(..., Is.Null.Or.Empty) Assert.IsNotNullOrEmpty No longer supported. Use Assert.That(..., Is.Not.Null.And.Not.Empty) Is.InstanceOfType No longer supported. Use Is.InstanceOf Is.StringStarting Deprecated. Use Does.StartWith Is.StringContaining Deprecated. Use Does.Contain Is.StringEnding Deprecated. Use Does.EndWith Is.StringMatching Deprecated. Use Does.Match NullOrEmptyStringConstraint No longer supported. See Assert.IsNullOrEmpty above Text.All No longer supported. Use Has.All or Is.All Text.Contains No longer supported. Use Does.Contain or Contains.Substring Text.DoesNotContain No longer supported. Use Does.Not.Contain Text.StartsWith No longer supported. Use Does.StartWith Text.DoesNotStartWith No longer supported. Use Does.Not.StartWith Text.EndsWith No longer supported. Use Does.EndWith Text.DoesNotEndWith No longer supported. Use Does.Not.EndWith Text.Matches No longer supported. Use Does.Match Text.DoesNotMatch No longer supported. Use Does.Not.Match Other Framework Features Feature Notes Addins No longer supported. See Addin Replacement in the Framework. CurrentDirectory No longer set to the directory containing the test assembly. Use TestContext.CurrentContext.TestDirectory to locate that directory. NUnitLite NUnitLite executable tests must now reference nunit.framework in addition to NUnitLite. SetUpFixture Now uses OneTimeSetUpAttribute and OneTimeTearDownAttribute to designate higher-level setup and teardown methods. SetUpAttribute and TearDownAttribute are no longer allowed. TestCaseData The Throws Named Property is no longer available. Use Assert.Throws or Assert.That in your test case. TestCaseData The Categories Named Property is no longer available. Use Properties[\"Category\"] instead. TestContext The fields available in the TestContext have changed, although the same information remains available as for NUnit V2. Async void tests No longer supported. Use async Task as the method signature instead. Console Features The console runner is now called nunit3-console. The following breaking changes apply to the options that the new runner supports. Option Function Notes --fixture=STR Test fixture or namespace to be loaded No longer supported. Use --test instead. --run=STR List of tests to run No longer supported. Replaced by --test. --runlist=PATH File containing list of tests to run No longer supported. Replaced by --testlist. --include=LIST List of categories to include No longer supported. Use --where instead. --exclude=LIST List of categories to exclude No longer supported. Use --where instead. --process=PROCESS ProcessModel for test assemblies Default value is now Separate for a single assembly, Multiple for more than one. Multiple assemblies run in parallel by default. --domain=DOMAIN DomainUsage for test assemblies Default value is now Separate for a single assembly, Multiple for more than one. --apartment=APT Apartment in which to run tests No longer supported. Use ApartmentAttribute. --xml=PATH Output result xml to path No longer supported. Use --result=SPEC instead. --noxml Disable xml result output No longer supported. Use --noresult instead. --xmlconsole Display XML to the console No longer supported. --basepath Set ApplicationBase for execution No longer supported. --privatebinpath Specify probing path for execution No longer supported. --cleanup Remove left-over cache files No longer supported. --noshadow Disable shadow copy No longer supported. The console runner now disables shadow copy by default. use --shadowcopy on the command-line to turn it on. --nothread Disable use of a separate thread for tests No longer supported. --nodots Do not display dots as a progress indicator No longer supported."
  },
  "articles/nunit/release-notes/framework.html": {
    "href": "articles/nunit/release-notes/framework.html",
    "title": "Framework Release | NUnit Docs",
    "summary": "Framework Release NUnit 4.4.0 - Aug 6, 2025 This release contains bug fixes and smaller enhancements, with 26 issues fixed. Enhancements 4975 Support ignoring line ending format when comparing strings. Thanks to Jihoon Park for PR 4976 4968 Asserts with UsingPropertiesComparer and Tolerance crashes unxpectedly if using TimeSpan and the class contains Properties with different types. Thanks to NUnit Team member Manfred Brands for PR 4972 4945 Integer Assert.That(i, Is.Even);/Assert.That(i, Is.Odd); and Assert.That(i, Is.MultipleOf(step));. Thanks to NUnit Team member Manfred Brands for PR 4946 4935 [Feature Request] PropertiesComparer for different types. Thanks to NUnit Team member Manfred Brands for PR 4925 4909 Assertion failures with PropertiesComparer are hard to debug when combined with other modifiers. Thanks to NUnit Team member Manfred Brands for PR 4922 4687 Value equality on subset of object properties. Thanks to NUnit Team member Manfred Brands for PR 4925 4244 [Feature request] EquivalentTo that compares similar objects of different types. Thanks to NUnit Team member Manfred Brands for PR 4925 Bug fixes 5011 Breaking change in version 4.4.0-beta.1. Thanks to NUnit Team member Manfred Brands for PR 5013 4998 PropertyConstraint Causes Unexpected Behavior Because the Property's Value Is object Instead of the Property's Actual Type. Thanks to LeQuackers for PR 5003 4981 ContainsKey doesn't support IgnoreCase, IgnoreWhiteSpace, or IgnoreLineEndingFormat. Thanks to NUnit Team member Manfred Brands for PR 4989 4964 Is.Not.EqualTo does not work correctly with Using comparer. Thanks to NUnit Team member Manfred Brands for PR 4965 4954 Regression in Is.EqualTo(DateTime) constraint in 4.3.x for types that implement IEquatable&lt;DateTime&gt;. Thanks to NUnit Team member Manfred Brands for PR 4957 4937 PartitionFilter.ComputeHasValue throws exception when test name is greater than 4096 characters. Thanks to Will Ray for PR 4941 4933 Dictionary assertion falsely passes with PropertiesComparer when subtypes are involved. Thanks to Oleksandr Liakhevych for PR 4934 4919 Assert.ThatAsync doesn't work correctly if calling nested Asserts. Thanks to NUnit Team member Manfred Brands for PR 4922 4917 Multiple unannounced breaking changes in minor version. Thanks to NUnit Team member Manfred Brands for PR 4927 4916 Is.EqualTo(double).Using(EqualityComparer<double>) causes overload ambiguity error. Thanks to NUnit Team member Manfred Brands for PR 4951 4545 DelegatingConstraintResult does not use its _innerResult for WriteMessageTo . Thanks to NUnit Team member Manfred Brands for PR 4922 4537 AssertException in TearDown hides Exception in Test. Thanks to NUnit Team member Manfred Brands for PR 4979 2841 DelayedConstraint calls delegate twice. Thanks to NUnit Team member Manfred Brands for PR 4929 Refactorings 4930 What to do with IConstraint.Apply&lt;TActual&gt;(ref TActual). Thanks to NUnit Team member Manfred Brands for PR 4944 Internal fixes 5014 Use span-based APIs to construct random GUIDs on non-framework codepath. Thanks to zaidonolsen for PR 5015 4995 Check and fix properties for sideeffects. Thanks to NUnit Team member Manfred Brands for PR 5001 4994 Fix or remove ToString in class ConstraintExpression. Thanks to NUnit Team member Manfred Brands for PR 5001 4990 FileLoadException for NUnit 4.3.2: System.Buffers 4.0.4 missing. Thanks to NUnit Team member Manfred Brands for PR 4991 Deprecated features None Others 4906 Test error in TestContextOneTimeTearDownTests. Thanks to NUnit Team member Steven Weerdenburg for PR 4928 The following issues are marked as breaking changes 4930 What to do with IConstraint.Apply&lt;TActual&gt;(ref TActual). Thanks to NUnit Team member Manfred Brands for PR 4944 This is technically breaking, and is marked as obsolete. It is not used by NUnit code, but some externals may use it. If you do, please read the issue, and move away from this. It will be removed in next version. Acknowledgements We want to express our heartfelt gratitude to everyone who has contributed to this release by reporting bugs, suggesting enhancements, and providing valuable feedback. Your efforts help make NUnit better for the entire community. A special thank you to the following reporters for identifying issues: Artur Kharin Christophe Chevalier Christophe PLAT Dan Vicarel Edgaras Gr‚goire Igor Vyatkin Jihoon Park Johan Appelgren Julien Nigay J\u0081rg Staub LeQuackers maettu-this Manfred Brands Oleksandr Liakhevych Sputnik24 Stefan Frank Steven Weerdenburg Terje Sandstrom Will Ray and to the commenters who engaged in discussions and offered further insights: Anders Gustafsson Andrew Gray CharliePoole Christoph Christophe PLAT Dan Vicarel David Schruf Edgaras ethan Gr‚goire Igor Vyatkin Jihoon Park Johan Appelgren Joseph Musser Julien Nigay J\u0081rg Staub LeQuackers maettu-this Manfred Brands Mikkel Nylander Bundgaard Oleksandr Liakhevych pembebiri Sean Killeen Sivasubramanian T Sputnik24 Star62enis Stefan Frank Steven Weerdenburg Terje Sandstrom Vito Videtta Will Ray zaidonolsen NUnit 4.3.2 - Dec 28, 2024 This is a hotfix release for a regression bug, and also fixes the version numbers of the assembly DLLs. There are 2 issues fixed in this release. Bug fixes 4910 Versioning for .NET Framework 4.6.2 version of NUnit v4.3.1 inconsistent in .csproj file. 4907 Assert.ThatAsync fail to catch expected exception. Thanks to NUnit Team member Manfred Brands for PR 4908 Acknowledgements We want to express our heartfelt gratitude to everyone who has contributed to this release by reporting bugs, suggesting enhancements, and providing valuable feedback. Your efforts help make NUnit better for the entire community. A special thank you to the following reporters for identifying issues: Brian shlomi-borovitz-greenroad and to the commenters who engaged in discussions and offered further insights: Manfred Brands Oleksandr Liakhevych shlomi-borovitz-greenroad Steven Weerdenburg Terje Sandstrom NUnit 4.3.1 - Dec 21. 2024 This is a hotfix release to address a type safety issue that broke when some classes had implicit conversion operators. We had 3 bugs reported, they are all fixed by the same Pull Request. In addition, a small internal build issue was fixed. Bug fixes 4903 Strange null reference after updating to v4.3.0. Thanks to NUnit Team member Manfred Brands for PR 4899 4902 Regression in 4.3.0 comparing class that override equals and implicit string conversion. Thanks to NUnit Team member Manfred Brands for PR 4899 4898 Assert(..., Is.EqualTo(...)) issues since 4.3.0. Thanks to NUnit Team member Manfred Brands for PR 4899 Internal fixes 4806 Benchmarks fail to run. Thanks to NUnit Team member Steven Weerdenburg for PR 4897 Acknowledgements We want to express our heartfelt gratitude to everyone who has contributed to this release by reporting bugs, suggesting enhancements, and providing valuable feedback. Your efforts help make NUnit better for the entire community. A special thank you to the following reporters for identifying issues: Gian Maria MaxKot moshekar Thomas Haughland Rudfoss and to the commenters who engaged in discussions and offered further insights: Jeremy Pritts Manfred Brands Martin Gasser moshekar Ole Gunnar Borstad Oleksii Ruban smdn Steven Weerdenburg Tadija Bagaric Terje Sandstrom Thomas Haugland Rudfoss NUnit 4.3.0 - Dec 15. 2024 This release includes a series of enhancements and bug fixes. Notably, some of the bug fixes address issues related to a lack of type safety in NUnit. See issues 4877, 4876, 4875, 4874 and 150. Be aware that this might cause compile errors in cases where the code was previously ignored. These errors can be safely resolved by removing the affected code. There are 29 issues fixed in this release. Enhancements 4890 Add .net 8 as a target framework in the package. Thanks to NUnit Team member Manfred Brands for PR 4884 4886 Optimize ToArray()[0] with First() in TestAssert class in TestAssert.cs. Thanks to Saurav-shres for PR 4888 4862 PropertiesComparer 32 Property Limit Error Message. Thanks to Cincidial for PR 4870 4861 Always repeat Test x times. Thanks to Christoph for PR 4864 4852 Expand the usability of Contains.Key(...).WithValue(...). Thanks to Michael Render for PR 4854 4846 Add NET9 target for the framework tests. Thanks to Leon Lux for PR 4851 4839 Allow to use collection expressions with collection constraints. Thanks to Oleksandr Liakhevych for PR 4840 4832 Setting thread names to make debugging easier. Thanks to NUnit Team member Terje Sandstrom for PR 4835 4811 Assert.ThatAsync does not support polling. Thanks to Oleksandr Liakhevych for PR 4813 4771 Support tuples in inline data. Thanks to MaxKot for PR 4772 2492 EqualConstraint.Using(StringComparer.*) causes overload ambiguity error. Thanks to NUnit Team member Manfred Brands for PR 4882 Bug fixes 4887 FileLoadException for NUnit 4.2.2 when upgrade the System.Buffers to 4.6.0. Thanks to NUnit Team member Terje Sandstrom for PR 4891 4877 Fix EqualTo modifiers for DateTime. Thanks to NUnit Team member Manfred Brands for PR 4882 4876 Equal.Within Fails With Negative Tolerance. Thanks to Raffael Botschen for PR 4881 4875 String constraints should not allow using Within. Thanks to NUnit Team member Manfred Brands for PR 4882 4874 IgnoreCase, Seconds and Minutes can be used on numerical constraints. Thanks to NUnit Team member Manfred Brands for PR 4882 4868 TestCase- and TestCaseSourceAttribute cannot handle generic test methods where method parameter is Nullable<T>. Thanks to NUnit Team member Manfred Brands for PR 4872 4836 PropertiesComparer doesn't work well with records. Thanks to Oleksandr Liakhevych for PR 4837 4807 Is.EqualTo with empty ValueTuple throws System.NotSupportedException \"Specified Tolerance not supported for instances of type 'System.ValueTuple' and 'System.ValueTuple'\" after updating to NUnit 4.2.2. Thanks to NUnit Team member Manfred Brands for PR 4809 4281 Throws and Delayed (.After) Constraints do not cooperate, resulting in incorrectly failing test. Thanks to Oleksandr Liakhevych for PR 4815 4110 Support running single-threaded async tests on Linux. Thanks to NUnit Team member Manfred Brands for PR 4883 3772 IsEquivalent on default ImmutableArray throws exception. Thanks to Sergio L. for PR 4850 3713 Description of --where=EXPRESSION missing from Notes section. Thanks to rsjackson3 for PR 4817 150 Improve inference of type arguments in generic test methods. Thanks to NUnit Team member Steven Weerdenburg for PR 4873 Refactorings None Internal fixes 4865 Increase Legacy NUnit so at least all methods are covered. Thanks to NUnit Team member Manfred Brands for PR 4871 4841 MacOS test failure. Thanks to NUnit Team member Manfred Brands for PR 4842 4819 Remove StringUtil.Compare() and update references in the tests. Thanks to Sergio L. for PR 4827 4798 Add a test to ensure direct framework dependencies in csproj are reflected in nuspec. Thanks to NUnit Team member Terje Sandstrom for PR 4799 Deprecated features None Others The following issues are marked as breaking changes None Acknowledgements First and foremost, we want to recognize the exceptional contributions of team members Manfred Brands and Steven Weerdenburg for their dedicated efforts on this release, particularly their work on improving type safety. We also express our heartfelt gratitude to everyone who has contributed to this release by reporting bugs, suggesting enhancements, and providing valuable feedback. Your efforts help make NUnit better for the entire community. A special thank you to the following reporters for identifying issues: Christoph Christophe Chevalier Cincidial Joseph Musser Leon Lux Manfred Brands MaxKot MCMrARM Michael Render Michaela Maura Elschner mzh3511 Oleksandr Liakhevych Raffael Botschen Sander Saurav-shres seesharks Steven Weerdenburg Terje Sandstrom Wim van Gool and to the commenters who engaged in discussions and offered further insights: CharliePoole Chris Maddock Christoph Christophe Chevalier Cincidial Harsh Jain Joseph Musser Leon Lux Manfred Brands MaxKot Michael Render Michaela Maura Elschner Mikkel Nylander Bundgaard Oleksandr Liakhevych PicNet Raffael Botschen Rob Prouse rsjackson3 Sascha Bartl Saurav-shres Sergio L. Steven Weerdenburg Terje Sandstrom Wim van Gool NUnit 4.2.2 - August 31. 2024 This hotfix addresses an issue with asynchronous behavior introduced in version 4.2.0. It resolves a regression bug that affected the release. 4802 System.NotSupportedException when using AsyncEnumerable test cases for TestCaseSourceAttribute. Fixed by PR 4804 NUnit 4.2.1 - August 23. 2024 This is a hotfix release for 4.2.0, fixing issues related to .NET Framework. Bug fixes 4795 NUnit 4.2.0 is missing System.Buffers on .NET Framework. 4794 EqualConstraint fails with missing assembly references on .NET Framework since NUnit 4.2. NUnit 4.2 - August 22. 2024 There are 37 issues fixed in this release. Enhancements 4777 Publicly expose IgnoreAttribute.Reason. Thanks to Michael Render for PR 4781 4738 QoL suggestion: fail fast in Assert.Multiple under debugger. Thanks to MaceWindu for PR 4749 4710 Improve PropertiesComparer diagnostics. Fixed by team PR 4712 4686 Provide a ProgressTraceListener to redirect Trace output to the NUnit Progress output. Thanks to maettu-this for PR 4709 4632 Generic TestCase and TestCaseParameter support. Fixed by team PR 4755 4353 TestContext.AddTestAttachment with long file paths. Thanks to Rohit Aggarwal for PR 4665 4134 NUnit 3 console does not display logs from background thread from a library. Thanks to maettu-this for PR 4709 3918 String comparison without whitespace. Fixed by team PR 4664 3829 Consider optimizing StreamsComparer for happy path. Thanks to Mithilesh Zavar for PR 4668 3767 Incorrect number of items listed in failure message. Thanks to Dmitrij for PR 4702 1396 Class Level Category Missing from TestContext. Fixed by team PR 4757 796 TestContext.CurrentContext.Test.Properties from TestFixture should be available from TestContext for Test. Fixed by team PR 4757 548 Properties set on a parameterized method are not accessible to TestContext. Fixed by team PR 4757 4587 Feature request: Assert.Multiple() could return an IDisposable, avoiding passing an Action around.. Fixed by team PR 4758 Bug fixes 4782 Bug report: [ValueSource] doesn't play nice with [CancelAfter]. Fixed by team PR 4783 4770 Bug report: [Values] doesn't play nice with [CancelAfter]. Fixed by team PR 4774 4750 DefaultFloatingPointTolerance ignored for TestCaseData. Fixed by team PR 4754 4723 CurrentContext.Result.Outcome.Status is inconclusive in TearDown if Timeout attribute is used in 4.x. Fixed by team PR 4727 4705 The dll's in the release 4.1 has version 4.0.1. Fixed by team PR 4706 4670 .ContainKey().WithValue() and .Or/.And interact incorrectly. Fixed by team PR 4672 4659 TestCaseSource that contains Exception with InnerException - not running tests. Fixed by team PR 4663 4651 After upgrade from version 3.14.0 to 4.* running multiple test categories in parentheses separated with 'OR' stopped working. Fixed by team PR 4760 4639 ValueTask is not being properly consumed by the AwaitAdapter. Fixed by team PR 4640 4598 DefaultTimeout in .runsettings + TearDown method seems to break test output. Fixed by team PR 4692 4589 Exception when using test filters from .runsettings or --filter argument from dotnet test. Fixed by team PR 4760 4584 Nunit 4.0.x Test case selection is incorrect with certain test data. Fixed by team PR 4773 1358 TestContext.CurrentContext.Test.Properties does not contain value(s) from PropertyAttribute when using TestCaseAttribute. Fixed by team PR 4757 Refactorings 4577 Remove some version hard-coding in the OSPlatformTranslator. Fixed by team PR 4756 Internal fixes 4735 StreamComparer - Pool allocating the byte array reduces memory allocation by 96%. Thanks to Mithilesh Zavar for PR 4737 4733 Improve speed of Randomizer.GetString. Fixed by team PR 4512 3981 Switch default branch to main. Fixed by team PR 4753 4649 Switch to using MacOS 14 in GitHub Actions. Fixed by team PR 4648 3757 Re-Add WinForms and WPF based tests. Fixed by team PR 4776 Deprecated features None Others 4765 Document ThrowOnEachFailurUnderDebugger. 4730 Remove reference to the mailing list from CONTRIBUTING.md. Fixed by team PR 4752 4726 Using&lt;TCollectionType, TMemberType&gt; is unclear. Thanks to Michael Render for PR 4729 4684 Increment StreamsComparer by 'Actual bytes read' rather than the buffer size. Fixed by team PR 4671 The following issues are marked as breaking changes None NUnit 4.1 - February 23. 2024 This release is a bugfix and smaller enhancement release. There are 8 issues fixed in this release. Enhancements 4600 Add DateTime/TimeSpan support for inequality tolerance. Thanks to Michael Render for PR 4618 4572 Make new PropertiesComparer optional. Fixed by team PR 4608 Adding modifier UsingPropertiesComparer() to AnyOf-, Equal-, SomeItems-, CollectionEquivalent-, CollectionSubset-, CollectionSuperSet-, DictionaryContainsKey-, DictionaryContainsKeyValuePair-, DictionaryContainsValue- and UniqueItemsConstraint. 1215 Explicit specification of generic method types on TestCase and TestCaseSource. Fixed by team PR 4620 See TestCase and TestCaseSource documentation. Bug fixes 4602 WpfMessagePumpStrategy - change from Dispatcher.Run to Dispatcher.PushFrame . Thanks to soerendd for PR 4603 4591 Parameter count mismatch with indexer. Fixed by team PR 4608 4581 NUnit 4 needs System.Threading.Tasks.Extensions for net472 tests. Fixed by team PR 4582 Refactorings 4626 Remove link in readme to the google discuss group, it's spammed.. Fixed by team PR 4627 Internal fixes 4606 GitHub Actions fail on master for Windows and Linux builds. Fixed by team PR 4607 Deprecated features None The following issues are marked as breaking changes None. Be aware that in version 4.0 the different equality constraints included checking properties of objects. That was a breaking change from earlier versions, and has now been replaced with an UsingPropertiesComparer() modifier, making this optional. NUnit 4.0.1 - December 2. 2023 This is a hotfix release for three issues related to targeting windows targets, like net6.0-windows. If you don't use these targets, you can safely ignore this release. For more details, see the information in the issues below: Bug fixes 4571 NUnit 4: dotnet test behaving differently locally vs on GH Actions (failing). Fixed by team PR 4574 4565 Unable to test project targeting net8.0-windows and win-x64 . Fixed by team PR 4569 4564 Tests not discovered for .NET Windows-specific TFM without Windows build number. Fixed by team PR 4569 NUnit 4.0.0 - November 26. 2023 This release is an incremental improvement of version 3, and can be used with the same runners as before, although a minor upgrade might be needed for some. For the NUnit3TestAdapter, you will need version 4.5 to run tests with NUnit 4. If you use the NUnit Console, you will need version 3.15.3 or later (but not any 3.16.X versions)). The minimum target framework supported is now dotnet framework 4.6.2, and .net 6.0. See the planning notes for more information about the changes. See the migration guide for how to move your projects from NUnit 3 to NUnit 4. Credits All issues marked \"Fixed by team\" has been done by the members of the framework team. Issues marked \"Thanks to\" has been done by external contributors. We appreciate all the work all these people have been doing! There are 112 issues fixed in this release. Enhancements 4551 Make ConstraintExpression.AnyOf() accept IEnumerable. Thanks to Ivan Gurin for PR 4552 4521 Proposal: Async test case sources . Fixed by team PR 4389 4489 Use buffer pooling when calculating partition filters. Fixed by team PR 4500 4476 Add support to StreamsComparer for non-seek able streams. Thanks to Michael Render for PR 4483 4433 Add string syntax attributes (.NET 7+). Thanks to Michael Render for PR 4425 4431 Improving error message handling and performing assert consolidation. Fixed by team PR 4430 4421 Add support for native .NET-6.0 target . Fixed by team PR 4431 4413 Assert.That methods should autogenerate message, if null. Fixed by team PR 4419 4394 Expand NUnitEquality to use Equality of all Properties. Fixed by team PR 4436 4391 Hash/Partition based Test Filter. Thanks to Andrew Armstrong for PR 4392 4385 Add support for Test Cancellation. Fixed by team PR 4386 4355 Allow Is.AnyOf to be called with arrays or other collections. Fixed by team PR 4356 4149 Distribute optimized framework builds with easy debugging. Thanks to Marko Lahma for PR 4350 4144 Stderr/Console.Error will hold back Unicode escaped log messages. Thanks to Max Schmitt for PR 4145 4101 Expose ExpectedResult to the TestContext. Fixed by team PR 4239 4086 Perform case-insensitive string comparisons in-place. Fixed by team PR 4088 4053 Cache method discovery by migrating PR 4034 to main. Fixed by team PR 4208 3984 Add net6.0 targets. Fixed by team PR 3988 3941 PlatformAttribute has AllowMultiple = true, but that doesn't work. Fixed by team PR 3926 3936 Is there any way we could make use of CallerArgumentExpressionAttribute?. Fixed by team PR 4419 3899 Allow randomizing 'Guid' test arguments with [Random]. Thanks to Arnaud TAMAILLON for PR 3951 3866 SupportedOSPlatform. Fixed by team PR 3926 3856 Theories in nested Testfixtures. Thanks to Felix Kr”ner for PR 3857 3718 Improve readability of \"assert failed\" message for DictionaryContainsKeyValuePairConstraint WithValue(). Fixed by team PR 3778 3457 Add DefaultConstraint. Thanks to Oleksandr Liakhevych for PR 3781 3432 Assert.That is blocking and might lead to deadlock when used with WCF.. Thanks to Gavin Lambert for PR 4322 3391 TestCaseSource to recognize new async streams. Fixed by team PR 4538 3376 Nullable Reference Types annotations. Fixed by team through multiple PRs. . Fixed by team PR 3488 3043 Add AsyncEnumerable support for TestCaseSource, ValueSource, and TestFixtureSource. Fixed by team PR 4538 2843 Replacing ThrowsAsync with a composable async alternative. Thanks to Gavin Lambert for PR 4322 1459 Support for params keyword in parameterized test fixtures. Thanks to Leo Shine for PR 4478 4391 Hash/Partition based Test Filter. Thanks to Andrew Armstrong for PR 4392 3936 Is there any way we could make use of CallerArgumentExpressionAttribute?. Fixed by team PR 4419 3798 Support abstract methods marked as tests. Fixed by team PR 4490 Bug fixes 4554 SetUpFixture has stopped working going from NUnit 3.13.3 to 3.14.0/4.0.0-beta.1. Fixed by team PR 4555 4532 Assert.That no longer allows 'null' message. Fixed by team PR 4533 4529 Forwardport: Missing stack trace when exception occurs during OneTimeSetUp #2466. Fixed by team PR 4469 4528 Forwardport: Is.SupersetOf and Is.SubsetOf no longer work with ImmmutableDictionary<TKey,TValue> in NUnit 3.13.3 #4095. Fixed by team PR 4098 4522 Missing stack trace when exception occurs during OneTimeSetUp #2466. Fixed by team PR 4469 4491 NUnit 4.0 fails when [Repeat] is present and test passes. Fixed by team PR 4517 4484 String not-regex constraint succeeds non-string actual value. Thanks to Michael Render for PR 4492 4450 Missing comparison failure details for EqualTo when comparing two collection. Thanks to Ashish Dawale for PR 4502 4423 Chaining multiple collection asserts with index. Thanks to Daniel Waechtler for PR 4480 4400 Within throws ArgumentException if null value is involved. Thanks to Ashish Dawale for PR 4482 4319 TextRunner accidentally disposes System.Out. Thanks to Norm Johanson for PR 4317 4308 Random attribute with Distinct and wide range causes test to disappear. Thanks to Russell Smith for PR 4316 4264 Assert.Multiple method should fail only if a contained assertion failed. Thanks to Samuel Delarosbil for PR 4313 4259 Bug: Assert.That(IEnumerable<Type>, Has.All.Property(nameof(Type.Namespace)) fails.. Fixed by team PR 4260 4255 InternalTrace.Initialize fails with Nullref exception. Fixed by team PR 4256 4246 Stack overflow when running tests on machine with Thai regional format. Fixed by team PR 4345 4243 Type args are not deduced correctly for parameterized fixtures. Thanks to Samuel Delarosbil for PR 4307 4237 Bogus check for Windows 11. Fixed by team PR 4374 4158 SetupFixture should have an AttributeUsage of Inherited = false. Thanks to TillW for PR 4222 4107 Incorrect type specified for Values attribute fails unrelated tests. Fixed by team PR 4133 4096 NUnit.Framework 3.13.2 introduced a breaking change that conceals problems with tests. Fixed by team PR 4133 3964 DictionaryContainsKeyValuePairConstraint doesn't work with IDictionary&lt;TKey, TValue&gt;. Thanks to Louis Zanella for PR 4014 3961 OneTimeTearDown runs on a new thread with mismatched Thread Name and Worker Id. Thanks to EraserKing for PR 4004 3953 Dispose is not called on test fixtures with LifeCycle.InstancePerTestCase without TearDown method. Fixed by team PR 3963 3872 Add support for ref bool, ref bool?, in bool, and in bool? when using NUnit.Framework.ValuesAttribute. Thanks to Samuel Delarosbil for PR 4304 3868 Order attribute skips classes with multiple test fixtures. Thanks to Samuel Delarosbil for PR 4304 3867 nunit Framework tests do not run with \"dotnet test\" nor inside VS2019 (Windows). Fixed by team PR 4315 3858 Running tests with ITestAction attributes leaks memory. Thanks to Marko Lahma for PR 4300 3811 Incorrect summary comments on Warn.If overloads. Fixed by team PR 3845 3735 Parallelizable TestFixtureSource with TestFixtureData not running in parallel. Thanks to Julien Richard for PR 4099 3449 Assert.AreEqual overloads for nullable double are not useful. Thanks to Anton Ashmarin for PR 3780 3274 Overridden tests are not discovered in NUnit 3.12.0. Fixed by team PR 4490 3215 Better error message for generic test where type parameter cannot be determined. Thanks to Ove Bastiansen for PR 4382 2870 CollectionTally (EquivalentTo) should throw for non-transitive comparisons. Thanks to Russell Smith for PR 4312 2841 DelayedConstraint calls delegate twice. Fixed by team PR 4488 2835 Control character encoding is inconsistent between TestCase[Source] and TestFixture[Source]. Fixed by team PR 4498 2436 Properties on System.Type cannot be used with either property constraint. Fixed by team PR 4259 1428 NUnitLite package always installs both Program.cs and Program.vb. Fixed by team PR 3952 Refactorings 4539 Upgrade to latest analyzers package and fix the warnings. 4434 Fixing the classic asserts. Fixed by team PR 4438 4416 Move classic asserts into its own project . Fixed by team PR 4417 4380 Consistently use _ prefix for field names. Fixed by team PR 4387 4378 Update code base to use 'is (not) null' consistently. Fixed by team PR 4379 4376 Update code base to explicitly specify accessibility. Fixed by team PR 4377 4364 Add NUnit.Analyzer to our test projects. Fixed by team PR 4366 4111 Is.Empty constraint on complex collections might hide bugs. Thanks to Felix Kr”ner for PR 4120 4051 Update codebase to use Array.Empty<T>. Thanks to Marcin Jedrzejek for PR 4127 3932 Make Numerics class internal. Thanks to TillW for PR 4205 Internal fixes 4503 Add NET8 target for the framework tests. Thanks to Ashish Dawale for PR 4511 4432 Fix null message in internal static string? ExtendedMessage(string methodName, string? message, string actualExpression, string constraintExpression). Fixed by team PR 4430 4331 Add testing to \"Accumulate further failures if any on AssertMultiple instead of throwing\". Thanks to Samuel Delarosbil for PR 4313 4212 Add Windows11 support to the Platform attribute. Fixed by team PR 4213 4170 Add .NET7 as a build target for the test suite . Fixed by team PR 4224 4078 THREAD_ABORT not properly set. Fixed by team PR 4079 4075 Remove unnecessary allocations in NUnitEqualityComparer. Fixed by team PR 4076 4072 Use pattern matching in Constraints to avoid unnecessary casts. Fixed by team PR 4073 4065 Use pattern matching in the comparers. Fixed by team PR 4066 4055 Use static Regex.IsMatch in ValueMatchFilter to take advantage of caching. Fixed by team PR 4056 4049 Simplify property retrieval in DefaultTestAssemblyBuilder.Build(). Thanks to Scott Buchanan for PR 4054 3935 Numerics.IsFixedPointNumeric should return false for decimals. Thanks to Wellington Balbo for PR 3942 3789 Change copyright header on files. Fixed by team PR 3795 3764 Switch to the dotnet tool version of Cake. Fixed by team PR 3835 3588 Audit string equality comparisons and consider changes for v4. Fixed by team PR 3770 2485 Remove\\Trim copyright on individual files. Fixed by team PR 3795 4504 Remove appveyor build. Fixed by team PR 4509 4465 Update cake version in build scripts. Fixed by team PR 4540 4036 Drop net45 build target in nunit4. Fixed by team PR 4050 3984 Add net6.0 targets. Fixed by team PR 3988 3980 Drop netcoreapp2.1 targets. Fixed by team PR 3988 3812 Add GitHub Actions. Fixed by team PR 3819 3764 Switch to the dotnet tool version of Cake. Fixed by team PR 3835 3758 Drop .NET 3.5 Build Targets. Fixed by team PR 3760 2485 Remove\\Trim copyright on individual files. Fixed by team PR 3795 Deprecated features 4415 Remove use of params for messages. Fixed by team PR 4419 4036 Drop net45 build target in nunit4. Fixed by team PR 4050 3980 Drop netcoreapp2.1 targets. Fixed by team PR 3988 3769 Remove code marked \"Obsolete\". Fixed by team PR 3836 3758 Drop .NET 3.5 Build Targets. Fixed by team PR 3760 3708 Drop .NET 4.0 Build Target. Fixed by team PR 3760 3410 Consider deprecating NUnitEqualityComparer.AreEqual optional bool parameter. Thanks to TillW for PR 3960 3132 Remove AssertionHelper and AssertionHelperTests. Fixed by team PR 3836 Others 3869 Copyright notices for third-party code. Thanks to Lennart Br\u0081ggemann for PR 4444 3301 [HandleProcessCorruptedStateExceptions] has no effect unless we disable partial trust. Fixed by team PR 4398 The following issues are marked as breaking changes 4416 Move classic asserts into its own project . Fixed by team PR 4417 4415 Remove use of params for messages. Fixed by team PR 4419 Also note that there are some breaking changes in the API for NUnit. Ref Issue 4610. Constraint.Description: It is now an abstract get property, earlier a virtual with protected setter. PrefixConstraint.DescriptionPrefix: It is now an abstract get property, earlier a virtual with protected setter. NUnit 3.14.0 - November 4, 2023 Total number of issues fixed in this release is : 16 Enhancements 4046 Backport .NET6 test infra + build improvements from #3984 onto v3.13 branch. Fixed by team PR 4077 ( backport of issue 3984) 4009 Performance degradation on many tests. Thanks to Marko Lahma for PR 4034 3859 Proper test result exception message when hitting TimeoutAttribute. Fixed by team PR 4118 3601 Nunit 3.10.1.0 + ReSharper 2020.1.4: Test execution delayed by ~60seconds . Thanks to Marko Lahma for PR 4034 2729 Proposal: Async test case sources. Fixed by team PR 4390 Bug fixes 4527 Backport: NUnit.Framework 3.13.2 introduced a breaking change that conceals problems with tests. Fixed by team PR 4104 ( backport of issue 4096 by pr 4133) 4525 Backport: SetupFixture should have an AttributeUsage of Inherited = false . Thanks to TillW for PR 4223 ( backport of issue 4158 by pr 4222) 4523 Backport: Stack overflow when running tests on machine with Thai regional format. Fixed by team PR 4346 ( backport of issue 4246 by pr 4345) 4324 Backport to v3: TextRunner accidentally disposes System.Out. Thanks to Norm Johanson for PR 4325 ( backport of issue 4319 by pr 4317) 4095 Is.SupersetOf and Is.SubsetOf no longer work with IImmmutableDictionary<TKey,TValue> in NUnit 3.13.3. Fixed by team PR 4097 3859 Proper test result exception message when hitting TimeoutAttribute. Fixed by team PR 4118 3710 Calling NUnitLite from LINQpad, can't parse assembly path. Thanks to Norm Johanson for PR 4325 2466 Missing stack trace when exception occurs during OneTimeSetUp. Fixed by team PR 4467 Refactorings None Internal fixes 4524 Backport: Add .NET7 as a build target for the test suite #4170. Fixed by team PR 4302 ( backport of issue 4170 by pr 4224) 4293 .NET5 Test Suite is failing on Azure DevOps for Windows. Fixed by team PR 4296 2973 Write up recommended way to test and link it from the readme. Thanks to Bruno Juchli for PR 2971 Deprecated features None The following issues are marked as breaking changes None NUnit 3.13.3 - March 20, 2022 This release includes several performance enhancements. @lahma provided a massive speed improvement for large, parametrized test suites. In addition, equivalency tests with large unsortable collections run faster by determining if the collections are sortable before attempting to sort them. We've added several fixes for .NET 6.0 and we've stopped testing NUnit against .NET Core 2.1 which is now out of support. There are also several fixes for the new FixtureLifeCycle feature and other smaller bug fixes and performance improvements. Issues Resolved 2963 Flakey tests in FrameworkControllerTests 3643 Assert.Pass(message) produces \"reason\" in XML-Result 3841 Breaking change: Is.SupersetOf with ValueTuple requires IComparable in NUnit 3.13.2 3843 IDisposable & InstancePerTestCase: Object created for OneTimeSetUp is not disposed 3898 NUnit 3.13.2 : LessThanOrEqualTo fails on a case which should succeed 3903 Backport race condition fix (PR 3883) 3904 Backport fix for \"IDisposable & InstancePerTestCase\" (PR 3843) 3929 Fix high precision decimal calculations in v3.13 (#3898) 3959 Marked 'NUnitEqualityComparer.AreEqual(object, object, Tolerance, bool)' as obsolete 3962 Ensure that AfterTest always runs in AfterTestCommand 3971 Backport \"Add missing [DoesNotReturn] annotations\" from #3958 3976 Equivalency fallback for non-IComparable types can leave CollectionTally in corrupt state 3998 Eagerly determine when a set is unsortable 3999 Numeric comparison fails when it should succeed. 4000 OverflowException comparing large double values 4007 Eagerly detect sortable types for equivalency tests in 3.13.x 4030 IsEmpty doesn't work with new .NET6 PriorityQueue 4032 Tests won't run with an abstract base class that has a TestCaseFixtureSource 4033 Recognized private members in base class for Source attributes 4034 Improve method discovery and filtering performance 4041 Minimize empty array allocations via centralized helper for pre-net46 4043 Stop testing the framework against netcoreapp21 in v3.13 branch 4045 Drop netcore2.1 as a target (backport #3986) 4058 Remove TopLevel property from ValueMatchFilter NUnit 3.13.2 - April 27, 2021 This release fixes a new issue with the FixtureLifeCycle attribute where IDisposable test fixtures were not being disposed properly. As always, @gleb-osokin has been a great help with this new feature. It also fixes a long-standing performance issue with CollectionAssert.AreEquivalent and the CollectionEquivalentConstraint when comparing large collections. The deep comparison that NUnit performs on the two collections will always have a worst case bound of O(n^2) but we have optimized it so that the majority of use cases will be closer to O(n). We've also made significant optimizations to the OR filters for selecting tests using their full name. This dramatically improves test performance for large code bases that use dotnet test. Thanks to @pakrym for his help with this. Issues Resolved 2799 CollectionAssert.AreEquivalent is extremely slow 3589 File headers, copyrights, and licenses 3773 IDisposable not working with InstancePerTestCase 3779 Obsolete AreEqual methods with nullable numeric arguments for 3.13 3784 Build the v3.13-dev branch 3786 NUnit with dotnet test results in O(n^2) filtering complexity 3810 Enable deterministic build 3818 AppVeyor failing to build v3.13-dev branch PRs 3832 Deploy v3.13-dev branch builds to MyGet NUnit 3.13.1 - January 31, 2021 This release addresses several misses with the new FixtureLifeCycle attribute, switches to using SourceLink and NuGet snupkg packages for debugging into NUnit from your unit tests. It also addresses issues with the time format of ignored and explicit tests in the test results file. Issues Resolved 2339 Wrong date format in Ignored TestFixtures 3715 FixtureLifeCycle(LifeCycle.InstancePerTestCase) Not working with TestFixtureSource 3716 Assembly level FixtureLifeCycle(LifeCycle.InstancePerTestCase) doesn't work 3724 Test start and end time should end with Z 3726 Assert EqualTo().Within().Seconds does not work with DateTimes in NUnit 3.13 3729 AppVeyor builds failing 3736 AreEqual.Within throws on failure with non-numeric types 3743 Parametrized tests do not respect FixtureLifeCycle.InstancePerTestCase 3745 After upgrading to NUnit 3.13.0 the debugger enters NUnit code despite having checked \"Enable Just My Code\" NUnit 3.13 - January 7, 2021 The FixtureLifeCycle attribute has been added to indicate that an instance for a test fixture or all test fixtures in an assembly should be constructed for each test within the fixture or assembly. This attribute may be applied to a test fixture (class) or to a test assembly. It is useful in combination with the Parallelizable Attribute so that a new instance of a test fixture is constructed for every test within the test fixture. This allows tests to run in isolation without sharing instance fields and properties during parallel test runs. This make running parallel tests easier because it is easier to make your tests thread safe. This release also fixes several issues running tests in .NET 5.0. If your tests target .NET 5.0, we recommend updating to this release. Issues Resolved 34 Async testing with F# 52 Self-contained item in array causes stack overflow 1394 Has.Property cannot see explicit interface implementation properties 1491 Add a CLA to the project 1546 NUnitEqualityComparer.GetEquatableGenericArguments should explicitly order arguments 1809 Assert.AreEqual fails for Complex on Linux 1897 EqualTo().Using() prevents caller from comparing strings to anything else 2211 Add support of indexers to the PropertyConstraint 2222 Switch to one Release branch 2477 Parameterized fixture with Explicit attribute can not be run when selected by name 2574 Instance-per-test-case feature 2680 Deprecate the DebugWriter class 3611 Properties are shown when --explore:nunit3 is run on entire project, but omitted when using the --where clause 3054 Don't enforce [Timeout] when debugger is attached 3075 Complete RunAsyncAction tests in FrameworkControllerTests 3228 Modulo bias is present in Randomizer.NextDecimal(decimal) 3240 Automate uploading of test results to Azure Pipelines 3243 Azure DevOps does not build release branch 3249 Pin GitLink version to speed up Cake script 3251 RawInt32() can't use Next since the maximum is always exclusive and it would never return int.MaxValue 3252 Timeout of 100 ms in TestTimeoutDoesNotStopCompletion occasionally fails the macOS build 3253 Chance of failure in random bias tests is not sufficiently low for CI 3256 Building under VS2019 3257 Running under mono 3259 The type of an Array isn't inferred from properly 3264 Test that IRepeatTest only gets attributes via the IMethodInfo interface 3275 Enable setting IgnoreUntilDate in TestCaseData.Ignore 3279 Improve failure message from UniqueItemsConstraint 3282 TimeoutAttribute makes all Assertions count as failure 3283 ExecutionContext is flowed between unrelated tests 3286 Testing for equality using a predicate throws exception for collections 3290 'Good first issue' or 'help wanted' issue count badge 3296 ExceptionHelper.GetExceptionMessage(Exception ex) should tolerate exceptions from exceptions 3302 Incorrect formatting of failure message if test fails with Assert.Multiple 3303 Check type of actual argument using consistent helper method 3304 CheckString should not be a generic method 3305 Remove unused methods 3307 Sporadic GetResultIsNotCalledUntilContinued failure 3308 Fix disposal in EnumerablesComparer 3309 Simplify code in EventListenerTextWriter 3311 Minimal unit of DateTime in the report when Test was started/ended 3312 Simplify ProviderCache and make it instantiable since it is intentionally not thread safe 3315 Assert.DoesNotThrow() stopped working as it was previously 3318 Fix AwaitAdapter terminology 3321 Keep dependencies up to date 3322 Speed up build script by removing unnecessary builds 3324 Broken link in CHANGES.md 3328 Problems when using a mixture of Not and Or filters in NUnit framework 3.12.0 3331 Contains.Key no longer working for IDictionary 3338 Azure Pipelines is failing on Linux for both netstandard 1.4 and 2.0 3356 SetUpFixture not run 3368 Tests with warnings are not added to console TestResult.xml total count 3383 Drop netstandard1.4 and stop testing on end-of-life versions of .NET Core 3389 Show names of parameters 3390 SetUpFixture not being triggered when running tests using --testlist 3392 Use of Thread.CurrentPrincipal in Blazor/WASM 3393 Nuget Package Not Signed 3395 Randomizer.NextString() can probably be sped up 3408 Save test results as build artifacts 3411 Update nuspec file to mention support for NET Standard 2.0+ 3414 Azure pipelines are failing on Linux 3415 Azure CI: Still publish test results on failure 3423 TestResult.cs casts ITestResult to TestResult 3447 Is.EqualTo(...).Using(StructuralComparisons.StructuralEqualityComparer or StructuralComparer) not working 3452 Assertions that use an existing Regex 3453 Visibility of SetUp/TearDown Methods 3454 Pre-Filtering in NUnitLite has problems 3464 Improve debugging experience 3470 Assertion for key-value-pair 3475 Our XML comments are using <code> (block element) instead of <c> (inline element) 3485 Should we make MultipleAssertException.TestResult maybe-null or obsolete two constructors? 3496 Adding data dictionary should not add a trailing newline 3497 Fix mixed line endings in Git 3503 Remove implicit cast from ITestResult to TestResult 3505 Better failure messages for Subset and Superset constraints 3506 ValueTuple tests now running if not targeting NET35 3536 Reduce newly added API surface 3542 Update NuGet Package Icons 3547 DelayedConstraint constrains does not preserve original result additional information 3551 Add PrivateAssets=\"all\" to analyzer dependency 3552 MessagePumpStrategy does not work for WPF on netcoreapp3.0 and upwards 3559 Disables the DOC100 suggestion and reverts the added paragraph elements 3563 Improve TextMessageWriter output for numeric values 3565 .NET 5 issue with PlatformAttribute 3583 Avoid using a culture-sensitive EndsWith in common code 3592 Add classname and methodname to the start-test event 3594 Reduce memory overhead of TestNameGenerator 3596 AreAlmostEqualUlps throws OverflowException for -0 3598 Fix typo 3608 [Platform] attribute fails with DllNotFoundException in WASM 3616 Extend Is.Empty to work for Guid.Empty 3618 NUnit has a P/Invoke whose native function doesn't exist on all platforms 3622 EmptyDirectoryConstraint doesn't need to enumerate entire directory contents 3632 Assert.Inconclusive() reports failed when timeout used 3636 NUnitLite filtering fails if space in test name before ( 3641 Type implementing IComparable<float> (or any IComparable) fails comparison. 3647 Fix exception under Blazor 5 3650 Build issue with the latest .NET SDK 5.0.100-rc.2 3657 Add Framework Version to the XML 3662 TestContext.CurrentContext.CurrentRepeatCount only contains retry count not the repeat count 3667 Create FrameworkPackageSetting to set CurrentCulture and CurrentUICulture 3676 Parallelizeable tests sometimes shares memory 3679 Issue 3390: Do not prefilter relevant SetUpFixtures 3694 Async tests causes double failure messages 3699 Compilation of netcoreapp3.1 targets fails on CI (both AppVeyor and Azure Pipelines) NUnit 3.12 - May 14, 2019 This release of NUnit finally drops support for .NET 2.0. If your application still targets .NET 2.0, your tests will need to target at least .NET 3.5. Microsoft ended support for .NET 2.0 on July 12, 2011. Microsoft recommends that everyone migrate to at least .NET Framework 3.5 SP1 for security and performance fixes. This release dramatically improves NUnit support for async tests including returning ValueTask and custom tasks from tests, improved handling of SynchronizationContexts and better exception handling. The .NET Standard 2.0 version of NUnit continues to gain more functionality that is found in the .NET 4.5 version of the framework like setting the ApartmentState and enabling Timeout on tests. Issues Resolved 474 TypeHelperTests.cs is orphaned 999 Support multiple TestOf attributes per test 1638 TimeoutAttribute not available when targeting netcoreapp framework 2168 ThrowsAsync reports OperationCanceledException as TaskCanceledException 2194 How to use Contains.Substring with And 2286 Add support for custom Task (i.e. ValueTask) 2579 AppVeyor Test Failures under .NET 3.5 2614 TestExecutionContext.CurrentContext is saved in Remoting CallContext between test runs 2696 Getting WorkerId fails in debug 2772 Random failing of parallel test run: Unhandled Exception: System.InvalidOperationException: Stack empty. 2975 ComparisonConstraints are allocating string on construction 3014 Timeout failures on MacOS 3023 NUnit runner fails when test method returns ValueTask<> 3035 Apartment state can't be used for .NET Standard 2.0 tests 3036 Apartment state can't be used for .NET Standard 2.0 tests 3038 TestName in TestCase attribute not validated to be not empty 3042 RequiresThreadAttribute allows ApartmentState.Unknown, unlike ApartmentAttribute 3048 Add .idea folder to .gitignore 3053 Conversion from TestCase string parameter to DateTimeOffset 3059 Constraint Throws.Exception does not work with async return value 3068 First Chance Exception in RuntimeFramework 3070 End support for .NET Framework 2.0 (released in 2005) 3073 CollectionAssert.AreEquivalent fails for ValueTuple Wrapped Dictionary 3079 Regression from 3.10 to 3.11: Range in bytes 3082 Is.Ordered.By 3085 XML Test-Suite Assembly does not contain DLL path anymore 3089 Remove outdated comment 3093 Tests having TaskLike objects as their return type throws Exception 3094 Bad error message if collections have different types 3104 Removed NET20 compile output 3105 Add tests for use of ApartmentState.Unknown in RequiresThreadAttribute 3107 Declare class in Program.cs provided with NUnitLite Nuget package static 3109 Azure DevOps build fails in Save package artifacts 3124 Switch copyright notice 3128 Correct documentation on ParallelScope 3137 Fix doc-comments in NUnitTestAssemblyRunner 3138 Assert.Ignore breaks when a Task is returned w/o using async/await 3139 Add Azure pipelines badge to front page 3144 Retry attribute should not derive from PropertyAttribute 3145 Capture additional exception details in the test output 3156 UnexpectedExceptionTests should tolerate Mono on Azure DevOps Ubuntu 3159 Make tests more tolerant 3161 https url repo 3166 Allow static SetUpFixture classes 3171 Incorrect type for Test Fixtures when using running explore with a filter 3175 Improve user-facing messages 3181 Template Based Test Naming - Incorrect truncation for individual arguments 3186 Fix licenseUrl element in nuspec, will be deprecated 3193 Cake Build Fails with Visual Studio 2019 3195 Drop or at least make Travis not required? 3231 Breaking change in filter functionality between framework 2.7 and 3.11 3209 Test fail when posting to SynchronizationContext.Current 3211 Fix logging 3218 Remove to-dos from the code base 3222 Our build script tests hang when run with Mono on Windows 3233 AndConstraint should write additional information from failed constraint NUnit 3.11 - October 6, 2018 More informative assertion messages PlatformAttribute is available on and now detects .NET Core ValuesAttribute now works with nullable types Async tests detecting and running Windows Forms or WPF message pumps rather than deadlocking Support for UWP 10.0 is back via .NET Standard 1.4 Issues Resolved 352 Test with infinite loop in TearDown cannot be aborted 452 Deprecate the existing Chocolatey framework package 660 Order dependence of And and Or constraints should be documented 1200 async test + Apartment(ApartmentState.STA) => await not returning on STA thread 2123 Task.Run inside a test will result in deadlock if a control was created previously 2146 Assert.That with a Throws constraint does not provide as much info as Assert.Throws 2427 PropertyConstraint throws away the more helpful message in the base constraint result 2432 Ability to exclude/include the platform .NET Core 2450 NullReferenceException in ExceptionHelper.BuildMessage on Mono 2536 SetArgDisplayNames for TestCaseData and TestFixtureData 2611 Enable .NET Standard 1.6 tests on non-Windows 2693 Ensure that ReSharper settings are consistent with the editorconfig configuration 2757 Broken char comparison in v3.7 and higher 2759 Test fails with \"No arguments were provided\" error when no values returned from IParameterDataSource 2761 Infinite loop in nunit 3.9 2781 Fixed pre-compiler typo 2786 Timeout value not resetting on Retry of failed test 2790 Removing ITypeInfo abstraction 2798 [Request] Show actual count value when test fail on Has.Exactly(x).Items 2814 Remove public marker types 2819 Only run AppVeyor PR build against open PRs 2821 Save and restore the SynchronizationContext before and after each test case 2823 SetUp failed for test fixture - Array was not a one-dimensional array. Issue seems related to byte[,] method parameters 2829 Obsoletion warning for DataAttribute 2831 Regular \"BusyExecIdle after 200 milliseconds delay\" CI failures 2833 Use longer BusyExecIdle to avoid CI failures 2836 NUnit.Framework.Does cannot be extended 2837 DictionaryContainsKeyConstraint behavior is inconstant with Dictionary.ContainsKey when the dictionary uses a custom Comparer 2842 Supporting inheritance of Assert and related classes 2854 Has.All.../Has.None... - show non-matching items in error message 2863 Make tests robust without depending on the order of attributes 2867 Skip executing TestCaseSources for tests which are not included in the filter 2876 Implement Discovery-time filtering for NUnitLite 2883 Our public ConcurrentQueue causes type conflicts 2885 Copy/paste error in Assert.That documentation 2887 NETStandard 1.3 support dropped in NUnit 3.10 2896 Some tests are silently skipped on netstandard1.x since #2796 2898 AssemblyPath contains invalid characters 2901 Values attribute support for nullable bool and enum types 2923 Update outdated CategoryAttribute xml doc 2928 Improve error message on EmptyConstraint 2929 Added NUnit XML schemas 2940 Increase StackTracesAreFiltered amount to 5 2955 Potential threading issue in IsolatedContext 2965 NuGet Package : Add repository metadata. 2970 InvalidCastException @ NUnit.Framework.TestFixtureSourceAttribute.BuildFrom 2979 Warn.If in Assert.Multiple 2994 Error in .NET Standard 1.4 DictionaryContainsKeyConstraint MetadataToken compatibility methods 2996 Remove unused enum 3009 Fix failing CI Builds by upgrading to NUnit Console 3.9.0 3020 Upgrade nunit-vs-adapter to 3.10 for nUnit 3.11 3024 Unable to add .IgnoreCase modifier to an AnyOf constraint in collection constraints 3032 APIs to restore before 3.11 NUnit 3.10.1 - March 12, 2018 Added a namespace to the props file included in the NuGet package to make it compatible with versions of Visual Studio prior to VS 2017. NUnit 3.10 - March 12, 2018 This release adds a .NET Standard 2.0 version of the framework which re-enables most of the features that have been missing in our earlier .NET Standard builds like parallelism, timeouts, directory and path based asserts, etc. It also contains numerous bug fixes and smaller enhancements. We've improved our XML docs, fixed performance issues and added more detail to Multiple Asserts. This release also contains source-indexed PDB files allowing developers to debug into the NUnit Framework. This allows you to track down errors or see how the framework works. In order to support the .NET Standard 2.0 version, the NUnit project switched to the new CSPROJ format and now requires Visual Studio 2017 to compile. This only effects people contributing to the project. NUnit still supports building and compiling your tests in older .NET IDEs and NUnit still supports older versions of the .NET Framework back to 2.0. For contributors, NUnit can now compile all supported targets on Windows, Linux and Mac using the Cake command line build. Issues Resolved 1212 Separate AssertionHelper project or assembly 1373 Setting with a null value 1382 Use array argument contents in name of parameterized tests rather than just array type. 1578 TestContext.CurrentTest exposes too much internal info 1678 Result Message: OneTimeSetUp: Category name must not contain ',', '!', '+' or '-' 1944 Removing Compact Framework workarounds 1958 System.Reflection.TargetInvocationException after run finished 2033 Nameof refactor 2202 Best practices for XML doc comments 2325 Retry attribute doesn't retry the test. 2331 Repo does not build in VS without running build -t build first 2405 Improve PropertyConstraint error output 2421 Publishing symbols with releases 2494 CollectionAssert.AllItemsAreUnique() very slow 2515 Re-target Solution to use the New CSPROJ Format 2518 Bug in CollectionAssert.AreEqual for ValueTuples. 2530 Running tests on main thread. Revisiting #2483 2542 NUnit does not support parallelism on .NET Core 2.0 2555 CI timeout: NUnit.Framework.Assertions.CollectionAssertTest.PerformanceTests 2564 Add minClientVersion to .nuspec files 2566 Refactor SimpleEnumerableWithIEquatable test object 2577 Warning in TearDown is inconsistent with Assertion failure 2580 Remove unused defines 2591 NUnitEqualityComparer.Default should be replaced with new NUnitEqualityComparer() 2592 Add .props with ProjectCapability to suppress test project service GUID item 2608 Culture differences on .NET Core on non-Windows causes test failures 2622 Fix flakey test 2624 Prevent emails for successful builds on Travis 2626 SetUp/TearDown methods are invoked multiple times before/after test in .NET Standard targeted projects 2627 Breaking change in CollectionAssert.AllItemsAreUnique with NUnit 3.9 2628 Error during installing tools when running build script 2630 Framework throws NullReferenceException if test parameter is marked with [Values(null)] 2632 Parallel tests are loading 100% CPU when nested SetUpFixture exists 2639 ValuesAttribute causes ExpectedResult to have no effect 2647 Add Current Attempt indicator in TestContext for use with RetryAttribute 2654 Address feedback from @oznetmaster 2656 NuGet package links to outdated license 2659 Naming Errors 2662 NullReferenceException after parallel tests have finished executing 2663 Building NUnit .NET 4.5 in VS2017 fails 2669 Removed vestigial build script helper method 2670 Invalid assemblies no longer give an error message 2671 Ensure that FailureSite.Child is used where appropriate. 2685 Remove Rebracer file 2688 Assert.Throws swallows console output 2695 MultipleAssertException doesn't provide proper details on failures 2698 Syntax suggestions errors as warnings 2704 Add Constraint to test whether actual item is contained in expected collection 2711 NUnitLite: Add support for --nocolor option 2714 AnyOfConstraint enumerates multiple times 2725 Enable 'strict' compilation flag 2726 Replace the ConcurrentQueue and SpinWait compatibility classes 2727 Avoid treating warnings as errors inside the IDE 2734 TestCaseAttribute: ExpectedResult should support same value conversion as normal method arguments 2742 FailureSite not correctly set on containing suites when tests are ignored. 2749 Update Travis SDK versions NUnit 3.9 - November 10, 2017 This release addresses numerous parallelization issues that were introduced in 3.8 when method level parallelization was added. Most of the parallelization issues resolved were tests never completing when using some combinations of parallel tests and ApartmentState not being properly applied to tests in all cases. Issues Resolved 893 Inconsistent Tuple behavior. 1239 NUnit3 sometimes hangs if SetUpFixtures are run in parallel 1346 NullReferenceException when [TestFixtureSource] refers to data in a generic class. 1473 Allow Is.Ordered to Compare Null Values 1899 Constraint Throws.Exception does not catch exception with async lambdas 1905 SetupFixture without namespace will make assembly-level Parallelizable attribute useless 2091 When a native exception of corrupted state is thrown, nunit test thread crashes and the nunit-console process hangs 2102 NUnitLite incorrectly reports Win 10 OS name 2271 When CollectionAssert.AreEqual do compare each element, it will ignore the IEquatable of the element too 2289 ResolveTypeNameDifference does not handle generic types well 2311 Resolve test projects' namespace situation 2319 Add .editorconfig to set file encodings so that people don't have to think about it 2364 Parallelizable attribute not invalidating invalid parallel scope combinations 2372 Create testing for compounded ConstraintFilters 2388 Parallelization causes test cases to stop respecting fixture's apartment state 2395 NUnit 3.8+ does not finish running tests 2398 NUnit CI spurious failures, NUnit.Framework.Internal.ThreadUtilityTests.Kill 2402 --labels=All doesn't show anything in console output executing NUnitLite Console Runner 2406 Summary descriptions replaced by more detailed ones 2411 And constraint on Has.Member throws 2412 Using fluent syntax unintentionally removed in 3.8 2418 Support equality comparison delegate 2422 Has.Property causes AmbiguousMatchException for shadowing properties 2425 XML doc typo fix 2426 Regression in 3.8.1: ApartmentAttribute no longer works when applied to an assembly 2428 Fix NullReferenceExceptions caused by WorkItemQueue not being thread-safe 2429 Stack trace shown for Assert.Warn 2438 [Parallelizable] hangs after a few tests 2441 Allows to override load-time/execution-time interfaces in built-in tests attributes 2446 CI failure in mono Warning tests 2448 Inherited Test SetUp, TearDown, etc. are not executed in .NET Core if they are not public 2451 Compile RegEx to improve performance 2454 SetUpFixture not respecting NonParallelizable tag on TestFixtures. 2459 [Parallelizable(ParallelScope.Children)] Unable to finish tests 2465 Possible wrong properties are returned by reflection in ReflectionExtensions.cs 2467 Test execution hangs when using [SetUpFixture] with NUnit 3.8.x 2469 Allow RangeAttribute to be specified multiple times for the same argument 2471 Parametrized test cases not running in parallel 2475 Framework incorrectly identifies Win 10 in xml results 2478 Attributes on SetUpFixture are not applied 2486 Message when asserting null with Is.EquivalentTo could be more helpful 2497 Use ConstraintUtils.RequireActual through out the codebase 2504 Support changing test display name on TestFixtureData 2508 Correct divergence from shadowed Is / Has members. 2516 When test writes something to the stdErr there is no guaranteed way to link a test-output event to a target test using ITestEventListener 2525 Remove unwanted space from comment 2526 SerializationException in low trust floating point equality test 2533 Matches<T>(Predicate<T>) throws ArgumentException or Fails when actual is null 2534 SetUpFixture causes NUnit to lock with Apartment( STA ) 2551 CollectionItemsEqualConstraint is missing Using(Func<T, T, bool>) 2554 Made TestFixtureData.SetName internal for 3.9 NUnit 3.8.1 - August 28, 2017 This release fixes two critical regressions in the 3.8 release. The first caused the console runner to crash if you are using test parameters. The second issue caused collection constraints checking for multiple items in a collection to fail. Issues Resolved 2386 Contains.Item() fails for collections in NUnit 3.8 2390 Missing value attribute in test parameters setting causes NullReferenceException in console NUnit 3.8 - August 27, 2017 This release removes several methods and attributes that were marked obsolete in the original 3.0 release. Support for iOS and Android has been improved. An issue that caused unit tests to run slower was addressed as was a bug that prevented the use of Assert.Multiple in async code. The Order attribute can now also be applied to the class level to set the order that test fixtures will be run. Issues Resolved 345 Order of Fixture Execution 1151 Include differences in output for Is.EquivalentTo 1324 Remove CollectionContainsConstraint 1670 Attaching files to the test result 1674 InRange-Constraint must work with object 1851 TestCaseSource unable to pass one element byte array 1996 Timeout does not work if native code is running at the time 2004 Has.One as synonym for Has.Exactly(1).Items 2062 TestCaseSource attribute causes test to pass when source is not defined 2144 Allow option on RandomAttribute to produce distinct values 2179 Some NUnit project's tests fail on systems with CultureInfo other than en 2195 Contains.Substring with custom StringComparison 2196 Expose ParallelizableAttribute (and other attribute) constructor arguments as properties 2201 Invalid platform name passed to PlatformAttribute should mark test NotRunnable 2208 StackFilter trims leading spaces from each line 2213 SetCultureAttribute: CultureInfo ctor should use default culture settings 2217 Console runner performance varies wildly depending on environmental characteristics 2219 Remove Obsolete Attributes 2225 OneTimeTearDown and Dispose Ordering 2237 System.Runtime.Loader not available for iOS/Android 2242 Running tests directly should never surface a NullReferenceException 2244 Add KeyValuePair<TKey, TValue> to the default formatters 2251 Randomizer.NextGuid() 2253 Parallelizable(ParallelScope.Fixtures) doesn't work on a TestFixture 2254 EqualTo on ValueTuple with Nullable unexpected 2261 When an assembly is marked with ParallelScope.None and there are Parallelizable tests NUnit hangs 2269 Parallelizable and NonParallelizable attributes on setup and teardown silently ignored 2276 Intermittent test failures in Travis CI: TestContextTests 2281 Add type constraint for Throws and any method requiring Exception 2288 Killing thread cancels test run 2292 Is.Ordered.By() with a field throws NullReferenceException 2298 Write TestParametersDictionary to xml result file in readable format 2299 NUnitLite NuGet package no longer installs NUnit NuGet package 2304 Revert accidental doc removal 2305 Correct misprint \".con\" -> \".com\" 2312 Prevent crash on invalid --result parsing in NUnitLite 2313 Incorrect xml doc on RetryAttribute 2332 Update build script to use NUnitConsoleRunner v3.7.0 2335 Execute OneTimeTearDown as early as possible when running fixtures in parallel 2342 Remove deprecated Is.String* Constraints 2348 Can't use Assert.Multiple with async code 2353 Provide additional Result information through TestContext 2358 Get framework to build under Mono 5.0 2360 Obsolete CollectionContainsConstraint Constructors 2361 NUnit Parallelizable and OneTimeSetUp with no namespace results in single-threaded test execution 2370 TestCaseAttribute can't convert int to nullable long NUnit 3.7.1 - June 6, 2017 This is a hotfix release that addresses occasional hangs when using test parallelization and fixes crashes in NCrunch prior to version 3.9. Issues Resolved 2205 NCrunch: System.Xml.XmlException: Root element is missing, when adding NUnit 3.7.0 2209 NUnit occasionally hangs when parallelizable TestFixture has OneTimeSetUp and OneTimeTearDown NUnit 3.7 - May 29, 2017 This release of NUnit expands on parallel test execution to allow test methods to be run in parallel. Please see the Parallelizable Attribute for more information. NUnit 3.7 also drops the Portable build of the framework and replaces it with a .NET Standard 1.3 version to compliment the .NET Standard 1.6 version. This change enables several constraints and other features in the .NET Standard builds that weren't available in portable like Path and Directory based asserts. The AssertionHelper class has been deprecated because it is seldom used and has not received any of the updates that Asserts and Constraints receive. If your code is using the AssertionHelper class, we recommend that you migrate your asserts. Issues Resolved 164 Run test methods within a fixture in parallel 391 Multiple Assertions 652 Add ability to execute test actions before SetUp or OneTimeSetUp 1000 Support multiple Author attributes per test 1096 Treat OneTimeSetup and OneTimeTearDown as separate work items 1143 NUnitLite - Explore flag does not apply where filter to output 1238 Feature request: Print LoaderExceptions when fixture loading fails 1363 Make Timeouts work without running test on its own thread 1474 Several SetUpFixtures at the same level may be active at the same time 1819 TestContext.Progress.Write writes new line 1830 Add --labels switch changes to NUnitLite and NUnitLite tests 1859 ConcurrentQueue is duplicate with System.Threading.dll package 1877 Resolve differences between NUnit Console and NUnitLite implementations of @filename 1885 Test parameter containing a semicolon 1896 Test has passed however Reason with an empty message is printed in the xml 1918 Changing DefaultFloatingPointTolerance breaks tests running in parallel 1932 NUnit Warn class should be removed from stack trace by filter 1934 NullReferenceException when null arguments are used in TestFixtureAttribute 1952 TestContext.Out null when used in task with .NET Core 1963 Investigate removing SpecialValue 1965 TestContext does not flow in async method 1971 Switch CHANGES.txt to Markdown 1973 Implemented TestExecutionContext to use AsyncLocal<> for NETSTANDARD1_6 1975 TestFixtureSource doesn't work with a class that has no namespace 1983 Add missing ConstraintExpression.Contain overload 1990 Add namespace filter 1997 Remove unused --verbose and --full command line options 1999 Author Tests assume ICustomAttributeProvider.GetCustomAttributes return order is defined 2003 Better user info about ParallelizableAttribute and ParallelScope 2005 Exclude empty failure messages from results xml 2007 3.6 Multiple assertion backwards compatibility 2010 Add DelayedConstraint in NetStandard 1.6 build 2020 Better message when timeout fails 2023 Ability to abort threads running a message pump 2025 NullReferenceException using Is.EqualTo on two unequal strings 2030 Add method to mark tests as invalid with a reason 2031 Limit Language level to C#6 2034 Remove SilverLight project - no longer used 2035 NullReferenceException inside failing Assert.That call 2040 Cannot catch AssertionException 2045 NUnitLite-runner crashes if no file is provided 2050 Creation of TestExecutionContext should be explicit 2052 NullReferenceException with TestCaseSource if a property has no setter 2061 TestContext.WorkDirectory not initialized during build process 2079 Make TestMethod.Arguments public or otherwise accessible (e.g. TestContext) 2080 Allow comments in @FILE files 2087 Enhance error message: Test is not runnable in single-threaded context. Timeout 2092 Convert Portable library to .NET Standard 1.3 2095 Extend use of tolerance to ComparisonConstraints 2099 Include type in start-suite/start-test report elements 2110 NullReferenceException when getting TestDirectory from TestContext 2115 Mark AssertionHelper as Obsolete 2121 Chained PropertyConstraint constraints report incorrect ActualValue 2131 Remove \"Version 3\" suffix from NUnitLite NuGet Package 2132 TestFixtureTests.CapturesArgumentsForConstructorWithMultipleArgsSupplied assumes order of custom attributes 2143 Non-parallel fixture with parallel children runs in parallel with other fixtures 2147 Test Assembly using NUnitLite & NUnit 3.6.1 hangs under .NET Core when --timeout is supplied on command line 2150 Add portable-slow-tests to Cake file 2152 Allow attaching files to TestResults 2154 Fix execution of non-parallel test fixtures 2157 Getting WorkerId inside Assert.Throws / DoesNotThrow returns null instead of previous non-null value 2158 Update SetupFixtureAttribute XML Docs 2159 Prevent crash in .NET standard with log file path 2165 Trying to install NUnit 3.6.1 on .NET Framework asks for download of 20 more packages 2169 Incorrect xml docs for SetUpAttribute 2170 Cake build fails if only Visual Studio 2017 installed 2173 Remove PreTestAttribute and PostTestAttribute 2186 Replace special characters as part of converting branch names to package versions 2191 System.Reflection.TargetInvocationException with nunit3-console --debug on Mono NUnit 3.6.1 - February 26, 2017 This is a hotfix release of the framework that addresses critical issues found in the 3.6 release. Issues Resolved 1962 A Theory with no data passes 1986 NUnitLite ignores --workers option 1994 NUnitLite runner crashing when --trace is specified 2017 Two NUnit project's tests fail on systems with comma decimal mark settings 2043 Regression in 3.6.0 when catching AssertionException NUnit 3.6 - January 9, 2017 This release of the framework no longer includes builds for Compact Framework or for SilverLight, but adds a .NET Standard 1.6 build. If anyone still using Compact Framework or SilverLight and would like to continue development on those versions of the framework, please contact the NUnit team. Framework .NET Standard 1.6 is now supported Adds support for Multiple Assert blocks Added the --params option to NUnitLite Theories now support Nullable enums Improved assert error messages to help differentiate differences in values Added warnings with Warn.If(), Warn.Unless() and Assert.Warn() Enabled Path, File and Directory Asserts/Constraints for .NET Core testing Added NonTestAssemblyAttribute for use by third-party developers to indicate that their assemblies reference the NUnit framework, but do not contain tests Issues Resolved 406 Warning-level Assertions 890 Allow file references anywhere in the command line. 1380 AppVeyor Failures when branch name is too long 1589 Split the nunit repository into multiple repositories 1599 Move Compact Framework to separate project 1601 Move SilverLight to a separate project 1609 Upgrade Cake build to latest version 1661 Create .NET Standard Framework Build 1668 Need implementation-independent way to test number of items in a collection 1743 Provide multiple results for a test case in the XML output 1758 No direct inverse for Contains.Key 1765 TestCaseSourceAttribute constructor for method with parameters 1802 Design Multiple Assert syntax as seen by users 1808 Disambiguate error messages from EqualConstraint 1811 Build.ps1 fails if spaces in path 1823 Remove engine nuspecs and old global.json 1827 Remove unused repository paths from repositories.config 1828 Add Retry for failed tests only 1829 NUnitLite accepts --params option but does not make any use of it. 1836 Support nullable enums in Theories 1837 [Request] AfterConstraint to support more readable usage 1840 Remove SL and CF #Defined source 1866 [Request] More readable way to set polling interval in After constraint 1870 EqualConstraint result failure message for DateTime doesn't show sufficient resolution 1872 Parameterized method being called with no parameter 1876 What should we do about Env.cs 1880 AttributeUsage for various Attributes 1889 Modify NUnitLite to display multiple assert information 1891 TestContext.Progress and TestContext.Error silently drop text that is not properly XML encoded 1901 Make NUnitLite-runner Prefer32Bit option consistent across Debug/Release 1904 Add .NET Standard 1.6 Dependencies to the Nuspec Files 1907 Handle early termination of multiple assert block 1911 Changing misleading comment that implies that every ICollection<T> is a list 1912 Add new warning status and result state 1913 Report Warnings in NUnitLite 1914 Extra AssertionResult entries in TestResults 1915 Enable Path, File and Directory Assert/Constraints in the .NET Standard Build 1917 Use of IsolatedContext breaks tests in user-created AppDomain 1924 Run tests using the NUnit Console Runner 1929 Rename zip and remove source zip 1933 Tests should pass if test case source provides 0 test cases 1941 Use dictionary-based property for test run parameters 1945 Use high-quality icon for nuspecs 1947 Add NonTestAssemblyAttribute 1954 Change Error Message for Assert.Equals 1960 Typo fixes 1966 Xamarin Runner cannot reference NUnit NuGet Package Earlier Releases Release Notes for NUnit 2.9.1 through 3.5 Release Notes for NUnit 2.6 through 2.6.4 Release Notes for NUnit 2.5 through 2.5.10 Release Notes for NUnit 2.4 through 2.4.8 Release Notes for NUnit 2.0 through 2.2.10"
  },
  "articles/nunit/running-tests/Console-Command-Line.html": {
    "href": "articles/nunit/running-tests/Console-Command-Line.html",
    "title": "Console Command Line | NUnit Docs",
    "summary": "Console Command Line The console interface runner is invoked by a command in the form NUNIT3-CONSOLE [inputfiles] [options] where inputfiles is one or more assemblies or test projects of a type that NUnit can process and options is zero or more options. Input files and options may be mixed in any order. Input Files The console program must always have an assembly or project specified. Assemblies are specified by file name or path, which may be absolute or relative. Relative paths are interpreted based on the current directory. In addition to assemblies, you may specify any project type that is understood by NUnit. Out of the box, this includes various Visual Studio project types as well as NUnit (.nunit) test projects (see NUnit Test Projects for a description of NUnit test projects). If the NUnit V2 framework driver is installed, test assemblies may be run based on any version of the NUnit framework beginning with 2.0. Without the V2 driver, only version 3.0 and higher tests may be run. Options Option Description @FILE Specifies the name (or path) of a FILE containing additional command-line arguments to be inserted at the point where the @FILE expression appears. Each line in the file represents one argument to the console runner. If an option takes a value, that value must appear on the same line. --test=FULLNAMES Comma-separated list of FULLNAMES of tests to run or explore. This option may be repeated. Note that this option is retained for backward compatibility. The --where option can now be used instead. --testlist=FILE The name (or path) of a FILE containing a list of tests to run or explore, one per line. May also include comment lines, indicated by # in the first column. --where=EXPRESSION An expression indicating which tests to run. It may specify test names, classes, methods, categories or properties comparing them to actual values with the operators ==, !=, =~ and !~. See Test Selection Language for a full description of the syntax. --testparam:PARAMETER, --tp:PARAMETER A test PARAMETER specified in the form NAME=VALUE for consumption by tests. Multiple parameters must be specified separated using a --testparam or --tp option for each. --params=PARAMETER, --p=PARAMETER (NOTE: this is deprecated and will be removed in a future release. Please use --testparam instead.) A test PARAMETER specified in the form NAME=VALUE for consumption by tests. Multiple parameters may be specified, separated by semicolons or by repeating the --params option multiple times. Case-sensitive. --config=NAME NAME of a project configuration to load (e.g.: Debug). --process=PROCESS PROCESS isolation for test assemblies. Values: Single, Separate, Multiple. If not specified, defaults to Separate for a single assembly or Multiple for more than one. By default, processes are run in parallel. --inprocess This option is a synonym for --process=Single --agents=NUMBER NUMBER of agents that may be allowed to run simultaneously assuming you are not running inprocess. If not specified, all agent processes run tests at the same time, whatever the number of assemblies. This setting is used to control running your assemblies in parallel. --domain=DOMAIN DOMAIN isolation for test assemblies. Values: None, Single, Multiple. If not specified, defaults to Single for a single assembly or Multiple for more than one. NOTE: None is an extremely rarely used option intended for cases where you are testing features that can only run in a primary domain; when choosing this option, you are responsible for copying all needed files, including NUnit components, into a common directory. --framework=FRAMEWORK FRAMEWORK type/version to use for tests. Examples: mono, net-4.5, v4.0, 2.0, mono-4.0. NOTE: Only use this option if you are sure all tests will run under the specified runtime. The option does not select a particular build from a project with multiple runtime targets. --x86 Run tests in a 32-bit process on 64-bit systems. NOTE: This option forces all tests to run as 32 bits. It is normally not needed since x86 test assemblies are automatically run as 32 bits. It is needed, however, when a non-x86 test assembly references an x86 assembly. --dispose-runners Dispose each test runner after it has finished running its tests --timeout=MILLISECONDS Set timeout for each test case in MILLISECONDS. --seed=SEED Set the random SEED used to generate test cases. --workers=NUMBER Specify the NUMBER of worker threads to be used in running tests. This setting is used to control running your tests in parallel and is used in conjunction with the Parallelizable Attribute. If not specified, workers defaults to the number of processors on the machine, or 2, whichever is greater. --stoponerror Stop run immediately upon any test failure or error. --skipnontestassemblies Skip any non-test assemblies specified - or assemblies containing NUnit.Framework.NonTestAssemblyAttribute, without error. --debug Causes NUnit to break into the debugger immediately before it executes your tests. This is particularly useful when the tests are running in a separate process to which you would otherwise have to attach. --debug-agent Available only in debug builds of NUnit, this option is for use by developers in debugging the nunit-agent itself. It breaks in the agent code immediately upon entry of the process. --pause Causes NUnit to immediately open a message box, allowing you to attach a debugger. For cases where --debug does not work. --wait Wait for input before closing console window. --work=PATH PATH of the directory to use for output files. --output, --out=PATH File PATH to contain text output from the tests. --result=SPEC An output SPEC for saving the test results. This option may be repeated. --explore[=SPEC] Display or save test info rather than running tests. Optionally provide an output SPEC for saving the test info. This option may be repeated. --noresult Don't save any test results. --trace=LEVEL Set internal trace LEVEL. Values: Off, Error, Warning, Info, Verbose (Debug) --labels=VALUE Specify whether to write test case names to the output. Values: Off, OnOutputOnly, Before, After, BeforeAndAfter, On, or All. If not specified, defaults to Off. Off: No labeling is used. Both normal and immediate output appear in the order produced - i.e. immediate first. OnOutputOnly: A label appears before each sequence of output lines from the same test. Since tests may be run in parallel, output from different tests may be intermixed. Before: A label appears at the start of every test, whether it produces output or not. Additional labels are produced as needed if interspersed output takes place, just as for --labels=OnOutputOnly. labels=After: A label appears at the end of every test, whether it produced output or not. This label includes the pass/fail status of the test in addition to its name. Additional labels are produced as needed if there is any output, just as for --labels=OnOutputOnly. BeforeAndAfter A label appears at the start and end of every test, whether it produced output or not. The label at the end of the test includes the pass/fail status of the test in addition to its name. Additional labels are produced as needed if interspersed output takes place, just as for --labels=OnOutputOnly. On. Synonym for --labels=OnOutputOnly, now deprecated (will be removed in a future release). All: Synonym for --labels=Before, now deprecated (will be removed in a future release). --test-name-format=VALUE Specify a non-standard naming pattern to use when generating all test names. See Template Based Test Naming. --encoding=CODEPAGE Specify the Console CODEPAGE, such as utf-8, ascii, etc. This option is not normally needed unless your output includes special characters. The page specified must be available on the system. --shadowcopy Tells .NET to copy loaded assemblies to the shadowcopy directory. --teamcity Turns on use of TeamCity service messages. --loaduserprofile Causes the user profile to be loaded in any separate test processes. --list-extensions Lists all extension points and the extensions installed on each of them. --set-principal-policy=POLICY Set the principal policy for the test domain to POLICY. Values: UnauthenticatedPrincipal, NoPrincipal, WindowsPrincipal --noheader, --noh Suppress display of program information at start of run. --nocolor, --noc Displays console output without color. --help, -h Display this message and exit. Description By default, this command runs the tests contained in the assemblies and projects specified. If the --explore option is used, no tests are executed but a description of the tests is saved in the specified or default format. Several options that specify processing of XML output take an output specification as a value. A SPEC may take one of the following forms: --OPTION:filename --OPTION:filename;format=formatname --OPTION:filename;transform=xsltfile Be aware that the semicolon (;) might need escaping in some terminals. The --result option may use any of the following formats: nunit3 - the native XML format for NUnit 3 nunit2 - legacy XML format used by earlier releases of NUnit The --explore option may use any of the following formats: nunit3 - the native XML format for NUnit 3 cases - a text file listing the full names of all test cases. If --explore is used without any specification following, a list of test cases is output to the console. If neither --result nor --explore is used, NUnit saves the results to TestResult.xml in nunit3 format. Any transforms provided must handle input in the native nunit3 format."
  },
  "articles/nunit/running-tests/Console-Runner.html": {
    "href": "articles/nunit/running-tests/Console-Runner.html",
    "title": "Console Runner | NUnit Docs",
    "summary": "Console Runner The nunit3-console.exe program is a text-based runner for listing and running our tests from the command-line. It is able to run all NUnit 3.0 or higher tests natively and can run NUnit 2.x tests if the v2 driver is installed. This runner is useful for automation of tests and integration into other systems. It automatically saves its results in XML format, allowing you to produce reports or otherwise process the results. The following is a screenshot of the console program output. In this example, nunit3-console has just run selected tests in the mock-nunit-assembly.exe assembly that is part of the NUnit distribution. This assembly contains a number of tests, some of which are either ignored or marked explicit. The summary line shows the result of the test run. Console Exit Codes The console will exit with zero if all tests pass, a positive number if there are any test failures, and a negative number in the case of any errors in running the test suite. The current exit codes used are summarized below: Exit code Meaning 0 All tests passed. Note that some tests may still have produced warnings -- those will be listed in the console output. 1-100 Some tests have failed. The exit code will reflect the number of test failures (capped at 100). -1 Invalid argument found on command line. -2 One of the assemblies passed into the console was found to be invalid. This may include assemblies which contain no tests. -3 No longer used. Previously used when a requested test fixture could not be found. -4 An invalid test fixture was found within the test suite. -5 No longer used. Previously used when the App Domain within which the tests were run could not be unloaded cleanly. This situation is now logged as a warning instead of an error, and will result in the console exiting zero. -100 An unexpected error occurred. This may indicate a bug within the test runner - please consider filing an issue on the nunit-console repository."
  },
  "articles/nunit/running-tests/Index.html": {
    "href": "articles/nunit/running-tests/Index.html",
    "title": "Running Tests | NUnit Docs",
    "summary": "Running Tests There are several ways to run your tests, depending on your needs. The most common way is to use one of the common IDEs, such as Visual Studio, Visual Studio Code or Rider, or to use dotnet test from the command line. All of these use different parts of the NUnit ecosystem to run your tests. The Microsoft tools use the NUnit3TestAdapter, whereas Jetbrains Rider use the NUnit.Engine. To start using NUnit with these tools, see the Installation section. Also see the information on the NUnit3TestAdapter for more detailed information on how to use it and configure it. In addition to these NUnit provides two special runners, the NUnit.Console and the NUnitLite runners, which are described below. The Console Runner, nunit-console.exe, is used for batch execution. The NUnitLite runner, nunitlite-runner.exe, is a light weight runner originally used internally in the team, but can be used by anyone who wants to have a simple way of running tests from the command line. Just for fun, to see how the different runners are being used, we can look at the nuget.org download statistics for each of the runners, per Oct 2023: Runner Downloads Comment NUnit3TestAdapter 211.4 million Used by Visual Studio, VS Code and dotnet test NUnit.Console 22.5 million NUnitLite 4.6 million Other runners The VSTest.Console is also a Microsoft runner, but it is less used now as dotnet test has taken over. It does use the NUnit3TestAdapter as well. The Azure Pipelines have some tasks for running tests, like VSTest, which also use the NUnit3TestAdapter under the hood. Some information on the internal working NUnit.Engine All runners except NUnitLite use the NUnit.Engine, including Rider. It should not be used alone, as the different runners have different requirements for how the engine is used and which version is being used. See Compatibility of the Test Adapter with the Test Engine for some more detailed information on this. NUnit Agent When running tests in a separate process, the console and gui runners make use of the NUnit Agent program, nunit-agent.exe. Although not directly run by users, nunit-agent does load and execute tests and users need to be aware of it, especially when debugging is involved. Additional Information For additional general information on how tests are loaded and run, see Runtime Selection Assembly Isolation Configuration Files Visual Studio Support"
  },
  "articles/nunit/running-tests/NUnit-Test-Projects.html": {
    "href": "articles/nunit/running-tests/NUnit-Test-Projects.html",
    "title": "NUnit Test Projects | NUnit Docs",
    "summary": "NUnit Test Projects Although you may simply enter multiple assembly names on the console command-line, running tests from multiple assemblies is facilitated by the use of NUnit test projects. These are files with the extension .nunit containing information about the assemblies to be loaded. The following is an example of a hypothetical test project file: <NUnitProject> <Settings activeconfig=\"Debug\"/> <Config name=\"Debug\"> <assembly path=\"LibraryCore\\bin\\Debug\\Library.dll\"/> <assembly path=\"LibraryUI\\bin\\Debug\\LibraryUI.dll\"/> </Config> <Config name=\"Release\"> <assembly path=\"LibraryCore\\bin\\Release\\Library.dll\"/> <assembly path=\"LibraryUI\\bin\\Release\\LibraryUI.dll\"/> </Config> </NUnitProject> This project contains two configurations, each of which contains two assemblies. The Debug configuration is currently active. By default, the assemblies will be loaded using the directory containing this file as the ApplicationBase. The PrivateBinPath will be set automatically to LibraryCore\\bin\\Debug;LibraryUI\\bin\\Debug or to the corresponding release path. XML attributes are used to specify non-default values for the ApplicationBase, Configuration File and PrivateBinPath. The Project Editor may be used to create or modify NUnit projects. If you edit the XML manually, you should make sure to use a path relative to the directory containing the project file as the location of any assemblies. For details, see NUnit Project XML Format Command-line Overrides The following command-line options override what is specified in the NUnit project file: --config --domain --process --framework"
  },
  "articles/nunit/running-tests/NUnitLite-Options.html": {
    "href": "articles/nunit/running-tests/NUnitLite-Options.html",
    "title": "NUnitLite Options | NUnit Docs",
    "summary": "NUnitLite Options The NUnitLite runner is invoked by executing the test program. If desired, any of the following options may be specified: Option Description --test=NAMES Comma-separated list of NAMES of tests to run or explore. This option may be repeated. --testlist=PATH File PATH containing a list of tests to run, one per line. This option may be repeated. --prefilter=NAMES Comma-separated list of NAMES of test classes or namespaces to be loaded. This option may be repeated. --where=EXPRESSION Test selection EXPRESSION indicating what tests will be run. --params, -p=VALUE Define a test parameter. --timeout=MILLISECONDS Set timeout for each test case in MILLISECONDS. --seed=SEED Set the random SEED used to generate test cases. --workers=NUMBER Specify the NUMBER of worker threads to be used in running tests. If not specified, defaults to 2 or the number of processors, whichever is greater. --stoponerror Stop run immediately upon any test failure or error. --wait Wait for input before closing console window. --work=PATH PATH of the directory to use for output files. If not specified, defaults to the current directory. --output, --out=PATH File PATH to contain text output from the tests. --err=PATH File PATH to contain error output from the tests. --result=SPEC An output SPEC for saving the test results. This option may be repeated. --explore[=SPEC] Display or save test info rather than running tests. Optionally provide an output SPEC for saving the test info. This option may be repeated. --noresult Don't save any test results. --labels=VALUE Specify whether to write test case names to the output. Values: Off, On, All --test-name-format=VALUE Non-standard naming pattern to use in generating test names. --teamcity Turns on use of TeamCity service messages. --trace=LEVEL Set internal trace LEVEL. Values: Off, Error, Warning, Info, Verbose (Debug) --noheader, --noh Suppress display of program information at start of run. --nocolor, --noc Displays console output without color. --help, -h Display this message and exit. --version, -V Display the header and exit. Description By default, this command runs the tests contained in the assemblies and projects specified. If the --explore option is used, no tests are executed but a description of the tests is saved in the specified or default format. Test Selection Several options allow selection of a subset of the tests in an assembly for execution or display. The --prefilter option operates first. If specified, it limits the classes, which NUnit will examine to find tests. Classes not included are simply ignored and the other two selection options never even see them. The --where option introduces a where clause, the most flexible but also the most complex way to introduce tests. See the documentation of Test SelectionLanguage for details. The --test and testlist options allow selecting individual tests by name. The list of tests selected is joined to any --where clause you provide by a logical and operation. That is, if both --test and --where are specified, both must be satisfied by a test in order for it to run. XML Output Several options that specify processing of XML output take an output specification as a value. A SPEC may take one of the following forms: --OPTION:filename --OPTION:filename;format=formatname Be aware that the semicolon (;) might need escaping in some terminals. The --result option may use any of the following formats: nunit3 - the native XML format for NUnit 3.0 nunit2 - legacy XML format used by earlier releases of NUnit The --explore option may use any of the following formats: nunit3 - the native XML format for NUnit 3.0 cases - a text file listing the full names of all test cases. If --explore is used without any specification following, a list of test cases is output to the console. If none of the options (--result, --explore, --noxml) is used, NUnit saves the results to TestResult.xml in nunit3 format."
  },
  "articles/nunit/running-tests/NUnitLite-Runner.html": {
    "href": "articles/nunit/running-tests/NUnitLite-Runner.html",
    "title": "NUnite Lite Runner | NUnit Docs",
    "summary": "NUnite Lite Runner NUnitLite started out life as a separate version of the NUnit framework, with fewer features and a built-in test runner. It ran on devices as well as on desktop .NET and mono and allowed users to create executable tests without the overhead of a full NUnit installation. With NUnit 3.0, the NUnitLite framework has been merged with the full NUnit framework. There is now only one framework, nunit.framework.dll. The built-in runner, which was a part of the old NUnitLite, is now packaged as nunitlite.dll. Using NUnitLite To run tests under NUnitLite, proceed as follows: You can use your existing unit test project (created with the dotnet new nunit command or from Visual Studio) or create a new console application. If you use an existing test project you will get a warning about duplicate entry points. This can be ignored. Using a standard test project has the benefit that you can use both the standard dotnet test command, the Visual Studio Test Explorer and the NUnitLite runner to run your tests. Make sure your test assembly references both nunit.framework and nunitlite. <PackageReference Include=\"NUnitLite\" Version=\"4.0.1\" /> <PackageReference Include=\"NUnit\" Version=\"4.0.1\" /> Optionally you can set the OutputType in a PropertyGroup to Exe, which allows you to run the tests directly and without the dotnet run. <OutputType>Exe</OutputType> Add a Program.cs containing a top level statements main routine like: using NUnitLite; return new AutoRun().Execute(args); If you don't use top-level statements, then just create a standard main routine with the same code. Execute your test application in order to run the tests. dotnet run If you install the NUnitLite runner via the NuGet package, steps 2 is handled automatically. Both assemblies are installed and referenced for you. NUnitLite Output As seen in the following screen shot, the output from an NUnitLite run is quite similar to that from the console runner. Tips Testing an executable application When testing an executable application, you can use the NUnitLite runner to execute your tests. However, this approach will result in having two Main methods in your application. To resolve this, you need to specify which Main method to use — specifically, the Main method from the test project. You do this by stating which class contains this method. You do this by adding a StartupObject to your project file: <StartupObject>TestProject.Program</StartupObject>"
  },
  "articles/nunit/running-tests/Template-Based-Test-Naming.html": {
    "href": "articles/nunit/running-tests/Template-Based-Test-Naming.html",
    "title": "Template-Based Test Naming | NUnit Docs",
    "summary": "Template-Based Test Naming NUnit uses a standard naming convention for all tests, which in the language described below corresponds to {m}{a}. The most used runners, Visual Studio and dotnet depends on this being the default, and trying to change this will cause display issues in these runners. We strongly recommend you to NOT change the test naming. If you still want to do it However, if you're out on your own, the naming can be overridden by the user if required. TestName generation is driven by a name formatting string, which may contain any of the following format specifiers: {n} The namespace of the test or empty if there is no namespace. If empty, any immediately following '.' is ignored. {c} The class name of the test or empty if there is no class. This name includes any type arguments, enclosed in angle braces and separated by commas. {C} The full name of the class. Equivalent to {n}.{c} {m} The method name of the test or empty if there is no method. The name includes any type arguments, enclosed in angle braces and separated by commas. {M} The full name of the method. {a} The full argument representation, enclosed in parentheses and separated by commas. Each argument is represented by the standard NUnit format for certain types, otherwise by the result of ToString(). {p} Same as {a} but with a parameter name before each argument in the same style as the named arguments C# language feature. {0}, {1}...{9}. An individual argument. This form is only useful when setting the name of an individual test case. If used in the default format string, any arguments not used will be ignored. {i} The test id, which is normally of the form mmm-nnn. Any text not included between curly braces is copied to the name as is. After the name is formatted, any leading or trailing '.' characters are removed. Otherwise, all non-format characters in the string are included as is. String arguments may be truncated to a maximum length. Either the {a} specifier or any of the individual argument specifiers may be followed by a colon and a length: {a:40} Truncate each string argument to 40 characters. All strings more than 37 characters are truncated to the first 37 followed by \"...\" {0:20} Truncate argument zero to 20 characters. Standard Name Formats Internally, NUnit uses certain standard formats unless overridden by the user. The standard format for generating a name from a test method and its arguments is: {m}{a} // Name This leads to test names like: Test1 Test2(5, 2) Test3(\"This is the argument\") Test4(\"This is quite long argument, so it is...\") Modifying the Name Format The SetName method of TestCaseData allows setting the name of an individual test case. In normal use, the provided string simply becomes the name of the test. However, if one of the template format specifiers is used in the argument to SetName, the name is regenerated using that format. For example, if the user wishes to specify only the argument portion of the name of a test method, while still retaining the method name, the name could be set to {m}(User argument) This would result in the display of the test name as SomeMethod(User Argument) Note that in this usage, it will generally only make sense to use {m}, {a} or {0} through {9} specifiers. However, NUnit will use whatever is provided."
  },
  "articles/nunit/running-tests/Test-Selection-Language.html": {
    "href": "articles/nunit/running-tests/Test-Selection-Language.html",
    "title": "Test Selection Language | NUnit Docs",
    "summary": "Test Selection Language The console command-line allows you to specify a filter, which will select which tests are executed. This is done using the --where option, followed by an expression in NUnit's Test Selection Language (TSL), a simple domain-specific language designed for this purpose. The --where option can be used with the dotnet test as -- NUnit.Where (note the space after the --). This will inject this into the runsettings. You can also add the same to a .runsettings file, see Adapter options and this blog post. Some of the characters used in the expression, such as space, | or &, may have a special meaning when entered on the command-line. In such a case, you should place the expression in quotation marks. dotnet test -- NUnit.Where=\"cat == Urgent or Priority == High\" nunit3-console mytest.dll --where \"cat == Urgent || Priority == High\" Simple Expressions Simple Expressions are essentially comparisons, consisting of a key word or property name on the left-hand side, an operator and some constant value on the right-hand side. Here are some examples: cat == Data test =~ /TestCaseAttributeTest/ method == SomeMethodName cat != Slow Priority == High namespace == My.Name.Space The following key words are recognized on the left-hand side of the comparison: test - The fully qualified test name as assigned by NUnit, e.g. My.Name.Space.TestFixture.TestMethod(5) name - The test name assigned by NUnit, e.g. TestMethod(5) class - The fully qualified name of the class containing the test, e.g. My.Name.Space.TestFixture namespace - The fully qualified name of the namespace containing the test(s), e.g. My.Name.Space method - The name of the method, e.g. TestMethod cat - A category assigned to the test, e.g. SmokeTests If the left-hand side of the comparison does not consist of a key word, it is treated as the name of a property on the test whose value is to be checked. See below for restrictions on use of properties. The following operators are supported == to test for equality - a single equal sign (=) may be used as well and has the same meaning != to test for inequality =~ to match a regular expression !~ to not match a regular expression The right-hand side of the comparison may be a sequence of non-blank, non-special characters or a quoted string. Quoted strings may be surrounded by single quotes ('), double quotes (\") or slashes (/) and may contain any character except the quote character used to delimit them. If it is necessary to include the quote character in the string, it may be escaped using a backslash () as may the backslash itself should you need to include one. The following expressions all do the same thing: test =~ /TestCaseAttributeTest/ test =~ \"TestCaseAttributeTest\" test =~ 'TestCaseAttributeTest' test =~ TestCaseAttributeTest test=~TestCaseAttributeTest For matching regular expressions, NUnit uses .NET's Regex.IsMatch method. For detailed information on the syntax of regular expressions in .NET, see Regular Expressions in .NET. For specifying qualified names, the same format as used for reflection should be used. For example My.Name.Space.TestFixture+NestedFixture can be used to select a nested fixture. For detailed information see: Specifying Special Characters Filtering By Namespace Using the namespace keyword with == will not match on sub-namespaces. For example by using the filter namespace == My.Name.Space, a test My.Name.Space.MyFixture will be selected but a test My.Name.Space.SubNamespace.MyFixture will not, since its namespace is not equal to the namespace provided. In order to inclusively select namespaces, a regular expression can be used. For example to match all namespaces under the root namespace My.Name.Space, the following filter can be used namespace =~ ^My\\.Name\\.Space($|\\.) Filtering Based on Properties Although the syntax will accept any property name - including names that don't actually exist - filtering will only work on existing, string-valued properties. The following properties are created by NUnit and have string values: Author Category Description SetCulture SetUICulture TestOf IgnoreUntilDate In general, these properties were not created with filtering in mind, but you can use them if it suits your needs. Using the Category property currently accomplishes the same thing as the cat keyword. You should be aware that the use of these properties by NUnit is considered an implementation detail and they may change in the future. We envision that most filtering by property will be based on user-defined properties, created for this purpose by inheriting from Property Attribute. When defining a property, you should keep the limitation to string values in mind. For example, a PriorityAttribute taking values of \"High\", \"Medium\" and \"Low\" could be used for filtering, while one that took the integers 1, 2 and 3 could not. Filtering by Test Id In addition to the left-hand-side items listed, NUnit supports filtering by the test id through the id keyword. The id may only be selected using the == operator and is intended only for use by programs that have explored the tests and cached the ids, not for general use by users. The reason for this restriction is that users have no way of predicting the id that will be assigned to a test. The id is not persistent across test runs and its format can differ between different framework drivers. Compound Expressions Simple expressions may be combined using logical and, logical or, parentheses or negation operators. Logical and is expressed as &&, & or and. Logical or is expressed as ||, |, or or. The negation operator is ! and may only appear before a left parenthesis. The letter variants, and and or, are provided for use on the command-line in systems that give & and | a special meaning. The following are valid compound expressions: test == \"My.Namespace\" and cat == Urgent test == \"My.Namespace\" and (cat == Urgent or Priority == High) test == \"My.Namespace\" and (cat == Urgent or Priority == High) method =~ /Source.*Test/ and class =~ \"My.Namespace.ClassName\" Usage on the Command Line Because TSL contains special characters and may contain blank spaces, you will usually want to put the expression in quotes on the command line. Consequently, any strings within the TSL expression will most likely need to use an alternate quote character. For example: nunit-console test.dll --where \"method =~ /Source.*Test/ && class =~ 'My.Namespace.Classname'\" Support in NUnit V2 The driver for NUnit V2 supports a subset of TSL. Because the V2 NUnit framework only allowed filtering on test names and categories, you may only use the cat and test keywords in comparisons. In addition, the regular expression operators =~ and !~ are not supported. If you use any of the unsupported keywords or operators with V2 tests, an error message is displayed and the tests are not run."
  },
  "articles/nunit/technical-notes/nunit-internals/Active-Attributes.html": {
    "href": "articles/nunit/technical-notes/nunit-internals/Active-Attributes.html",
    "title": "Active Attributes | NUnit Docs",
    "summary": "Active Attributes Warning Out Of Date - Needs Rewrite NUnit identifies tests and fixtures of custom attributes. Additional attributes are used to identify test data, modify tests and control how they execute. NUnit 3.0 is changing how attributes are used and recognized internally, while maintaining the same API for the test writer. This specification describes how the new version will recognize and use attributes, the interfaces implemented by attributes and the class hierarchy of NUnit's custom attributes. Rationale In the NUnit 2.x releases, attributes are recognized by the text of their name rather than using the attribute Type. This means that there is no need or the runner to have an actual reference to the nunit.framework assembly, where attributes are defined. This approach was taken in order to support multiple versions of the framework. Each new release of NUnit was able to run tests built against older frameworks, so long as the names remained the same. However, this approach has some drawbacks: As new attributes were added to the framework, it became necessary to also add the name of each attribute to the nunit core, which contained the code to load and run tests. The growing number of attributes in the framework now presents and extremely large surface area for the core to be aware of. Inheritance from attributes does not work as users would expect with NUnit failing to automatically recognize those attributes as equivalent to their base classes. In a few cases, NUnit contains special code to scan the base classes of any attributes found but it is not easy for users to discover which attributes allow this. NUnit must examine all attributes of a given class or method, comparing their names with the names it understands. This is quite inefficient and can slow down loading of assemblies containing large numbers of classes or methods. By locating the code to load and run tests in the framework assembly, NUnit 3.0 eliminates the first problem above. Test runners now need only be aware of a much narrower API. The design section below describes how we are handling the second and third issues. Design With NUnit 3.0, attributes are now only used within the framework assembly. Since all references are within that assembly, we can now handle them as Types rather than strings. All existing code that uses attribute names will be modified to use Type references, improving efficiency and allowing use of standard object-oriented programming techniques. The following sections provide an outline of the planned design. As implementation progresses, the code itself should be examined for updated information and further details. Active Attributes NUnit has a relatively small number of test types (e.g. TestFixture, TestMethod, Theory) and a relatively larger number of attributes. The current (2.x) design uses attributes almost exclusively as passive containers for their arguments and properties. All active code around attributes is located in the code around loading and running tests. In almost all cases, it is possible to reverse this logic and have the attributes play an active part in modifying the operation of tests. For example, the NUnit 2.6 test building logic understands that a test description may be found as a property of a DescriptionAttribute, TestAttribute or TestFixtureAttribute. In NUnit 3.0, each of those attributes will simply be called upon to update the test under construction with whatever information they can supply using the IApplyToTest interface. Attribute Hierarchy With just a few exceptions, NUnit's current set of attributes inherit from System.Attribute directly. Since we are now switching to use of the standard .NET reflection mechanism via attribute Types, it is useful to categorize attributes according to how and when they are used. For example, at a certain point in the construction of tests, NUnit must scan the attributes on a method to apply all those that provide modifications to the test being built. This is currently done by looking at all attributes of the method but it will be much more convenient to only retrieve TestModificationAttributes. The top levels of the Attribute hierarchy are listed here to the extent that they have been thought out. This will change as we implement it and will not necessarily remain stable in future releases because the hierarchy is considered to be an internal implementation detail. NUnitAttribute TestIdentificationAttribute TestModificationAttribute PropertyAttribute TestActionAttribute DataAttribute TestCaseDataAttribute ParameterDataAttribute Interface Usage While class inheritance of attributes is useful for retrieving groups of them and for sharing implementation, public access to capabilities of an attribute is better provided through an interface. For example, most TestModificationAttributes will implement the IApplyToTest interface, allowing them to be called upon to modify the test under construction. public interface IApplyToTest { void ApplyToTest(ITest test); } Interfaces are defined in the NUnit.Framework.Api namespace. Properties Versus Separate Attributes In some cases, there is a design choice to be made between use of a separate attribute or a property of the primary attribute for holding a particular of information. For example, the description of a test may be given as a property of TestAttribute or using a separate DescriptionAttribute. Recent versions of NUnit have deprecated use of properties in favor of separate attributes. Separate attributes provide a more orthogonal design and have been preferred for that reason. However, the introduction of parameterized tests has necessitated adding properties to the TestCaseAttribute and other attributes, representing functionality that was provided by a separate attribute on non-parameterized tests. For example, a test is ignored using the IgnoreAttribute while a TestCase is ignored by setting the Ignore property of TestCaseAttribute to true. For NUnit 3.0, we will try to provide some consistency of use for cases like this. This may result in \"un-deprecating\" certain existing properties and creating new ones. Attribute Targets NUnit will continue to rely on the AttributeUsageAttribute being properly defined on each of its attributes. This allows us to use one attribute type for both methods and classes while still counting on a given attribute only appearing in the proper context. Unresolved Issues One problem that is created by the new approach is that NUnit will no longer \"just work\" with tests compiled against framework versions prior to 3.0. This requires the NUnit test execution engine to use the old approach when dealing with tests compiled against a pre-3.0 framework version. This specification does not cover the execution engine, so the problem is not discussed further here."
  },
  "articles/nunit/technical-notes/nunit-internals/Architectural-Overview.html": {
    "href": "articles/nunit/technical-notes/nunit-internals/Architectural-Overview.html",
    "title": "Architectural Overview | NUnit Docs",
    "summary": "Architectural Overview Warning This is a draft. The contents may be out of date. This specification describes the overall layered architecture of the NUnit Platform. Details of individual components are covered only as they are relevant to the overall architecture. Layers The basic architecture of the NUnit Extended testing platform consists of three layers: Test Runner Layer Test Engine Layer Framework Layer The layering can be seen in the diagram below. This is the original architectural document, which is a bit out of date with regard to some details. A replacement is being created. Test Runner Layer The Test Runner or UI layer contains various runners, some provided by the NUnit team, others by independent projects leveraging the NUnit platform. Some runners are stand-alone programs, while others are tasks or plugins running under the control of an IDE or other application. This diversity of runners is part of the reason we refer to NUnit 3.0 as a Testing Platform – we expect many different runners to come into existence and will facilitate their development by providing reusable controls for several key environments. Programs in this layer are able to participate in the NUnit platform plugin architecture, providing extension points that allow them to be extended. Plugins at this level will usually add some functionality to the UI. Some of them may be standalone while others may require the presence of specific test engine plugins in order to operate. The NUnit project will continue to provide both a console runner and a WinForms-based GUI with extended capabilities those in NUnit 2.6. In addition, two new GUI runners will be developed, one based on WPF, the other on GTK#. We’ll work with the NAnt project to provide updates to the NAnt task for use with NUnit 3.0, with the goal of keeping that task current as new versions of NUnit are released. We will provide an NUnit plugin for the new Gallio platform. In the area of IDE integration, we will deliver a Visual Studio addin or package for running NUnit tests. Since other folks are already providing open source plugins for SharpDevelop and MonoDevelop, we’ll work with them to ensure compatibility. There is a long-standing need for a runner that executes tests in an actual or simulated web server environment. While good practice calls for extracting as much functionality as possible into separately testable assemblies, more complex applications often contain code which can only be tested in such an environment. For that reason, NUnit 3.0 will feature a web runner, which allows tests to be executed on a web server, reporting results back to the desktop. Each of the runners will have the option of participating in the NUnit plugin architecture and using functionality provided by NUnit to whatever degree desired. For the runners developed directly by the NUnit team, this capability will be used to the max, allowing others to add GUI features that function by themselves or in conjunction with other plugins operating at the level of the test engine. Test Engine Layer The Test Engine Layer is the core of the NUnit platform. It provides a public API for use by applications that want to locate, load and run tests and display test results. Many aspects of the Test Engine are already present in NUnit 2.6, while others are new. I’ll focus on the new features here. NUnit 2.6 already supports running tests in a separate process, allowing selection of the CLR version under which the test is to be run. NUnit 3.0 will extend this feature to allow test processes to run on other machines. It will also support distribution of test execution across a network of remote Test Agents. This facility is intended to be used in several distinct scenarios: Simple load sharing when test execution time is excessive Testing applications on multiple platforms Testing applications, which are themselves distributed A great deal of distributed function is already present in NUnit 2.6 through pNUnit, the distributed testing runner contributed to our project by Codice Software. With NUnit 3.0, we plan to integrate this function more completely into NUnit, allowing them to be executed by any runner that uses the NUnit Test Engine. NUnit will support performance and coverage analysis, test result reporting and maintenance of a history of test results. These features will function only as called upon by the user. That is, we will not carry on data collection activities with the potential of impacting performance when the user simply wants to run tests. Through use of plugins, NUnit will be able to support a wide variety of test types beyond low-level, isolated programmer tests. What is available in this area will be dependent on the interests of users and their willingness to contribute their efforts to creating them. Examples of the kinds of things we envision, some of which we will provide directly, are: Randomization of test execution order Deterministic test ordering for integration tests Parameterized (data-driven) tests Transactional test behavior Timed tests and parameterized timeout failures Dynamic test generation based on data input Repetitive test execution Tests written as non-managed code Test generation for legacy applications Framework Layer In NUnit 3.0, the NUnit framework itself – the assembly that is referenced by user tests – will be split along two dimensions. First, there will be separate framework assemblies for different version levels of the Common Language Runtime. By splitting the framework in this way, we will be able to take advantage of newer features, and allow users to take advantage of them, without compromising basic support for older runtimes. The second split we plan is between the core framework capabilities and the syntactic features that make it easy to access those features. A key example of this is the fluent interface introduced in NUnit 2.4 – the “Assert.That” syntax. One thing we learned through that experiment is that the same syntactic “sugar” does not work well for different language environments. Many of the 2.4/2.5/2.6 constructs are unusable or very difficult to use in other languages – C++ for example. By a combination of separate namespaces and separate assemblies, we will allow users to select the appropriate syntax for the work they are doing. Other people will be able to build on the syntax we provide or create entirely new syntactic overlays for their own purposes. Through use of plugins in the Test Engine layer, NUnit will be able to recognize, load and run tests written using other frameworks. Our focus will be on facilitating the creation of plugins in support of external frameworks by the projects that produce those frameworks or by interested users. For frameworks where that sort of support is not possible – commercial frameworks, for example – we have the option of creating the plugins ourselves. In some cases, individuals with an idea for a new framework may be able to create them more simply by writing an adapter on top of the NUnit framework itself. We will encourage and support this by giving priority to framework modifications that provide the necessary infrastructure for such projects. NUnit will also provide or re-package some framework extensions for specific types of applications, including Windows Forms development, WPF development, web page access, XML testing, performance measurement and load testing. At this point, it is not yet possible to state which of these will involve existing third-party packages and which will be developed from scratch, because discussions are ongoing. The NUnitLite framework will be supported running on devices and reporting results back to the Test Engine through a communications channel. Various popular mock frameworks will be supported. NUnit's own self-tests now use the NSubstitute framework, which is packaged with NUnit, but users may make use of whatever mocking framework they prefer. See Also You can also view the Original Architectural Overview Document created for NUnit 3.0 in 2009."
  },
  "articles/nunit/technical-notes/nunit-internals/Attribute-Hierarchy.html": {
    "href": "articles/nunit/technical-notes/nunit-internals/Attribute-Hierarchy.html",
    "title": "Attribute Hierarchy | NUnit Docs",
    "summary": "Attribute Hierarchy Warning This is a draft. The contents may be out of date. This technical note describes the inheritance hierarchy used for attributes in NUnit. It applies to the built-in attributes and may also be used as a guide for where to place custom attributes in the hierarchy. However, use of these attributes as base classes is entirely optional for custom attributes, as all functionality is accessed through the implemented interfaces. Essentially, we use attribute inheritance to define the \"what\" of an attribute... that is, what it primarily is and what it primarily is used for. The actual functionality of an attribute is defined by the use of interfaces. Abstract Attribute Classes The base of the hierarchy is formed by a number of abstract classes. They generally incorporate no code. NUnitAttribute All NUnit attributes inherit directly or indirectly from NUnitAttribute. Its only purpose is to allow easy selection of all NUnit attributes on a member. If a custom attribute does not fit under any of the other attribute classes, you may derive it directly from NUnitAttribute. TestFixtureBuilderAttribute TestFixtureBuilderAttribute is the base class for any attribute that knows how to build a test fixture of some kind from a provided class. In this context, a test fixture means any test that is based on a user class. NUnit includes the following attributes derived from TestFixtureBuilderAttribute: TestFixtureAttribute SetUpFixtureAttribute. Derived classes that build fixtures should implement the IFixtureBuilder interface. TestFixtureBuilderAttribute does not implement this interface itself since future versions of NUnit may introduce additional interfaces that build fixtures. Therefore, the choice of interface is left to the derived class. TestCaseBuilderAttribute TestCaseBuilderAttribute is the base class for any attribute that knows how to build a test case from a given method. Test cases may be simple (without arguments) or parameterized (taking arguments) and are always based on a MethodInfo. NUnit includes the following attributes derived from TestCaseBuilderAttribute: CombiningStrategyAttribute CombinatorialAttribute PairwiseAttribute SequentialAttribute TestAttribute TestCaseAttribute TestCaseSourceAttribute TheoryAttribute As with TestFixtureBuilderAttribute, the choice of a specific interface to implement is left to the derived class. Custom classes that build test cases should implement one of the interfaces designed for the purpose: ISimpleTestCaseBuilder or ITestCaseBuilder. Further interfaces may be defined in the future. In addition, any builder that is intended to cause a non-attributed class to be used as an NUnit TestFixture should implement IImplyFixture. IncludeExcludeAttribute IncludeExcludeAttribute is the base class for any attributes used to decide whether to include a test in the current run or exclude it based on the string properties Include, Exclude and Reason. The abstract base simply makes these properties available to the derived class, which is responsible for taking action on them. NUnit currently defines two attributes that derive from IncludeExcludeAttribute: CultureAttribute PlatformAttribute These two attributes implement IApplyToTest and set the RunState of the test based on interpreting the arguments and the current environment. Custom classes derived from IncludeExcludeAttribute should do the same thing."
  },
  "articles/nunit/technical-notes/nunit-internals/Framework-Api.html": {
    "href": "articles/nunit/technical-notes/nunit-internals/Framework-Api.html",
    "title": "Framework API | NUnit Docs",
    "summary": "Framework API The NUnit 3 Framework API consists of a number of related classes with well-known names contained in the framework. The NUnit 3 Framework Driver, which is part of the engine, performs actions by creating these classes. All required actions are performed in the constructor. The driver only needs to know the names of the classes and the arguments each one accepts. This document describes the interface between the driver and framework and the rules that must be followed to provide continued backward compatibility as new versions of the framework are created. Note that it only applies to the NUnit 3 framework. The following is a simplified example of how a calling program might use the framework to load and run tests in a particular AppDomain. This sort of code is expected to reside only in a driver. User-created runners should use the Engine API rather than dealing with the framework at this low level. See below for explanations of each call. var myHandler = new MyHandlerClass(); // implements ICallbackEventHandler // Create the controller var args = new object[] { \"my.test.assembly.dll\", new Hashtable()}; var controller = domain.CreateInstanceAndUnwrap( \"nunit.framework\", \"NUnit.Framework.Api.FrameworkController\", false, 0, null, args, null, null, null); // Load the assembly args = new object[] { controller, myHandler }; domain.CreateInstanceAndUnwrap( \"nunit.framework\", \"NUnit.Framework.Api.FrameworkController+LoadTestsAction\", false, 0, null, args, null, null, null); // myHandler.GetCallbackResult() should return an Xml string with the result // of the Load, which was passed to it by the framework. // We're not checking this here, as we normally would do. // Run the tests args = new object[] { controller, \"<filter/>\", myHandler }; domain.CreateInstanceAndUnwrap( \"nunit.framework\", \"NUnit.Framework.Api.FrameworkController+RunTestsAction\", false, 0, null, args, null, null, null); // myHandler.GetCallbackResult() should return an Xml string with the results // of running the test, which was passed to it by the framework. API Classes The following classes provide the API: FrameworkPackageSettings FrameworkController FrameworkControllerAction LoadTestsAction CountTestsAction ExploreTestsAction RunTestsAction FrameworkPackageSettings This static class defines constants for the names of all settings recognized by the framework. We use FrameworkPackageSettings rather than constants spread throughout the code in order to keep things consistent. A copy of this class is maintained in both the console runner and the framework and the settings are passed through to the framework by the engine. As new versions of the framework are released, settings in this file are not changed, although new settings may be added. See the code itself for a list of the settings in use. FrameworkController The driver creates a FrameworkController instance using reflection for each test assembly that must be loaded for browsing or execution. The constructor is defined as follows: public FrameworkController(string assemblyPath, string idPrefix, IDictionary settings) where assemblyPath is the full path to the test assembly. idPrefix is a prefix used for all test ids created under this controller. This is how the engine is able to provide unique ids for each test identified, even though multiple assemblies, frameworks and controllers may be involved. settings is an IDictionary containing the settings to be used in loading and running this assembly. A non-generic dictionary is used to allow for implementation of the framework on platforms that don't support Generics. This constructor always succeeds, provided that the arguments are of the correct types. Any operational errors will occur when specific actions like Load or Run are taken. FrameworkControllerAction As the driver needs to perform some action, it creates a temporary instance of a class derived from FrameworkControllerAction. The constructors for all actions have the following points in common: They take an instance of FrameworkController as their first argument. This must be the instance originally created by the driver for the particular assembly. This instance provides a common point of communication among various actions taken against the assembly. Another argument, the last one, is an object that implements System.Web.UI.ICallbackEventHandler. The handler receives the result of each action and - in the case of executing tests - progress notifications. Due to the nature of the ICallbackEventHandler interface, the results returned are always strings. The specific content of each result depends on the particular action. Exceptions are only thrown in the case of completely unanticipated errors, generally meaning an error in the calling program or a bug in the framework. We don't consider things like missing or bad files or exceptions thrown in user code as unanticipated. Some actions take the string representation of a test filter as an argument. The NUnit Engine and Framework have shared knowledge of the format of a filter. For an empty filter (no filtering) use \"<filter/>\". A null or empty string is also accepted for an empty filter as of NUnit 3.7.1, but \"<filter/>\" should be used for backwards compatibility. Note The ICallbackEventHandler is actually passed as an object and cast to the interface by the framework. This is intended to allow future use of other interfaces for progress. LoadTestsAction LoadTestsAction must be used before any other action can be called. Its constructor is as follows: public LoadTestsAction(FrameworkController controller, object handler); where controller is the FrameworkController instance that was created for managing the test assembly. handler is an object implementing ICallbackEventHandler, to receive the result of the load. The result returned from handler.GetCallbackResult() is the XML representation of the loaded test assembly. No child tests are included in the XML, since this method will be called by programs with no need for such a level of detail. Programs requiring the full tree of tests, such as Gui runners, should follow up by using the ExploreTestsAction. If the assembly can not be found or loaded, the same result is returned, but with a RunState of NotRunnable. ExploreTestsAction ExploreTestsAction is used to get the full tree of tests, as for display in a Gui. Its constructor is as follows: public ExploreTestsAction(FrameworkController controller, string filter, object handler); where controller is the FrameworkController instance that was created for managing the test assembly. filter is the string representation of a filter in XML format to be used when exploring tests. handler is an object implementing ICallbackEventHandler, to receive the result of the call. The result returned from handler.GetCallbackResult() is the XML representation of the test assembly, containing all tests that passed the filter, arranged as a tree with child tests contained within their parents. If the assembly was not found or unable to be loaded, a non-runnable assembly with no child tests is returned. If this action is invoked without first invoking LoadTestsAction, an InvalidOperationException is thrown. CountTestsAction CountTestsAction is used to get the number of test cases that will be executed under a specified filter, for use in a progress display. Its constructor is as follows. public CountTestsAction(FrameworkController controller, string filter, object handler); where controller is the FrameworkController instance that was created for managing the test assembly. filter is the string representation of a filter in XML format to be used when counting tests. handler is an object implementing ICallbackEventHandler, to receive the result of the call. The result returned from handler.GetCallbackResult() is the string representation of the integer number of test cases that match the filter. If the assembly was not found or unable to be loaded, \"0\" is returned. If this action is invoked without first invoking LoadTestsAction, an InvalidOperationException is thrown. RunTestsAction RunTestsAction is used to execute the loaded tests. Its constructor is as follows: public RunTestsAction(FrameworkController controller, string filter, object handler); where controller is the FrameworkController instance that was created for managing the test assembly. filter is the string representation of a filter in XML format to be used when counting tests. handler is an object implementing ICallbackEventHandler, to receive the result of the call. The result returned from handler.GetCallbackResult is the XML representation of the test result, including all child results. If the assembly was not found or could not be loaded, a non-runnable result with no child tests is returned. If this action is invoked without first invoking LoadTestsAction, an InvalidOperationException is thrown. RunAsyncAction RunAsyncAction is used to initiate an asynchronous test run, returning immediately. Its constructor is as follows: public RunAsyncAction(FrameworkController controller, string filter, object handler); where controller is the FrameworkController instance that was created for managing the test assembly. filter is the string representation of a filter in XML format to be used when counting tests. handler is an object implementing ICallbackEventHandler, to receive the result of the call. No actual result is returned immediately from the call. The handler progress notices must be tracked in order to know what is going on with the tests and eventually the final result may be retrieved. If the assembly was not found or could not be loaded, a non-runnable result with no child tests is returned. If this action is invoked without first invoking LoadTestsAction, an InvalidOperationException is thrown. StopRunAction StopRunAction is used to stop an ongoing test run. Its constructor is as follows: public StopRunAction(FrameworkController controller, bool force, object handler); where controller is the FrameworkController instance that was created for managing the test assembly. force indicates whether or not the stop should be forced, as opposed to a cooperative stop. handler is an object implementing ICallbackEventHandler, to receive the result of the call. No result is returned from the call. If no run is in progress, the call is ignored."
  },
  "articles/nunit/technical-notes/nunit-internals/Framework-Design.html": {
    "href": "articles/nunit/technical-notes/nunit-internals/Framework-Design.html",
    "title": "Framework Design | NUnit Docs",
    "summary": "Framework Design Warning This is a draft. The contents may be out of date. NUnit 3.0 is intentionally changing certain design decisions made in earlier versions. We document those changes here so that developers may find them all in one place. For details, see the individual specifications referenced under each design change subheading. Key Design Changes Multiple Framework Distributions NUnit 3.0 introduces separate framework builds for each supported runtime version, including .NET 2.0, 3.5, 4.0 and 4.5. We will continue to use the same framework assemblies for both the Microsoft and Mono implementations. Merge NUnitLite NUnitLite is a light-weight version of NUnit, requiring minimal resources and running on platforms not supported by full NUnit. NUnitLite is approximately equivalent to the framework portion of NUnit, with the addition of a rudimentary test runner. For the NUnit 3.0 release, the NUnitLite project code has been merged with the code of NUnit itself, using conditional compilation to support a reduced feature set. Framework Boundary Historically, most xUnit frameworks incorporate the logic for loading and running tests in the same module that includes assertions, attributes and other types referenced by the tests. NUnit started that way but the loading and test execution logic was extracted into a separate assembly in later versions. This approach had some benefit -- most notably NUnit's ability to run tests built against older versions of the framework -- but has proven less useful as more features were added. Essentially, the surface area that NUnit presents to a client program wanting to run tests grows each time a new feature is added. This has made it very difficult for third parties to keep up with NUnit's feature growth. For NUnit 3.0, the boundary has been moved. Each version of the framework incorporates a test runner that knows how to load and execute the tests supported by that version. Framework Api The internal (core) interfaces used by earlier versions of NUnit are not suitable for external use because they tend to change as features are added. The 3.0 release incorporates a new interface, supporting the same functionality as the existing interfaces, but with fewer dependencies on custom types. It is usable by both NUnit and third-party runners and will provide functions of test discovery, loading and execution. See Framework Api Active Attributes In the NUnit 2.x series, Attributes are fundamentally passive objects. They are used as markers for certain kinds of functionality, but that functionality is implemented in the nunit.core assembly. Reflection is used to identify attributes, in order to avoid a reference from the core to a specific version of the framework. In NUnit 3.0, since the test loader is part of the framework assembly, we'll be able to identify attributes without use of reflection, which should improve load performance. Attributes will actually contain the code that carries out the necessary functionality. See DRAFT:Active Attributes Test Loading Earlier releases of NUnit load tests in a hierarchy based on the namespace and may optionally load them as a flat list of fixtures. The test hierarchy is built as the tests are loaded and reflected in the gui display. With NUnit 3.0, the test loader will only load fixtures and will not create a hierarchy. It will be the responsibility of the Gui to construct whatever display hierarchy the user chooses as a view of the tests. This will simplify the loading of tests and is compatible with NUnitLite, which already loads tests this way. Test Execution Currently, the sequencing of tests is the responsibility of the tests themselves. That is, each test suite executes its own child tests and each test reports its own results. The absence of a distinct test execution object makes it difficult to support certain features, such as high-level setup and teardown, parallel test execution and cancellation of running tests with restart. In NUnit 3.0, the objects representing tests will no longer have the responsibility of running any subordinate tests and a separate test runner will sequence through the tests to execute them in the desired order."
  },
  "articles/nunit/technical-notes/nunit-internals/NUnit-3.0-Architecture-(2009).html": {
    "href": "articles/nunit/technical-notes/nunit-internals/NUnit-3.0-Architecture-(2009).html",
    "title": "NUnit 3.0 Architecture (2009) | NUnit Docs",
    "summary": "NUnit 3.0 Architecture (2009) This is the original - now out of date - document created to describe the planned architecture for NUnit 3.0. We are keeping it for whatever historical interest it may have. The diagram was created first and was shown for the first time by Charlie Poole at a Mono gathering in Madrid in 2008. The complete document was published the following year. Summary This specification describes the overall layered architecture of the NUnit Platform. Details of individual components are covered only as they are relevant to the overall architecture. Launchpad Blueprint http://blueprints.launchpad.net/nunit-3.0/+spec/nunit-3.0-architecture User Stories An NUnit User upgrades selected components of the NUnit platform without changing others. runs tests using alternate runners and frameworks under the NUnit platform. installs and uses addins and other extensions to the NUnit platform. An NUnit Developer understands how each component fits into the overall architecture of NUnit. chooses the proper component and project for making a fix or adding a feature. is able to focus attention on the component being modified, without worrying about the details of other components. An NUnit Extension Developer can develop an extension to a specific NUnit component, without dealing with other parts. can develop extensions to multiple NUnit components, which work together to achieve their result. Layers The basic architecture of the NUnit Extended testing platform consists of three layers: Test Runner Layer Test Engine Layer Framework Layer Test Runner Layer The Test Runner or UI layer contains various runners, some provided by the NUnit team, others by independent projects leveraging the NUnit platform. Some runners are stand-alone programs, while others are tasks or plugins running under the control of an IDE or other application. This diversity of runners is part of the reason we refer to NUnit 3.0 as a Testing Platform – we expect many different runners to come into existence and will facilitate their development by providing reusable controls for several key environments. Programs in this layer are able to participate in the NUnit platform plugin architecture, providing extension points that allow them to be extended. Plugins at this level will usually add some functionality to the UI. Some of them may be standalone while others may require the presence of specific test engine plugins in order to operate. The NUnit project will continue to provide both a console runner and a WinForms-based GUI with extended capabilities those in NUnit 2.5. In addition, two new GUI runners will be developed, one based on WPF, the other on GTK#. We’ll work with the NAnt project to provide updates to the NAnt task for use with NUnit 3.0, with the goal of keeping that task current as new versions of NUnit are released. We will provide an NUnit plugin for the new Gallio platform. In the area of IDE integration, we will deliver a Visual Studio addin or package for running NUnit tests. Since other folks are already providing open source plugins for SharpDevelop and MonoDevelop, we’ll work with them to ensure compatibility. There is a long-standing need for a runner that executes tests in an actual or simulated web server environment. While good practice calls for extracting as much functionality as possible into separately testable assemblies, more complex applications often contain code which can only be tested in such an environment. For that reason, NUnit 3.0 will feature a web runner, which allows tests to be executed on a web server, reporting results back to the desktop. Each of the runners will have the option of participating in the NUnit plugin architecture and using functionality provided by NUnit to whatever degree desired. For the runners developed directly by the NUnit team, this capability will be used to the max, allowing others to add GUI features that function by themselves or in conjunction with other plugins operating at the level of the test engine. Test Engine Layer The Test Engine Layer is the core of the NUnit platform. It provides a public API for use by applications that want to locate, load and run tests and display test results. Many aspects of the Test Engine are already present in NUnit 2.4, while others are new. I’ll focus on the new features here. NUnit 2.5 already supports running tests in a separate process, allowing selection of the CLR version under which the test is to be run. NUnit 3.0 will extend this feature to allow test processes to run on other machines. It will also support distribution of test execution across a network of remote Test Agents. This facility is intended to be used in several distinct scenarios: Simple load sharing when test execution time is excessive Testing applications on multiple platforms Testing applications, which are themselves distributed A great deal of distributed function is already present in NUnit 2.5 through pNUnit, the distributed testing runner contributed to our project by Codice Software. With NUnit 3.0, we plan to integrate this function more completely into NUnit, allowing them to be executed by any runner that uses the NUnit Test Engine. NUnit will support performance and coverage analysis, test result reporting and maintenance of a history of test results. These features will function only as called upon by the user. That is, we will not carry on data collection activities with the potential of impacting performance when the user simply wants to run tests. Through use of plugins, NUnit will be able to support a wide variety of test types beyond low-level, isolated programmer tests. What is available in this area will be dependent on the interests of users and their willingness to contribute their efforts to creating them. Examples of the kinds of things we envision, some of which we will provide directly, are: Randomization of test execution order Deterministic test ordering for integration tests Parameterized (data-driven) tests Transactional test behavior Timed tests and parameterized timeout failures Dynamic test generation based on data input Repetitive test execution Tests written as non-managed code Test generation for legacy applications Framework Layer In NUnit 3.0, the NUnit framework itself – the assembly that is referenced by user tests – will be split along two dimensions. First, there will be separate framework assemblies for different version levels of the Common Language Runtime. By splitting the framework in this way, we will be able to take advantage of newer features, and allow users to take advantage of them, without compromising basic support for older runtimes. The second split we plan is between the core framework capabilities and the syntactic features that make it easy to access those features. A key example of this is the fluent interface introduced in NUnit 2.4 – the “Assert.That” syntax. One thing we learned through that experiment is that the same syntactic “sugar” does not work well for different language environments. Many of the 2.4/2.5 constructs are unusable or very difficult to use in other languages – C++ for example. By a combination of separate namespaces and separate assemblies, we will allow users to select the appropriate syntax for the work they are doing. Other people will be able to build on the syntax we provide or create entirely new syntactic overlays for their own purposes. Through use of plugins in the Test Engine layer, NUnit will be able to recognize, load and run tests written using other frameworks. Our focus will be on facilitating the creation of plugins in support of external frameworks by the projects that produce those frameworks or by interested users. For frameworks where that sort of support is not possible – commercial frameworks, for example – we have the option of creating the plugins ourselves. In some cases, individuals with an idea for a new framework may be able to create them more simply by writing an adapter on top of the NUnit framework itself. We will encourage and support this by giving priority to framework modifications that provide the necessary infrastructure for such projects. NUnit will also provide or re-package some framework extensions for specific types of applications, including Windows Forms development, WPF development, web page access, XML testing, performance measurement and load testing. At this point, it is not yet possible to state which of these will involve existing third-party packages and which will be developed from scratch, because discussions are ongoing. The NUnitLite framework will be supported running on devices and reporting results back to the Test Engine through a communications channel. Various popular mock frameworks will be supported. One framework will be selected for use by NUnit’s own self-tests and will be packaged with NUnit. Further Details More detailed specifications are being developed for each of the layers. Consult the Specifications index for their current status."
  },
  "articles/nunit/technical-notes/nunit-internals/NUnit-APIs.html": {
    "href": "articles/nunit/technical-notes/nunit-internals/NUnit-APIs.html",
    "title": "NUnit APIs | NUnit Docs",
    "summary": "NUnit APIs NUnit provides three levels of public APIs for discovering and running tests. From highest to lowest level they are: Test Engine API - for general use by any program that needs to discover and execute tests. Engine Driver API - implemented by framework drivers to allow the engine to communicate with a particular framework. Framework API - used by the NUnit 3 framework driver to communicate with the framework. Test Engine API The NUnit TestEngine is a separate component, introduced in NUnit 3.0, which knows how to discover and execute tests. It provides an API for both simple batch execution and more complex interaction as needed by Gui test runners. It also provides additional Engine services beyond what the framework provides. This is what we recommend for use by anyone needing to run NUnit tests programmatically. See Test Engine API for more info. Engine Driver API The NUnit TestEngine uses drivers to communicate with test frameworks. It is possible to create a driver for running any sort of test framework, supporting any language at all. The driver API is what makes this possible. The TestEngine has support for the NUnit 3 framework built in. An extension driver for running NUnit 2 tests is also available. The driver API is only intended to be implemented by drivers and is only used by the NUnit engine. See Engine Driver API for more info. NUnit Framework API This is a primitive API implemented by the NUnit 3 Framework. The NUnitFrameworkDriver in the engine uses this API. The API is a bit complicated to use. Since it needs to support multiple versions of the framework, it uses well-known framework class names, which are constructed via reflection. All results are returned as raw XML. This API is not intended for any use except by NUnit itself. See Framework API for more info."
  },
  "articles/nunit/technical-notes/nunit-internals/NUnit-Internals.html": {
    "href": "articles/nunit/technical-notes/nunit-internals/NUnit-Internals.html",
    "title": "NUnit Internals | NUnit Docs",
    "summary": "NUnit Internals Architectural Overview NUnit APIs Test Engine API Framework Driver API Framework API Framework Design Active Attributes Attribute Hierarchy Test Discovery And Execution Engine Extensibility"
  },
  "articles/nunit/technical-notes/nunit-internals/Test-Discovery-And-Execution.html": {
    "href": "articles/nunit/technical-notes/nunit-internals/Test-Discovery-And-Execution.html",
    "title": "Test Discovery And Execution | NUnit Docs",
    "summary": "Test Discovery And Execution Warning This is a draft. The contents may be out of date. This spec summarizes the three levels of APIs provided by NUnit for discovering and running tests. Note that only one of them - the highest level - is supported for general usage. The others have very specific purposes and should only be used for those purposes. The three APIs, from highest to lowest level, are: Test Engine API - for use by any program that needs to discover and execute tests. Engine Driver API - for use by framework drivers, intended to be loaded by the engine to enable communication with a particular framework. Framework API - only used by NUnit's own framework driver to communicate with the framework. Test Engine API The NUnit TestEngine is a separate component, new to NUnit 3.0, which knows how to discover and execute tests. It provides an API for both simple batch execution and more complex interaction as needed by typical Gui test runners. It also provides additional Engine services beyond what the framework provides. This API is currently under development. See Test Engine API for more info. Engine Driver API The NUnit TestEngine uses drivers to communicate with test frameworks. Initially, the engine will come with a driver for NUnit 3.0, followed by an NUnit 2.x driver. It is possible to create a driver for running any sort of test framework, supporting any language at all. The driver API is what makes this possible. The driver API is only intended to be implemented by drivers and is only used by the NUnit engine. This API is currently under development. See Engine Driver API for more info. NUnit Framework API This is a primitive API implemented by the nunit.framework and NUnitLite assemblies. The NUnitFrameworkDriver in the engine uses this API. The API is a bit complicated to use. Since it needs to support multiple versions of the framework, it uses well-known framework class names, which are constructed via reflection. All results are returned as raw XML. This API is not intended for any use except by NUnit itself. See Framework API for more info."
  },
  "articles/nunit/technical-notes/nunit-internals/specs/Dynamic-Test-Cases-Spec.html": {
    "href": "articles/nunit/technical-notes/nunit-internals/specs/Dynamic-Test-Cases-Spec.html",
    "title": "Dynamic Test Cases Spec | NUnit Docs",
    "summary": "Dynamic Test Cases Spec Warning This is a draft. The contents may be out of date. This specification describes changes in how test cases will be generated in NUnit 3.0 Rationale NUnit currently supports parameterized tests using the TestCase, TestCaseSource, Values, ValueSource, Random and Range attributes. All these data sources provide data that is used to generate test cases as the tests are loaded. We refer to these as \"pre-generated\" test cases. There is also a need for what we are calling \"dynamically generated\" test cases, which are not created until the test is about to run and which may be re-created each time the test is run. For example, it may be desirable to perform some initialization of the data in a OneTimeFixtureSetUp method. This is not possible using the pre-generated model, because the tests are generated before any execution. As another example, the data may consist of the names of files in a certain directory. If the directory content is changing dynamically, we may want our tests to reflect those changes, which is only possible using the dynamic model. For all these reasons - and because users have requested it - we are introducing the notion of \"dynamically generated\" test cases in NUnit 3.0. Some existing attributes will be re-purposed and new attributes created to support it. Note Dynamic test case generation is also required for the proper implementation of Theories, which will be described in a separate specification. Design Key Tradeoffs The two types of test cases have important differences in how they may be used by NUnit and each has certain advantages and limitations as well. Pre-Generated Dynamically Generated Data must be known at the time of loading in order to construct the test. Data is not needed until the point of running the test. Data may not change between test runs unless the tests are reloaded. Data may change between test runs. Test cases are available to show in the Gui as soon as the test is loaded. Test cases can only be displayed after the test has been run. Certain types of errors may be displayed as soon as the test is loaded. Errors can only be displayed after the test has been run. Data may not be initialized in OneTimeSetUp because the individual test cases have already been created by that time. Data may be initialized in OneTimeSetUp if desired. External changes to a data source have no effect on subsequent test runs. Each test run reflects the current state of the data. Static methods, properties and fields must be used to hold test data for two forms of the TestCaseSource attribute. Instance methods, properties and fields may be used in all cases. Test runs are automatically repeatable within a session at least until the test is reloaded. Repeatability within a session will require special support within NUnit. Data-generating code is only executed once - as the test is loaded. Data-generating code is executed for each run. General Approach Introduce dynamic test case generation, as described above. For ease of use, each data attribute should use either the pre-generated or dynamically generated model exclusively. Parameterized test methods may mix both types of attribute, allowing both pre-generated and dynamically generated test cases. Provided that external data sources such as files and databases are not changed, we will support repeatable test runs across different program sessions and within the same session. The Gui will display new test cases as they are generated and will provide a visual cue to distinguish the two types of test cases. Syntax As in NUnit 2.5, Attributes applied to test methods will provide or point to the data to be used as test arguments. Except as noted below, attributes will not change syntactically and will continue to operate as before even though many of them will now generate test cases dynamically. The following paragraphs describe the impact of the change on each attribute. TestCaseAttribute will continue to work as it now does, producing pre-generated test cases. TestCaseSourceAttribute and ValueSourceAttribute will continue to create pre-generated test cases, but will be more limited in their usage than before. The following data sources will be supported: Static fields, properties or methods of the test fixture. Static or instance fields properties or methods of an external or nested class. It's likely that there will be ways to 'trick' NUnit into accepting an instance member for one of these attributes, leading to instantiation of the test class at load time. If that occurs, the results are undefined. Obviously, such trickery is not recommended and we'll try hard to detect and reject such attempts. A new DynamicDataSourceAttribute (the name is a placeholder) will supplant both TestCaseSourceAttribute and ValueSourceAttribute for dynamic generation of test cases and parameter values respectively. Suggestions are welcome for the final name of this attribute. ValuesAttribute, RangeAttribute, RandomAttribute, CombinatorialAttribute, PairwiseAttribute and SequentialAttribute (that is, all other data attributes) will be used to produce test cases dynamically. DatapointAttribute and DatapointsAttribute are only used for Theories, but for the sake of completeness it may be noted that they will also operate dynamically. Where necessary, additional properties may be added to some attributes in order to provide for repeatability of tests. At the moment, the only known requirement is for specification of a random seed for RandomAttribute but others may arise in implementation. Gui Design Notes Since we don't have an NUnit 3.0 Gui yet, these notes are for the future... When tests are run in batch mode using the console runner, the distinction between fixed and dynamic data is moot. In that environment, tests are loaded and executed in rapid sequence, after which the process is terminated. But when using the Gui, the affect of using dynamic data is quite visible. Dynamic tests are initially loaded without showing any subordinate test cases. After each run, test cases are repopulated and may even be different. This has several important consequences for the Gui... It must be able to deal with test cases added during test execution. It must be able to trigger regeneration of test cases for a rerun. It must also provide some way to re-run the same tests in a repeatable fashion. It must give the user control over whether to run the tests repeatably or not. Implementation Notes Interface changes will be required to identify the presence of either pre-generated or dynamic data for a method. NUnitTestCaseBuilder will accept a test method with arguments so long as either type is present but will only create pre-generated test cases. Dynamic test case generation will take place in the Run method of ParameterizedMethodSuite class using registered extensions that support dynamic data. The result will be a new addition to the standard sequence of test execution, as follows: Create test fixture instance Run TestFixtureSetUp Generate dynamic test cases For each test case Run SetUp method Run Test method Run TearDown method Run TestFixtureTearDown Dispose and destroy the test fixture instance Unresolved Issues None known, implementation issues aside."
  },
  "articles/nunit/technical-notes/nunit-internals/specs/Engine-Addins-Spec.html": {
    "href": "articles/nunit/technical-notes/nunit-internals/specs/Engine-Addins-Spec.html",
    "title": "Engine Addins Spec | NUnit Docs",
    "summary": "Engine Addins Spec Note This page is a specification that was used as a starting point for creating the feature in NUnit. It needs to be reviewed and revised in order to accurately reflect what was actually built. If you take it with a grain of salt, it may still be helpful to you as documentation. This notice will be removed when the page is brought up to date. This spec covers a proposed new approach to Engine addins, replacing the use of Mono.Addins. Background We originally planned to use Mono.Addins for the engine and have done so in the first betas. However, Mono.Addins no longer supports .NET 2.0. We are using a modified version that we created and which we will have to maintain in the future. Mono.Addins has many more features than we expect to use and has a rather large memory and disk footprint. In sum, Mono.Addins is not really carrying its weight for our usage. We will try to replace it with a simple plugin architecture of our own design, using some pieces of our old NUnit 2.x addin feature as well as other features inspired by Mono.Addins. At a minimum, we need to support existing addins that are supported by Mono.Addins. Once we have that support, we can replace Mono.Addins. Further features could be added later. Three addin types are currently supported: Project Loaders - used to load NUnit and VS projects Result Writers - used to write out results in NUnit 2 format Driver Factories - used to create the driver for running NUnit 2 tests under NUnit 3 Design Extension Points In both Mono and NUnit (2.x) addins, extensibility centers around ExtensionPoints. An ExtensionPoint is a place in the application where add-ins can register themselves in order to provide added functionality. extension nodes to provide extra functionality. NUnit 3.0 will continue to use this concept. In our initial implementation, all extension points must be known in advance and are contained in the engine. At a future point, we will probably want to add a way to dynamically create new extension points so that addins can themselves host extensions. ExtensionPoints in the engine will be identified by use of ExtensionPointAttribute at the assembly level. Each attribute identifies one extension point, specifying an identifying string (the Path) and the required Type of any extension objects to be registered with it. Example [assembly: ExtensionPoint(Path=\"/NUnit/Engine/DriverService\" Type=\"NUnit.Engine.Extensibility.IDriverFactory\")] In this example, the Path identifying the extension point is \"/NUnit/Engine/DriverService.\" Any type to be plugged into this extension point must implement IDriverFactory. Note that even though each extension point is typically implemented by some class in the system, the identity of that class is an implementation detail, which is not revealed in the ExtensionPoint. Extensions An Extension is a single object of the required type, which is registered with an ExtensionPoint. Extensions are identified by the ExtensionAttribute which is applied to the class. Extensions identified in this way must have a default constructor. See the Addins section below for dealing with more complex situations. Example [Extension(Path = \"/NUnit/Engine/DriverService\")] public class NUnit2DriverFactory : IDriverFactory { /* ... */ } The example above shows an extension Type being used with the ExtensionPoint defined in the previous example. An instance of NUnit2DriverFactory will be supplied to the DriverService when needed. The Path property must match the Path for the intended ExtensionPoint. The Path is actually optional so long as NUnit is able to deduce the correct ExtensionPoint based on the Type. In fact, that's the case in this example, which can be rewritten more simply as... [Extension] public class NUnit2DriverFactory : IDriverFactory { /* ... */ } The Path may be omitted provided that no other extension point is able to accept an object of the same class as the extension. Locating Addins Assemblies containing Addins and Extensions are stored in one or more locations indicated in files of type .addins. Each line of the file contains the path of an addin assembly or a directory containing assemblies. Wildcards may be used for assembly entries and relative paths are interpreted based on the location of the .addins file. The default nunit.engine.addins is located in the engine directory and lists addins we build with NUnit, which are contained in the addins directory. Any assemblies specified in a .addins file will be scanned fully, looking for addins and extensions. Any directories specified will be browsed, first looking for any .addins files. If one or more files are found, the content of the files will direct all further browsing. If no such file is found, then all .dll files in the directory will be scanned, just as if a .addins file contained \"*.dll.\" Assemblies are be examined using Cecil. Any assembly that cannot be opened is be ignored, with a log message generated. This be a normal occurrence in cases where the assembly targets a higher level runtime than that which is in use. Info is saved for actual instantiation of extensions on a just-in-time basis. We hope that the combination of specifically indicating which assemblies to scan and the use of Cecil to do the scanning will make this process quite efficient. If that turns out not to be the case, we can use an assembly-level attribute to identify assemblies containing extensions. Future Enhancements Addins An Addin is a Type that provides Extensions. As indicated in the previous section, simple extensions providing a single instance of the object through a default constructor do not require an Addin. For more complex situations, an Addin object could be allowed to create and register one or more extensions. This is the approach that we took in NUnit 2.x. Addins would be identified by the AddinAttribute and implement the IAddin interface. They actively participate in the installation of extensions and may be used to create objects that require parameters, to install multiple extensions or to select among different extensions. Example [Addin] public class MyAddin : IAddin { public bool Install(IExtensionHost host) { var ep = host.GetExtensionPoint(\"/NUnit/Engine/DriverFactory\"); ep.Install(new NUnit2DriverFactory()); } } public class NUnit2DriverFactory : IDriverFactory { /* ... */ } The above example does the same thing as the previous example in a more complicated way. Obviously, you would use this approach only in more complex situations. Note that the factory class does not have an ExtensionAttribute as this would lead to its being installed twice. Notes This design feature is not required initially and will be omitted from the implementation until we actually require it. The interfaces used in this section are notionally based on NUnit 2.6.4. Addins on Addins Initially, we only need one level of addins to allow for everything we now do. It may be convenient at some point to support addins on top of other addins. For example, a given framework driver might be enhanced with some special feature through an addin. An ExtensionPoint in an extension assembly could be identified in the same way as an engine extension point is known, using the ExtensionPointAttribute at assembly level. However, this is not a feature we need for the 3.0 release, only one to keep in mind for the future."
  },
  "articles/nunit/technical-notes/nunit-internals/specs/Extended-Constraint-Syntax-Spec.html": {
    "href": "articles/nunit/technical-notes/nunit-internals/specs/Extended-Constraint-Syntax-Spec.html",
    "title": "Extended Constraint Syntax Spec | NUnit Docs",
    "summary": "Extended Constraint Syntax Spec Warning This is a draft. The contents may be out of date. This specification is about a new syntax for expressing NUnit assertions using the features of .NET framework 3.5 including language improvements. There are two key features this enables: Extension methods permit a modular, extensible fluent constraint syntax, and LINQ expression trees permit using plain C# (or VB) as a expression-based constraint language. User Stories Fluent Constraint Syntax A user expresses assertions in a fluent fashion A user extends NUnit's constraints without modifying NUnit An extension developer packages new constraints and their syntax in a single extension This improves NUnit by making extensibility easier. Expression-based Constraints A user expresses assertions in C# or VB without needing to learn NUnit-specific constraints Any boolean expression convertible to an expression tree can form a constraint Failed assertions include detailed error messages such as sub-expression values - i.e. unlike Debug.Assert. This improves NUnit by making it easier to learn and less necessary to extend. Existing Implementations There are already a couple of implementations implementing a fluent syntax or expression-based syntax or both: Extension Methods for NUnit: this is substantially an aliasing mechanism which, without touching the constraints themselves, provides a fluent way to express them SharpTestsEx: this is an improvement of NUnitEx and provides an extension-method based constraint syntax in addition to a starting point for an expression-based mechanism of assertions. ExpressionToCode: this is an expression-based assertion library. It is a reimplementation of Power Assert .NET, which is itself a port of Groovy's Power Assert. Extensible Fluent Constraint Proposal Ideally we would like to be able to use a constraint syntax similar to the current fluent syntax that is extensible. This requires using extension methods instead of static classes, as the following example demonstrates: Assert.That(1, Is.GreaterThan(0)) This example is not extensible since it uses the static ''Is'' class. If I wanted to write something like ''Is.MuchGreaterThan(int x)'' and thus a constraint ''MuchGreaterThan'' which NUnit doesn't provide, I would have to alter and recompile NUnit's code. Patching NUnit like this and maintaining such a patch is a high barrier to entry. The same assertion could be written as: Assert.That(1).Is.GreaterThan(0) This allows for extensions since any user can define a new extension method for the class of the ''Is'' property. Say ''Is'' were to return a value of type ''IIsConstraint'', then I could just write public static void MuchGreaterThan(this IIsConstraint iis) { /* ... */ } Taking syntax shown on the SharpTestsEx homepage as an example, some assertions with the new NUnit syntax could be written as following: SharpTestsEx NUnit 3.0 proposal true.Should().Be.True(); Assert.That(true).Is.True \"something\".Should().Contain(\"some\"); Assert.That(\"something\").Contains(\"some\") \"something\".Should().StartWith(\"so\").And.EndWith(\"ing\") Assert.That(\"something\").StartsWith(\"so\").And.EndsWith(\"ing\") new[] { 1, 2, 3 }.Should().Have.SameSequenceAs(new[] { 1, 2, 3 }); Assert.That(new[] { 1, 2, 3 }).Is.EquivalentTo(new[] { 1, 2, 3 }) %%ActionAssert.Throws<ArgumentException>(() => new SillyClass(null))%% %%Assert.That(() => new SillyClass(null)).Throws<ArgumentException>()%% Unresolved Issues How would the following actually work? Assert.That(\"something\").StartsWith(\"so\").Or.EndsWith(\"ing\"); How would ''StartsWith'' know that it's not supposed to do anything if it fails, since there is a chance ''EndsWith'' might succeed? Remember, the above code is semantically identical to this: var temp = Assert.That(\"something\").StartsWith(\"so\"); temp.Or.EndsWith(\"ing\"); Extension methods can lead to namespace pollution; in particular if defined on ''object'' (which we therefore should try to avoid). Expression Based Constraint Proposal NUnit provides a wealth of constraints. This means that knowing how to expression non-trivial constraints isn't always easy (particularly for new or casual users). Finding the appropriate constraint (or combination of constraints) requires knowledge NUnit's many constraints, and the semantics of a particular constraint may not be clear without reading the documentation. For example, consider the assertion (valid for many uppercase strings, for most cultures): Assert.That(() => x == x.ToLower().ToUpper()); This expression can be expressed as a standard equality constraint, but doing so means not showing the intermediate steps in the computation. Using expression trees, a failure could be rendered as: Assert.That failed for: x == x.ToLower().ToUpper() | | | | | | | | | \"ABC I\" | | | \"abc i\" | | \"ABC İ\" | false \"ABC İ\" This variant requires very little knowledge of NUnit, yet is still usable even for complex constraints by leveraging a language the user already knows (namely VB or C#). Possible extensions to this concept could be \"Helpers\" that recognize specific patterns and improve readability. For instance, if an expression consists of a sequence of ''&&'' operators, a helper might suppress showing the details of non-failing clauses. Or, if an expression contains multiple DateTime, the helper could ensure the accuracy of the DateTime.ToString is high enough to represent any differences. If an ''=='' operator fails but ''.Equals'' would have succeeded, this could be mentioned."
  },
  "articles/nunit/technical-notes/nunit-internals/specs/Include and Exclude Attributes (Alternatives).html": {
    "href": "articles/nunit/technical-notes/nunit-internals/specs/Include and Exclude Attributes (Alternatives).html",
    "title": "Include And Exclude Attributes Alternatives | NUnit Docs",
    "summary": "Include And Exclude Attributes Alternatives This spec describes proposed new attributes to replace and extend the existing CultureAttribute and PlatformAttribute. These attributes derive from the abstract IncludeExcludeAttribute, which provides Include and Exclude named properties. The following examples show how these attributes are currently used: [Culture(\"fr-FR\")] [Culture(Include=\"fr-FR\")] [Culture(Exclude=\"fr-FR\")] [Platform(\"Net-4.5\")] [Platform(Include=\"Net-4.5\")] [Platform(Exclude=\"Net-4.5\")] Alternative Approaches Note Three alternative approaches were identified in March, 2014. This is the final update of the document prior to choosing an alternative. Approach #3 seems to be the front-runner at this time. 1. Keep the current approach How it Works Exclude has priority. If any attribute excludes a test, it remains excluded, even if another attribute matches it for inclusion. The default constructor argument represents inclusion, so you should not use it along with the Include parameter. Comma-separated alternatives form a union, so that if any item is matched, the test is included (or excluded). Pros Having a separate attribute for each domain from which we are making a selection is easy for users to understand. With the new attribute-based framework extensibility model in NUnit 3.0, this is probably the easiest approach of all to extend. Cons The current Platform attribute actually works across three different domains: the OS, the runtime and the bit-ness of the process. It's very difficult to define criteria like Windows 7 or 8 running .NET 4.5 using a single attribute. [Platform(\"Windows7,Windows8,Net-4.5)] will include Win 7 or 8 with any runtime and .NET 4.5 with any OS. The best we can do is [Platform(\"Windows7,Windows8\",Exclude=\"Net-2.0,Net-3.0,Net-3.5\")]. Boolean expressions involving the accepted values would permit the above more cleanly. For example, we might write Platform(\"(Windows7 | Windows8) & !Net-4.5)\"). Such logic would have to be implemented for each attribute, most likely in the base class. However, any such logic would only apply within the single attribute: it would not be possible to include both OS and Culture (for example) in the same expression. Extensibility Create a new attribute that inherits from IncludeExcludeAttribute and implement the necessary selection logic to decide whether a given string tag is supported. 2. Keep Current Approach, but Split PlatformAttribute How It Would Work As mentioned above, PlatformAttribute actually tests over three different domains. We would create a separate attribute for each domain, for example: PlatformAttribute, RuntimeAttribute and ProcessAttribute. Pros All the same as for approach #1, plus... The first 'con' in approach #1 would be eliminated. The example given would work as [Platform(\"Windows7,Windows8\"), Runtime(\"Net-4.5\")]. Having separate attributes might make it easier to understand for some users. (see cons) Cons Boolean expressions would become even more limited, as compared to #1 Having separate attributes might make it harder to understand for some users. (see pros) We would be proliferating attributes, although that may not be a serious issue. Extensibility Create a new attribute that inherits from IncludeExcludeAttribute and implement the necessary selection logic to decide whether a given string tag is supported. 3. Create Replacement Attributes How It Would Work Invert the implied hierarchy by providing an IncludeAttribute and an ExcludeAttribute, which specify what is to be tested in one of several ways. For example: [Include(Culture=\"fr-FR\")] [Exclude(\"Runtime:Net-4.5\")] Note that the above example includes two mutually exclusive ways of implementing the syntax. See below. Pros This seems to be at least as easy to understand as the current approach. In some cases it may be better, since use of Include as the attribute name makes it quite clear what is happening, whereas Culture may be misunderstood as changing the culture. May be extended by the user, depending on which syntactic sub-option we select below. Cons Allows future development of an expression syntax that would combine all selection elements, but again, depending on the syntax option chosen. Some of the syntactic sub-options are not so easy to extend. See below. Syntax Options For this alternative we will want to use a separate namespace for each domain. There would be one set of unique names for the Operating System, one for Runtimes, one for Culture, etc. There are two options we might use to implement this, which are designated as alternatives 3A and 3B. 3A. Create Replacement Attributes Using Named Properties Map each domain to a separate named property. For example: [Include(Culture=\"fr-FR\")] [Exclude(Runtime=\"Net-2.0\")] Pros Easiest to implement Familiar syntax for users Cons Need to decide how to combine tests across multiple domains. Does [Include(Culture=\"fr-FR\", Runtime=\"Net-2.0\")] mean both or either? Not possible to have logical expressions that combine domains (but maybe they are not needed). Extensibility We would need to provide a registration mechanism, whereby a program provided the name of the domain, the value and a function for evaluating whether the feature is supported or not. It would not be possible to add new domains. 3B. Create Replacement Attributes Using Prefixes Prefix each value with the domain name, thereby creating a unified namespace. [Include(\"Culture:fr-FR\")] [Exclude(\"Runtime:Net-2.0\")] Pros Similar to syntax used by VS for selecting tests We could create an expression syntax for combining tags. Could support other relations than simple equality, e.g.: [\"Runtime>=4.0\"]. Cons Slightly more work initially. Lots more work if we implement expressions. New syntax for many users Extensibility We would need to provide a registration mechanism, whereby a program provided the name of the domain, the value and a function for evaluating whether the feature is supported or not. New domains could be added in addition to new values. Next Steps We need to pick the general approach and then work can begin on the feature."
  },
  "articles/nunit/technical-notes/nunit-internals/specs/Include-and-Exclude-Attributes-Spec.html": {
    "href": "articles/nunit/technical-notes/nunit-internals/specs/Include-and-Exclude-Attributes-Spec.html",
    "title": "Include And Exclude Attributes Spec | NUnit Docs",
    "summary": "Include And Exclude Attributes Spec Warning This is a draft. The contents may be out of date. This spec describes proposed new attributes to replace and extend the existing CultureAttribute and PlatformAttribute. We considered several alternative approaches to doing this and selected the approach described here. See Include and Exclude Attributes (Alternatives) for the original discussion of choices. Attributes We would define two new attributes, IncludeAttribute and ExcludeAttribute: [Include(Culture=\"fr-FR\")] [Include(Platform=\"Win7,Win8\")] [Exclude(\"Runtime:Net-4.5\")] [Exclude(\"Linux\")] [Include(\"Runtime >= 4.0 and Platform == \"Linux\"\")] Syntax Options There are a number of possible alternatives for specifying when a test is to be included or excluded. Each of them is illustrated in the examples above, from which we need to select a subset. 1. Named Properties As illustrated in the first two examples, this approach allows us to clearly separate the namespaces for each selection domain. Comma-separated values are intended to be alternatives, so the second example would include the test under either Win7 or Win8. Separate properties (domains) would be \"and-ed\" together. 2. Prefixes By prefixing each value with the domain name, we can create a unified namespace. The third example above uses this approach, making it clear that Net-4.5 represents a runtime and nothing else. As in #1, comma-separated values are alternatives. There is no other way to create logical combinations. 3. Implied Domain To the extent that the accepted values are exclusive, it's possible to deduce the domain from the value. The fourth example above takes advantage of this. Note that this approach can be combined with #2 as a kind of shorthand. 4. Logical Expression We can define a DSL that allows us to specify arbitrary expressions for including or excluding tests. The last example above does this. If the expression language included not, then we could do away with the ExcludeAttribute. Comparison of Options Note The following are Charlie's ratings. Feel free to disagree! Ease of implementation (easy to hard) 1 > 2 > 3 > 4 Expressiveness (least to greatest) 3 > 2 > 1 > 4 Learning Curve (shallow to steep) 1 > 3 > 2 > 4 Extensibility to new domains (easy to hard) 1 > (2, 3, 4) Extensibility with new values (easy to hard) 3 > (2, 4) > 1"
  },
  "articles/nunit/technical-notes/nunit-internals/specs/Internal-Trace-Spec.html": {
    "href": "articles/nunit/technical-notes/nunit-internals/specs/Internal-Trace-Spec.html",
    "title": "Internal Trace Spec | NUnit Docs",
    "summary": "Internal Trace Spec Warning This is a draft. The contents may be out of date. NUnit traps text output directed to the Console, Trace or a logging subsystem. This makes it difficult to use text output when debugging the framework itself, particularly when working on the classes that redirect output. For that reason, NUnit incorporates a simple internal tracing mechanism for use by developers and for debugging problems in the field. User Stories An NUnit User enables NUnit's internal trace in order to collect information about an apparent bug or unexplained error. An NUnit Developer makes use of the internal trace as a part of the development cycle. Design NUnit provides a simple internal trace facility using the InternalTrace class. The following public methods are provided for creating output: public static void Error(string message, params object[] args) public static void Warning(string message, params object[] args) public static void Info(string message, params object[] args) public static void Debug(string message, params object[] args) By default, all output through InternalTrace is sent to the console, which means it is mixed with other console output. Note that the trace mechanism bypasses NUnit's redirection of output and displays on the actual Console. Of course, if NUnit is being run without a console - from the Gui, for example - the output will be lost. Redirecting Output The InternalTrace.Open() method allows the programmer to specify a file to which the output will be written. Any absolute or relative path may be used as an argument. Relative paths are interpreted as relative to the location of the assembly being tested. A programmer working on NUnit may call this method at any point in the code. InternalTrace.Close() is also provided. Note Since the path is saved as a static property, it must be specified separately within each AppDomain. Writing to the same file from two different AppDomains is not supported. Specifying Verbosity Verbosity is specified using the nested enum InternalTrace.TraceLevel. Although the values currently match those of System.Diagnostics.TraceLevel, they have no actual relation to that class. Additional values may be added in the future. public class InternalTrace { public enum TraceLevel { Off, Error, Warning, Info, Debug } /* ... */ } A programmer working on NUnit may set the TraceLevel at any point in the code by setting the InternalTrace.Level property. Unresolved Issues How should the destination and verbosity level of internal trace be specified by a user?"
  },
  "articles/nunit/technical-notes/nunit-internals/specs/Parameterized-Test-Fixtures-Spec.html": {
    "href": "articles/nunit/technical-notes/nunit-internals/specs/Parameterized-Test-Fixtures-Spec.html",
    "title": "Parameterized Test Fixtures Spec | NUnit Docs",
    "summary": "Parameterized Test Fixtures Spec Note This page is a specification that was used as a starting point for creating the feature in NUnit. It needs to be reviewed and revised in order to accurately reflect what was actually built. If you take it with a grain of salt, it may still be helpful to you as documentation. This notice will be removed when the page is brought up to date. NUnit 2.6.4 supports parameterized test fixtures using constructor arguments specified on the TestFixtureAttribute. This is similar to the way that TestCaseAttribute handles parameterized methods. However, methods in 2.6.4 benefit from a very rich set of attributes in addition, allowing the data to be kept separately from the test and permitting use of data types that cannot appear as arguments to an Attribute constructor in .NET. For NUnit 3.0, we would like to create a similarly rich set of attributes for specifying how TestFixture instances should be created. This spec will outline the features we plan to support. Type names are placeholders and may be changed as the work proceeds. TestFixtureSourceAttribute This will work similarly to TestCaseSourceAttribute and will supply the constructor arguments for the fixture. The two types will probably be unified under a common base. TestFixtureData This will work similarly to TestCaseData with the addition of a number of features that are needed for fixtures. In particular, the Type will need to support a TypeArgs property and possibly a separate set of arguments for use with the OneTimeSetUp method. ValuesAttribute ValueSourceAttribute RangeAttribute RandomAttribute These attributes may be used on a TestFixture constructor with arguments. Their effect will be similar to use on method arguments, causing the fixture to be constructed a number of times. CombinatorialAttribute PairwiseAttribute SequentialAttribute These attributes will need to be modified to work on test fixtures as well as methods. They specify how individual argument values are to be combined to for a set of arguments for constructing the fixture."
  },
  "articles/nunit/technical-notes/nunit-internals/specs/Specifications.html": {
    "href": "articles/nunit/technical-notes/nunit-internals/specs/Specifications.html",
    "title": "Specifications | NUnit Docs",
    "summary": "Specifications Note Some of these items are actually implemented in the latest release. We are in the process of reviewing all the specs in this section to determine what needs to be converted into actual documentation pages. Specifications are descriptions of work we are doing or plan to do. They may vary in degree of specificity and the actual code may sometimes deviate from the spec as work progresses, without necessarily going back to change the spec. When the work is done, the spec is removed from the site or incorporated into a tech note as needed. Component Title Implemented? General Internal Trace Spec Partial? Framework Include and Exclude Attributes Spec No Extended Constraint Syntax Spec No Dynamic Test Cases Spec No Parameterized Test Fixtures Spec Partial Test Dependency Attribute Spec No Test Engine Engine Addins Spec Partial"
  },
  "articles/nunit/technical-notes/nunit-internals/specs/Test-Dependency-Attribute-Spec.html": {
    "href": "articles/nunit/technical-notes/nunit-internals/specs/Test-Dependency-Attribute-Spec.html",
    "title": "Test Dependency Attribute Spec | NUnit Docs",
    "summary": "Test Dependency Attribute Spec Warning This is a draft. The contents may be out of date. This spec describes a proposed new attribute to be used to specify dependencies between tests within a test fixture, and between different test fixtures. Attribute We would define a new attributes, Dependencies: [Dependencies (<dependency-specification> [, <dependency-specification> [, ...]])] where <dependency-specification> is: Before=\"TestA, TestB\" After=\"TestC, TestD\" AfterAnySuccess=\"TestE, TestF\" AfterAnyFailure=\"TestG, TestH\" AfterAllSuccess=\"TestE, TestF\" AfterAllFailure=\"TestG, TestH\" BeforeAll AfterAll AfterAllSuccess This attribute would apply to Test's within a single TestFixture, or to TextFixture's within a single test assembly. Each dependency-specification is described in more detail below (in all cases, <test-list> should be replaced with a <testfixture-list> if the attribute is being applied to a TestFixture): <test-list> is a string containing a comma separated list of Test's to include in the dependency. <testfixture-list> is a string containing a comma separated list of TestFixture's to include in the dependency. Before=<test-list> The designated Test or TestFixture will be run to completion (successfully or not) before any of the tests specified in the list are run. After=<test-list> The designated Test or TestFixture will be run after the completion (successfully or not) of all of the tests specified in the list. AfterAllSuccess=<test-list> The Test or TestFixture will be run after the successful completion of all of the tests specified in the list. If any of the tests specified in the list fail, the designated Test or TestFixture will not be run. AfterAllFailure=<test-list> The Test or TestFixture will be run after the failure of all of the tests specified in the list. If any of the tests specified in the list succeed, the designated Test or TestFixture will not be run. AfterAnySuccess=<test-list> The Test or TestFixture will be run after the successful completion of any of the tests specified in the list. If all of the tests specified in the list fail, the designated Test or TestFixture will not be run. AfterAnyFailure=<test-list> The Test or TestFixture will be run after the failure of any of the tests specified in the list. If all of the tests specified in the list succeed, the designated Test or TestFixture will not be run. BeforeAll The Test or TestFixture will be run before all other tests or test fixtures are run. This dependency can be overridden by a specific Before dependency referencing this Test or TestFixture. AfterAll The Test or TestFixture will be run after all other tests or test fixtures have been run (whether they have completed successfully or not). This dependency can be overridden by a specific Afterxxx dependency referencing this Test or TestFixture. AfterAllSuccess The Test or TestFixture will be run after all other tests or test fixtures have been run and completed successfully. If any Test or TestFixture fails, this Test or TestFixture will not be run. This dependency can be overridden by a specific Afterxxx dependency referencing this Test or TestFixture. Note that a single Test or TestFixture may have multiple <dependency-specification> elements as long as they do not conflict with each other. Any loops or contradictory references in the dependencies will be discovered, and will result in the specified dependencies being ignored, and a warning being given. For example, if TestA has Before=\"TestB\" and TestB has Before=\"TestA\", both will be ignored, and a warning given. (An alternative would be to use whichever was specified first or last). If multiple tests or test fixtures are in the same relative position in the dependency tree, the order in which they will be run will be the default order. For example, if multiple tests have a BeforeAll dependency, they will run in the default order, but before all other tests not having that dependency specified. Items to consider: Is the name in a <test-list> the name in the code, or the generated name for the test? I would prefer to use the static name that is in the code, but there may be a case for using the generated name. Should there be a simple dependency language to be used to specify the dependency rather then the static properties? e.g. before(\"TestA\") && afterFails (\"TestB\") || afterSuccess (\"TestC\")"
  },
  "articles/nunit/technical-notes/usage/Addin-Replacement-in-the-Framework.html": {
    "href": "articles/nunit/technical-notes/usage/Addin-Replacement-in-the-Framework.html",
    "title": "Addin Replacement In The Framework | NUnit Docs",
    "summary": "Addin Replacement In The Framework NUnit 2.6 supports six types of addins, all of which are being removed from NUnit 3.0: SuiteBuilders TestCaseBuilders TestDecorators TestCaseProviders DataPointProviders EventListeners General Approach The addin design for NUnit 2.6 was intended to extend to the console and gui runners in addition to the framework. However, this was never implemented and all six of the existing addin types apply to the framework only. In NUnit 3.0, the functions provided by these addins are being taken over by the use of custom attributes. NUnit 3.0 attributes are generally active. That is, they contain code to perform the function they call for rather than simply serving as markers to be interpreted by the runner. Advantages In general, all the same capabilities will be present in NUnit 3.0 and will be much more easily accessible to those who create extensions. Currently, creating an extension is complex and error prone. Use of active attributes generally involves one of two approaches: Derive the new attribute class from an existing NUnit base that provides the needed facilities. For example, a new data-providing attribute might derive from DataAttribute. Derive directly from NUnitAttribute, the base of the NUnit attribute hierarchy, and implement one or more interfaces that perform the desired function. Limitations All existing addins will need to be re-implemented as custom attributes. They will not work in NUnit 3.0. Addins not based on custom attributes are no longer possible. In NUnit 2.6, for example, it was possible to write an addin that defined tests based on the name of a method, e.g.: methods beginning with \"Test\". This sort of extension will no longer be possible in the NUnit 3.0 framework. However, this does not seem to be a big problem, since virtually all addins that we know about have been based on attributes. Implementation Because parts of NUnit are implemented as internal addins, it's not possible to simply remove all addin support at once. Many things would stop working if we did this. Therefore, we will refactor code for each of the internal types to conform to the new design, only removing the overall addin framework when this is complete. The remaining sections of this spec deal with how each of the addin types is being replaced. The order of the sections reflects the order in which we are implementing the changes. The implementation status of each of the types is shown in parentheses. This spec refers to a number of interfaces that form part of the NUnit framework. Until a technical note covering these interfaces is published, please rely on the source code for documentation. Some of the sections that follow have not had all their design work completed, so the degree of detail varies among them. More information will be added as work progresses. TestDecorators Status: REMOVED TestDecorators in NUnit 2.6 could do one of three things: Modify the properties of the test or the execution context Drop the test by returning null. Replace the test, possibly wrapping the old test within the new one. In NUnit 3.0, each of these is implemented differently. To modify the properties of the test, create an attribute that implements IApplyToTest. To modify the execution context, implement IApplyToContext. This is a new capability. It is no longer possible - but not necessary either - to replace the test. In NUnit 3.0, the test object does not execute itself. Instead, a series of commands is created, which carry out the necessary operations to run the test. An attribute that implements ICommandDecorator is able to contribute to add additional commands to be executed when running the test. It is no longer possible to simply eliminate the test. Once created, a test will always appear in the UI, for example. However, by use of a command decorator, it is possible to prevent the test from executing. DataPointProviders Status: Removed NUnit 2.6 has two built-in providers of data for individual parameters of test methods: ParameterDataProvider gets data from attributes that appear directly on the parameter. DatapointProvider gets data from DataPoint and DataPointSource attributes, which appear on the data source rather than on the parameter. In the current 3.0 code, ParameterDataProvider actually delegates its work to the attributes, which must implement IParameterDataSource. In NUnit 3.0, users will be able to create additional attributes implementing this interface and they will be used as data sources. On the other hand, DataPointProvider contains the code for accessing the data specified by the DataPoint and DataPointSource attributes, which are simply used as markers. This is because the attributes do not have a reference to the member on which they are placed. It would be necessary to introduce a method to provide them with this reference in order to do the processing within the attribute and this would appear to introduce otherwise unneeded code with no particular benefit. Consequently, for the initial implementation of NUnit 3.0, it will not be possible to create custom attributes that work in similar fashion to DataPoint or DataPointSource. If the need arises, some interface may be introduced. Since DataPointProviders are only called from within TestCaseProviders, implementation of these changes may need to be interleaved with changes related to TestCaseProviders. See the next section for details. TestCaseProviders Status: REMOVED NUnit 2.6 currently has two built-in TestCaseProviders: DataAttributeTestCaseProvider gets test case data from any DataAttribute, such as TestCaseAttribute. CombinatorialTestCaseProvider creates test cases by combining parameter data from a DataPointProvider. Currently, DataAttributeTestCaseProvider delegates all the work to the DataAttribute. This is the desired approach. Users implementing a new custom data attribute may inherit from DataAttribute or implement an interface. CombinatorialTestCaseProvider works differently. It instantiates one of three available CombiningStrategy types, based on attributes appearing on the method. The CombiningStrategy is used to generate test cases from the available parameter data. For NUnit 3.0, the work of combining parameter data into cases will be moved into the CombiningStrategy attributes. An interface will be defined and users will be able to create new combining strategies by defining a custom attribute that implements the interface. EventListeners Status: REMOVED EventListeners implement the ITestListener interface and are notified when important events in the life of a test occur. Almost all the functions of an EventListener can already be emulated in NUnit 2.6 by use of an ActionAttribute. ActionAttributes are not yet implemented in NUnit 3.0. Consequently, the first step in removing EventListeners is to implement ActionAttributes. Some changes may be made in the process and a separate spec will be written to describe them. The only function of EventListeners that cannot be duplicated by ActionAttributes at this time is the capture of text output from the test. A new approach will be designed for this purpose. TestCaseBuilders Status: REMOVED NUnit 2.6 has one built-in TestCaseBuilder, NUnitTestCaseBuilder, which implements ITestCaseBuilder2. All TestCaseBuilders must implement either ITestCaseBuilder or ITestCaseBuilder2. In NUnit 3.0, the interface and its implementation will be moved into the attributes that designate a test. For example, TestAttribute will actually build a test case. This may be done using ITestCaseBuilder2 or a new interface may be designed. Users wishing to create a new kind of test case will need to define a new attribute, which implements the interface. A few issues need to be resolved: Some attributes, such as TestCaseAttribute or TestCaseSourceAttribute serve dual functions: they both mark a test case and provide data for the test case. Some combination of the code for generating test cases with that for creating tests is likely to be required. For backward compatibility, an extra TestAttribute accompanying one or more TestCaseAttributes should not generate an additional TestCase. SuiteBuilders Status: REMOVED NUnit 2.6 has one built-in SuiteBuilder, which implements the required ISuiteBuilder interface. Similarly to what is being done for test cases, the building of a test fixture will be moved into the TestFixture attribute. The supporting interface may need to be redefined. Users may create new types of test fixtures by defining a new attribute, which implements the interface. Similar issues as with TestCaseBuilder must be resolved, in addition to a few others: TestFixtureAttribute both marks a test case and provides arguments used to construct the fixture. Extra TestFixtureAttributes in the hierarchy must be ignored. We want to add similar data-generation capabilities to TestFixture as exist for methods using TestCaseSource. We want to allow \"TheoryFixtures\", which combine multiple related Theories into a single fixture. We want to support an AbstractTestFixtureAttribute, which marks a class as the base of a fixture hierarchy but not a fixture itself."
  },
  "articles/nunit/technical-notes/usage/Assembly-Isolation.html": {
    "href": "articles/nunit/technical-notes/usage/Assembly-Isolation.html",
    "title": "Assembly Isolation | NUnit Docs",
    "summary": "Assembly Isolation NUnit isolates test assemblies from its own code and from one another by use of separate Processes and AppDomains. By default, NUnit loads each test assembly into a separate Process under the control of the NUnit Agent program. This allows NUnit to ensure that each assembly is loaded in the environment for which it was built. Within the agent process, NUnit's own code runs in the primary AppDomain while the tests run in a separate AppDomain. If desired, multiple test assemblies may be loaded into the same process and even the same domain by use of the -process and -domain command-line options. See Console Command Line."
  },
  "articles/nunit/technical-notes/usage/Configuration-Files.html": {
    "href": "articles/nunit/technical-notes/usage/Configuration-Files.html",
    "title": "Configuration Files | NUnit Docs",
    "summary": "Configuration Files Normally, a configuration file used to provide settings or to control the environment in which tests are run, should be given the name as the assembly file with the suffix \".config\" added. For example, the configuration file used to run nunit.tests.dll must be named nunit.tests.dll.config and located in the same directory as the dll. Notes: When multiple assemblies are specified in an NUnit project (file extension .nunit), it is possible to specify a common config file for the included test assemblies. When multiple assemblies are specified on the command-line using the --domain:Single option, no config file is currently used."
  },
  "articles/nunit/technical-notes/usage/Counting-Tests.html": {
    "href": "articles/nunit/technical-notes/usage/Counting-Tests.html",
    "title": "Counting Tests | NUnit Docs",
    "summary": "Counting Tests Counting tests sounds simple but there are a few issues. This page documents how the framework counts tests in various categories. In general, when counting tests, we are talking about test cases. In the case of non-parameterized test methods, that's the same as the number of methods. Where there are parameters, we count the number of individual cases. When all the tests in an assembly are run, the total number of tests is the number of tests present in the assembly. When selection is made - either via the command line or through a Gui - we count only tests that are actually selected. Non-selected tests don't appear at all in the XML result file and are not taken into account by the counts. Tests are categorized in one of four statuses: Passed, Failed, Inconclusive and Skipped. Passed tests currently only have one ResultState, Success. Failed tests are caused by any of the following: Failure of an assertion (ResultState.Failure) An unexpected exception (ResultState.Error) An invalid test (ResultState.NotRunnable) User cancellation (ResultState.Cancelled) Inconclusive tests currently only have one ResultState, Inconclusive Skipped tests are caused by Ignoring the test (ResultState.Ignored) The test was marked explicit (ResultState.Skipped) Note: this may change to ResultState.Explicit in the future A Platform, Culture or UICulture attribute test failed (ResultState.Skipped) Users may define new ResultStates in any of the four statuses. Failures, errors, skipping or ignoring in the SetUp for a test counts the same as if the action happened in the test method itself. When fixtures are ignored or otherwise skipped using an attribute on the class, all tests within the fixture are given the corresponding result. Failures, errors, skipping or ignoring in the OneTimeSetUp for a fixture causes all the test cases in the fixture to get the corresponding result. An invalid fixture causes all of its test cases to count as invalid."
  },
  "articles/nunit/technical-notes/usage/Debugging-Support.html": {
    "href": "articles/nunit/technical-notes/usage/Debugging-Support.html",
    "title": "Debugging Support | NUnit Docs",
    "summary": "Debugging Support This document describes framework functionality for debugging support of tests and tested code. ThrowOnEachFailureUnderDebugger Setting (From version 4.2.0) Setting name defined by FrameworkPackageSettings.ThrowOnEachFailureUnderDebugger constant. It may sometimes be necessary to debug the current state of a test during an Assertion.Multiple block. Typically, assertion exceptions are thrown only after the block is completed. This boolean framework setting will cause the debugger to throw on a failed assertion during an Assert.Multiple block. This allows user to break execution on exception and inspect tested code state at time of failure. Because this behavior is useful only for debugging, it is not activated without an attached debugger (Debugger.IsAttached = true)."
  },
  "articles/nunit/technical-notes/usage/Engine-Parallel-Test-Execution.html": {
    "href": "articles/nunit/technical-notes/usage/Engine-Parallel-Test-Execution.html",
    "title": "Engine Parallel Test Execution | NUnit Docs",
    "summary": "Engine Parallel Test Execution The NUnit test engine is able to offer a certain degree of parallelization by running the tests in each test assembly in a different Process. This is a separate facility from Framework Parallel Test Execution although the two may be used concurrently. If tests are already split across multiple assemblies, this is the simplest way to improve performance through parallel execution. By running in separate processes, the tests in each assembly are independent of one another so long as they do not use any common external resources such as files or databases. Parallel execution is the default behavior when running multiple assemblies together using the nunit3-console runner. Normally, all the test processes run simultaneously. If you need to reduce the number of processes allowed to run at one time, you may specify a value for the --agents option on the nunit3-console command-line. For example, if you are running tests in 10 different processes, a setting of --agents=3 will allow no more than three of them to execute simultaneously. Note This facility does not depend on the test framework used in any way. Test assemblies that use older versions of NUnit may be run in parallel processes just as easily as those using NUnit 3. If extensions are created to support additional frameworks, the NUnit engine will run those assemblies in parallel as well. Process Model NUnit 3 uses the ProcessModel enumeration to specify how assemblies are split across processes. The ProcessModel for a run may specified either on the console command-line or in the NUnit project file. As in NUnit V2, three values are defined: ProcessModel.Single causes all tests to be run within the NUnit process itself. ProcessModel.Separate loads and runs all the tests in a single separate process. ProcessModel.Multiple loads and runs each test assembly in a separate process. In NUnit 3, if ProcessModel.Multiple is used, the processes are executed in parallel. This is also the default if the ProcessModel is not specified."
  },
  "articles/nunit/technical-notes/usage/Framework-Parallel-Test-Execution.html": {
    "href": "articles/nunit/technical-notes/usage/Framework-Parallel-Test-Execution.html",
    "title": "Framework Parallel Test Execution | NUnit Docs",
    "summary": "Framework Parallel Test Execution The NUnit 3.0 framework can run tests in parallel within an assembly. This is a completely separate facility from Engine Parallel Test Execution, although it is possible to use both in the same test run. By default, no parallel execution takes place. Attributes are used to indicate which tests may run in parallel and how they relate to other tests. Platform Support Parallel execution is supported by the NUnit framework on desktop .NET runtimes and .NET Standard 2.0. It is not supported in the .NET Standard 1.6 build, although the attributes are recognized without error in order to allow use in projects that build against multiple targets. ParallelizableAttribute This attribute is used to indicate whether the test and/or its descendants may be run in parallel with other tests. The constructor takes an optional ParallelScope enumeration argument (see below), which defaults to ParallelScope.Self. The attribute may be used at the assembly, class or method level and the word \"test\" in the rest of this description refers to the suite or test case that corresponds to the item on which the attribute appears. One Named Property is supported: Scope = ParallelScope for setting ParallelScope using property syntax NonParallelizableAttribute This Attribute is used to indicate that the test as well as its descendants may not be run in parallel with other tests. Although [NonParallelizable] is completely equivalent to [Parallelizable(ParallelScope.None)], we recommend that you use the former for clarity. ParallelScope Enumeration This is a [Flags] type enumeration used to specify which tests may run in parallel. It applies to the test upon which it appears and any subordinate tests. The following values are available for use: ParallelScope.Self indicates that the test itself may be run in parallel with other tests. This is the default for the ParallelizableAttribute and is the only value permitted on a test method. ParallelScope.Children indicates that the descendants of the test may be run in parallel with respect to one another. ParallelScope.Fixtures indicates that test fixtures that are the descendants of the test may be run in parallel with one another.` Note Additional values of the enumerator are used internally. They do not show up in the Intellisense and are not documented here. The value ParallelScope.None, which was used before the creation of the NonParallelizableAttribute is still accepted for the purpose of backward compatibility. Specifying Parallelism at Multiple Test Levels [Parallelizable] or [NonParallelizable] may be specified on multiple levels of the tests, with lower-level specifications overriding higher ones to a certain degree. Thus, if the assembly has [NonParallelizable] either by use of the attribute or by default, classes with [Parallelizable] may be run in parallel as may their children if an appropriate scope is used. It is important to note that a parallel or non-parallel specification only applies at that level where it appears and below. It cannot override the settings on higher-level tests. In this way, parallelism is not absolute but is relative to other tests at the same level in the tree. The following are a few examples of how this works: Non-parallel class with parallel methods: The methods only run in parallel with one another, not with the test methods of any other classes. Parallel class with non-parallel methods: The methods run sequentially, usually on the same thread that ran the class one-time setup, but may actually be running in parallel with other, unrelated methods from other classes. Non-parallel SetUpFixture with parallel test fixtures: The entire group of fixtures runs separately from any fixtures outside the group. Within the group, multiple fixtures run in parallel. Parallel SetUpFixture with non-parallel test fixtures: The group runs in parallel with other fixtures and groups. Within the group, only one fixture at a time may execute. Parallel SetUpFixture with non-parallel test fixtures containing parallel test cases: This is just one example of a more complex setup. The fixtures themselves run as described in (4) but the cases within each fixture run in parallel with one another. Once you understand the principles, you can construct complex hierarchies of parallel and non-parallel tests. LevelOfParallelismAttribute This is an assembly-level attribute, which may be used to specify the level of parallelism, that is, the maximum number of worker threads executing tests in this assembly. It may be overridden using a command-line option in the console runner. If it is not specified, NUnit uses a default value based on the number of processors available or a specified minimum, whichever is greater. Parallel Execution Internals We use multiple queues organized into \"shifts\". A WorkShift consists of one or more queues of work items, which may be active at the same time. As the name suggests, no two shifts are active simultaneously. NUnit runs one WorkShift until all available work is complete and then switches to the next shift. When there is no work for any shift, the run is complete. There are three shifts, listed here with their associated queues... Shift Queues Workers Usage Parallel Shift Parallel Queue LoP* Parallelizable tests run in the MTA Parallel STA Queue 1 Parallelizable tests run in the STA Non-Parallel Shift Non-Parallel Queue 1 Non-parallelizable tests run in the MTA Non-Parallel STA Shift Non-Parallel STA Queue 1 Non-parallelizable tests run in the STA (* Depends on Level of Parallelism) For efficiency, each queue is created when the first test is added to it. At the time of creation, all workers for that queue are also created and initialized. Whenever a non-parallel fixture begins execution, an entirely new set of queues is created so that the child tests of that fixture may be run without any conflict from other tests that are already in the main set of queues. If the command line specifies zero workers, all use of the dispatcher and its queues is bypassed and tests are run sequentially on a single thread."
  },
  "articles/nunit/technical-notes/usage/NUnit-Project-XML-Format.html": {
    "href": "articles/nunit/technical-notes/usage/NUnit-Project-XML-Format.html",
    "title": "NUnit Project XML Format | NUnit Docs",
    "summary": "NUnit Project XML Format <NUnitProject> The required root element for any NUnit project file. Containing Element: None Contained Elements: <Settings>, <Config> Attributes: None <Settings> Contains global settings that apply to all configurations in the project. May be empty or absent. Containing Element: <NUnitProject> Contained Elements: None Attributes: activeconfig The name of the config to use if none is specified by the user. Using nunit-console, you may override this through the --config command-line option. appbase The application base to use in loading and running tests. Defaults to the location of the .nunit project file. If the path is relative, as it normally is, it is taken as relative to the location of the project file. processModel Specifies how NUnit should create processes for executing test assemblies. Possible values are: Default, Single (no separate processes are created), Separate (tests are run in a single, separate process) and Multiple (each assembly is run in its own separate process). The default value is Multiple, provided there are multiple assemblies, otherwise Separate. domainUsage Specifies how NUnit should create AppDomains within each process for running tests. Possible values are: Default, None (no domain is created), Single (a single domain is created) and Multiple (a separate domain is created for each assembly). The default is Multiple if multiple assemblies are run in the same process, Single if only one assembly is run in a process. <Config> Describes a specific configuration of the project. This may map to traditional compiler configs like Debug or Release or may be used to specify any arbitrary collection of assemblies to be tested together. At least one configuration should be specified or the project will not be usable. Containing Element: <NUnitProject> Contained Elements: <assembly> Attributes: name The name of this configuration. (Required) appbase The application base to use in loading and running tests under this config. Defaults to the appbase specified in the <Settings> element. The path should normally be relative to that global application base or to the location of project file if there is no global appbase. binpath The probing path used to search for assemblies, consisting of a number of directory paths separated by semicolons. The directory paths should be relative to the application base and must be under it. Specifying this attribute automatically sets the binpathtype to 'manual'. binpathtype Indicates how the probing path is determined. Possible values are: Auto (the probing path is determined from the location of the test assemblies), Manual (the path is specified by the binpath attribute) and None (no probing path is used). It is an error to specify a value other than Manual if the binpath attribute is also used. configfile Specifies the path to a config file to be used when running tests under this configuration. The path is relative to the application base. processModel Specifies how NUnit should create processes for executing test assemblies under this configuration. Possible values are: Default, Single (no separate processes are created), Separate (tests are run in a single, separate process) and Multiple (each assembly is run in its own separate process). The default is the value specified globally or Multiple if nothing has been specified. domainUsage Specifies how NUnit should create AppDomains within each process for running tests under this configuration. Possible values are: Default, None (no domain is created), Single (a single domain is created) and Multiple (a separate domain is created for each assembly). The default is the value specified globally, if provided, otherwise Multiple if multiple assemblies are run in the same process, Single if only one assembly is run in a process. runtimeFramework Specifies a runtime framework to be used in running tests. Abbreviations are the same as those accepted by the nunit-console command-line. If none is specified, tests are run under the target runtime specified when the assembly was compiled. <assembly> Specifies a single assembly containing tests. Containing Element: <Config> Contained Elements: None Attributes: path The path to the test assembly, relative to the application base for its configuration."
  },
  "articles/nunit/technical-notes/usage/Parameterized-Tests.html": {
    "href": "articles/nunit/technical-notes/usage/Parameterized-Tests.html",
    "title": "Parameterized Tests | NUnit Docs",
    "summary": "Parameterized Tests NUnit supports parameterized tests. Test methods may have parameters and various attributes are available to indicate what arguments should be supplied by NUnit. Multiple sets of arguments cause the creation of multiple tests. All arguments are created at the point of loading the tests, so the individual test cases are available for display and selection in the Gui, if desired. Some attributes allow you to specify arguments inline - directly on the attribute - while others use a separate method, property or field to hold the arguments. In addition, some attributes identify complete test cases, including all the necessary arguments, while others only provide data for a single argument. This gives rise to four groups of attributes, as shown in the following table. Complete Test Cases Data for One Argument Inline TestCase Attribute Random Attribute, Range Attribute, Values Attribute Separate TestCaseSource Attribute ValueSource Attribute In addition, when data is specified for individual arguments, special attributes may be added to the test method itself in order to tell NUnit how to go about combining the arguments. Currently, the following attributes are provided: Combinatorial Attribute (default) Pairwise Attribute Sequential Attribute Order of Execution The individual test cases are executed in the order in which NUnit discovers them. This order does not necessarily follow the lexical order of the attributes and will often vary between different compilers or different versions of the CLR. The following specific rules for ordering apply: If all arguments are specified in a single TestCaseSource attribute, the ordering of the cases provided will be maintained. If each parameter has a single Values, ValueSource or Range attribute and the Sequential combining strategy is used - or there is only one argument - the ordering will be maintained. In all other cases, including using multiple TestCase attributes or a combination of different types of attributes, the ordering of the test cases is undefined."
  },
  "articles/nunit/technical-notes/usage/Platform-Selection.html": {
    "href": "articles/nunit/technical-notes/usage/Platform-Selection.html",
    "title": "Platform Selection | NUnit Docs",
    "summary": "Platform Selection If your tests are compiled x86 or x64, NUnit will run each assembly by default in a process targeted at the appropriate platform as well as the targeted runtime. If you run multiple assemblies in the same process, you may not mix x86 and x64 assemblies. On an x64 machine, if your test assembly is compiled x86, you must not use /process=Single on the command line. This is because NUnit is already running in a 64-bit process and will fail when it tries to load your assembly into the same process. If your test assembly references any x86 or x64 assemblies, it should be built for the same platform. Consequently, you may not mix x86 and x64 references."
  },
  "articles/nunit/technical-notes/usage/Runtime-Selection.html": {
    "href": "articles/nunit/technical-notes/usage/Runtime-Selection.html",
    "title": "Runtime Selection | NUnit Docs",
    "summary": "Runtime Selection By default, NUnit runs tests under the runtime version for which the test assembly was built, provided it is available on the test machine. If it is not available, NUnit runs the assembly under the best available runtime that will allow it to run. If no suitable runtime can be found, an error is reported. Overriding the Defaults The default runtime framework may be overridden using command line options. In all cases, NUnit will attempt to honor the options given, issuing an error message if the assembly cannot be loaded. See Console Command Line for more information. The /framework option of console runner allows you to specify the framework type and version to be used for a test run. When this option is used, NUnit will attempt to run the tests under the framework specified even if the assembly targets a different runtime. The /process:Single command-line option indicates that tests should be run in the NUnit process itself. This forces usage of the runtime under which NUnit is already running. The process:Separate causes a single separate process to be used for all assemblies. In this case, NUnit will use the highest level runtime targeted by any of the assemblies, if it is available."
  },
  "articles/nunit/technical-notes/usage/SetUp-and-TearDown.html": {
    "href": "articles/nunit/technical-notes/usage/SetUp-and-TearDown.html",
    "title": "SetUp And TearDown | NUnit Docs",
    "summary": "SetUp And TearDown Attribute Usage SetUpAttribute is now used exclusively for per-test setup. TearDownAttribute is now used exclusively for per-test teardown. OneTimeSetUpAttribute is used for one-time setup per test-run. If you run n tests, this event will only occur once. OneTimeTearDownAttribute is used for one-time teardown per test-run. If you run n tests, this event will only occur once SetUpFixtureAttribute continues to be used as at before, but with changed method attributes. Attribute Usage by Fixture Type TestFixture SetUpFixture OneTimeSetUp Supported Supported OneTimeTearDown Supported Supported TestFixtureSetUp Deprecated Not Allowed TestFixtureTearDown Deprecated Not Allowed SetUp Supported Not Allowed TearDown Supported Not Allowed How Setup and TearDown Methods Are Called Multiple SetUp, OneTimeSetUp, TearDown and OneTimeTearDown methods may exist within a class. Setup methods (both types) are called on base classes first, then on derived classes. If any setup method throws an exception, no further setups are called. Teardown methods (again, both types) are called on derived classes first, then on the base class. The teardown methods at any level in the inheritance hierarchy will be called only if a setup method at the same level was called. The following example is illustrates the difference. public class BaseClass { [SetUp] public void BaseSetUp() { /* ... */ } // Exception thrown! [TearDown] public void BaseTearDown() { /* ... */ } } [TestFixture] public class DerivedClass : BaseClass { [SetUp] public void DerivedSetUp() { /* ... */ } [TearDown] public void DerivedTearDown() { /* ... */ } [Test] public void TestMethod() { /* ... */ } } Execution will proceed as follows: BaseSetUp BaseTearDown rather than BaseSetUp DerivedTearDown BaseTearDown See also: SetUp and TearDown Changes"
  },
  "articles/nunit/technical-notes/usage/Test-Filters.html": {
    "href": "articles/nunit/technical-notes/usage/Test-Filters.html",
    "title": "Test Filters | NUnit Docs",
    "summary": "Test Filters Test Filters represent a selection of tests to be displayed, run or loaded. When a filter needs to be passed to the framework, it is passed as a string containing an XML fragment. This page describes the elements present in the XML for a filter. <filter> This is the required top-level element for any filter. If it contains no other elements, it represents an empty filter. If it contains just one element, that element is used as the filter for all tests. If it contains multiple elements, it works like an <and> element. Child elements allowed: <and>, <or>, <not>, <id>, <test>, <cat>, <class>, <method>, <namespace>, <prop>, <name>. <and> Represents an AndFilter. All contained filter elements must pass in order for this filter to pass. Child elements allowed: <and>, <or>, <not>, <id>, <test>, <cat>, <class>, <method>, <namespace>, <prop>, <name>. <or> Represents an OrFilter. At least one contained filter element must pass in order for this filter to pass. Child elements allowed: <and>, <or>, <not>, <id>, <test>, <cat>, <class>, <method>, <namespace>, <prop>, <name>. <not> Represents a NotFilter. The single contained filter element must fail in order for this filter to pass. Child elements allowed: <and>, <or>, <not>, <id>, <test>, <cat>, <class>, <method>, <namespace>, <prop>, <name>. <id> Represents an IdFilter. The text of the element contains a single test id or multiple ids separated by commas. Since test ids are an internal construct, this filter is not useful externally. However, it is used by the NUnit Gui to efficiently select tests from the list of those loaded. Child elements allowed: None. <test> Represents a selection by test name. The full name of the test is used as its inner text. If the filter should use a regular expression for matching then the element should contain an attribute named re with the value \"1\". Child elements allowed: None. <cat> Represents a CategoryFilter. The text of the element contains a single category. If the filter should use a regular expression for matching then the element should contain an attribute named re with the value \"1\". Child elements allowed: None. <class> Represents a selection by class name. The fully qualified name of the class is used as its inner text. If the filter should use a regular expression for matching then the element should contain an attribute named re with the value \"1\". Child elements allowed: None. <method> Represents a selection by method name. The name of the method is used as its inner text. If the filter should use a regular expression for matching then the element should contain an attribute named re with the value \"1\". Child elements allowed: None. <namespace> Represents a selection by namespace. The fully qualified name of the namespace is used as its inner text. If the filter should use a regular expression for matching then the element should contain an attribute named re with the value \"1\". Child elements allowed: None. <prop> Represents a PropertyFilter. The element has an attribute name which specifies the name of the property. The text of the element contains the value of the property. If the filter should use a regular expression for matching then the element should contain an attribute named re with the value \"1\". Child elements allowed: None. <name> Represents a selection by test name. The test name assigned by NUnit is used as its inner text. If the filter should use a regular expression for matching then the element should contain an attribute named re with the value \"1\". Child elements allowed: None."
  },
  "articles/nunit/technical-notes/usage/Test-Result-XML-Format.html": {
    "href": "articles/nunit/technical-notes/usage/Test-Result-XML-Format.html",
    "title": "Test Result XML Format | NUnit Docs",
    "summary": "Test Result XML Format <test-run> The required root element for any NUnit 3.0 test result file. Containing Elements: None Contained Elements: <command-line>, <filter>, <test-suite> Attributes: id The unique ID of this test. testcasecount The number of test cases contained in this test run. result The basic result of the test. May be Passed, Failed, Inconclusive or Skipped. total The total number of test cases executed in the run. This may be less than the testcasecount due to filtering of tests. passed The number of test cases that passed. failed The number of test cases that failed. inconclusive The number of test cases that were inconclusive. skipped The number of test cases that were skipped. asserts The number of asserts executed in the test run. engine-version The version of the NUnit test engine in use. clr-version The runtime version under which the engine is running, taken from Environment.Version. start-time The UTC time that the test run started. end-time The UTC time that the test run ended. duration The duration of the test run in seconds, expressed as a real number. <command-line> Holds a CDATA section containing the text of the command used to run the tests. Containing Elements: <test-run> Contained Elements: None Attributes: None <filter> The XML representation of the filter used to execute tests. This element is also used as a fragment in passing the filter to a runner and by the NUnit 3.0 framework and driver. Containing Elements: <test-run> Contained Elements: <or>, <and>, <not>, <id>, <test>, <class>, <method>, <cat> Attributes: None <or> Represents a composite filter that contains other filters. At least one of the contained filters must pass in order for this filter to pass. Containing Elements: <filter>, <or>, <and>, <not> Contained Elements: <or>, <and>, <not>, <id>, <test>, <class>, <method>, <cat>, <prop> Attributes: None <and> Represents a composite filter that contains other filters. All of the contained filters must pass in order for this filter to pass. Containing Elements: <filter>, <or>, <and>, <not> Contained Elements: <or>, <and>, <not>, <id>, <test>, <class>, <method>, <cat>, <prop> Attributes: None <not> Represents a composite filter that contains wraps a single base filters. The base filter must fail in order for this filter to pass. Containing Elements: <filter>, <or>, <and>, <not> Contained Elements: <or>, <and>, <not>, <id>, <test>, <class>, <method>, <cat>, <prop> Attributes: None <id> Represents a filter that examines the test id, which is generated by NUnit. Containing Elements: <filter>, <or>, <and>, <not> Contained Elements: None Attributes: None <test> Containing Elements: <filter>, <or>, <and>, <not> Contained Elements: None Attributes: re Set to '1' to indicate that a regular expression comparison is to be used. <class> Containing Elements: <filter>, <or>, <and>, <not> Contained Elements: None Attributes: re Set to '1' to indicate that a regular expression comparison is to be used. <method> Containing Elements: <filter>, <or>, <and>, <not> Contained Elements: None Attributes: re Set to '1' to indicate that a regular expression comparison is to be used. <prop> Containing Elements: <filter>, <or>, <and>, <not> Contained Elements: None Attributes: name The name of the property to filter on. re Set to '1' to indicate that a regular expression comparison is to be used. <cat> Containing Elements: <filter>, <or>, <and>, <not> Contained Elements: None Attributes: None <test-suite> Containing Elements: <test-run>, <test-suite> Contained Elements: <environment>, <settings>, <properties>, <reason>, <failure>, <output>, <attachments>, <test-suite>, <test-case> Attributes type The type of suite represented by this element. Currently supported types are Project, Assembly, TestSuite, TestFixture, GenericFixture, ParameterizedFixture, SetUpFixture, GenericMethod, ParameterizedMethod, Theory. id The unique id of this test. Coded as \"mmm-nnn\" where the part before the hyphen represents the assembly and the part after it represents a test in that assembly. Currently, mmm and nnn are ints, but that is merely an accident of the implementation and should not be relied on. name The display name of the test as generated by NUnit. fullname The full name of the test as generated by NUnit. classname The full name of the class (fixture) representing this test. Only present if type is equal to \"TestFixture\". testcasecount The number of test cases contained, directly or indirectly, in this suite. runstate An indicator of whether the suite is runnable. Value may be NotRunnable, Runnable, Explicit, Skipped or Ignored. NotRunnable means there is an error in how the test is expressed in code, for example, the signature may be wrong. Explicit, Skipped and Ignored are set by attributes on the test. result The basic result of the test. May be Passed, Failed, Inconclusive or Skipped. label Additional labeling information about the result. In principle, this may be any string value and is combined with the result to give a more precise reason for failure. Currently, NUnit may use the following labels in combination with the Failure result: Error, Cancelled or Invalid. It may use the following labels in combination with a Skipped result: Ignored or Explicit. Additional values may be added in future releases or supplied by extensions, so code that processes a result file should be prepared to deal with any label or none at all. site Optional element indicating where a failure occurred. Values are Test, SetUp, TearDown, Parent or Child. Default is Test and the attribute does not normally appear in that case. start-time The UTC time that the suite started. end-time The UTC time that the suite ended. duration The duration of the suite in seconds, expressed as a real number. total The total number of test cases executed under this suite. passed The number of test cases that passed. failed The number of test cases that failed. inconclusive The number of test cases that were inconclusive. skipped The number of test cases that were skipped. asserts The number of asserts executed by the suite, including any nested suites or test cases. Since asserts may be executed in OneTimeSetUp and in ActionAttributes, this number can be greater than the total of the asserts for the test cases. <environment> Describes the environment in which the tests in a particular assembly are being run. Containing Elements: <test-suite> (Assembly level only) Contained Elements: None Attributes: framework-version The version of the nunit framework in use. clr-version The runtime version under which the tests are running, taken from Environment.Version. os-version A text string describing the operating system running the tests, taken from Environment.OsVersion. platform The platform id, taken from Environment.OsVersion.Platform. cwd The current working directory path, taken from Environment.CurrentDirectory. machine-name The machine name, taken from Environment.MachineName. user The user id, taken from Environment.UserName. user-domain The user domain, taken from Environment.UserDomainName. culture The current culture, taken from CultureInfo.CurrentCulture. uiculture The current UI culture, taken from CultureInfo.CurrentUICulture. os-architecture The architecture, taken from GetProcessorArchitecture(). <settings> Settings used by the engine for executing an assembly. These are taken from the supplied settings in the TestPackage supplemented by default settings created by the engine itself. Containing Elements: <test-suite> (Assembly level only) Contained Elements: <setting> Attributes: None <setting> A single setting Containing Elements: <settings> Contained Elements: None Attributes: name The name of the setting. value The value assigned to the setting. <test-case> Containing Elements: <test-suite> Contained Elements: <properties>, <reason>, <failure>, <output>, <attachments> Attributes id The unique id of this test. Coded as \"mmm-nnn\" where the part before the hyphen represents the assembly and the part after it represents a test in that assembly. Currently, mmm and nnn are ints, but that is merely an accident of the implementation and should not be relied on. name The display name of the test as generated by NUnit or, in the case of some parameterized tests, specified by the user. fullname The full name of the test as generated by NUnit. methodname The name of the method representing the test case. classname The full name of the class in which this test case appears. runstate An indicator of whether the suite is runnable. Value may be NotRunnable, Runnable, Explicit, Skipped or Ignored. NotRunnable means there is an error in how the test is expressed in code, for example, the signature may be wrong. Explicit, Skipped and Ignored are set by attributes on the test. seed The seed used to generate random arguments and other values for this test. result The basic result of the test. May be Passed, Failed, Inconclusive or Skipped. label Additional labeling information about the result. In principle, this may be any string value and is combined with the result to give a more precise reason for failure. Currently, NUnit may use the following labels in combination with the Failure result: Error, Cancelled or Invalid. It may use the following labels in combination with a Skipped result: Ignored or Explicit. Additional values may be added in future releases or supplied by extensions, so code that processes a result file should be prepared to deal with any label or none at all. site Optional element indicating where a failure occurred. Values are Test, SetUp, TearDown, Parent or Child. Default is Test and the attribute does not normally appear in that case. start-time The UTC time that the test started. end-time The UTC time that the test ended. duration The duration of the test in seconds, expressed as a real number. asserts The number of asserts executed by the test. <properties> Optional element containing any properties assigned to the test case or suite. Containing Elements: <test-suite>, <test-case> Contained Elements: <property> Attributes None <property> A single property Containing Elements: <properties> Contained Elements: None Attributes name The name of the property value The value of the property <reason> Optional element that may appear on tests or suites that were not executed. The element may also appear on tests that were short circuited using Assert.Pass. Contains a message giving the reason for skipping or short circuiting the test. Containing Elements: <test-suite>, <test-case> Contained Elements: <message> Attributes None <failure> Optional element that appears on all tests or suites with a result of 'Failed'. Optionally contains the error message and/or a stack trace. Containing Elements: <test-suite>, <test-case> Contained Elements: <message>, <stack-trace> Attributes None <assertions> Containing Elements: <test-suite>, <test-case> Contained Elements: <assertion> Attributes None <assertion> Containing Elements: <assertions> Contained Elements: <message>, <stack-trace> Attributes result The result of the assertion. May be Inconclusive, Passed, Warning, Failed or Error. <message> Optional element with a CDATA section containing a message relating to the test's result. Containing Elements: <failure>, <reason>, <assertion> Contained Elements: None Attributes None <stack-trace> Optional element with a CDATA section containing a stack-trace of the location where a test failed. Containing Elements: <failure>, <assertion> Contained Elements: None Attributes None <output> Optional element that appears on tests or suites that produce text output. The output may be intercepted from writes to the console or captured directly when the test writes to the TestContext. It is contained in a CDATA section. Containing Elements: <test-suite>, <test-case> Contained Elements: None Attributes None <attachments> Optional element that appears when files are attached to a test. Contains a list of <attachment> elements. Containing Elements: <test-suite>, <test-case> Contained Elements: <attachment> Attributes None <attachment> Groups together the file path and description of a test attachment. Containing Elements: <attachments> Contained Elements: <filePath>, <description> Attributes None <filePath> Contains the file path for the attachment. Paths will be fully rooted. Containing Elements: <attachment> Contained Elements: None Attributes None <description> Optional element that contains the user's description of the attachment. It is contained in a CDATA section. Containing Elements: <attachment> Contained Elements: None Attributes None"
  },
  "articles/nunit/technical-notes/usage/Trace-and-Debug-Output.html": {
    "href": "articles/nunit/technical-notes/usage/Trace-and-Debug-Output.html",
    "title": "How to enable Trace and Debug output | NUnit Docs",
    "summary": "How to enable Trace and Debug output Trace and Debug output is by default not sent to the console output, or anywhere else. If you want to have this output, you must add a TraceListener. Activating the System.Diagnostics.ConsoleTraceListener in your code This is easy to do, and you can do it per assembly, per namespace or per test. All it takes is to add the necessary initialization of the ConsoleTraceListener. To add it to a namespace, place the following class inside that namespace, and it will apply to all tests inside that namespace and below. The code shown adds the output to console output. [SetUpFixture] public class SetupTrace { [OneTimeSetUp] public void StartTest() { Trace.Listeners.Add(new ConsoleTraceListener()); } [OneTimeTearDown] public void EndTest() { Trace.Flush(); } } If you place the code above outside of any namespace it will apply to the whole assembly. If you'd like to only apply to a given test fixture/class, you can add the StartTest and EndTest methods to the given test fixture/class. If you like you can change that to another kind of listener. Example outputs Given the following verbose test: [Test] public void Test1() { Debug.WriteLine(\"This is Debug.WriteLine\"); Trace.WriteLine(\"This is Trace.WriteLine\"); Console.WriteLine(\"This is Console.Writeline\"); TestContext.WriteLine(\"This is TestContext.WriteLine\"); TestContext.Out.WriteLine(\"This is TestContext.Out.WriteLine\"); TestContext.Progress.WriteLine(\"This is TestContext.Progress.WriteLine\"); TestContext.Error.WriteLine(\"This is TestContext.Error.WriteLine\"); Assert.Pass(); } With a TraceListener, the output in Visual Studio Test Explorer is: Without the TraceListener, the blocks in red will not be present. Running dotnet test -v n, the output will be: Activating the NUnit.Framework.Diagnostics.ProgressTraceListener in your code Opposed to the ConsoleTraceListener, the ProgressTraceListener will show Trace and Debug output immediately. Activating is equally easy to do, and you can also do it per assembly, per namespace or per test. All it takes is to add the necessary initialization of the ProgressTraceListener and make sure it is only added once. The final Trace.Flush() is not needed with the ProgressTraceListener. To add it to a namespace, place the following class inside that namespace, and it will apply to all tests inside that namespace and below. The code shown adds the output to progress output. [SetUpFixture] public class SetupTrace { [OneTimeSetUp] public void StartTest() { if (!Trace.Listeners.OfType<ProgressTraceListener>().Any()) Trace.Listeners.Add(new ProgressTraceListener()); } } If you place the code above outside of any namespace it will apply to the whole assembly. If you'd like to only apply to a given test fixture/class, you can add the StartTest and EndTest methods to the given test fixture/class. If you like you can change that to another kind of listener. Discussion and source This issue has been discussed at Issue 718 and Issue 301. Use of TraceListener suggested by Frans Bouma. This issue has also been discussed at NUnit Issue 4686 based on TestCentric GUI Issue 1043. ProgressTraceListener suggested by Charlie Poole. The repro code for the issue can be found on this vs-adapter issue and on this TestCentric GUI issue."
  },
  "articles/nunit/technical-notes/usage/Usage-Notes.html": {
    "href": "articles/nunit/technical-notes/usage/Usage-Notes.html",
    "title": "Usage Notes | NUnit Docs",
    "summary": "Usage Notes Runtime Selection Platform Selection Assembly Isolation Configuration Files XML Formats Visual Studio Support SetUp and TearDown Parameterized Tests Addin Replacement in the Framework Counting Tests Framework Parallel Test Execution Engine Parallel Test Execution"
  },
  "articles/nunit/technical-notes/usage/Visual-Studio-Support.html": {
    "href": "articles/nunit/technical-notes/usage/Visual-Studio-Support.html",
    "title": "Visual Studio Support | NUnit Docs",
    "summary": "Visual Studio Support Warning This is a draft. The contents may be out of date. NUnit supports the Visual Studio project and solution format, which are also used by a number of other IDEs. Running From Within Visual Studio The most convenient way to do this is to set up a custom tool entry specifying the path to NUnit as the command. For a VS2003 C# project, you can use $(TargetPath) for the arguments and $(TargetDir) for the initial directory. With Visual Studio VS2005 this becomes a bit harder, because that release changed the meaning of the 'Target' macros so they now point to the intermediate 'obj' directories rather than the final output in one of the 'bin' directories. Here are some alternatives that work in both versions: \\((ProjectDir)\\)(ProjectFileName) to open the VS Project rather than the assembly. If you use this approach, be sure to rename your config file accordingly and put it in the same directory as the VS project file. \\((ProjectDir)bin/Debug/\\)(TargetName)$(TargetExt) to run the assembly directly. Note that this requires hard-coding part of the path, including the configuration. If you would like to debug your tests, use the Visual Studio Debug | Processes… menu item to attach to NUnit after starting it and set breakpoints in your test code as desired before running the tests. Opening Visual Studio Projects When Visual Studio support is enabled, the File Open dialog displays the following supported Visual Studio project types: C#, VB.Net, J# and C++. The project file is read and the configurations and output assembly locations are identified. Since the project files do not contain information about the most recently opened configuration, the output assembly for the first configuration found (usually Debug) is loaded in the GUI. The tree shows the project as the top-level node with the assembly shown as its descendant. When tests are run for a Visual studio project, they run just as if the output assembly had been loaded with one exception. The default location for the config file is the directory containing the project file and its default name is the same as the project file with an extension of .config. For example, the following command would load the tests in the nunit.tests assembly using the configuration file nunit.tests.dll.config located in the same directory as the dll. nunit.exe nunit.tests.dll On the other hand, the following command would load the tests using the configuration file nunit.tests.config located in the same directory as the csproj file. nunit.exe nunit.tests.csproj The same consideration applies to running tests using the console runner. Opening Visual Studio Solutions When Visual Studio support is enabled, solution files may be opened as well. All the output assemblies from contained projects of the types supported will be loaded in the tree. In the case where all contained projects are located in the subdirectories beneath the solution, it will be possible to load and run tests using this method directly. When a solution contains projects located elsewhere in the file system, it may not be possible to run the tests - although the solution will generally load without problem. In this case, the Project Editor should be use to modify and save the NUnit test project so that there is all referenced assemblies are located in or beneath the application base directory."
  },
  "articles/nunit/technical-notes/usage/XML-Formats.html": {
    "href": "articles/nunit/technical-notes/usage/XML-Formats.html",
    "title": "XML Formats | NUnit Docs",
    "summary": "XML Formats Warning This is a draft. The contents may be out of date. Use of XML in NUnit 2.x is somewhat limited and is only used in external files. NUnit 3.0 uses XML in several of its interfaces for communicating between its three architectural layers. The samples given here represent the current state of the application and are subject to change. Watch this page for new information as development continues. NUnit Projects An NUnit project is stored as a file with the extension .nunit and describes one or more test assemblies to be executed, together with certain parameters used in running them. No schema is used for this file. Sample NUnit Project Currently, the format is the same as for NUnit 2.x but it is likely to change as the project proceeds. Note that NUnitLite does not use or recognize NUnit projects, but only assemblies. For details of the file contents, see NUnit Project XML Format NUnit Settings The NUnitSettings30.xml file holds default settings for NUnit 3.0. No schema is used for this file. The format is the same as for 2.x but new settings may be added and the names of certain keys are likely to change. Sample NUnit Settings File Test Results The results of an test run are saved in a file with the default name of TestResult.xml. The schema of this file is being modified substantially for NUnit 3.0. Sample Schema not yet available For details of the file layout see Test Result XML Format. V2 Test Results Optionally, NUnit 3.0 is able to save results in the NUnit 2.x format for use with CI servers that do not yet understand the new format. Sample Schema Test Representation When using the -explore option, a list of tests without results is returned. The format used is simply a subset of the test result format, without the result information. See Test Result XML Format for details. Test Filters Information about which tests to run is provided to the framework using a test filter, represented as an XML fragment. See Test Filters for details. Test Packages Progress Reports As a test run progresses, individual test run results are sent as xml fragments from the result file under construction. A runner can, in fact, construct a copy of the result file incrementally using these fragments if desired. VisualState The Gui runner uses a file with the suffix .VisualState.xml to save the current visual state of a project so that it may be restored upon re-opening. This file is private to the Gui but is included here for completeness. The current format is identical to that used in NUnit 2.x. Sample Visual State File"
  },
  "articles/nunit/writing-tests/AssertionHelper.html": {
    "href": "articles/nunit/writing-tests/AssertionHelper.html",
    "title": "Assertion Helper | NUnit Docs",
    "summary": "Assertion Helper AssertionHelper has been deprecated as of NUnit Framework 3.7. The syntax is now maintained and being enhanced as an independent library, NUnit.StaticExpect. Some users prefer a shorter form of assertion than is given by Assert.That. If you derive your test fixture class from AssertionHelper, the Expect() method may be used instead... Expect(bool condition); Expect(bool condition, string message, params object[] params); Expect(ActualValueDelegate del, IResolveConstraint constraint) Expect(ActualValueDelegate del, IResolveConstraint constraint, string message, params object[] params) Expect<TActual>(TActual actual, IResolveConstraint constraint) Expect<TActual>(TActual actual, IResolveConstraint constraint, string message, params object[] params) Expect(TestDelegate del, IResolveConstraint constraint); In addition, AssertionHelper allows the derived class to make direct use of many of the syntactic elements that would normally require you to specify the Is, Has or Does class in order to use them. For example, you can write... Expect(actual, EqualTo(\"Hello\")); Use Intellisense to determine which syntactic elements are available in the current release."
  },
  "articles/nunit/writing-tests/Assumptions.html": {
    "href": "articles/nunit/writing-tests/Assumptions.html",
    "title": "Assumptions | NUnit Docs",
    "summary": "Assumptions Assumptions are intended to express the state a test must be in to provide a meaningful result. They are functionally similar to assertions, however an unmet assumption will produce an Inconclusive test result, as opposed to a Failure. Assumptions make use of the Assume static class. Syntax Example [TestCase(5)] [TestCase(0)] [TestCase(-5)] public void Number_Divided_By_Itself_Is1(int numberToCheck) { var divisor = GetMatchingDivisor(numberToCheck); Assume.That(divisor, Is.Not.EqualTo(0), () => \"divisor must not be zero in order for this test to be valid\"); var result = numberToCheck / divisor; Assert.That(result, Is.EqualTo(1)); } /// <summary> /// Returns same number that's passed in /// </summary> private int GetMatchingDivisor(int inputNumber) { // If this ever returned 0, we'd be in trouble return inputNumber; } Assume.That() has the same set of overloads as Assert.That(). For further details, see the Constraint Model documentation. Note Failing assumptions indicate that running tests is invalid, while Multiple Asserts allow testing to continue after a failure. For that reason, the two features are incompatible and assumptions may not be used within a multiple assert block."
  },
  "articles/nunit/writing-tests/ListMapper.html": {
    "href": "articles/nunit/writing-tests/ListMapper.html",
    "title": "ListMapper | NUnit Docs",
    "summary": "ListMapper Important ListMapper has been deprecated as of NUnit Framework 3.13.2. The functionality was removed in NUnit Framework 4.0. Unlike Constraint classes, ListMapper is used to modify the actual value argument to Assert.That(). It transforms the actual value, which must be a collection, creating a new collection to be tested against the supplied constraint. Currently, ListMapper supports one transformation: creating a collection of property values. Normally, ListMapper will be used through the List.Map() syntax helper. The following example shows two forms of the same assert. string[] strings = new string[] { \"a\", \"ab\", \"abc\" }; int[] lengths = new int[] { 1, 2, 3 }; Assert.That(List.Map(strings).Property(\"Length\"), Is.EqualTo(lengths)); Assert.That(new ListMapper(strings).Property(\"Length\"), Is.EqualTo(lengths));"
  },
  "articles/nunit/writing-tests/Randomizer-Methods.html": {
    "href": "articles/nunit/writing-tests/Randomizer-Methods.html",
    "title": "Randomizer Methods | NUnit Docs",
    "summary": "Randomizer Methods The Randomizer object exposed by TestContext.CurrentContext.Random extends System.Random to provide random data for a wide range of numeric types as well as enums and strings. Each test context has access to its own Randomizer which is used to generate random values for the RandomAttribute as well as for use by the user calling its methods. The benefit of using Randomizer rather than System.Random directly is twofold: A wide range of types are provided in a uniform manner. Randomizer produces repeatable values for the test run so long as no tests are changed and the same seed is used to initialize the run. A future extension is planned, which would provide repeatability at the individual method level, even if other methods are changed. Int (System.Int32) Next() Returns the next random non-negative int. (Inherited from System.Random) Next(int max) Returns the next random non-negative int less than max, which must be positive. (Inherited from System.Random) Next(int min, int max) Returns the next random int in the range min to max, excluding max. (Inherited from System.Random) UInt (System.UInt32) NextUInt() Returns the next random uint. NextUInt(uint max) Returns the next random uint less than max. NextUInt(uint min, uint max) Returns the next random uint in the range min to max, excluding max. Long (System.Int64) NextLong() Returns the next random non-negative long. NextLong(long max) Returns the next random non-negative long less than max, which must be positive. NextLong(long min, long max) Returns the next random long in the range min to max, excluding max. ULong (System.UInt64) NextULong() Returns the next random ulong. NextULong(ulong max) Returns the next random ulong less than max. NextULong(ulong min, ulong max) Returns the next random ulong in the range min to max, excluding max. Short (System.Int16) NextShort() Returns the next random non-negative short. NextShort(short max) Returns the next random non-negative short less than max, which must be positive. NextShort(short min, short max) Returns the next random short in the range min to max, excluding max. UShort (System.UInt16) NextUShort() Returns the next random ushort. NextUShort(ushort max) Returns the next random ushort less than max. NextUShort(ushort min, ushort max) Returns the next random ushort in the range min to max, excluding max. SByte (System.SByte) NextSByte() Returns the next random non-negative sbyte. NextSByte(sbyte max) Returns the next random non-negative sbyte less than max, which must be positive. NextSByte(sbyte min, sbyte max) Returns the next random sbyte in the range min to max, excluding max. Byte (System.Byte) NextByte() Returns the next random byte. NextByte(byte max) Returns the next random byte less than max. NextByte(byte min, byte max) Returns the next random byte in the range min to max, excluding max. Double (System.Double) NextDouble() Returns the next double in the range 0.0 to 1.0, exclusive. (Inherited from System.Random.) NextDouble(double max) Returns the next non-negative double less than max. NextDouble(double min, double max) Returns the next double in the range min to max, excluding max. Float (System.Float) NextFloat() Returns the next float in the range 0.0f to 1.0f, exclusive. NextFloat(float max) Returns the next non-negative float less than max. NextFloat(float min, float max) Returns the next float in the range min to max, excluding max. Decimal (System.Decimal) NextDecimal() Returns the next non-negative random decimal. NextDecimal(decimal max) Returns the next non-negative decimal less than max. NextDecimal(decimal min, decimal max) Returns the next decimal in the range min to max, excluding max. Notes on Decimal Implementation In the current implementation, the scale is always set to zero. That is, the values are all integral, with no decimal places. This may be enhanced in a future release by allowing the user to specify the scale. In the third form, an exception is currently thrown if the range is greater than decimal.MaxValue. This can only occur if min is negative and max is positive. Bool (System.Boolean) NextBool() Returns a random bool with equal probability of true or false. NextBool(double probability) Returns a random bool with the specified probability of being true. Probability argument must be in the range 0.0 to 1.0, inclusive. Enum (System.Enum) NextEnum<T>() Returns a random enum value of type T. All the values of the enum are returned with equal probability. Note that this may not be useful in all cases for enums with the FlagsAttribute specified. NextEnum(Type type) Returns a random enum value of the type specified as an object, which the caller will normally cast to the specified type. String (System.String) GetString() Returns a random string of default length, composed using a default set of characters. In the current implementation, the default length is hard-coded as 25 and the default characters are abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNOPQRSTUVWXYZ0123456789_. GetString(int length) Returns a random string of the specified length. GetString(int outputLength, string allowedChars) Returns a random string of the specified length using the characters in the string given as the second argument. Guid (System.Guid) NextGuid() (available in version 3.8) Generates a version 4 Guid conforming the RFC 4122. Version 4 Guids are made of random data."
  },
  "articles/nunit/writing-tests/TestCaseData.html": {
    "href": "articles/nunit/writing-tests/TestCaseData.html",
    "title": "TestCaseData | NUnit Docs",
    "summary": "TestCaseData The TestCaseData class provides extended test case information for a parameterized test, although any object deriving from TestCaseParameters may be used. Unlike NUnit 2, you cannot implement ITestCaseData, you must derive from TestCaseParameters. [TestFixture] public class MyTests { [TestCaseSource(typeof(MyDataClass), nameof(MyDataClass.TestCases))] public int DivideTest(int n, int d) { return n / d; } } public class MyDataClass { public static IEnumerable TestCases { get { yield return new TestCaseData(12, 3).Returns(4); yield return new TestCaseData(12, 2).Returns(6); yield return new TestCaseData(12, 4).Returns(3); } } } This example uses the fluent interface supported by TestCaseData to make the program more readable. TestCaseData supports the following properties and methods, which may be appended to an instance in any order. Explicit() or Explicit(string) causes the test case to be marked explicit, optionally specifying the reason for doing so. Ignore(string) causes the test case to be ignored and specifies the reason, which is required. Returns specifies the expected result to be returned from the method, which must have a compatible return type. SetArgDisplayNames(string[]) sets the list of display names to use as the parameters in the test name. SetCategory(string) applies a category to the test. SetDescription(string) sets the description property of the test. SetName(string) provides a name for the test. If not specified, a name is generated based on the method name and the arguments provided. See Template Based Test Naming. SetProperty(string, string), SetProperty(string, int) and SetProperty(string, double) apply a named property and value to the test. TypeArgs specifies the Types to be used when targeting a generic test method. (NUnit 4.1+)"
  },
  "articles/nunit/writing-tests/TestContext.html": {
    "href": "articles/nunit/writing-tests/TestContext.html",
    "title": "TestContext | NUnit Docs",
    "summary": "TestContext Each NUnit test runs in an execution context, which includes information about the environment as well as the test itself. The TestContext class allows tests to access certain information about the execution context. Note It's important to remember that \"test\" in NUnit may refer to an individual test cases or a suite such as a TestFixture. Within a test method, SetUp method or TearDown method, the context is that of the individual test case. Within a OneTimeSetUp or OneTimeTearDown method, the context refers to the fixture as a whole. This can lead to confusion, since most runners display information about fixtures differently from test cases. In fact, some runners may not display information about fixtures at all! Static Properties CurrentContext Gets the context of the currently executing test. This context is created separately for each test before it begins execution. See below for properties of the current context. Out Gets a TextWriter used for sending output to the current test result. Error Gets a TextWriter used for sending error output intended for immediate display. Progress Gets a TextWriter used for sending normal (non-error) output intended for immediate display. TestParameters Test parameters may be supplied to a run in various ways, depending on the runner used. For example, the console runner provides a command-line argument and v3.4 of the NUnit 3 VS Adapter will supports specifying them in a .runsettings file. The static TestParameters property returns an object representing those passed-in parameters. The TestParameters object supports the following properties: Count - The number of parameters. Names - A collection of the names of the supplied parameters. this[string name] - The value of a parameter. In Vb, use Item. The TestParameters object supports the following methods: Exists(string name) - Returns true if a parameter of that name exists. Get(string name)- Returns the same value as the indexer. Get<T>(string name, T defaultValue) - Returns the value of the parameter converted from a string to type T or the specified default if the parameter doesn't exist. Throws an exception if conversion fails. Note that all parameter values are strings. You may convert them to other Types using the generic Get method listed above or using your own code. An exception may be thrown if the supplied value cannot be converted correctly. Static Methods Write Writes text to the current test result, that is the Out writer. Prefer to use the Out writer directly for better clarity. Note: These methods will be deprecated in the future Write(bool value) Write(char value) Write(char[] value) Write(double value) Write(Int32 value) Write(Int64 value) Write(decimal value) Write(object value) Write(Single value) Write(string value) Write(UInt32 value) Write(UInt64 value) Write(string format, object arg1) Write(string format, object arg1, object arg2) Write(string format, object arg1, object arg2, object arg3) Write(string format, params object[] args) WriteLine Writes text to the current test result, followed by a newline, that is the Out writer. Prefer to use the Out writer directly for better clarity. Note: These methods will be deprecated in the future WriteLine() WriteLine(bool value) WriteLine(char value) WriteLine(char[] value) WriteLine(double value) WriteLine(Int32 value) WriteLine(Int64 value) WriteLine(decimal value) WriteLine(object value) WriteLine(Single value) WriteLine(string value) WriteLine(UInt32 value) WriteLine(UInt64 value) WriteLine(string format, object arg1) WriteLine(string format, object arg1, object arg2) WriteLine(string format, object arg1, object arg2, object arg3) WriteLine(string format, params object[] args) AddFormatter (3.2+) Adds a formatter for values based on some criterion, such as the Type of the value. The provided formatter will be used when an expected or actual value needs to be displayed as part of a message from a constraint. AddFormatter(ValueFormatter formatter); AddFormatter(ValueFormatterFactory formatterFactory); Both ValueFormatter and ValueFormatterFactory are delegates. ValueFormatter takes a single object as an argument and returns its string representation. The AddFormatter overload that takes a ValueFormatter is intended for use in most cases that arise. AddTestAttachment (3.7+) Attaches a file, with optional description, to the current test. AddTestAttachment(string filePath, string description = null); The file will be attached to the test result in the xml report. Test runners, such as the NUnit 3 VS Adapter, may also present the file to the user. Notes: The file must exist at the time of attachment. File paths will be resolved as fully rooted paths, relative to TestContext.CurrentContext.WorkDirectory, which can be set by the user. Properties of the CurrentContext Test Gets a representation of the current test, with the following properties: ID - The unique Id of the test Name - The name of the test, whether set by the user or generated automatically Namespace - The namespace of the test DisplayName - The display name of the test FullName - The fully qualified name of the test MethodName - The name of the method representing the test, if any Method - The IMethodInfo of the test method Type - The TypeInfo of the test ClassName - The classname of the test Arguments - The arguments as a list of objects, if any. ExpectedResult - The expected result, if that is set for the test Properties - An IPropertyBag of the test properties. Note: The Get method ONLY returns the first property (with a given key) for the current level. The following properties are in version 4.2 and above. Parent - The parent of the given test. AllPropertyValues - Returns a list of values (as objects) for a given property across the complete test hierarchy AllCategories - Returns a list of all categories (as strings) across the complete test hierarchy PropertyHierarchy - A utility method which returns the complete hierarchy of all properties including the name, value and level where they are found. Result Gets a representation of the test result, with the following properties: Outcome - A ResultState representing the outcome of the test. ResultState has the following properties: Status - A TestStatus with four possible values: Inconclusive Skipped Passed Warning Failed Label - An optional string value, which can provide sub-categories for each Status. See below for a list of common outcomes supported internally by NUnit. Site - A FailureSite value, indicating the stage of execution in which the test generated its result. Possible values are Test SetUp TearDown Parent Child Assertions - A list of AssertionResult values generated up to this point in the test. Please note that only failed assertions will be stored in here to limit the size of the result tree and potential impact on performance. Each AssertionResult has the following properties: Status - An AssertionStatus with five possible values: Inconclusive Passed Warning Failed Error Message - A string containing the message produced by the assertion (possibly null). StackTrace - A string containing the stack trace associated with the assertion. PassCount - An int representing the number of test cases that passed when running the test and all its children. FailCount - An int representing the number of test cases that failed when running the test and all its children. SkipCount - An int representing the number of test cases that were skipped when running the test and all its children. InconclusiveCount - An int representing the number of test cases that were inconclusive when running the test and all its children. StackTrace - A string containing the stack trace associated with an error or failure. Message - A string containing the message associated with a test failure or with not running the test. Although the outcome of the test may be accessed during setup or test execution, it only has a useful value in the teardown stage. Common Outcomes The following is a list of outcomes currently produced by NUnit. Others may be added in the future. Success: the test passed. (Status=Passed) Inconclusive: the test was inconclusive. (Status=Inconclusive) Failure: a test assertion failed. (Status=Failed, Label=empty) Error: an unexpected exception occurred. (Status=Failed, Label=Error) NotRunnable: the test was invalid and could not be run. (Status=Failed, Label=Invalid) Cancelled: the user cancelled while this test was running. (Status=Failed, Label=Cancelled) Ignored: the test was ignored. (Status=Skipped, Label=Ignored) Explicit: the test was not run because it is marked Explicit. (Status=Skipped, Label=Explicit) Skipped: the test was skipped for some other reason. (Status=Skipped, Label=empty) TestDirectory Gets the full path of the directory containing the current test assembly. WorkDirectory Gets the full path of the directory to be used for output from this test run. The XML result file and any redirected output files are located under this directory. This is normally the directory that was current when execution of NUnit began but may be changed by use of the --work option of nunit-console. Random Returns a Randomizer object, which may be used in the test code to generate random values. These values are repeatable on reruns of the tests so long as (a) the test assembly is not changed and (b) the same seed is used. The initial random seed used in any test run may be found in the XML result file and may be provided to a subsequent run on the command line. See Randomizer Methods for details about each available random data type."
  },
  "articles/nunit/writing-tests/TestFixtureData.html": {
    "href": "articles/nunit/writing-tests/TestFixtureData.html",
    "title": "TestFixtureData | NUnit Docs",
    "summary": "TestFixtureData The TestFixtureData class provides specific instance information for a parameterized fixture, although any object deriving from TestFixtureParameters may be used. Unlike NUnit 2, you cannot implement IFixtureData, you must derive from TestFixtureParameters. The following example varies the example shown under TestFixture Attribute by using a TestFixtureSourceAttribute with a data source in a separately defined class. [TestFixtureSource(typeof(MyFixtureData), nameof(MyFixtureData.FixtureParams))] public class ParameterizedTestFixture { private readonly string _eq1; private readonly string _eq2; private readonly string? _neq; public ParameterizedTestFixture(string eq1, string eq2, string? neq) { _eq1 = eq1; _eq2 = eq2; _neq = neq; } public ParameterizedTestFixture(string eq1, string eq2) : this(eq1, eq2, null) { } public ParameterizedTestFixture(int eq1, int eq2, int neq) { _eq1 = eq1.ToString(); _eq2 = eq2.ToString(); _neq = neq.ToString(); } [Test] public void TestEquality() { Assert.That(_eq2, Is.EqualTo(_eq1)); Assert.That(_eq2.GetHashCode(), Is.EqualTo(_eq1.GetHashCode())); } [Test] public void TestInequality() { Assert.That(_neq, Is.Not.EqualTo(_eq1)); if (_neq != null) { Assert.That(_neq.GetHashCode(), Is.Not.EqualTo(_eq1.GetHashCode())); } } } public class MyFixtureData { public static IEnumerable FixtureParams { get { yield return new TestFixtureData(\"hello\", \"hello\", \"goodbye\"); yield return new TestFixtureData(\"zip\", \"zip\"); yield return new TestFixtureData(42, 42, 99); } } }"
  },
  "articles/nunit/writing-tests/Warnings.html": {
    "href": "articles/nunit/writing-tests/Warnings.html",
    "title": "Warnings | NUnit Docs",
    "summary": "Warnings Sometimes - especially in integration testing - it's desirable to give a warning message but continue execution. Beginning with release 3.6, NUnit supports this with the Warn class and the Assert.Warn method. Syntax // Use Warn with reversed condition Warn.If(2 + 2 != 5); Warn.If(() => 2 + 2 != 5); Warn.If(2 + 2, Is.Not.EqualTo(5)); Warn.If(() => 2 + 2, Is.Not.EqualTo(5).After(500)); // Use Warn with original condition Warn.Unless(2 + 2 == 5); Warn.Unless(() => 2 + 2 == 5); Warn.Unless(2 + 2, Is.EqualTo(5)); Warn.Unless(() => 2 + 2, Is.EqualTo(5).After(500)); // Issue a warning message Assert.Warn(\"Warning message\"); Each of the above items would fail. The test would continue to execute, however, and the warning messages would only be reported at the end of the test. If the test subsequently fails, the warnings will be reported along with the failure message or - in the case of Assert.Multiple - messages. All of the overloads above also have a variant that accepts a function, Func<string>, that is used to build the message included with the Exception. Note The framework reports warnings by including information about them in the XML result that is sent to the runner in use. If you are using this facility, make sure the runner you use supports warnings. Generally, the runners released by the NUnit team after the release of the 3.6 framework will have this support. Earlier releases will not. Many third party runners will not know what to do with warnings either."
  },
  "articles/nunit/writing-tests/assertions/assertion-models/classic.html": {
    "href": "articles/nunit/writing-tests/assertions/assertion-models/classic.html",
    "title": "Classic Model | NUnit Docs",
    "summary": "Classic Model The classic Assert model uses a separate method to express each individual assertion of which it is capable. Here's a simple assert using the classic model: StringAssert.AreEqualIgnoringCase(\"Hello\", myString); The Assert class provides the most common assertions in NUnit: ClassicAssert.True ClassicAssert.False ClassicAssert.Null ClassicAssert.NotNull ClassicAssert.Zero ClassicAssert.NotZero ClassicAssert.IsNaN ClassicAssert.IsEmpty ClassicAssert.IsNotEmpty ClassicAssert.AreEqual ClassicAssert.AreNotEqual ClassicAssert.AreSame ClassicAssert.AreNotSame ClassicAssert.Contains ClassicAssert.Greater ClassicAssert.GreaterOrEqual ClassicAssert.Less ClassicAssert.LessOrEqual ClassicAssert.Positive ClassicAssert.Negative ClassicAssert.IsInstanceOf ClassicAssert.IsNotInstanceOf ClassicAssert.IsAssignableFrom ClassicAssert.IsNotAssignableFrom Assert.Throws Assert.ThrowsAsync Assert.DoesNotThrow Assert.DoesNotThrowAsync Assert.Catch Assert.CatchAsync Additional assertions are provided by the following classes, which are also in the NUnit.Framework.Legacy namespace: String Assert Collection Assert File Assert Directory Assert See Also Constraint Model Notes The exception-family of classic asserts have not yet been moved to the legacy namespace. They have not yet full equivalents in the constraint model."
  },
  "articles/nunit/writing-tests/assertions/assertion-models/constraint.html": {
    "href": "articles/nunit/writing-tests/assertions/assertion-models/constraint.html",
    "title": "Constraint Model (Assert.That) | NUnit Docs",
    "summary": "Constraint Model (Assert.That) The constraint-based Assert model uses a single method of the Assert class for all assertions. The logic necessary to carry out each assertion is embedded in the constraint object passed as the second parameter to that method. Here's a very simple assert using the constraint model: Assert.That(myString, Is.EqualTo(\"Hello\")); The second argument in this assertion uses one of NUnit's syntax helpers to create an EqualConstraint. The same assertion could also be made in this form: Assert.That(myString, new EqualConstraint(\"Hello\")); Using this model, all assertions are made using one of the forms of the Assert.That() method, which has a number of overloads... Assert.That(bool condition); Assert.That(bool condition, string message); Assert.That(bool condition, Func<string> getExceptionMessage); Assert.That(Func<bool> condition); Assert.That(Func<bool> condition, string message); Assert.That(Func<bool> condition, Func<string> getExceptionMessage); Assert.That<TActual>(ActualValueDelegate<TActual> del, IResolveConstraint constraint) Assert.That<TActual>(ActualValueDelegate<TActual> del, IResolveConstraint constraint, string message) Assert.That<TActual>(ActualValueDelegate<TActual> del, IResolveConstraint expr, Func<string> getExceptionMessage) Assert.That<TActual>(TActual actual, IResolveConstraint constraint) Assert.That<TActual>(TActual actual, IResolveConstraint constraint, string message) Assert.That<TActual>(TActual actual, IResolveConstraint expression, Func<string> getExceptionMessage) Assert.That(TestDelegate del, IResolveConstraint constraint) Assert.That(TestDelegate code, IResolveConstraint constraint, string message) Assert.That(TestDelegate code, IResolveConstraint constraint, Func<string> getExceptionMessage) The overloads that take a bool work exactly like ClassicAssert.IsTrue, except that ClassicAssert.IsTrue does not accept a Func<string> for the exception message. For overloads taking a constraint, the argument must be an object implementing the IResolveConstraint interface, which supports performing a test on an actual value and generating appropriate messages. This interface is described in more detail under Custom Constraints. NUnit provides a number of constraint classes similar to the EqualConstraint used in the examples above. Generally, these classes may be used directly or through a syntax helper. The valid forms are described on the pages related to each constraint. See also Classic Model"
  },
  "articles/nunit/writing-tests/assertions/assertion-models/special.html": {
    "href": "articles/nunit/writing-tests/assertions/assertion-models/special.html",
    "title": "Special Assertions | NUnit Docs",
    "summary": "Special Assertions The special assertions do not check any condition. They are used for special purposes, like unconditional failure or success, ignoring a test, etc. Assert.Pass Assert.Fail Assert.Ignore Assert.Inconclusive"
  },
  "articles/nunit/writing-tests/assertions/assertions.html": {
    "href": "articles/nunit/writing-tests/assertions/assertions.html",
    "title": "Assertions | NUnit Docs",
    "summary": "Assertions Assertions are central to unit testing in any of the xUnit frameworks, and NUnit is no exception. NUnit provides a rich set of assertions as static methods of the Assert class. If an assertion fails, the method call does not return and an error is reported. If a test contains multiple assertions, any that follow the one that failed will not be executed. For this reason, it's usually best to try for one assertion per test. Each method may be called without a message, with a simple text message or with a message with interpolated arguments (aka interpolated string). Two Models In NUnit 3.0 and higher, assertions are written primarily using the Assert.That method, which takes constraint objects as an argument. We call this the Constraint Model of assertions. In earlier versions of NUnit, a separate method of the Assert class was used for each different assertion. This Classic Model is still supported but since no new features have been added to it for some time, the constraint-based model must be used in order to have full access to NUnit's capabilities. For example, the following code must use the constraint model. There is no real classic equivalent. int[] array = { 1, 2, 3 }; Assert.That(array, Has.Exactly(1).EqualTo(3)); Assert.That(array, Has.Exactly(2).GreaterThan(1)); Assert.That(array, Has.Exactly(3).LessThan(100)); Where equivalents do exist, the two approaches will always give the same result, because the methods of the classic approach have all been implemented internally using constraints. For example... ClassicAssert.AreEqual(4, 2 + 2); Assert.That(2 + 2, Is.EqualTo(4)); Some notes on the Classic/Legacy asserts The classic/legacy asserts, like ClassicAssert.AreEqual, have now been moved into its own project (namespace), and may later be released as a separate package. They are now in the namespace NUnit.Framework.Legacy, and the Assert have been renamed to ClassicAssert. If you're upgrading from NUnit 3.X to NUnit 4, you need to add a using for NUnit.Framework.Legacy to your test classes, and rename all classic asserts from Assert to ClassicAssert. You can freely mix the constraint model assertions and the classic asserts in the same test class. All assertions in the ClassicAssert class are rerouting to use the constraint model. As shown in the example in Towards NUnit 4, error message have been enhanced so that you see the Assert expression. This also works for the ClassicAsserts, but what you will see there is the equivalent constraint expression."
  },
  "articles/nunit/writing-tests/assertions/classic-assertions/Assert.AreEqual.html": {
    "href": "articles/nunit/writing-tests/assertions/classic-assertions/Assert.AreEqual.html",
    "title": "ClassicAssert.AreEqual | NUnit Docs",
    "summary": "ClassicAssert.AreEqual ClassicAssert.AreEqual tests whether the two arguments are equal. ClassicAssert.AreEqual(double expected, double actual, double tolerance); ClassicAssert.AreEqual(double expected, double actual, double tolerance, string message, params object[] params); ClassicAssert.AreEqual(object expected, object actual); ClassicAssert.AreEqual(object expected, object actual, string message, params object[] params); Comparing Numerics of Different Types The method overloads that compare two objects make special provision so that numeric values of different types compare as expected. This assert succeeds: [Test] public void AreEqual_Examples() { // Comparing numerics of different types ClassicAssert.AreEqual(5, 5.0); // Floating point special values ClassicAssert.AreEqual(double.PositiveInfinity, double.PositiveInfinity); ClassicAssert.AreEqual(double.NegativeInfinity, double.NegativeInfinity); ClassicAssert.AreEqual(double.NaN, double.NaN); // Basic equality ClassicAssert.AreEqual(\"expected\", \"expected\"); ClassicAssert.AreEqual(42, 42); // With tolerance for floating point ClassicAssert.AreEqual(2.1 + 1.2, 3.3, 0.001); } Comparing Floating Point Values Values of type float and double are compared using an additional argument that indicates a tolerance within which they will be considered as equal. Special values are handled so that the following Asserts succeed: [Test] public void AreEqual_Examples() { // Comparing numerics of different types ClassicAssert.AreEqual(5, 5.0); // Floating point special values ClassicAssert.AreEqual(double.PositiveInfinity, double.PositiveInfinity); ClassicAssert.AreEqual(double.NegativeInfinity, double.NegativeInfinity); ClassicAssert.AreEqual(double.NaN, double.NaN); // Basic equality ClassicAssert.AreEqual(\"expected\", \"expected\"); ClassicAssert.AreEqual(42, 42); // With tolerance for floating point ClassicAssert.AreEqual(2.1 + 1.2, 3.3, 0.001); } Comparing Arrays and Collections NUnit is able to compare single-dimensioned arrays, multi-dimensioned arrays, nested arrays (arrays of arrays) and collections. Two arrays or collections are considered equal if they have the same dimensions and if each pair of corresponding elements is equal. NUnit 3.0 adds the ability to compare generic collections and dictionaries. See Also Equal Constraint DefaultFloatingPointTolerance Attribute"
  },
  "articles/nunit/writing-tests/assertions/classic-assertions/Assert.AreNotEqual.html": {
    "href": "articles/nunit/writing-tests/assertions/classic-assertions/Assert.AreNotEqual.html",
    "title": "ClassicAssert.AreNotEqual | NUnit Docs",
    "summary": "ClassicAssert.AreNotEqual ClassicAssert.AreNotEqual tests whether the two arguments are unequal. ClassicAssert.AreNotEqual(object expected, object actual); ClassicAssert.AreNotEqual(object expected, object actual, string message, params object[] params); See ClassicAssert.AreEqual for details of how NUnit performs equality comparisons. See Also ClassicAssert.AreEqual Equal Constraint"
  },
  "articles/nunit/writing-tests/assertions/classic-assertions/Assert.AreNotSame.html": {
    "href": "articles/nunit/writing-tests/assertions/classic-assertions/Assert.AreNotSame.html",
    "title": "ClassicAssert.AreNotSame | NUnit Docs",
    "summary": "ClassicAssert.AreNotSame ClassicAssert.AreNotSame tests that the two arguments do not reference the same object. ClassicAssert.AreNotSame(object expected, object actual); ClassicAssert.AreNotSame(object expected, object actual, string message, params object[] params); See Also SameAs Constraint"
  },
  "articles/nunit/writing-tests/assertions/classic-assertions/Assert.AreSame.html": {
    "href": "articles/nunit/writing-tests/assertions/classic-assertions/Assert.AreSame.html",
    "title": "ClassicAssert.AreSame | NUnit Docs",
    "summary": "ClassicAssert.AreSame ClassicAssert.AreSame tests that the two arguments reference the same object. ClassicAssert.AreSame(object expected, object actual); ClassicAssert.AreSame(object expected, object actual, string message, params object[] params); See Also SameAs Constraint"
  },
  "articles/nunit/writing-tests/assertions/classic-assertions/Assert.Catch.html": {
    "href": "articles/nunit/writing-tests/assertions/classic-assertions/Assert.Catch.html",
    "title": "Assert.Catch | NUnit Docs",
    "summary": "Assert.Catch Assert.Catch is similar to Assert.Throws but will pass for an exception that is derived from the one specified. Exception Assert.Catch(TestDelegate code); Exception Assert.Catch(TestDelegate code, string message, params object[] params); Exception Assert.Catch(Type expectedExceptionType, TestDelegate code); Exception Assert.Catch(Type expectedExceptionType, TestDelegate code, string message, params object[] params); T Assert.Catch<T>(TestDelegate code); T Assert.Catch<T>(TestDelegate code, string message, params object[] params); See Also Assert.CatchAsync Assert.Throws Assert.ThrowsAsync ThrowsConstraint"
  },
  "articles/nunit/writing-tests/assertions/classic-assertions/Assert.CatchAsync.html": {
    "href": "articles/nunit/writing-tests/assertions/classic-assertions/Assert.CatchAsync.html",
    "title": "Assert.CatchAsync | NUnit Docs",
    "summary": "Assert.CatchAsync Assert.CatchAsync is similar to Assert.ThrowsAsync but will pass for an exception that is derived from the one specified. Exception Assert.CatchAsync(AsyncTestDelegate code); Exception Assert.CatchAsync(AsyncTestDelegate code, string message, params object[] params); Exception Assert.CatchAsync(Type expectedExceptionType, AsyncTestDelegate code); Exception Assert.CatchAsync(Type expectedExceptionType, AsyncTestDelegate code, string message, params object[] params); T Assert.CatchAsync<T>(AsyncTestDelegate code); T Assert.CatchAsync<T>(AsyncTestDelegate code, string message, params object[] params); See Also Assert.Catch Assert.Throws Assert.ThrowsAsync ThrowsConstraint"
  },
  "articles/nunit/writing-tests/assertions/classic-assertions/Assert.Contains.html": {
    "href": "articles/nunit/writing-tests/assertions/classic-assertions/Assert.Contains.html",
    "title": "ClassicAssert.Contains | NUnit Docs",
    "summary": "ClassicAssert.Contains ClassicAssert.Contains is used to test whether an object is contained in a collection. ClassicAssert.Contains(object anObject, ICollection collection); ClassicAssert.Contains(object anObject, ICollection collection, string message, params object[] params); See Also CollectionContainsConstraint"
  },
  "articles/nunit/writing-tests/assertions/classic-assertions/Assert.DoesNotThrow.html": {
    "href": "articles/nunit/writing-tests/assertions/classic-assertions/Assert.DoesNotThrow.html",
    "title": "Assert.DoesNotThrow | NUnit Docs",
    "summary": "Assert.DoesNotThrow Assert.DoesNotThrow verifies that the delegate provided as an argument does not throw an exception. See Assert.DoesNotThrowAsync for asynchronous code. void Assert.DoesNotThrow(TestDelegate code); void Assert.DoesNotThrow(TestDelegate code, string message, params object[] params); See Also Assert.Throws ThrowsConstraint"
  },
  "articles/nunit/writing-tests/assertions/classic-assertions/Assert.DoesNotThrowAsync.html": {
    "href": "articles/nunit/writing-tests/assertions/classic-assertions/Assert.DoesNotThrowAsync.html",
    "title": "Assert.DoesNotThrowAsync | NUnit Docs",
    "summary": "Assert.DoesNotThrowAsync Assert.DoesNotThrowAsync verifies that the delegate provided as an argument does not throw an exception. See Assert.DoesNotThrow for synchronous code. void Assert.DoesNotThrowAsync(AsyncTestDelegate code); void Assert.DoesNotThrowAsync(AsyncTestDelegate code, string message, params object[] params); See Also Assert.ThrowsAsync ThrowsConstraint"
  },
  "articles/nunit/writing-tests/assertions/classic-assertions/Assert.Fail.html": {
    "href": "articles/nunit/writing-tests/assertions/classic-assertions/Assert.Fail.html",
    "title": "",
    "summary": ""
  },
  "articles/nunit/writing-tests/assertions/classic-assertions/Assert.False.html": {
    "href": "articles/nunit/writing-tests/assertions/classic-assertions/Assert.False.html",
    "title": "ClassicAssert.False | NUnit Docs",
    "summary": "ClassicAssert.False ClassicAssert.False and ClassicAssert.IsFalse test that the specified condition is false. The two forms are provided for compatibility with past versions of NUnit and NUnitLite. ClassicAssert.False(bool condition); ClassicAssert.False(bool condition, string message, params object[] params); ClassicAssert.IsFalse(bool condition); ClassicAssert.IsFalse(bool condition, string message, params object[] params); See Also Condition Constraints"
  },
  "articles/nunit/writing-tests/assertions/classic-assertions/Assert.Greater.html": {
    "href": "articles/nunit/writing-tests/assertions/classic-assertions/Assert.Greater.html",
    "title": "ClassicAssert.Greater | NUnit Docs",
    "summary": "ClassicAssert.Greater ClassicAssert.Greater tests whether one object is greater than another. Contrary to the normal order of Asserts, these methods are designed to be read in the \"natural\" English-language or mathematical order. Thus ClassicAssert.Greater(x, y) asserts that x is greater than y (x > y). ClassicAssert.Greater(int arg1, int arg2); ClassicAssert.Greater(int arg1, int arg2, string message, params object[] params); ClassicAssert.Greater(uint arg1, uint arg2); ClassicAssert.Greater(uint arg1, uint arg2, string message, params object[] params); ClassicAssert.Greater(long arg1, long arg2); ClassicAssert.Greater(long arg1, long arg2, string message, params object[] params); ClassicAssert.Greater(ulong arg1, ulong arg2); ClassicAssert.Greater(ulong arg1, ulong arg2, string message, params object[] params); ClassicAssert.Greater(decimal arg1, decimal arg2); ClassicAssert.Greater(decimal arg1, decimal arg2, string message, params object[] params); ClassicAssert.Greater(double arg1, double arg2); ClassicAssert.Greater(double arg1, double arg2, string message, params object[] params); ClassicAssert.Greater(float arg1, float arg2); ClassicAssert.Greater(float arg1, float arg2, string message, params object[] params); ClassicAssert.Greater(IComparable arg1, IComparable arg2); ClassicAssert.Greater(IComparable arg1, IComparable arg2, string message, params object[] params); See Also ClassicAssert.GreaterOrEqual ClassicAssert.Less ClassicAssert.LessOrEqual Comparison Constraints"
  },
  "articles/nunit/writing-tests/assertions/classic-assertions/Assert.GreaterOrEqual.html": {
    "href": "articles/nunit/writing-tests/assertions/classic-assertions/Assert.GreaterOrEqual.html",
    "title": "ClassicAssert.GreaterOrEqual | NUnit Docs",
    "summary": "ClassicAssert.GreaterOrEqual ClassicAssert.GreaterOrEqual tests whether one object is greater than or equal to another. Contrary to the normal order of Asserts, these methods are designed to be read in the \"natural\" English-language or mathematical order. Thus ClassicAssert.GreaterOrEqual(x, y) asserts that x is greater than or equal to y (x >= y). ClassicAssert.GreaterOrEqual(int arg1, int arg2); ClassicAssert.GreaterOrEqual(int arg1, int arg2, string message, params object[] params); ClassicAssert.GreaterOrEqual(uint arg1, uint arg2); ClassicAssert.GreaterOrEqual(uint arg1, uint arg2, string message, params object[] params); ClassicAssert.GreaterOrEqual(long arg1, long arg2); ClassicAssert.GreaterOrEqual(long arg1, long arg2, string message, params object[] params); ClassicAssert.GreaterOrEqual(ulong arg1, ulong arg2); ClassicAssert.GreaterOrEqual(ulong arg1, ulong arg2, string message, params object[] params); ClassicAssert.GreaterOrEqual(decimal arg1, decimal arg2); ClassicAssert.GreaterOrEqual(decimal arg1, decimal arg2, string message, params object[] params); ClassicAssert.GreaterOrEqual(double arg1, double arg2); ClassicAssert.GreaterOrEqual(double arg1, double arg2, string message, params object[] params); ClassicAssert.GreaterOrEqual(float arg1, float arg2); ClassicAssert.GreaterOrEqual(float arg1, float arg2, string message, params object[] params); ClassicAssert.GreaterOrEqual(IComparable arg1, IComparable arg2); ClassicAssert.GreaterOrEqual(IComparable arg1, IComparable arg2, string message, params object[] params); See Also ClassicAssert.Greater ClassicAssert.Less ClassicAssert.LessOrEqual Comparison Constraints"
  },
  "articles/nunit/writing-tests/assertions/classic-assertions/Assert.Ignore.html": {
    "href": "articles/nunit/writing-tests/assertions/classic-assertions/Assert.Ignore.html",
    "title": "",
    "summary": ""
  },
  "articles/nunit/writing-tests/assertions/classic-assertions/Assert.Inconclusive.html": {
    "href": "articles/nunit/writing-tests/assertions/classic-assertions/Assert.Inconclusive.html",
    "title": "",
    "summary": ""
  },
  "articles/nunit/writing-tests/assertions/classic-assertions/Assert.IsAssignableFrom.html": {
    "href": "articles/nunit/writing-tests/assertions/classic-assertions/Assert.IsAssignableFrom.html",
    "title": "ClassicAssert.IsAssignableFrom | NUnit Docs",
    "summary": "ClassicAssert.IsAssignableFrom ClassicAssert.IsAssignableFrom succeeds if the object provided may be assigned a value of the expected type. ClassicAssert.IsAssignableFrom(Type expected, object actual); ClassicAssert.IsAssignableFrom(Type expected, object actual, string message, params object[] params); ClassicAssert.IsAssignableFrom<T>(object actual); ClassicAssert.IsAssignableFrom<T>(object actual, string message, params object[] params); See Also Type Constraints"
  },
  "articles/nunit/writing-tests/assertions/classic-assertions/Assert.IsEmpty.html": {
    "href": "articles/nunit/writing-tests/assertions/classic-assertions/Assert.IsEmpty.html",
    "title": "ClassicAssert.IsEmpty | NUnit Docs",
    "summary": "ClassicAssert.IsEmpty ClassicAssert.IsEmpty may be used to test either a string or a collection or IEnumerable. When used with a string, it succeeds if the string is the empty string. When used with a collection, it succeeds if the collection is empty. ClassicAssert.IsEmpty(string aString); ClassicAssert.IsEmpty(string aString, string message, params object[] args); ClassicAssert.IsEmpty(IEnumerable collection); ClassicAssert.IsEmpty(IEnumerable collection, string message, params object[] args); Note When used with an IEnumerable that is not also an ICollection, ClassicAssert.IsEmpty attempts to enumerate the contents. It should not be used in cases where this results in an unwanted side effect. See Also Condition Constraints"
  },
  "articles/nunit/writing-tests/assertions/classic-assertions/Assert.IsInstanceOf.html": {
    "href": "articles/nunit/writing-tests/assertions/classic-assertions/Assert.IsInstanceOf.html",
    "title": "ClassicAssert.IsInstanceOf | NUnit Docs",
    "summary": "ClassicAssert.IsInstanceOf ClassicAssert.IsInstanceOf succeeds if the object provided as an actual value is an instance of the expected type. ClassicAssert.IsInstanceOf(Type expected, object actual); ClassicAssert.IsInstanceOf(Type expected, object actual, string message, params object[] params); ClassicAssert.IsInstanceOf<T>(object actual); ClassicAssert.IsInstanceOf<T>(object actual, string message, params object[] params); See Also Type Constraints"
  },
  "articles/nunit/writing-tests/assertions/classic-assertions/Assert.IsNaN.html": {
    "href": "articles/nunit/writing-tests/assertions/classic-assertions/Assert.IsNaN.html",
    "title": "ClassicAssert.IsNaN | NUnit Docs",
    "summary": "ClassicAssert.IsNaN ClassicAssert.IsNaN tests that the specified double value is NaN. ClassicAssert.IsNaN(double aDouble); ClassicAssert.IsNaN(double aDouble, string message, params object[] params); See Also Condition Constraints"
  },
  "articles/nunit/writing-tests/assertions/classic-assertions/Assert.IsNotAssignableFrom.html": {
    "href": "articles/nunit/writing-tests/assertions/classic-assertions/Assert.IsNotAssignableFrom.html",
    "title": "ClassicAssert.IsNotAssignableFrom | NUnit Docs",
    "summary": "ClassicAssert.IsNotAssignableFrom ClassicAssert.IsNotAssignableFrom succeeds if the object provided may not be assigned a value of the expected type. ClassicAssert.IsNotAssignableFrom(Type expected, object actual); ClassicAssert.IsNotAssignableFrom(Type expected, object actual, string message, params object[] params); ClassicAssert.IsNotAssignableFrom<T>(object actual); ClassicAssert.IsNotAssignableFrom<T>(object actual, string message, params object[] params); See also Type Constraints"
  },
  "articles/nunit/writing-tests/assertions/classic-assertions/Assert.IsNotEmpty.html": {
    "href": "articles/nunit/writing-tests/assertions/classic-assertions/Assert.IsNotEmpty.html",
    "title": "ClassicAssert.IsNotEmpty | NUnit Docs",
    "summary": "ClassicAssert.IsNotEmpty ClassicAssert.IsNotEmpty may be used to test either a string or a collection or IEnumerable. When used with a string, it succeeds if the string is not the empty string. When used with a collection, it succeeds if the collection is not empty. ClassicAssert.IsNotEmpty(string aString); ClassicAssert.IsNotEmpty(string aString, string message, params object[] args); ClassicAssert.IsNotEmpty(IEnumerable collection); ClassicAssert.IsNotEmpty(IEnumerable collection, string message, params object[] args); Note When used with an IEnumerable that is not also an ICollection, ClassicAssert.IsEmpty attempts to enumerate the contents. It should not be used in cases where this results in an unwanted side effect. See Also Condition Constraints"
  },
  "articles/nunit/writing-tests/assertions/classic-assertions/Assert.IsNotInstanceOf.html": {
    "href": "articles/nunit/writing-tests/assertions/classic-assertions/Assert.IsNotInstanceOf.html",
    "title": "ClassicAssert.IsNotInstanceOf | NUnit Docs",
    "summary": "ClassicAssert.IsNotInstanceOf ClassicAssert.IsNotInstanceOf succeeds if the object provided as an actual value is not an instance of the expected type. ClassicAssert.IsNotInstanceOf(Type expected, object actual); ClassicAssert.IsNotInstanceOf(Type expected, object actual, string message, params object[] params); ClassicAssert.IsNotInstanceOf<T>(object actual); ClassicAssert.IsNotInstanceOf<T>(object actual, string message, params object[] params); See Also Type Constraints"
  },
  "articles/nunit/writing-tests/assertions/classic-assertions/Assert.Less.html": {
    "href": "articles/nunit/writing-tests/assertions/classic-assertions/Assert.Less.html",
    "title": "ClassicAssert.Less | NUnit Docs",
    "summary": "ClassicAssert.Less ClassicAssert.Less tests whether one object is less than another. Contrary to the normal order of Asserts, these methods are designed to be read in the \"natural\" English-language or mathematical order. Thus ClassicAssert.Less(x, y) asserts that x is less than y (x < y). ClassicAssert.Less(int arg1, int arg2); ClassicAssert.Less(int arg1, int arg2, string message, params object[] params); ClassicAssert.Less(uint arg1, uint arg2); ClassicAssert.Less(uint arg1, uint arg2, string message, params object[] params); ClassicAssert.Less(long arg1, long arg2); ClassicAssert.Less(long arg1, long arg2, string message, params object[] params); ClassicAssert.Less(ulong arg1, ulong arg2); ClassicAssert.Less(ulong arg1, ulong arg2, string message, params object[] params); ClassicAssert.Less(decimal arg1, decimal arg2); ClassicAssert.Less(decimal arg1, decimal arg2, string message, params object[] params); ClassicAssert.Less(double arg1, double arg2); ClassicAssert.Less(double arg1, double arg2, string message, params object[] params); ClassicAssert.Less(float arg1, float arg2); ClassicAssert.Less(float arg1, float arg2, string message, params object[] params); ClassicAssert.Less(IComparable arg1, IComparable arg2); ClassicAssert.Less(IComparable arg1, IComparable arg2, string message, params object[] params); See Also ClassicAssert.Greater ClassicAssert.GreaterOrEqual ClassicAssert.LessOrEqual Comparison Constraints"
  },
  "articles/nunit/writing-tests/assertions/classic-assertions/Assert.LessOrEqual.html": {
    "href": "articles/nunit/writing-tests/assertions/classic-assertions/Assert.LessOrEqual.html",
    "title": "ClassicAssert.LessOrEqual | NUnit Docs",
    "summary": "ClassicAssert.LessOrEqual ClassicAssert.LessOrEqual tests whether one object is less than or equal to another. Contrary to the normal order of Asserts, these methods are designed to be read in the \"natural\" English-language or mathematical order. Thus ClassicAssert.LessOrEqual(x, y) asserts that x is less than or equal to y (x <= y). ClassicAssert.LessOrEqual(int arg1, int arg2); ClassicAssert.LessOrEqual(int arg1, int arg2, string message, params object[] params); ClassicAssert.LessOrEqual(uint arg1, uint arg2); ClassicAssert.LessOrEqual(uint arg1, uint arg2, string message, params object[] params); ClassicAssert.LessOrEqual(long arg1, long arg2); ClassicAssert.LessOrEqual(long arg1, long arg2, string message, params object[] params); ClassicAssert.LessOrEqual(ulong arg1, ulong arg2); ClassicAssert.LessOrEqual(ulong arg1, ulong arg2, string message, params object[] params); ClassicAssert.LessOrEqual(decimal arg1, decimal arg2); ClassicAssert.LessOrEqual(decimal arg1, decimal arg2, string message, params object[] params); ClassicAssert.LessOrEqual(double arg1, double arg2); ClassicAssert.LessOrEqual(double arg1, double arg2, string message, params object[] params); ClassicAssert.LessOrEqual(float arg1, float arg2); ClassicAssert.LessOrEqual(float arg1, float arg2, string message, params object[] params); ClassicAssert.LessOrEqual(IComparable arg1, IComparable arg2); ClassicAssert.LessOrEqual(IComparable arg1, IComparable arg2, string message, params object[] params); See Also ClassicAssert.Greater ClassicAssert.GreaterOrEqual ClassicAssert.Less Comparison Constraints"
  },
  "articles/nunit/writing-tests/assertions/classic-assertions/Assert.Negative.html": {
    "href": "articles/nunit/writing-tests/assertions/classic-assertions/Assert.Negative.html",
    "title": "ClassicAssert.Negative | NUnit Docs",
    "summary": "ClassicAssert.Negative Asserts that a number is negative. //true ClassicAssert.Negative(-1); //false ClassicAssert.Negative(1); All the overloads of the method are ClassicAssert.Negative(int actual); ClassicAssert.Negative(int actual, string message, params object[] args); ClassicAssert.Negative(uint actual); ClassicAssert.Negative(uint actual, string message, params object[] args); ClassicAssert.Negative(long actual); ClassicAssert.Negative(long actual, string message, params object[] args); ClassicAssert.Negative(ulong actual); ClassicAssert.Negative(ulong actual, string message, params object[] args); ClassicAssert.Negative(decimal actual); ClassicAssert.Negative(decimal actual, string message, params object[] args); ClassicAssert.Negative(double actual); ClassicAssert.Negative(double actual, string message, params object[] args); ClassicAssert.Negative(float actual); ClassicAssert.Negative(float actual, string message, params object[] args); You may also use ClassicAssert.That with a Is.Negative constraint to achieve the same result. See Also ClassicAssert.Positive ClassicAssert.Zero ClassicAssert.NotZero ClassicAssert.IsNaN"
  },
  "articles/nunit/writing-tests/assertions/classic-assertions/Assert.NotNull.html": {
    "href": "articles/nunit/writing-tests/assertions/classic-assertions/Assert.NotNull.html",
    "title": "ClassicAssert.NotNull | NUnit Docs",
    "summary": "ClassicAssert.NotNull ClassicAssert.NotNull and ClassicAssert.IsNotNull test that the specified object is non-null. The two forms are provided for compatibility with past versions of NUnit and NUnitLite. ClassicAssert.NotNull(object anObject); ClassicAssert.NotNull(object anObject, string message, params object[] params); ClassicAssert.IsNotNull(object anObject); ClassicAssert.IsNotNull(object anObject, string message, params object[] params); See Also Condition Constraints"
  },
  "articles/nunit/writing-tests/assertions/classic-assertions/Assert.NotZero.html": {
    "href": "articles/nunit/writing-tests/assertions/classic-assertions/Assert.NotZero.html",
    "title": "ClassicAssert.NotZero | NUnit Docs",
    "summary": "ClassicAssert.NotZero ClassicAssert.NotZero tests that a value is not zero. ClassicAssert.NotZero(int actual); ClassicAssert.NotZero(int actual, string message, params object[] args); ClassicAssert.NotZero(uint actual); ClassicAssert.NotZero(uint actual, string message, params object[] args); ClassicAssert.NotZero(long actual); ClassicAssert.NotZero(long actual, string message, params object[] args); ClassicAssert.NotZero(ulong actual); ClassicAssert.NotZero(ulong actual, string message, params object[] args); ClassicAssert.NotZero(decimal actual); ClassicAssert.NotZero(decimal actual, string message, params object[] args); ClassicAssert.NotZero(double actual); ClassicAssert.NotZero(double actual, string message, params object[] args); ClassicAssert.NotZero(float actual); ClassicAssert.NotZero(float actual, string message, params object[] args); You may also use ClassicAssert.That with a Is.Not.Zero constraint to achieve the same result."
  },
  "articles/nunit/writing-tests/assertions/classic-assertions/Assert.Null.html": {
    "href": "articles/nunit/writing-tests/assertions/classic-assertions/Assert.Null.html",
    "title": "ClassicAssert.Null | NUnit Docs",
    "summary": "ClassicAssert.Null ClassicAssert.Null and ClassicAssert.IsNull test that the specified object is null. The two forms are provided for compatibility with past versions of NUnit and NUnitLite. ClassicAssert.Null(object anObject); ClassicAssert.Null(object anObject, string message, params object[] params); ClassicAssert.IsNull(object anObject); ClassicAssert.IsNull(object anObject, string message, params object[] params); See Also Condition Constraints"
  },
  "articles/nunit/writing-tests/assertions/classic-assertions/Assert.Pass.html": {
    "href": "articles/nunit/writing-tests/assertions/classic-assertions/Assert.Pass.html",
    "title": "",
    "summary": ""
  },
  "articles/nunit/writing-tests/assertions/classic-assertions/Assert.Positive.html": {
    "href": "articles/nunit/writing-tests/assertions/classic-assertions/Assert.Positive.html",
    "title": "ClassicAssert.Positive | NUnit Docs",
    "summary": "ClassicAssert.Positive Asserts that a number is positive. //false ClassicAssert.Positive(-1); //true ClassicAssert.Positive(1); All the overloads of the method are ClassicAssert.Positive(int actual); ClassicAssert.Positive(int actual, string message, params object[] args); ClassicAssert.Positive(uint actual); ClassicAssert.Positive(uint actual, string message, params object[] args); ClassicAssert.Positive(long actual); ClassicAssert.Positive(long actual, string message, params object[] args); ClassicAssert.Positive(ulong actual); ClassicAssert.Positive(ulong actual, string message, params object[] args); ClassicAssert.Positive(decimal actual); ClassicAssert.Positive(decimal actual, string message, params object[] args); ClassicAssert.Positive(double actual); ClassicAssert.Positive(double actual, string message, params object[] args); ClassicAssert.Positive(float actual); ClassicAssert.Positive(float actual, string message, params object[] args); You may also use ClassicAssert.That with a Is.Positive constraint to achieve the same result. See Also ClassicAssert.Negative ClassicAssert.Zero ClassicAssert.NotZero ClassicAssert.IsNaN"
  },
  "articles/nunit/writing-tests/assertions/classic-assertions/Assert.Throws.html": {
    "href": "articles/nunit/writing-tests/assertions/classic-assertions/Assert.Throws.html",
    "title": "Assert.Throws | NUnit Docs",
    "summary": "Assert.Throws The Assert.Throws method is pretty much in a class by itself. Rather than comparing values, it attempts to invoke a code snippet, represented as a delegate, in order to verify that it throws a particular exception. It's also in a class by itself in that it returns an Exception, rather than void, if the Assert is successful. See the example below for a few ways to use this. Assert.Throws may be used with a constraint argument, which is applied to the actual exception thrown, or with the Type of exception expected. The Type format is available in both a non-generic and generic form. If the code under test is async, you must use Assert.ThrowsAsync. Exception Assert.Throws(Type expectedExceptionType, TestDelegate code); Exception Assert.Throws(Type expectedExceptionType, TestDelegate code, string message, params object[] params); Exception Assert.Throws(IResolveConstraint constraint, TestDelegate code); Exception Assert.Throws(IResolveConstraint constraint, TestDelegate code, string message, params object[] params); Assert.Throws<T>(TestDelegate code); Assert.Throws<T>(TestDelegate code, string message, params object[] params); In the above code TestDelegate is a delegate of the form void TestDelegate(), which is used to execute the code in question. This may be an anonymous delegate or, when compiling under C# 3.0 or greater, a lambda expression. The following example shows different ways of writing the same test. [TestFixture] public class AssertThrowsTests { [Test] public void Tests() { // Using a method as a delegate Assert.Throws<ArgumentException>(MethodThatThrows); // Using an anonymous delegate Assert.Throws<ArgumentException>( delegate { throw new ArgumentException(); }); // Using a Lambda expression Assert.Throws<ArgumentException>( () => throw new ArgumentException()); } void MethodThatThrows() { throw new ArgumentException(); } } If, for example, we were to assume a custom exception class of: public class MyException : Exception { public int MyParam { get; } public MyException(string message, int myParam) : base(message) { MyParam = myParam; } } The below example shows use of the return value to perform additional verification of the exception. [TestFixture] public class UsingReturnValue { [Test] public void TestException() { MyException ex = Assert.Throws<MyException>( () => throw new MyException(\"message\", 42)); Assert.That(ex.Message, Is.EqualTo(\"message\")); Assert.That(ex.MyParam, Is.EqualTo(42)); } } This example does the same thing using the overload that includes a constraint. [TestFixture] public class UsingConstraint { [Test] public void TestException() { Assert.Throws(Is.TypeOf<MyException>() .And.Message.EqualTo(\"message\") .And.Property(\"MyParam\").EqualTo(42), () => throw new MyException(\"message\", 42)); } } Use the form that matches your style of coding. Exact Versus Derived Types When used with a Type argument, Assert.Throws requires that exact type to be thrown. If you want to test for any derived Type, use one of the forms that allows specifying a constraint. Alternatively, you may use Assert.Catch, which differs from Assert.Throws in allowing derived types. See the following code for examples: // Require an ApplicationException - derived types fail! Assert.Throws(typeof(ApplicationException), code); Assert.Throws<ApplicationException>(code); // Allow both ApplicationException and any derived type Assert.Throws(Is.InstanceOf(typeof(ApplicationException)), code); Assert.Throws(Is.InstanceOf<ApplicationException>(), code); // Allow both ApplicationException and any derived type Assert.Catch<ApplicationException>(code); // Allow any kind of exception Assert.Catch(code); See Also Assert.Catch Assert.CatchAsync Assert.ThrowsAsync ThrowsConstraint"
  },
  "articles/nunit/writing-tests/assertions/classic-assertions/Assert.ThrowsAsync.html": {
    "href": "articles/nunit/writing-tests/assertions/classic-assertions/Assert.ThrowsAsync.html",
    "title": "Assert.ThrowsAsync | NUnit Docs",
    "summary": "Assert.ThrowsAsync The Assert.ThrowsAsync is the async equivalent to Assert.Throws for asynchronous code. See Assert.Throws for more information. Exception Assert.ThrowsAsync(Type expectedExceptionType, AsyncTestDelegate code); Exception Assert.ThrowsAsync(Type expectedExceptionType, AsyncTestDelegate code, string message, params object[] params); Exception Assert.ThrowsAsync(IResolveConstraint constraint, AsyncTestDelegate code); Exception Assert.ThrowsAsync(IResolveConstraint constraint, AsyncTestDelegate code, string message, params object[] params); TActual Assert.ThrowsAsync<TActual>(AsyncTestDelegate code); TActual Assert.ThrowsAsync<TActual>(AsyncTestDelegate code, string message, params object[] params); In the above code AsyncTestDelegate is a delegate of the form Task AsyncTestDelegate(), which is used to execute the code in question. This will likely be a lambda expression. The following example shows the most common way of writing tests. [TestFixture] public class AssertThrowsTests { [Test] public void Tests() { // Using a method as a delegate Assert.ThrowsAsync<ArgumentException>(async () => await MethodThatThrows()); } private async Task MethodThatThrows() { await Task.Delay(100); throw new ArgumentException(); } } This example shows use of the return value to perform additional verification of the exception. Note that you do not need to await the result. [TestFixture] public class UsingReturnValue { [Test] public void TestException() { MyException ex = Assert.ThrowsAsync<MyException>(async () => await MethodThatThrows()); Assert.That(ex.Message, Is.EqualTo(\"message\")); Assert.That(ex.MyParam, Is.EqualTo(42)); } private async Task MethodThatThrows() { await Task.Delay(100); throw new MyException(\"message\", 42); } } See Also Assert.Catch Assert.CatchAsync Assert.Throws ThrowsConstraint"
  },
  "articles/nunit/writing-tests/assertions/classic-assertions/Assert.True.html": {
    "href": "articles/nunit/writing-tests/assertions/classic-assertions/Assert.True.html",
    "title": "ClassicAssert.True | NUnit Docs",
    "summary": "ClassicAssert.True ClassicAssert.True and ClassicAssert.IsTrue test that the specified condition is true. The two forms are provided for compatibility with past versions of NUnit and NUnitLite. ClassicAssert.True(bool condition); ClassicAssert.True(bool condition, string message, params object[] params); ClassicAssert.IsTrue(bool condition); ClassicAssert.IsTrue(bool condition, string message, params object[] params); You can also use Assert.That with a Boolean argument to achieve the same result. [Test] public void True_Examples() { ClassicAssert.True(2 + 2 == 4); ClassicAssert.IsTrue(true); ClassicAssert.True(\"Hello\".StartsWith(\"H\")); } See Also Condition Constraints"
  },
  "articles/nunit/writing-tests/assertions/classic-assertions/Assert.Zero.html": {
    "href": "articles/nunit/writing-tests/assertions/classic-assertions/Assert.Zero.html",
    "title": "ClassicAssert.Zero | NUnit Docs",
    "summary": "ClassicAssert.Zero ClassicAssert.Zero tests that a value is zero. ClassicAssert.Zero(int actual); ClassicAssert.Zero(int actual, string message, params object[] args); ClassicAssert.Zero(uint actual); ClassicAssert.Zero(uint actual, string message, params object[] args); ClassicAssert.Zero(long actual); ClassicAssert.Zero(long actual, string message, params object[] args); ClassicAssert.Zero(ulong actual); ClassicAssert.Zero(ulong actual, string message, params object[] args); ClassicAssert.Zero(decimal actual); ClassicAssert.Zero(decimal actual, string message, params object[] args); ClassicAssert.Zero(double actual); ClassicAssert.Zero(double actual, string message, params object[] args); ClassicAssert.Zero(float actual); ClassicAssert.Zero(float actual, string message, params object[] args); You may also use Assert.That with a Is.Zero constraint to achieve the same result."
  },
  "articles/nunit/writing-tests/assertions/classic-assertions/Collection-Assert.html": {
    "href": "articles/nunit/writing-tests/assertions/classic-assertions/Collection-Assert.html",
    "title": "CollectionAssert | NUnit Docs",
    "summary": "CollectionAssert The CollectionAssert class provides a number of methods that are useful when examining collections and their contents or for comparing two collections. These methods may be used with any object implementing IEnumerable. The AreEqual overloads succeed if the corresponding elements of the two collections are equal. AreEquivalent tests whether the collection contents are equal, but without regard to order. In both cases, elements are compared using NUnit's default equality comparison. CollectionAssert.AllItemsAreInstancesOfType(IEnumerable collection, Type expectedType); CollectionAssert.AllItemsAreInstancesOfType( IEnumerable collection, Type expectedType, string message, params object[] args); CollectionAssert.AllItemsAreNotNull(IEnumerable collection); CollectionAssert.AllItemsAreNotNull( IEnumerable collection, string message, params object[] args); CollectionAssert.AllItemsAreUnique(IEnumerable collection); CollectionAssert.AllItemsAreUnique( IEnumerable collection, string message, params object[] args); CollectionAssert.AreEqual(IEnumerable expected, IEnumerable actual); CollectionAssert.AreEqual( IEnumerable expected, IEnumerable actual, string message, params object[] args); CollectionAssert.AreEquivalent(IEnumerable expected, IEnumerable actual); CollectionAssert.AreEquivalent( IEnumerable expected, IEnumerable actual, string message, params object[] args); CollectionAssert.AreNotEqual(IEnumerable expected, IEnumerable actual); CollectionAssert.AreNotEqual( IEnumerable expected, IEnumerable actual, string message, params object[] args); CollectionAssert.AreNotEquivalent(IEnumerable expected, IEnumerable actual); CollectionAssert.AreNotEquivalent( IEnumerable expected, IEnumerable actual, string message, params object[] args); CollectionAssert.Contains(IEnumerable expected, object actual); CollectionAssert.Contains( IEnumerable expected, object actual, string message, params object[] args); CollectionAssert.DoesNotContain(IEnumerable expected, object actual); CollectionAssert.DoesNotContain( IEnumerable expected, object actual, string message, params object[] args); CollectionAssert.IsSubsetOf(IEnumerable subset, IEnumerable superset); CollectionAssert.IsSubsetOf( IEnumerable subset, IEnumerable superset, string message, params object[] args); CollectionAssert.IsNotSubsetOf(IEnumerable subset, IEnumerable superset); CollectionAssert.IsNotSubsetOf( IEnumerable subset, IEnumerable superset, string message, params object[] args); CollectionAssert.IsEmpty(IEnumerable collection); CollectionAssert.IsEmpty( IEnumerable collection, string message, params object[] args); CollectionAssert.IsNotEmpty(IEnumerable collection); CollectionAssert.IsNotEmpty( IEnumerable collection, string message, params object[] args); CollectionAssert.IsOrdered(IEnumerable collection); CollectionAssert.IsOrdered( IEnumerable collection, string message, params object[] args); CollectionAssert.IsOrdered(IEnumerable collection, IComparer comparer); CollectionAssert.IsOrdered(IEnumerable collection, IComparer comparer, string message, params object[] args); See Also Collection Constraints"
  },
  "articles/nunit/writing-tests/assertions/classic-assertions/Directory-Assert.html": {
    "href": "articles/nunit/writing-tests/assertions/classic-assertions/Directory-Assert.html",
    "title": "DirectoryAssert | NUnit Docs",
    "summary": "DirectoryAssert The DirectoryAssert class provides methods for comparing two directories or verifying the existence of a directory. Directories may be provided as DirectoryInfos or as strings giving the path to each directory. DirectoryAssert.AreEqual(DirectoryInfo expected, DirectoryInfo actual); DirectoryAssert.AreEqual(DirectoryInfo expected, DirectoryInfo actual, string message, params object[] args); DirectoryAssert.AreNotEqual(DirectoryInfo expected, DirectoryInfo actual); DirectoryAssert.AreNotEqual(DirectoryInfo expected, DirectoryInfo actual, string message, params object[] args); DirectoryAssert.Exists(DirectoryInfo actual); DirectoryAssert.Exists(DirectoryInfo actual, string message, params object[] args); DirectoryAssert.Exists(string actual); DirectoryAssert.Exists(string actual, string message, params object[] args); DirectoryAssert.DoesNotExist(DirectoryInfo actual); DirectoryAssert.DoesNotExist(DirectoryInfo actual, string message, params object[] args); DirectoryAssert.DoesNotExist(string actual); DirectoryAssert.DoesNotExist(string actual, string message, params object[] args); See Also File and Directory Constraints"
  },
  "articles/nunit/writing-tests/assertions/classic-assertions/File-Assert.html": {
    "href": "articles/nunit/writing-tests/assertions/classic-assertions/File-Assert.html",
    "title": "FileAssert | NUnit Docs",
    "summary": "FileAssert The FileAssert class provides methods for comparing or verifying the existence of files, which may be provided as Streams, as FileInfos or as strings giving the path to each file. FileAssert.AreEqual(Stream expected, Stream actual); FileAssert.AreEqual( Stream expected, Stream actual, string message, params object[] args); FileAssert.AreEqual(FileInfo expected, FileInfo actual); FileAssert.AreEqual( FileInfo expected, FileInfo actual, string message, params object[] args); FileAssert.AreEqual(string expected, string actual); FileAssert.AreEqual( string expected, string actual, string message, params object[] args); FileAssert.AreNotEqual(Stream expected, Stream actual); FileAssert.AreNotEqual( Stream expected, Stream actual, string message, params object[] args); FileAssert.AreNotEqual(FileInfo expected, FileInfo actual); FileAssert.AreNotEqual( FileInfo expected, FileInfo actual, string message, params object[] args); FileAssert.AreNotEqual(string expected, string actual); FileAssert.AreNotEqual( string expected, string actual, string message, params object[] args); FileAssert.Exists(FileInfo actual); FileAssert.Exists( FileInfo actual, string message, params object[] args); FileAssert.Exists(string actual); FileAssert.Exists( string actual, string message, params object[] args); FileAssert.DoesNotExist(FileInfo actual); FileAssert.DoesNotExist( FileInfo actual, string message, params object[] args); FileAssert.DoesNotExist(string actual); FileAssert.DoesNotExist( string actual, string message, params object[] args); See Also File and Directory Constraints"
  },
  "articles/nunit/writing-tests/assertions/classic-assertions/String-Assert.html": {
    "href": "articles/nunit/writing-tests/assertions/classic-assertions/String-Assert.html",
    "title": "StringAssert | NUnit Docs",
    "summary": "StringAssert The StringAssert class provides a number of methods that are useful when examining string values. StringAssert.Contains(string expected, string actual); StringAssert.Contains(string expected, string actual, string message, params object[] args); StringAssert.DoesNotContain(string expected, string actual); StringAssert.DoesNotContain(string expected, string actual, string message, params object[] args); StringAssert.StartsWith(string expected, string actual); StringAssert.StartsWith(string expected, string actual, string message, params object[] args); StringAssert.DoesNotStartsWith(string expected, string actual); StringAssert.DoesNotStartsWith(string expected, string actual, string message, params object[] args); StringAssert.EndsWith(string expected, string actual); StringAssert.EndsWith(string expected, string actual, string message, params object[] args); StringAssert.DoesNotEndWith(string expected, string actual); StringAssert.DoesNotEndWith(string expected, string actual, string message, params object[] args); StringAssert.AreEqualIgnoringCase(string expected, string actual); StringAssert.AreEqualIgnoringCase(string expected, string actual, string message params object[] args); StringAssert.AreNotEqualIgnoringCase(string expected, string actual); StringAssert.AreNotEqualIgnoringCase(string expected, string actual, string message params object[] args); StringAssert.IsMatch(string regexPattern, string actual); StringAssert.IsMatch(string regexPattern, string actual, string message, params object[] args); StringAssert.DoesNotMatch(string regexPattern, string actual); StringAssert.DoesNotMatch(string regexPattern, string actual, string message, params object[] args); See Also String Constraints"
  },
  "articles/nunit/writing-tests/assertions/multiple-asserts.html": {
    "href": "articles/nunit/writing-tests/assertions/multiple-asserts.html",
    "title": "Multiple Asserts | NUnit Docs",
    "summary": "Multiple Asserts Usually, once an assertion fails, we want the test to terminate. But sometimes, it's desirable to continue and accumulate any additional failures so they may all be fixed at once. This is particularly useful for testing things like object initialization and UI appearance as well as certain kinds of integration testing. Syntax / Example Multiple asserts are implemented using the Assert.EnterMultipleScope method. Let's assume we have production code that looks like the following: public class CalculationResult { public double RealPart { get; set; } public double ImaginaryPart { get; set; } } public class SomeCalculator { public CalculationResult DoCalculation() { return new CalculationResult { // Hard-coded for demo RealPart = 5.2, ImaginaryPart = 3.9 }; } } In that case, we could write a test with multiple assertions, such as: [Test] public void MultipleAssertsScopeDemo() { var situationUnderTest = new SomeCalculator(); var result = situationUnderTest.DoCalculation(); using (Assert.EnterMultipleScope()) { Assert.That(result.RealPart, Is.EqualTo(5.2)); Assert.That(result.ImaginaryPart, Is.EqualTo(3.9)); } // Can also work with the classic assertion syntax using (Assert.EnterMultipleScope()) { ClassicAssert.AreEqual(5.2, result.RealPart, \"Real Part\"); ClassicAssert.AreEqual(3.9, result.ImaginaryPart, \"Imaginary Part\"); } } Functionally, this results in NUnit storing any failures encountered in the block and reporting all of them together upon exit from the block. If both asserts failed, then both would be reported. The test itself would terminate at the end of the block if any failures were encountered, but would continue otherwise. Older NUnit versions Earlier than NUnit 4.2 you can must use Assert.Multiple: [Test] public void MultipleAssertsDemo() { var situationUnderTest = new SomeCalculator(); var result = situationUnderTest.DoCalculation(); Assert.Multiple(() => { Assert.That(result.RealPart, Is.EqualTo(5.2)); Assert.That(result.ImaginaryPart, Is.EqualTo(3.9)); }); // Can also work with the classic assertion syntax Assert.Multiple(() => { ClassicAssert.AreEqual(5.2, result.RealPart, \"Real Part\"); ClassicAssert.AreEqual(3.9, result.ImaginaryPart, \"Imaginary Part\"); }); } Notes For more information on EnterMultipleScope see this Feature Request. The multiple assert block may contain any arbitrary code, not just asserts. Multiple assert blocks may be nested. Failure is not reported until the outermost block exits. If the code in the block calls a method, that method may also contain multiple assert blocks. The test will be terminated immediately if any exception is thrown that is not handled. An unexpected exception is often an indication that the test itself is in error, so it must be terminated. If the exception occurs after one or more assertion failures have been recorded, those failures will be reported along with the terminating exception itself. Assert.Fail is handled just as any other assert failure. The message and stack trace are recorded but the test continues to execute until the end of the block. An error is reported if any of the following are used inside a multiple assert block: Assert.Pass Assert.Ignore Assert.Inconclusive Assume.That Use of Warnings (Assert.Warn, Warn.If, Warn.Unless) is permitted inside a multiple assert block. Warnings are reported normally along with any failures that occur inside the block. Runner Support Multiple assertion failures per test are stored in the representation of the test result using new XML elements, which are not recognized by older runners. The following runners are known to support display of the new elements: NUnit3 Visual Studio Adapter 3.7++ (Used by Visual Studio and dotnet test) NUnit Console Runner 3.6++ Compatibility Older runners generally display a single failure message and stack trace for each test. For compatibility purposes, the framework creates a single message that lists all the failures. The stack trace in such a case will indicate the end of the assert multiple block."
  },
  "articles/nunit/writing-tests/assertions/special-assertions/Assert.Fail.html": {
    "href": "articles/nunit/writing-tests/assertions/special-assertions/Assert.Fail.html",
    "title": "Assert.Fail | NUnit Docs",
    "summary": "Assert.Fail The Assert.Fail method provides you with the ability to generate a failure based on tests that are not encapsulated by the other methods. It is also useful in developing your own project-specific assertions. Assert.Fail(); Assert.Fail(string message); Here's an example of its use to create a private assertion that tests whether a string contains an expected value. public void AssertStringContains(string expected, string actual) { AssertStringContains(expected, actual, string.Empty); } public void AssertStringContains(string expected, string actual, string message) { if (actual.IndexOf(expected) < 0) Assert.Fail(message); } See Also Assert.Pass Assert.Ignore Assert.Inconclusive"
  },
  "articles/nunit/writing-tests/assertions/special-assertions/Assert.Ignore.html": {
    "href": "articles/nunit/writing-tests/assertions/special-assertions/Assert.Ignore.html",
    "title": "Assert.Ignore | NUnit Docs",
    "summary": "Assert.Ignore The Assert.Ignore method provides you with the ability to dynamically cause a test or suite to be ignored at runtime. It may be called in a test, setup or fixture setup method. We recommend that you use this only in isolated cases. The category facility is provided for more extensive inclusion or exclusion of tests or you may elect to simply divide tests run on different occasions into different assemblies. Assert.Ignore(); Assert.Ignore(string message); See Also Assert.Pass Assert.Fail Assert.Inconclusive"
  },
  "articles/nunit/writing-tests/assertions/special-assertions/Assert.Inconclusive.html": {
    "href": "articles/nunit/writing-tests/assertions/special-assertions/Assert.Inconclusive.html",
    "title": "Assert.Inconclusive | NUnit Docs",
    "summary": "Assert.Inconclusive The Assert.Inconclusive method indicates that the test could not be completed with the data available. It should be used in situations where another run with different data might run to completion, with either a success or failure outcome. Assert.Inconclusive(); Assert.Inconclusive(string message); See Also Assert.Pass Assert.Fail Assert.Ignore"
  },
  "articles/nunit/writing-tests/assertions/special-assertions/Assert.Pass.html": {
    "href": "articles/nunit/writing-tests/assertions/special-assertions/Assert.Pass.html",
    "title": "Assert.Pass | NUnit Docs",
    "summary": "Assert.Pass The Assert.Pass method allows you to immediately end the test, recording it as successful. Since it causes an exception to be thrown, it is more efficient to simply allow the test to return. However, Assert.Pass allows you to record a message in the test result and may also make the test easier to read in some situations. Additionally, like the other methods on this page, it can be invoked from a nested method call with the result of immediately terminating test execution. Assert.Pass(); Assert.Pass(string message); See Also Assert.Fail Assert.Ignore Assert.Inconclusive"
  },
  "articles/nunit/writing-tests/attributes.html": {
    "href": "articles/nunit/writing-tests/attributes.html",
    "title": "Attributes | NUnit Docs",
    "summary": "Attributes NUnit uses custom attributes to identify tests. All NUnit attributes are contained in the NUnit.Framework namespace. Each source file that contains tests must include a using statement for that namespace and the project must reference the framework assembly, nunit.framework.dll. This table lists all the attributes supported by NUnit. Attribute Usage Apartment Attribute Indicates that the test should run in a particular apartment. Author Attribute Provides the name of the test author. CancelAfter Attribute Provides a timeout value in milliseconds for test cases. Category Attribute Specifies one or more categories for the test. Combinatorial Attribute Generates test cases for all possible combinations of the values provided. Culture Attribute Specifies cultures for which a test or fixture should be run. Datapoint Attribute Provides data for Theories. DatapointSource Attribute Provides data for Theories. DefaultFloatingPointTolerance Attribute Indicates that the test should use the specified tolerance as default for float and double comparisons. Description Attribute Applies descriptive text to a Test, TestFixture or Assembly. Explicit Attribute Indicates that a test should be skipped unless explicitly run. FixtureLifeCycle Attribute Specifies the lifecycle of a fixture allowing a new instance of a test fixture to be constructed for each test case. Useful in situations where test case parallelism is important. Ignore Attribute Indicates that a test shouldn't be run for some reason. LevelOfParallelism Attribute Specifies the level of parallelism at assembly level. MaxTime Attribute Specifies the maximum time in milliseconds for a test case to succeed. NonParallelizable Attribute Specifies that the test and its descendants may not be run in parallel. NonTestAssembly Attribute Specifies that the assembly references the NUnit framework, but that it does not contain tests. OneTimeSetUp Attribute Identifies methods to be called once prior to any child tests. OneTimeTearDown Attribute Identifies methods to be called once after all child tests. Order Attribute Specifies the order in which decorated test should be run within the containing fixture or suite. Pairwise Attribute Generate test cases for all possible pairs of the values provided. Parallelizable Attribute Indicates whether test and/or its descendants can be run in parallel. Platform Attribute Specifies platforms for which a test or fixture should be run. Property Attribute Allows setting named properties on any test case or fixture. Random Attribute Specifies generation of random values as arguments to a parameterized test. Range Attribute Specifies a range of values as arguments to a parameterized test. Repeat Attribute Specifies that the decorated method should be executed multiple times. RequiresThread Attribute Indicates that a test method, class or assembly should be run on a separate thread. Retry Attribute Causes a test to be rerun if it fails, up to a maximum number of times. Sequential Attribute Generates test cases using values in the order provided, without additional combinations. SetCulture Attribute Sets the current Culture for the duration of a test. SetUICulture Attribute Sets the current UI Culture for the duration of a test. SetUp Attribute Indicates a method of a TestFixture called just before each test method. SetUpFixture Attribute Marks a class with one-time setup or teardown methods for all the test fixtures in a namespace. SingleThreaded Attribute Marks a fixture that requires all its tests to run on the same thread. TearDown Attribute Indicates a method of a TestFixture called just after each test method. Test Attribute Marks a method of a TestFixture that represents a test. TestCase Attribute Marks a method with parameters as a test and provides inline arguments. TestCaseSource Attribute Marks a method with parameters as a test and provides a source of arguments. TestFixture Attribute Marks a class as a test fixture and may provide inline constructor arguments. TestFixtureSetup Attribute Deprecated synonym for OneTimeSetUp Attribute. TestFixtureSource Attribute Marks a class as a test fixture and provides a source for constructor arguments. TestFixtureTeardown Attribute Deprecated synonym for OneTimeTearDown Attribute. TestOf Attribute Indicates the name or Type of the class being tested. Theory Attribute Marks a test method as a Theory, a special kind of test in NUnit. Timeout Attribute Provides a timeout value in milliseconds for test cases. Values Attribute Provides a set of inline values for a parameter of a test method. ValueSource Attribute Provides a source of values for a parameter of a test method."
  },
  "articles/nunit/writing-tests/attributes/apartment.html": {
    "href": "articles/nunit/writing-tests/attributes/apartment.html",
    "title": "Apartment | NUnit Docs",
    "summary": "Apartment The ApartmentAttribute is used on a test method, class or assembly to specify that the tests should be run in a particular apartment, either the STA or the MTA. When running tests in parallel, the test is simply scheduled to execute from a queue that uses the apartment specified. When the parallel feature is not in use, it causes creation of a new thread if the parent test is not already running in the correct apartment. When this attribute is not specified, tests run in the MTA. This attribute replaces the RequiresMTA and RequiresSTA attributes, which are now considered obsolete. Assembly Level Examples // All the tests in this assembly will use the MTA by default. Since // this is the general default, the attribute is not actually needed. [assembly:Apartment(ApartmentState.MTA)] ... // All the tests in this assembly will use the STA by default [assembly:Apartment(ApartmentState.STA)] Test Fixture Examples // TestFixture requiring use of the MTA. The attribute is not // needed unless the STA was specified at a higher level. [TestFixture, Apartment(ApartmentState.MTA)] public class FixtureRequiringMTA { // All tests in the fixture will run in the MTA. } // TestFixture requiring use of the STA. [TestFixture, Apartment(ApartmentState.STA)] public class FixtureRequiringSTA { // All tests in the fixture will run in the STA. } Test Method Examples [TestFixture] public class AnotherFixture { [Test, Apartment(ApartmentState.MTA)] public void TestRequiringMTA() { // This test will run in the MTA. } [Test, Apartment(ApartmentState.STA)] public void TestRequiringSTA() { // This test will run in the STA. } } See Also RequiresThread Attribute"
  },
  "articles/nunit/writing-tests/attributes/author.html": {
    "href": "articles/nunit/writing-tests/attributes/author.html",
    "title": "Author | NUnit Docs",
    "summary": "Author The Author Attribute adds information about the author of the tests. It can be applied to test fixtures and to tests. The constructor takes the name of the test author and optionally the author's email address. Author can also be specified on a TestFixture or Test attribute. [TestFixture] [Author(\"Jane Doe\", \"jane.doe@example.com\")] [Author(\"Another Developer\", \"email@example.com\")] public class MyTests { [Test] public void Test1() { /* ... */ } [Test] [Author(\"Joe Developer\")] [Author(\"Yet Another Developer\", \"not.my.email@example.com\")] public void Test2() { /* ... */ } } [TestFixture(Author = \"Jane Doe\")] public class MyOtherTests { [Test] public void Test1() { /* ... */ } [Test(Author = \"Joe Developer\")] public void Test2() { /* ... */ } } Note From NUnit version 3.7, you can have multiple Author attributes per fixture or test. Before version 3.7 you could only have one Author attribute per fixture or test."
  },
  "articles/nunit/writing-tests/attributes/cancelafter.html": {
    "href": "articles/nunit/writing-tests/attributes/cancelafter.html",
    "title": "CancelAfter | NUnit Docs",
    "summary": "CancelAfter Normally, NUnit simply runs tests and waits for them to terminate -- the test is allowed to run indefinitely. For certain kinds of tests, however, it may be desirable to specify a timeout value. For .NET Core and later, Thread.Abort as used by the TimeoutAttribute can no longer be used, and there is therefore no way to interrupt an endless loop. For all tests, one could use the --blame-hang(-timeout) options of dotnet test. However, this will stop any further execution of the remaining tests. To still be able to cancel tests, one has to move to cooperative cancellation. See Cancellation in Managed Threads using a `CancellationToken``. The CancelAfterAttribute is used to specify a timeout value in milliseconds for a test case. If the test case runs longer than the time specified, the supplied CancellationToken is set to canceled. It is however up to the test code to check this token, either directly or indirectly. The specified timeout value covers the test setup and teardown as well as the test method itself. Before and after actions may also be included, depending on where they were specified. Since the timeout may occur during any of these execution phases, no guarantees can be made as to what will be run and any of these phases of execution may be incomplete. If only used on a test, once a test has timed out, its teardown methods are executed. The attribute may also be specified on a fixture, in which case it indicates the default timeout for any subordinate test cases. When using the console runner, it is also possible to specify a default timeout on the command-line. When used on test methods, NUnit automatically adds an extra argument to your method containing the NUnit CancellationToken. If you want to check for cancellation in SetUp methods, you can use TestContext.CurrentContext.CancellationToken Example [Test, CancelAfter(2000)] public void RunningTestUntilCanceled(CancellationToken token) { while (!token.IsCancellationRequested) { /* */ } } [CancelAfter(2000)] [TestCase(\"http://server1\")] [TestCase(\"http://server2\")] public async Task PotentiallyLongRunningTest(string uri, CancellationToken token) { HttpClient client = _httpClientFactory.CreateClient(); HttpContent content = CreateContent(); await client.PostAync(uri, content, token); HttpResponseMessage response = await client.GetAsync(uri, token); /* */ } Note When debugging a unit test, i.e. when a debugger is attached to the process, the timeout is not enforced. See Also Timeout Attribute MaxTime Attribute"
  },
  "articles/nunit/writing-tests/attributes/category.html": {
    "href": "articles/nunit/writing-tests/attributes/category.html",
    "title": "Category | NUnit Docs",
    "summary": "Category The Category attribute provides an alternative to suites for dealing with groups of tests. Either individual test cases or fixtures may be identified as belonging to a particular category. Some runners, including the Console Runner, allow specifying categories to be included in or excluded from the run. When categories are used, only the tests in the selected categories will be run. Those tests in categories that are not selected are not reported at all. Warning While the C# syntax allows you to place a Category attribute on a SetUpFixture class, the attribute is ignored by NUnit and has no effect in current releases. Test Fixture Syntax [Test] public void Test_InLongRunningCategory() { Assert.Pass(\"This test is in the LongRunning category\"); } Test Syntax [Test] [Category(\"Fast\")] public void FastTest() { Assert.Pass(\"This is a fast test\"); } [Test] [Category(\"Slow\")] [Category(\"Database\")] public void SlowDatabaseTest() { Assert.Pass(\"This test has multiple categories\"); } Custom Category Attributes Custom attributes that derive from CategoryAttribute will be recognized by NUnit. The default protected constructor of CategoryAttribute sets the category name to the name of your class. Here's an example that creates a category of Critical tests. It works just like any other category, but has a simpler syntax. A test reporting system might make use of the attribute to provide special reports. [AttributeUsage(AttributeTargets.Method, AllowMultiple = false)] public class CriticalAttribute : CategoryAttribute { } [Test] [Critical] public void CriticalTest() { Assert.Pass(\"This test uses a custom category attribute\"); }"
  },
  "articles/nunit/writing-tests/attributes/combinatorial.html": {
    "href": "articles/nunit/writing-tests/attributes/combinatorial.html",
    "title": "Combinatorial | NUnit Docs",
    "summary": "Combinatorial The CombinatorialAttribute is used on a test to specify that NUnit should generate test cases for all possible combinations of the individual data items provided for the parameters of a test. Since this is the default, use of this attribute is optional. Example The following test will be executed six times: [Test, Combinatorial] public void MyTest( [Values(1, 2, 3)] int x, [Values(\"A\", \"B\")] string s) { ... } MyTest is called six times, as follows: MyTest(1, \"A\") MyTest(1, \"B\") MyTest(2, \"A\") MyTest(2, \"B\") MyTest(3, \"A\") MyTest(3, \"B\") Limitations When used on a generic method the programmer must ensure that all possible combinations of arguments are valid. When multiple parameters use the same generic type (e.g.: T) this may not be possible and the attribute may generate invalid test cases. See Also Sequential Attribute Pairwise Attribute"
  },
  "articles/nunit/writing-tests/attributes/culture.html": {
    "href": "articles/nunit/writing-tests/attributes/culture.html",
    "title": "Culture | NUnit Docs",
    "summary": "Culture The Culture attribute is used to specify cultures for which a test or fixture should be run. It does not affect the culture setting, but merely uses it to determine whether to run the test. If you wish to change the culture when running a test, use the SetCulture attribute instead. If the specified culture requirements for a test are not met it is skipped. In the gui, the tree node for the test remains gray and the status bar color is not affected. One use of the Culture attribute is to provide alternative tests under different cultures. You may specify either specific cultures, like \"en-GB\" or neutral cultures like \"de\". Test Fixture Syntax namespace NUnit.Tests { using System; using NUnit.Framework; [TestFixture] [Culture(\"fr-FR\")] public class FrenchCultureTests { // ... } } Test Syntax namespace NUnit.Tests { using System; using NUnit.Framework; [TestFixture] public class SuccessTests { [Test] [Culture(Exclude=\"en,de\")] public void SomeTest() { /* ... */ } } See Also SetCulture Attribute"
  },
  "articles/nunit/writing-tests/attributes/datapoint.html": {
    "href": "articles/nunit/writing-tests/attributes/datapoint.html",
    "title": "Datapoint | NUnit Docs",
    "summary": "Datapoint The Datapoint attribute is used to provide data for Theories and is ignored for ordinary tests - including tests with parameters. When a Theory is loaded, NUnit creates arguments for each of its parameters by using any fields of the same type as the parameter annotated with the DatapointAttribute. Fields must be members of the class containing the Theory and their Type must exactly match the argument for which data is being supplied. Automatically Supplied Datapoints It is normally not necessary to specify datapoints for boolean or enum arguments. NUnit automatically supplies values of true and false for boolean arguments and will supply all defined values of any enumeration. If for some reason you don't wish to use all possible values, you can override this behavior by supplying your own datapoints. If you supply any datapoints for an argument, automatic datapoint generation is suppressed. Example For an example of use, see Theory Attribute See Also Theory Attribute Parameterized Tests"
  },
  "articles/nunit/writing-tests/attributes/datapointsource.html": {
    "href": "articles/nunit/writing-tests/attributes/datapointsource.html",
    "title": "DatapointSource | NUnit Docs",
    "summary": "DatapointSource The DatapointSource attribute is used to provide data for Theories and is ignored for ordinary tests - including tests with parameters. Collections of datapoints may be provided by use of the DatapointSourceAttribute. This attribute may be placed on methods or properties in addition to fields. The returned value must be either an array of the required type or an IEnumerable<T> returning an enumeration of the required type. The data Type must exactly match the argument for which data is being supplied. In earlier versions of NUnit, the obsolete DatapointsAttribute was used in place of DatapointSourceAttribute. Automatically Supplied Datapoints It is normally not necessary to specify datapoints for boolean or enum arguments. NUnit automatically supplies values of true and false for boolean arguments and will supply all defined values of any enumeration. If for some reason you don't wish to use all possible values, you can override this behavior by supplying your own datapoints. If you supply any datapoints for an argument, automatic datapoint generation is suppressed. Example For an example of use, see Theory Attribute See Also Theory Attribute Parameterized Tests"
  },
  "articles/nunit/writing-tests/attributes/defaultfloatingpointtolerance.html": {
    "href": "articles/nunit/writing-tests/attributes/defaultfloatingpointtolerance.html",
    "title": "DefaultFloatingPointTolerance | NUnit Docs",
    "summary": "DefaultFloatingPointTolerance The DefaultFloatingPointToleranceAttribute is used to indicate that comparisons of values of types float and double - within the test method, class, or assembly marked with the attribute - should use the tolerance specified in the constructor unless a specific tolerance is given for the comparison. Examples [TestFixture] [DefaultFloatingPointTolerance(1)] public class ToleranceTest { [Test] public void ComparisonUsingDefaultFloatingPointToleranceFromFixture() { // Passes due to the DefaultFloatingPointToleranceAttribute from the fixture. Assert.That(1f, Is.EqualTo(2)); } [Test] public void ComparisonOfIntegersDoNotUseTolerance() { // Fails as DefaultFloatingPointTolerance only effects comparisons // of floats and doubles. Assert.That(1, Is.EqualTo(2)); } [Test] public void ComparisonUsingSpecificTolerance() { // Fails as 1 is not equal to 2 using the specified tolerance 0. Assert.That(1f, Is.EqualTo(2).Within(0)); } [Test] [DefaultFloatingPointTolerance(2)] public void ComparisonUsingDefaultFloatingPointToleranceFromTest() { // Passes due to the DefaultFloatingPointTolerance from the test. Assert.That(2f, Is.EqualTo(4)); } } See Also Assert.AreEqual EqualConstraint"
  },
  "articles/nunit/writing-tests/attributes/description.html": {
    "href": "articles/nunit/writing-tests/attributes/description.html",
    "title": "Description | NUnit Docs",
    "summary": "Description The Description attribute is used to apply descriptive text to a Test, TestFixture or Assembly. The text appears in the XML output file. Example [Test] [Description(\"This test should always pass\")] public void AlwaysPassingTest() { Assert.Pass(\"Test passed as expected\"); } Note The Test and TestFixture attributes continue to support an optional Description property. The Description attribute should be used for new applications. If both are used, the Description attribute takes precedence."
  },
  "articles/nunit/writing-tests/attributes/explicit.html": {
    "href": "articles/nunit/writing-tests/attributes/explicit.html",
    "title": "Explicit | NUnit Docs",
    "summary": "Explicit The Explicit attribute causes a test or test fixture to be skipped unless it is explicitly selected for running. The test or fixture will be run if it is selected by name or if it is included by use of a filter. A not filter, which excludes certain tests, is not treated as an explicit selection and never causes an explicit test to be run. All other filters are considered to explicitly select the tests that they match. See examples below. An optional string argument may be used to give the reason for marking the test Explicit. If a test or fixture with the Explicit attribute is encountered in the course of running tests, it is skipped unless it has been specifically selected by one of the above means. The test does not affect the overall result of the test run. Explicit tests are displayed in the gui as skipped. Warning While the C# syntax allows you to place an Explicit attribute on a SetUpFixture class, the attribute is ignored by NUnit and has no effect in current releases. Examples of Use Using the console command-line to select tests, the following options will include any explicit tests that fall under the selection. --test=My.Namespace.Fixture.Method --test=My.Namespace.Fixture --test=My.Namespace --where test==My.Namespace.Fixture.Method --where test==My.Namespace.Fixture --where test==My.Namespace --where cat==X --where \"cat==X || cat==Y\" However, the following options will not include explicit tests --where test!=My.Namespace.Fixture --where cat!=X TRAP If a project contains only explicit tests, running the test project will execute all tests, as it is treated as an explicit test run. To prevent this, ensure the project includes at least one non-explicit test, even if it's just a dummy test. From this issue, the following comment explains how the adapter works with explicit tests: \"When the adapter is called from the testhost, it receives a list of tests to run. It doesn't know HOW the Test Explorer is being used. And thus it has no knowledge if there are other tests present that are not selected, OR if the tests it receives are all the tests in the solution. If all the tests are Explicit it will assume that this is an explicit testrun. When you only have one test, and that test is explicit, it will be an explicit test run. When you add the second test, which is not explicit, it will see both tests, and since there is a non-explicit test included, the test is a non-explicit testrun, and all explicit tests will be ignored. If you have a situation with only one explicit test, the work around is to just add another non-explicit test, which can be empty, or even have a false Assume statement, which will make the test be inconclusive, thus not part of your results.\" Test Fixture Syntax C#: namespace NUnit.Tests { using System; using NUnit.Framework; [TestFixture, Explicit] public class ExplicitTests { // ... } } Visual Basic: Imports System Imports NUnit.Framework Namespace NUnit.Tests <TestFixture(), Explicit()> Public Class ExplicitTests ' ... End Class End Namespace C++: using namespace System; using namespace NUnit::Framework; namespace NUnitTests { [TestFixture] [Explicit] public __gc class ExplicitTests { // ... }; } # include \"cppsample.h\" namespace NUnitTests { // ... } Test Syntax C#: namespace NUnit.Tests { using System; using NUnit.Framework; [TestFixture] public class SuccessTests { [Test, Explicit] public void ExplicitTest() { /* ... */ } } Visual Basic: Imports System Imports NUnit.Framework Namespace NUnit.Tests <TestFixture()> Public Class SuccessTests <Test(), Explicit()> Public Sub ExplicitTest() ' ... End Sub End Class End Namespace C++: # using <NUnit.Framework.dll> using namespace System; using namespace NUnit::Framework; namespace NUnitTests { [TestFixture] public __gc class SuccessTests { [Test][Explicit] void ExplicitTest(); }; } # include \"cppsample.h\" namespace NUnitTests { // ... }"
  },
  "articles/nunit/writing-tests/attributes/fixturelifecycle.html": {
    "href": "articles/nunit/writing-tests/attributes/fixturelifecycle.html",
    "title": "FixtureLifeCycle | NUnit Docs",
    "summary": "FixtureLifeCycle Added in NUnit 3.13 The FixtureLifeCycleAttribute is used to indicate that an instance for a test fixture or all test fixtures in an assembly should be constructed for each test within the fixture or assembly. This attribute may be applied to a test fixture (class) or to a test assembly. It is useful in combination with the Parallelizable Attribute so that a new instance of a test fixture is constructed for every test within the test fixture. This allows tests to run in isolation without sharing instance fields and properties during parallel test runs. This make running parallel tests easier because it is easier to make your tests thread safe. This attribute can be applied to classes or to the entire test assembly. If applied to an assembly, it may be overridden at the class level. LifeCycle Enumeration The constructor of FixtureLifeCycleAttribute takes a LifeCycle attribute to indicate if a single instance of a test fixture should be created for all tests or if a new instance should be created for each test. Value Meaning LifeCycle.SingleInstance A single instance is created and shared for all test cases. This is the default. LifeCycle.InstancePerTestCase A new instance is created for each test case Notes When using LifeCycle.InstancePerTestCase, the OneTimeSetUp and OneTimeTearDown methods must be static, and each are only called once. This is required so that the setup or teardown methods do not access instance fields or properties that are reset for every test. When using LifeCycle.InstancePerTestCase, a class's constructor will be called before every test is executed and IDisposable test fixtures will be disposed after the test is finished. SetUp and TearDown methods are called before and after every test. The Order attribute is respected. See Also Parallelizable Attribute OneTimeSetUp Attribute OneTimeTearDown Attribute"
  },
  "articles/nunit/writing-tests/attributes/ignore.html": {
    "href": "articles/nunit/writing-tests/attributes/ignore.html",
    "title": "Ignore | NUnit Docs",
    "summary": "Ignore IgnoreAttribute is used to indicate that a test should not be executed for some reason. Note that with NUnit 3, the reason must be specified. Ignored tests are displayed by the runners as warnings in order to provide a reminder that the test needs to be corrected or otherwise changed and re-instated. Note that the IgnoreAttribute is attached to a method. If you have multiple test cases using the same method, adding it will ignore all the cases. To ignore individual test cases see Ignoring Individual Test Cases below. Test Fixture Syntax namespace NUnit.Tests { using System; using NUnit.Framework; [TestFixture] [Ignore(\"Ignore a fixture\")] public class SuccessTests { // ... } } Test Syntax [Test] [Ignore(\"Test is not ready yet\")] public void IgnoredTest() { Assert.Fail(\"This test is ignored and should not run\"); } Ignore Until The Until named parameter allows you to ignore a test for a specific period of time, after which the test will run normally. The until date must be a string that can be parsed to a date. [TestFixture] [Ignore(\"Waiting for Joe to fix his bugs\", Until = \"2014-07-31 12:00:00Z\")] public class MyTests { [Test] public void Test1() { /* ... */ } } In the above example, it's assumed that the test would fail if run. With the IgnoreAttribute, it will give a warning until the specified date. After that time, it will run normally and either pass or fail. Ignoring Individual Test Cases The IgnoreAttribute causes all the test cases using the method on which it is placed to be ignored. Ignoring individual test cases is possible, depending on how they are specified. Attribute How to ignore a case TestCase Use the Ignore named parameter of the TestCaseAttribute. TestCaseSource Use TestCaseData for the source and set the Ignore property."
  },
  "articles/nunit/writing-tests/attributes/levelofparallelism.html": {
    "href": "articles/nunit/writing-tests/attributes/levelofparallelism.html",
    "title": "LevelOfParallelism | NUnit Docs",
    "summary": "LevelOfParallelism This is an assembly-level attribute, which may be used to specify the level of parallelism, that is, the maximum number of worker threads executing tests in the assembly. It may be overridden using a command-line option in the console runner. This attribute is optional. If it is not specified, NUnit uses the processor count or 2, whichever is greater. For example, on a four processor machine the default value is 4. Example The following code, which might be placed in AssemblyInfo.cs, sets the level of parallelism to 3: [assembly:LevelOfParallelism(3)] Platform Support Parallel execution is supported by the NUnit framework on desktop .NET runtimes. It is not supported in our Portable or .NET Standard builds at this time, although the attributes are recognized without error in order to allow use in projects that build against multiple targets. See Also Parallelizable Attribute"
  },
  "articles/nunit/writing-tests/attributes/maxtime.html": {
    "href": "articles/nunit/writing-tests/attributes/maxtime.html",
    "title": "MaxTime | NUnit Docs",
    "summary": "MaxTime The MaxTimeAttribute is used on test methods to specify a maximum time in milliseconds for a test case. If the test case takes longer than the specified time to complete, it is reported as a failure. Example [Test, MaxTime(2000)] public void TimedTest() { /* ... */ } Notes Any assertion failures take precedence over the elapsed time check. This attribute does not cancel the test if the time is exceeded. It merely waits for the test to complete and then compares the elapsed time to the specified maximum. If you want to cancel long-running tests, see Timeout Attribute."
  },
  "articles/nunit/writing-tests/attributes/nonparallelizable.html": {
    "href": "articles/nunit/writing-tests/attributes/nonparallelizable.html",
    "title": "NonParallelizable | NUnit Docs",
    "summary": "NonParallelizable This attribute is used to indicate that the test on which it appears may not be run in parallel with any other tests. The attribute takes no arguments and may be used at the assembly, class or method level. When used at the assembly level, its only effect is that execution begins on the non-parallel queue. Test suites, fixtures and test cases will continue to run on the same thread unless a fixture or method is marked with the Parallelizable Attribute. When used on a test fixture or method, that test will be queued on the non-parallel queue and will not run while other tests marked as Parallelizable are being run. Platform Support Parallel execution is not supported by all builds of the NUnit Framework, although the attributes are recognized without error in order to allow use in projects that build against multiple targets. Currently, only the .NET Standard 1.6 build does not support parallelization. See Also Parallelizable Attribute LevelOfParallelism Attribute"
  },
  "articles/nunit/writing-tests/attributes/nontestassembly.html": {
    "href": "articles/nunit/writing-tests/attributes/nontestassembly.html",
    "title": "NonTestAssembly | NUnit Docs",
    "summary": "NonTestAssembly This is an assembly-level attribute, which may be used to specify that even though the assembly refers to NUnit it does not contain any tests. This attribute can be used in connection with the command line option --skipnontestassemblies of the console to skip assemblies without failing. Example The following code, which might be placed in AssemblyInfo.cs, specifies that the assembly does not contain any tests. [assembly: NonTestAssembly] See Also --skipnontestassemblies in Console Command Line"
  },
  "articles/nunit/writing-tests/attributes/onetimesetup.html": {
    "href": "articles/nunit/writing-tests/attributes/onetimesetup.html",
    "title": "OneTimeSetUp | NUnit Docs",
    "summary": "OneTimeSetUp This attribute is to identify methods that are called once prior to executing any of the tests in a fixture. It may appear on methods of a TestFixture or a SetUpFixture. OneTimeSetUp methods may be either static or instance methods and you may define more than one of them in a fixture. Normally, multiple OneTimeSetUp methods are only defined at different levels of an inheritance hierarchy, as explained below. If a OneTimeSetUp method fails or throws an exception, none of the tests in the fixture are executed and a failure or error is reported. Example namespace NUnit.Tests { using System; using NUnit.Framework; [TestFixture] public class SuccessTests { [OneTimeSetUp] public void Init() { /* ... */ } [OneTimeTearDown] public void Cleanup() { /* ... */ } [Test] public void Add() { /* ... */ } } } Inheritance The OneTimeSetUp attribute is inherited from any base class. Therefore, if a base class has defined a OneTimeSetUp method, that method will be called before any methods in the derived class. You may define a OneTimeSetUp method in the base class and another in the derived class. NUnit will call base class OneTimeSetUp methods before those in the derived classes. Warning If a base class OneTimeSetUp method is overridden in the derived class, NUnit will not call the base class OneTimeSetUp method; NUnit does not anticipate usage that includes hiding the base method. Note that you may have a different name for each method; as long as both have the [OneTimeSetUp] attribute present, each will be called in the correct order. Notes Although it is possible to define multiple OneTimeSetUp methods in the same class, you should rarely do so. Unlike methods defined in separate classes in the inheritance hierarchy, the order in which they are executed is not guaranteed. OneTimeSetUp methods may be async if running under .NET 4.0 or higher. OneTimeSetUp methods run in the context of the TestFixture or SetUpFixture, which is separate from the context of any individual test cases. It's important to keep this in mind when using TestContext methods and properties within the method. When using FixtureLifeCycle with LifeCycle.InstancePerTestCase, the OneTimeSetUp method must be static and is only called once. This is required so that the setup method does not access instance fields or properties that are reset for every test. When set on a base class the method is invoked for each fixture that inherits from this base class and its invoked for the base class too if its not abstract. Use SetUpFixture if this only needs to be run once or put the code in a static constructor. See Also SetUp Attribute TearDown Attribute OneTimeTearDown Attribute FixtureLifeCycle Attribute"
  },
  "articles/nunit/writing-tests/attributes/onetimeteardown.html": {
    "href": "articles/nunit/writing-tests/attributes/onetimeteardown.html",
    "title": "OneTimeTearDown | NUnit Docs",
    "summary": "OneTimeTearDown This attribute is to identify methods that are called once after executing all the tests in a fixture. It may appear on methods of a TestFixture or a SetUpFixture. OneTimeTearDown methods may be either static or instance methods and you may define more than one of them in a fixture. Normally, multiple OneTimeTearDown methods are only defined at different levels of an inheritance hierarchy, as explained below. Example namespace NUnit.Tests { using System; using NUnit.Framework; [TestFixture] public class SuccessTests { [OneTimeSetUp] public void Init() { /* ... */ } [OneTimeTearDown] public void Cleanup() { /* ... */ } [Test] public void Add() { /* ... */ } } } Inheritance The OneTimeTearDown attribute is inherited from any base class. Therefore, if a base class has defined a OneTimeTearDown method, that method will be called after any test methods in the derived class. You may define a OneTimeTearDown method in the base class and another in the derived class. NUnit will call base class OneTimeTearDown methods after those in the derived classes. Warning If a base class OneTimeTearDown method is overridden in the derived class, NUnit will not call the base class OneTimeTearDown method; NUnit does not anticipate usage that includes hiding the base method. Note that you may have a different name for each method; as long as both have the [OneTimeTearDown] attribute present, each will be called in the correct order. Notes Although it is possible to define multiple OneTimeTearDown methods in the same class, you should rarely do so. Unlike methods defined in separate classes in the inheritance hierarchy, the order in which they are executed is not guaranteed. OneTimeTearDown methods may be async if running under .NET 4.0 or higher. OneTimeTearDown methods run in the context of the TestFixture or SetUpFixture, which is separate from the context of any individual test cases. It's important to keep this in mind when using TestContext methods and properties within the method. When using FixtureLifeCycle with LifeCycle.InstancePerTestCase, the OneTimeTearDown method must be static and is only called once. This is required so that the teardown method does not access instance fields or properties that are reset for every test. See Also SetUp Attribute TearDown Attribute OneTimeSetUp Attribute TestFixture Attribute SetUpFixture Attribute FixtureLifeCycle Attribute"
  },
  "articles/nunit/writing-tests/attributes/order.html": {
    "href": "articles/nunit/writing-tests/attributes/order.html",
    "title": "Order | NUnit Docs",
    "summary": "Order The OrderAttribute may be placed on a test method or fixture to specify the order in which tests are run within the fixture or other suite in which they are contained. Ordering is given by the required order argument to the attribute, an int. Example The following tests will be run in the order: TestA TestB TestC public class MyFixture { [Test, Order(1)] public void TestA() { /* ... */ } [Test, Order(2)] public void TestB() { /* ... */ } [Test] public void TestC() { /* ... */ } } Notes As stated, ordering is local to the test that contains the ordered tests. For test cases (methods) ordering applies within the containing fixture. For fixtures it applies within the containing namespace. There is no facility in NUnit to order tests globally. Tests with an OrderAttribute argument are started before any tests without the attribute. Ordered tests are started in ascending order of the order argument. Among tests with the same order value or without the attribute, execution order is indeterminate. Tests do not wait for prior tests to finish. If multiple threads are in use, a test may be started while some earlier tests are still being run."
  },
  "articles/nunit/writing-tests/attributes/pairwise.html": {
    "href": "articles/nunit/writing-tests/attributes/pairwise.html",
    "title": "Pairwise | NUnit Docs",
    "summary": "Pairwise The PairwiseAttribute is used on a test to specify that NUnit should generate test cases in such a way that all possible pairs of values are used. This is a well-known approach for combatting the combinatorial explosion of test cases when more than two features (parameters) are involved. Example Using the Combinatorial attribute, the following test would be executed 12 (3x2x2) times. With Pairwise it is executed only enough times so that each possible pair is covered.. [Test, Pairwise] public void MyTest( [Values(\"a\", \"b\", \"c\")] string a, [Values(\"+\", \"-\")] string b, [Values(\"x\", \"y\")] string c) { Console.WriteLine(\"{0} {1} {2}\", a, b, c); } For this test, NUnit currently calls the method six times, producing the following output: a - x a + y b - y b + x c - x c + y Note that this is not the optimal output. The pairs (-, x) and (+, y) appear twice. NUnit uses a heuristic algorithm to reduce the number of test cases as much as it can. Improvements may be made in the future. Limitations When used on a generic method the programmer must ensure that all possible combinations of arguments are valid. When multiple parameters use the same generic type (e.g.: T) this may not be possible and the attribute may generate invalid test cases. See Also Sequential Attribute Combinatorial Attribute"
  },
  "articles/nunit/writing-tests/attributes/parallelizable.html": {
    "href": "articles/nunit/writing-tests/attributes/parallelizable.html",
    "title": "Parallelizable | NUnit Docs",
    "summary": "Parallelizable Added in NUnit 3.7 The ParallelizableAttribute is used to indicate that a test and/or its descendants may be run in parallel with other tests. By default, no parallel execution takes place. When used without an argument, Parallelizable causes the test fixture or method on which it is placed to be queued for execution in parallel with other parallelizable tests. It may be used at the assembly, class or method level. Warning When tests are run in parallel, you are responsible for the thread safety of your tests. Tests that run at the same time and modify instance fields or properties without locks will cause unexpected behavior as they would in any multi-threaded program. If you are using fields or properties between parallel tests consider using the FixtureLifeCycleAttribute to construct a new instance of a test fixture (class) for each test that is run. The constructor takes an optional ParallelScope enumeration argument (see below), which indicates whether the attribute applies to the item itself, to its descendants or both. It defaults to ParallelScope.Self. The Scope may also be specified using the constructor argument scope:, for example; [Parallelizable(scope: ParallelScope.All)] ParallelScope Enumeration This is a [Flags] enumeration used to specify which tests may run in parallel. It applies to the test upon which it appears and any subordinate tests. The following values are available to users: Value Meaning Valid On ParallelScope.Self the test itself may be run in parallel with other tests Classes, Methods ParallelScope.Children child tests may be run in parallel with one another Assembly, Classes ParallelScope.Fixtures fixtures may be run in parallel with one another Assembly, Classes ParallelScope.All the test and its descendants may be run in parallel with others at the same level Classes, Methods Notes Some values are invalid on certain elements, although they will compile. NUnit will report any tests so marked as invalid and will produce an error message. The ParallelScope enum has additional values, which are used internally but are not visible to users through Intellisense. The ParallelizableAttribute may be specified on multiple levels of the tests. Settings at a higher level may affect lower level tests, unless those lower-level tests override the inherited settings. See Also FixtureLifeCycle Attribute NonParallelizable Attribute LevelOfParallelism Attribute"
  },
  "articles/nunit/writing-tests/attributes/platform.html": {
    "href": "articles/nunit/writing-tests/attributes/platform.html",
    "title": "Platform | NUnit Docs",
    "summary": "Platform The Platform attribute is used to specify platforms for which a test or fixture should be run. Platforms are specified using case-insensitive string values and may be either included or excluded from the run by use of the Include or Exclude properties respectively. Platforms to be included may alternatively be specified as an argument to the PlatformAttribute constructor. In either case, multiple comma-separated values may be specified. If a test or fixture with the Platform attribute does not satisfy the specified platform requirements it is skipped. The test does not affect the outcome of the run at all: it is not considered as ignored and is not even counted in the total number of tests. [Ed.: Check this.] In the gui, the tree node for the test remains gray and the status bar color is not affected. Test Fixture Syntax namespace NUnit.Tests { using System; using NUnit.Framework; [TestFixture] [Platform(\"NET-2.0\")] public class DotNetTwoTests { // ... } } Test Syntax namespace NUnit.Tests { using System; using NUnit.Framework; [TestFixture] public class SuccessTests { [Test] [Platform(Exclude=\"Win98,WinME\")] public void SomeTest() { /* ... */ } } Platform Specifiers The following values are recognized as platform specifiers. They may be expressed in upper, lower or mixed case. Operating System Win Win32 Win32S Win32Windows Win32NT WinCE Win95 Win98 WinMe NT3 NT4 NT5 NT6 Win2K WinXP Win2003Server Vista Win2008Server Win2008ServerR2 Windows7 Win2012Server Windows8 Windows8.1 Windows10 Windows11 WindowsServer10 Unix Linux MacOsX XBox A list of supported platform identifiers can also be obtained from the constant string PlatformHelper.OSPlatforms of the NUnit assembly you use. Note that this is for informational purposes only, because the PlatformHelper is considered an internal type and shall not be used in production. Architecture 32-Bit 32-Bit-Process 32-Bit-OS (.NET 4.0 and higher only) 64-Bit 64-Bit-Process 64-Bit-OS (.NET 4.0 and higher only) Runtime Net Net-1.0 Net-1.1 Net-2.0 Net-3.0 (1) Net-3.5 (2) Net-4.0 Net-4.5 (3) NetCF SSCLI Rotor Mono Mono-1.0 Mono-2.0 Mono-3.0 (4) Mono-3.5 (5) Mono-4.0 Notes Includes Net-2.0 Includes Net-2.0 and Net-3.0 Includes Net-4.0 Includes Mono-2.0 Includes Mono-2.0 and Mono-3.0 [SupportedOSPlatformAttribute] and [UnsupportedOSPlatformAttribute] support The [SupportedOSPlatform] and [UnsupportedOSPlatform] attributes are also supported, however they are only supported on a subset of dotnet versions compared to [Platform]. See the docs from Microsoft for more information about [SupportedOSPlatform] and [UnsupportedOSPlatform]."
  },
  "articles/nunit/writing-tests/attributes/property.html": {
    "href": "articles/nunit/writing-tests/attributes/property.html",
    "title": "Property | NUnit Docs",
    "summary": "Property PropertyAttribute provides a generalized approach to setting named properties on any test case or fixture, using a name/value pair. In the example below, the fixture class MathTests is given a Location value of 723 while the test case AdditionTest is given a Severity of \"Critical\" Example namespace NUnit.Tests { using System; using NUnit.Framework; [TestFixture, Property(\"Location\", 723)] public class MathTests { [Test, Property(\"Severity\", \"Critical\")] public void AdditionTest() { /* ... */ } } } Usage Note The PropertyAttribute is not currently used for any purpose by NUnit itself, other than to display them in the XML output file and in the Test Properties dialog of the gui. You may also use properties with the --where option on the command-line in order to select tests to run. See Test Selection Language. Note that his filtering will only work for properties where the values have type string. User tests may access properties through the TestContext or by reflection. Custom Property Attributes Users can define custom attributes that derive from PropertyAttribute and have them recognized by NUnit. PropertyAttribute provides a protected constructor that takes the value of the property and sets the property name to the name of the derived class with the 'Attribute' suffix removed. Here's an example that creates a Severity property. It works just like any other property, but has a simpler syntax and is type-safe. A custom test reporting system might make use of the property to provide special reports. public enum SeverityLevel { Critical, Major, Normal, Minor } [AttributeUsage(AttributeTargets.Method, AllowMultiple=false)] public class SeverityAttribute : PropertyAttribute { public SeverityAttribute(SeverityLevel level) : base(level.ToString()) {} } ... [Test, Severity(SeverityLevel.Critical)] public void MyTest() { /*...*/ } A PropertyAttribute may contain multiple name/value pairs. This capability is not exposed publicly but may be used by derived property classes."
  },
  "articles/nunit/writing-tests/attributes/random.html": {
    "href": "articles/nunit/writing-tests/attributes/random.html",
    "title": "Random | NUnit Docs",
    "summary": "Random The RandomAttribute is used to specify a set of random values to be provided for an individual numeric parameter, or Guid of a parameterized test method. Since NUnit combines the data provided for each parameter into a set of test cases, data must be provided for all parameters if it is provided for any of them. By default, NUnit creates test cases from all possible combinations of the datapoints provided on parameters - the combinatorial approach. This default may be modified by use of specific attributes on the test method itself. RandomAttribute supports the following constructors: public Random(int count); public Random(int min, int max, int count); public Random(uint min, uint max, int count); public Random(long min, long max, int count); public Random(ulong min, ulong max, int count); public Random(short min, short max, int count); public Random(ushort min, ushort max, int count); public Random(byte min, byte max, int count); public Random(sbyte min, sbyte max, int count); public Random(double min, double max, int count); public Random(float min, float max, int count); In the first form, without minimum and maximum values, the attribute automatically generates values of the appropriate numeric Type or Guid for the argument provided, using the Randomizer object associated with the current context. See Randomizer Methods for details. In general, the forms that specify a minimum and maximum should be used on arguments of the same type. However, the following exceptions are supported: You may use an int range on arguments of type short, ushort, byte, sbyte and decimal. You may use a double range on arguments of type decimal. Note that there is no constructor taking decimal values for min and max. This is because .NET does not support use of decimal in an attribute constructor. Note Guid support for RandomAttribute is available from version 4.0 onwards. Example The following test will be executed fifteen times, three times for each value of x, each combined with 5 random doubles from -1.0 to +1.0. [Test] public void MyTest( [Values(1, 2, 3)] int x, [Random(-1.0, 1.0, 5)] double d) { ... } See Also Values Attribute Range Attribute Sequential Attribute Combinatorial Attribute Pairwise Attribute"
  },
  "articles/nunit/writing-tests/attributes/range.html": {
    "href": "articles/nunit/writing-tests/attributes/range.html",
    "title": "Range | NUnit Docs",
    "summary": "Range The RangeAttribute is used to specify a range of values to be provided for an individual parameter of a parameterized test method. Since NUnit combines the data provided for each parameter into a set of test cases, data must be provided for all parameters if it is provided for any of them. By default, NUnit creates test cases from all possible combinations of the datapoints provided on parameters - the combinatorial approach. This default may be modified by use of specific attributes on the test method itself. RangeAttribute supports the following constructors: public RangeAttribute(int from, int to); public RangeAttribute(int from, int to, int step); public RangeAttribute(long from, long to, long step); public RangeAttribute(float from, float to, float step); public RangeAttribute(double from, double to, double step); Example The following test will be executed nine times. [Test] public void RangeAttribute_Example( [Values(1, 2, 3)] int x, [Range(0.2, 0.6, 0.2)] double d) { Assert.That(x, Is.GreaterThan(0)); Assert.That(d, Is.GreaterThan(0.0)); } The MyTest method is called nine times, as follows: MyTest(1, 0.2) MyTest(1, 0.4) MyTest(1, 0.6) MyTest(2, 0.2) MyTest(2, 0.4) MyTest(2, 0.6) MyTest(3, 0.2) MyTest(3, 0.4) MyTest(3, 0.6) See Also Values Attribute Random Attribute Sequential Attribute Combinatorial Attribute Pairwise Attribute"
  },
  "articles/nunit/writing-tests/attributes/repeat.html": {
    "href": "articles/nunit/writing-tests/attributes/repeat.html",
    "title": "Repeat | NUnit Docs",
    "summary": "Repeat RepeatAttribute is used on a test method to specify that it should be executed multiple times. If any repetition fails, the remaining ones are not run and a failure is reported. Notes If RepeatAttribute is used on a parameterized method, each individual test case created for that method is repeated. It is not currently possible to use RepeatAttribute on a TestFixture or any higher level suite. Only test cases may be repeated. Examples [Test] [Repeat(25)] public void MyTest() { /* The contents of this test will be run 25 times. */ }"
  },
  "articles/nunit/writing-tests/attributes/requiresthread.html": {
    "href": "articles/nunit/writing-tests/attributes/requiresthread.html",
    "title": "RequiresThread | NUnit Docs",
    "summary": "RequiresThread The RequiresThreadAttribute is used to indicate that a test method, class or assembly should be run on a separate thread. Optionally, the desired apartment for the thread may be specified in the constructor. Note This attribute, used with or without an ApartmentState argument will always result in creation of a new thread. To create a thread only if the current ApartmentState is not appropriate, use the ApartmentAttribute. Examples // A thread will be created and used to run // all the tests in the assembly [assembly:RequiresThread] /* ... */ // TestFixture requiring a separate thread [TestFixture, RequiresThread] public class FixtureOnThread { // A separate thread will be created and all // tests in the fixture will run on it. } [TestFixture] public class AnotherFixture { [Test, RequiresThread] public void TestRequiringThread() { // A separate thread will be created for this test } [Test, RequiresThread(ApartmentState.STA)] public void TestRequiringSTAThread() { // A separate STA thread will be created for this test. } } See Also Apartment Attribute"
  },
  "articles/nunit/writing-tests/attributes/retry.html": {
    "href": "articles/nunit/writing-tests/attributes/retry.html",
    "title": "Retry | NUnit Docs",
    "summary": "Retry RetryAttribute is used on a test method to specify that it should be rerun if it fails, up to a maximum number of times. Notes: The argument you specify is the total number of attempts and not the number of retries after an initial failure. So [Retry(1)] does nothing and should not be used. It is not currently possible to use RetryAttribute on a TestFixture or any other type of test suite. Only single tests may be repeated. If a test has an unexpected exception, an error result is returned and it is not retried. Only assertion failures can trigger a retry. To convert an unexpected exception into an assertion failure, see the ThrowsConstraint."
  },
  "articles/nunit/writing-tests/attributes/sequential.html": {
    "href": "articles/nunit/writing-tests/attributes/sequential.html",
    "title": "Sequential | NUnit Docs",
    "summary": "Sequential The SequentialAttribute is used on a test to specify that NUnit should generate test cases by selecting individual data items provided for the parameters of the test, without generating additional combinations. Note If parameter data is provided by multiple attributes, the order in which NUnit uses the data items is not guaranteed. However, it can be expected to remain constant for a given runtime and operating system. For best results with SequentialAttribute use only one data attribute on each parameter. Example The following test will be executed three times. [Test, Sequential] public void MyTest( [Values(1, 2, 3)] int x, [Values(\"A\", \"B\")] string s) { /* ... */ } MyTest is called three times, as follows: MyTest(1, \"A\") MyTest(2, \"B\") MyTest(3, null) See also Combinatorial Attribute Pairwise Attribute"
  },
  "articles/nunit/writing-tests/attributes/setculture.html": {
    "href": "articles/nunit/writing-tests/attributes/setculture.html",
    "title": "SetCulture | NUnit Docs",
    "summary": "SetCulture The SetCulture attribute is used to set the current Culture for the duration of a test. It may be specified at the level of a test, fixture or assembly. The culture remains set until the test or fixture completes and is then reset to its original value. If you wish to use the current culture setting to decide whether to run a test, use the Culture attribute instead of this one. Only one culture may be specified. Running a test under multiple cultures is a planned future enhancement. At this time, you can achieve the same result by factoring out your test code into a private method that is called by each individual test method. Examples namespace NUnit.Tests { using System; using NUnit.Framework; [TestFixture] [SetCulture(\"fr-FR\")] public class FrenchCultureTests { // ... } } See also Culture Attribute"
  },
  "articles/nunit/writing-tests/attributes/setuiculture.html": {
    "href": "articles/nunit/writing-tests/attributes/setuiculture.html",
    "title": "SetUICulture | NUnit Docs",
    "summary": "SetUICulture The SetUICulture attribute is used to set the current UI Culture for the duration of a test. It may be specified at the level of a test or a fixture. The UI culture remains set until the test or fixture completes and is then reset to its original value. If you wish to use the current culture setting to decide whether to run a test, use the Culture attribute instead of this one. Only one culture may be specified. Running a test under multiple cultures is a planned future enhancement. At this time, you can achieve the same result by factoring out your test code into a private method that is called by each individual test method. Examples namespace NUnit.Tests { using System; using NUnit.Framework; [TestFixture] [SetUICulture(\"fr-FR\")] public class FrenchCultureTests { // ... } } See also Culture Attribute] SetCulture Attribute"
  },
  "articles/nunit/writing-tests/attributes/setup.html": {
    "href": "articles/nunit/writing-tests/attributes/setup.html",
    "title": "SetUp | NUnit Docs",
    "summary": "SetUp This attribute is used inside a TestFixture to provide a common set of functions that are performed just before each test method is called. SetUp methods may be either static or instance methods and you may define more than one of them in a fixture. Normally, multiple SetUp methods are only defined at different levels of an inheritance hierarchy, as explained below. If a SetUp method fails or throws an exception, the test is not executed and a failure or error is reported. Example [TestFixture] public class SetupTeardownExamples { private int _counter; [SetUp] public void Init() { _counter = 0; Console.WriteLine(\"SetUp method called before each test\"); } [TearDown] public void Cleanup() { Console.WriteLine(\"TearDown method called after each test\"); } [Test] public void TestMethod1() { _counter++; Assert.That(_counter, Is.EqualTo(1)); } [Test] public void TestMethod2() { _counter++; Assert.That(_counter, Is.EqualTo(1)); } } Inheritance The SetUp attribute is inherited from any base class. Therefore, if a base class has defined a SetUp method, that method will be called before each test method in the derived class. You may define a SetUp method in the base class and another in the derived class. NUnit will call base class SetUp methods before those in the derived classes. Warning If a base class SetUp method is overridden in the derived class, NUnit will not call the base class SetUp method; NUnit does not anticipate usage that includes hiding the base method. Note that you may have a different name for each method; as long as both have the [SetUp] attribute present, each will be called in the correct order. Notes Although it is possible to define multiple SetUp methods in the same class, you should rarely do so. Unlike methods defined in separate classes in the inheritance hierarchy, the order in which they are executed is not guaranteed. You may specify an async method (async keyword in c#) if necessary, when running under .NET 4.0 or higher. See also TearDown Attribute OneTimeSetUp Attribute OneTimeTearDown Attribute testfixture attribute"
  },
  "articles/nunit/writing-tests/attributes/setupfixture.html": {
    "href": "articles/nunit/writing-tests/attributes/setupfixture.html",
    "title": "SetUpFixture | NUnit Docs",
    "summary": "SetUpFixture This is the attribute that marks a class that contains the one-time setup or teardown methods for all the test fixtures in a given namespace including nested namespaces below, within an assembly. The class may contain at most one method marked with the OneTimeSetUpAttribute and one method marked with the OneTimeTearDownAttribute. There are a few restrictions on a class that is used as a setup fixture. It must be a publicly exported type or NUnit will not see it. It must have a default constructor or NUnit will not be able to construct it. The OneTimeSetUp method in a SetUpFixture is executed once before any of the fixtures contained in its namespace. The OneTimeTearDown method is executed once after all the fixtures have completed execution. In the examples below, the method RunBeforeAnyTests() is called before any tests or setup methods in the NUnit.Tests namespace. The method RunAfterAnyTests() is called after all the tests in the namespace as well as their individual or fixture teardowns have completed execution. Multiple SetUpFixtures may be created in a given namespace. The order of execution of such fixtures is indeterminate. Notes The scope of a SetUpFixture is limited to an assembly. A SetUpFixture in a namespace will apply to all tests in that namespace and all contained namespaces within the assembly. A SetUpFixture outside of any namespace provides SetUp and TearDown for the entire assembly. Example using System; using NUnit.Framework; namespace NUnit.Tests { [SetUpFixture] public class MySetUpClass { [OneTimeSetUp] public void RunBeforeAnyTests() { // ... } [OneTimeTearDown] public void RunAfterAnyTests() { // ... } } } Detailed explanation With respect to the order of execution of setup (also one-time setup) it's deterministic between namespaces (including nested namespaces) but non-deterministic if you have two setups at the same level, e.g. two methods in the same class marked [SetUp]. That's, however, a usage that should only come up in limited situations and is easy to avoid. The defined order is as follows... Setup starts at the assembly level SetUpFixture, outside of any namespace. It continues with the top level of any SetUpFixtures in a namespace , proceeds downward into any nested namespaces. Setup code in a TestFixture comes after any SetUpFixtures that control the namespace of the fixture. At each of the above levels, inheritance may also come into play. Base class setups are run before those of the derived class. Teardown for any of the above executes in the reverse order. Ordering of TestFixtures or SetUpFixtures within the same namespace is indeterminate. Ordering of multiple setup methods within the same class is indeterminate. [Items 6 and 7 rarely come into play but the features are available for situations like code generation, where it may be more convenient to have multiple setup fixtures and/or methods.] Notes About filtering on SetUpFixtures: A SetUpFixture is normally not used for filtering tests. However, if that is done, one should be aware that a SetUpFixture encapsulates all tests to which it belongs. If placed in a namespace it will encapsulate all tests in that namespace and contained namespaces. If placed on the assembly level, it will encapsulate all tests in the assembly. Prior to NUnit 3.0, SetUpFixture used the SetUp and TearDown attributes rather than OneTimeSetUp and OneTimeTearDown. The older attributes are no longer supported in SetUpFixtures in NUnit 3.0 and later. See also SetUp Attribute TearDown Attribute OneTimeSetUp Attribute OneTimeTearDown Attribute"
  },
  "articles/nunit/writing-tests/attributes/singlethreaded.html": {
    "href": "articles/nunit/writing-tests/attributes/singlethreaded.html",
    "title": "SingleThreaded | NUnit Docs",
    "summary": "SingleThreaded SingleThreadedAttribute is used on a TestFixture and indicates that the OneTimeSetUp, OneTimeTearDown and all the child tests must run on the same thread. When using this attribute, any ParallelScope setting is ignored."
  },
  "articles/nunit/writing-tests/attributes/teardown.html": {
    "href": "articles/nunit/writing-tests/attributes/teardown.html",
    "title": "TearDown | NUnit Docs",
    "summary": "TearDown This attribute is used inside a TestFixture to provide a common set of functions that are performed after each test method. TearDown methods may be either static or instance methods and you may define more than one of them in a fixture. Normally, multiple TearDown methods are only defined at different levels of an inheritance hierarchy, as explained below. So long as any SetUp method runs without error, the TearDown method is guaranteed to run. For example, it is not guaranteed to run if a SetUp method fails or throws an exception. Example namespace NUnit.Tests { using System; using NUnit.Framework; [TestFixture] public class SuccessTests { [SetUp] public void Init() { /* ... */ } [TearDown] public void Cleanup() { /* ... */ } [Test] public void Add() { /* ... */ } } } Inheritance The TearDown attribute is inherited from any base class. Therefore, if a base class has defined a TearDown method, that method will be called after each test method in the derived class. You may define a TearDown method in the base class and another in the derived class. NUnit will call base class TearDown methods after those in the derived classes. Warning If a base class TearDown method is overridden in the derived class, NUnit will not call the base class TearDown method; NUnit does not anticipate usage that includes hiding the base method. Note that you may have a different name for each method; as long as both have the [TearDown] attribute present, each will be called in the correct order. Notes Although it is possible to define multiple TearDown methods in the same class, you should rarely do so. Unlike methods defined in separate classes in the inheritance hierarchy, the order in which they are executed is not guaranteed. TearDown methods may be async if running under .NET 4.0 or higher. See also SetUp Attribute OneTimeSetUp Attribute OneTimeTearDown Attribute TestFixture Attribute"
  },
  "articles/nunit/writing-tests/attributes/test.html": {
    "href": "articles/nunit/writing-tests/attributes/test.html",
    "title": "Test | NUnit Docs",
    "summary": "Test The Test attribute is one way of marking a method inside a TestFixture class as a test. It is normally used for simple (non-parameterized) tests but may also be applied to parameterized tests without causing any extra test cases to be generated. See Parameterized Tests for more info. The test method may be either an instance or a static method. Test methods targeting .Net 4.0 or higher may be marked as async and NUnit will wait for the method to complete before recording the result and moving on to the next test. Async test methods must return Task if no value is returned, or Task<T> if a value of type T is returned. If the programmer marks a test method that does not have the correct signature it will be considered as not runnable. If the test method returns a value, you must pass in the ExpectedResult named parameter to the Test attribute. This expected return value will be checked for equality with the return value of the test method. The test Description may be specified as a named parameter. This is exactly equivalent to using the DescriptionAttribute on the test. Examples namespace NUnit.Tests { using System; using NUnit.Framework; [TestFixture] public class SuccessTests { // A simple test [Test] public void Add() { /* ... */ } // A test with a description property [Test(Description=\"My really cool test\")] public void Add() { /* ... */ } // Alternate way to specify description as a separate attribute [Test, Description(\"My really really cool test\")] public void Add() { /* ... */ } // A simple async test [Test] public async Task AddAsync() { /* ... */ } // Test with an expected result [Test(ExpectedResult = 4)] public int TestAdd() { return 2 + 2; } // Async test with an expected result [Test(ExpectedResult = 4)] public async Task<int> TestAdd() { await ... return 2 + 2; } } }"
  },
  "articles/nunit/writing-tests/attributes/testcase.html": {
    "href": "articles/nunit/writing-tests/attributes/testcase.html",
    "title": "TestCase | NUnit Docs",
    "summary": "TestCase TestCaseAttribute serves the dual purpose of marking a method with parameters as a test method and providing inline data to be used when invoking that method. Here is an example of a test being run three times, with three different sets of data: [TestCase(12, 3, 4)] [TestCase(12, 2, 6)] [TestCase(12, 4, 3)] public void DivideTest(int n, int d, int q) { Assert.That(n / d, Is.EqualTo(q)); } Note Because arguments to .NET attributes are limited in terms of the Types that may be used, NUnit will make some attempt to convert the supplied values using Convert.ChangeType() before supplying it to the test. TestCaseAttribute may appear one or more times on a test method, which may also carry other attributes providing test data. The method may optionally be marked with the Test Attribute as well. By using the named parameter ExpectedResult this test set may be simplified further: [TestCase(12, 3, ExpectedResult = 4)] [TestCase(12, 2, ExpectedResult = 6)] [TestCase(12, 4, ExpectedResult = 3)] public int DivideTest(int n, int d) { return n / d; } In the above example, NUnit checks that the return value of the method is equal to the expected result provided on the attribute. TestCaseAttribute supports a number of additional named parameters: Author sets the author of the test. Category provides a comma-delimited list of categories for this test. Description sets the description property of the test. ExcludePlatform specifies a comma-delimited list of platforms on which the test should not run. ExpectedResult sets the expected result to be returned from the method, which must have a compatible return type. Explicit is set to true in order to make the individual test case Explicit. Use Reason to explain why. Ignore causes the test case to be ignored and specifies the reason. IgnoreReason causes this test case to be ignored and specifies the reason. IncludePlatform specifies a comma-delimited list of platforms on which the test should run. Reason specifies the reason for not running this test case. Use in conjunction with Explicit. TestName provides a name for the test. If not specified, a name is generated based on the method name and the arguments provided. See Template Based Test Naming. TestOf specifies the Type that this test is testing (this is not used within NUnit during test execution, but may serve a purpose for the test author) TypeArgs specifies the Types to be used when targeting a generic test method. (NUnit 4.1+) Be aware of mixing the syntax for named parameters and attributes with the same name Correct Ignore Attribute Usage, by Example Warning When using the Ignore parameter (and others, see below), note that this has to be a named parameter. It is easy to accidentally add another Ignore attribute after the TestCase attribute. That will be the same as adding it separately, and it will apply to the complete fixture. This may apply to other named parameters, with names equal to other attributes, like the Explicit and Category parameters. Correct example usage: [TestCase(1, 1)] [TestCase(0, 0, Ignore = \"Only ignore this\")] [TestCase(1, 3)] public void AddTestWithIgnore(int a, int b) { var result = a + b; Assert.That(result, Is.GreaterThan(1)); } Warning Wrong way! Below, we demonstrate an incorrect approach. (1) Adding it on the same line is the same as adding it on a separate line (3), both results in the fixture being ignored (2). Thanks to Geir Marius Gjul for raising this question again. Correct Explicit Attribute Usage, by Example Explicit, used correctly, looks like the following: [TestCase(1, 1)] [TestCase(0, 0, Explicit = true, Reason = \"This will fail so only run explicitly\")] [TestCase(1, 3)] public void AddTestWithExplicit(int a, int b) { var result = a + b; Assert.That(result, Is.GreaterThan(1)); } Note that adding the Reason is optional, and Visual Studio TestExplorer will not even show it. Correct Category Attribute Usage, by Example Categories can be applied to a single TestCase the same way, as a named parameter. Otherwise, it will apply to the whole fixture. Be sure what you're asking for! [TestCase(1, 1)] [TestCase(2, 0, Category = \"Crazy\")] [TestCase(1, 3)] public void AddTestWithCategory(int a, int b) { var result = a + b; Assert.That(result, Is.GreaterThan(1)); } Order of Execution Individual test cases are executed in the order in which NUnit discovers them. This order does not necessarily follow the lexical order of the attributes and will often vary between different compilers or different versions of the CLR. As a result, when TestCaseAttribute appears multiple times on a method or when other data-providing attributes are used in combination with TestCaseAttribute, the order of the test cases is undefined."
  },
  "articles/nunit/writing-tests/attributes/testcasesource.html": {
    "href": "articles/nunit/writing-tests/attributes/testcasesource.html",
    "title": "TestCaseSource | NUnit Docs",
    "summary": "TestCaseSource TestCaseSourceAttribute is used on a parameterized test method to identify the source from which the required arguments will be provided. The attribute additionally identifies the method as a test method. The data is kept separate from the test itself and may be used by multiple test methods. See Parameterized Tests for a general introduction to tests with arguments. Usage Consider a test of the divide operation, taking three arguments: the numerator, the denominator and the expected result. We can specify the test and its data using one of the forms of TestCaseSourceAttribute: Form 1 - [TestCaseSource(string sourceName)] Note We use the nameof operator to avoid introducing magic strings into code, which offers better resilience when refactoring. While nameof is recommended, you could also use the string \"DivideCases\" to achieve the same outcome. public class BasicTestCaseSourceFixture { [TestCaseSource(nameof(DivideCases))] public void DivideTest(int n, int d, int q) { ClassicAssert.AreEqual(q, n / d); } public static object[] DivideCases = { new object[] { 12, 3, 4 }, new object[] { 12, 2, 6 }, new object[] { 12, 4, 3 } }; } The single attribute argument in this form is a string representing the name of the source used to provide test cases. It has the following characteristics: It may be a field, property or method in the test class. It must be static. This is a change from NUnit 2.x. It must return an IEnumerable or a type that implements IEnumerable. For fields an array is generally used. For properties and methods, you may return an array or implement your own iterator. Methods may also return an IAsyncEnumerable or a type that implements IAsyncEnumerable. (NUnit 4+) Methods may be async by wrapping the return type in a Task<T>. (NUnit 3.14+) The individual items returned by the enumerator must be compatible with the signature of the method on which the attribute appears. See the Test Case Construction section below for details. Sometimes we would like to parameterize the source, e.g. if we use the same source for multiple tests, to this end it is possible to pass parameters to the source, if the source is a method. The parameters are specified as an array of parameters that are passed to the source method. public class ParameterizedSourceExampleFixture { [TestCaseSource(nameof(TestStrings), new object[] { true })] public void LongNameWithEvenNumberOfCharacters(string name) { Assert.That(name.Length, Is.GreaterThan(5)); bool hasEvenNumOfCharacters = (name.Length % 2) == 0; Assert.That(hasEvenNumOfCharacters, Is.True); } [TestCaseSource(nameof(TestStrings), new object[] { false })] public void ShortNameWithEvenNumberOfCharacters(string name) { Assert.That(name.Length, Is.LessThan(15)); bool hasEvenNumOfCharacters = (name.Length % 2) == 0; Assert.That(hasEvenNumOfCharacters, Is.True); } static IEnumerable<string> TestStrings(bool generateLongTestCase) { if (generateLongTestCase) { yield return \"ThisIsAVeryLongNameThisIsAVeryLongName\"; yield return \"SomeName\"; yield return \"YetAnotherName\"; } else { yield return \"AA\"; yield return \"BB\"; yield return \"CC\"; } } } Form 2 - [TestCaseSource(Type sourceType, string sourceName)] public class TestFixtureThatUsesClassMethodAsTestCaseSource { [TestCaseSource(typeof(AnotherClassWithTestFixtures), nameof(AnotherClassWithTestFixtures.DivideCases))] public void DivideTest(int n, int d, int q) { ClassicAssert.AreEqual(q, n / d); } } public class AnotherClassWithTestFixtures { public static object[] DivideCases = { new object[] { 12, 3, 4 }, new object[] { 12, 2, 6 }, new object[] { 12, 4, 3 } }; } The first argument of the attribute in this form is a Type representing the class that will provide the test cases. The second argument is a string representing the name of the source used to provide test cases. It has the following characteristics: It may be a field, property or method in the test class. It must be static. This is a change from NUnit 2.x. It must return an IEnumerable or a type that implements IEnumerable. For fields an array is generally used. For properties and methods, you may return an array or implement your own iterator. Methods may also return an IAsyncEnumerable or a type that implements IAsyncEnumerable. (NUnit 4+) Methods may be async by wrapping the return type in a Task<T>. (NUnit 3.14+) The individual items returned by the enumerator must be compatible with the signature of the method on which the attribute appears. See the Test Case Construction section below for details. Similar to Form 1 it is possible to pass parameters to the source, if the source is a method. Form 3 - [TestCaseSource(Type sourceType)] public class TestFixtureThatUsesClassAsTestCaseSource { [TestCaseSource(typeof(DivideCasesClass))] public void DivideTest(int n, int d, int q) { ClassicAssert.AreEqual(q, n / d); } } public class DivideCasesClass : IEnumerable { public IEnumerator GetEnumerator() { yield return new object[] { 12, 3, 4 }; yield return new object[] { 12, 2, 6 }; yield return new object[] { 12, 4, 3 }; } } The Type argument in this form represents the class that provides test cases. It must have a default constructor and implement IEnumerable. The enumerator should return test case data compatible with the signature of the test on which the attribute appears. See the Test Case Construction section below for details. Note that it is not possible to pass parameters to the source, even if the source is a method. Sources with expected result using TestCaseData As of NUnit 3.12, it is possible to use a typed source with an expected result. This is done by using the TestCaseSource attribute on a method that returns a TestCaseData object. The TestCaseData object can be constructed with the expected result as a parameter. [TestFixture] public class MyTests { [TestCaseSource(typeof(MyDataClass), nameof(MyDataClass.TestCases))] public int DivideTest(int n, int d) { return n / d; } } public class MyDataClass { public static IEnumerable TestCases { get { yield return new TestCaseData(12, 3).Returns(4); yield return new TestCaseData(12, 2).Returns(6); yield return new TestCaseData(12, 4).Returns(3); } } } See TestCaseData for more information on the TestCaseData class. Sources for generic methods using TestCaseData As of NUnit 4.1, it is possible to explicitly specify the generic types to be used for a generic method. This may be useful when any of the test case arguments differ from the desired generic types. When omitted, NUnit will infer the generic type arguments based on the passed values from the TestCaseSource. [TestFixture] public class MyExplicitlyTypedTests { [TestCaseSource(nameof(ExplicitTypeArgsTestCases))] public void ExplicitTypeArgs<T>(T input) { Assert.That(typeof(T), Is.EqualTo(typeof(long))); } private static IEnumerable<TestCaseData> ExplicitTypeArgsTestCases() { yield return new TestCaseData(2) { TypeArgs = new[] { typeof(long) } }; yield return new TestCaseData(2L) { TypeArgs = new[] { typeof(long) } }; } } See TestCaseData for more information on the TestCaseData class. Examples using TestCaseSource with Typed data and expected results It may seem from the examples above that TestCaseSource can only be used with simple data types or the base Object type. This is not the case. TestCaseSource can be used with typed data and also including expected results, also without using TestCaseData. In the example below the test method takes a single argument of a an anonymous tuple type with Person and an expected value of type bool. It can of course be any type, if that makes sense for the test. The TestCaseSource method returns an IEnumerable<> of the anonymous tuple type. public class TypedValuesWithExpectedAsAnonymousTuple { [TestCaseSource(nameof(TestCases))] public void TestOfPersonAge((Person P, bool Expected) td) { var res = td.P.IsOldEnoughToBuyAlcohol(); Assert.That(res, Is.EqualTo(td.Expected)); } public static IEnumerable<(Person, bool)> TestCases() { yield return (new Person { Name = \"John\", Age = 10 }, false); yield return (new Person { Name = \"Jane\", Age = 30 }, true); } } public class Person { public string Name { get; set; } = \"\"; public int Age { get; set; } public bool IsOldEnoughToBuyAlcohol() { return Age >= 18; } } It is also possible to use a generic wrapper (or any custom wrapper) for the testcase data and the expected result, as shown in the example below. public class TypedValuesWithExpectedInWrapperClass { [TestCaseSource(nameof(TestCases))] public void TestOfPersonAge(TestDataWrapper<Person, bool> td) { var res = td.Value?.IsOldEnoughToBuyAlcohol(); Assert.That(res, Is.EqualTo(td.Expected)); } public static IEnumerable<TestDataWrapper<Person, bool>> TestCases() { yield return new TestDataWrapper<Person, bool> { Value = new Person { Name = \"John\", Age = 10 }, Expected = false }; yield return new TestDataWrapper<Person, bool> { Value = new Person { Name = \"Jane\", Age = 30 }, Expected = true }; } } public class TestDataWrapper<T, TExp> { public T? Value { get; set; } public TExp? Expected { get; set; } } Named Parameters TestCaseSourceAttribute supports one named parameter: Category is used to assign one or more categories to every test case returned from this source. Test Case Construction In constructing tests, NUnit uses each item returned by the enumerator as follows: If it is an object derived from the TestCaseParameters class, its properties are used to provide the test case. NUnit provides the TestCaseData type for this purpose. If the test has a single argument and the returned value matches the type of that argument it is used directly. This can eliminate a bit of extra typing by the programmer, as in this example: private static int[] _evenNumbers = { 2, 4, 6, 8 }; [Test, TestCaseSource(nameof(_evenNumbers))] public void TestMethod(int num) { Assert.That(num % 2, Is.Zero); } If it is an object[], its members are used to provide the arguments for the method. This is the approach taken in the three first examples above. If it is an array of some other type, NUnit can use it provided that the arguments to the method are all of that type. For example, the above examples could be modified to make the three nested arrays of type int[]. If anything else is returned, it is used directly as the sole argument to the method. Because every returned value is used, NUnit is able to give an error message in cases where the method requires a different number of arguments or an argument of a different type. Notes It is recommended that the SourceType not be the same as the test fixture class. It may be a nested class, however, and probably should be if the data is only used within that fixture. A generic IEnumerable and IEnumerator may be used but NUnit will actually deal with the underlying IEnumerator in the current release. The GetEnumerator method may use yield statements or simply return the enumerator for an array or other collection held by the class. Order of Execution Individual test cases are executed in the order in which NUnit discovers them. This order does not follow the lexical order of the attributes and will often vary between different compilers or different versions of the CLR. As a result, when TestCaseSourceAttribute appears multiple times on a method or when other data-providing attributes are used in combination with TestCaseSourceAttribute, the order of the test cases is undefined. However, when a single TestCaseSourceAttribute is used by itself, the order of the tests follows exactly the order in which the test cases are returned from the source. Object Construction NUnit locates the test cases at the time the tests are loaded. It creates instances of each class used with the third form of the attribute and builds a list of tests to be executed. Each data source class is only created once at this time and is destroyed after all tests are loaded. By design, no communication is possible between the load and execution phases except through the tests that are created."
  },
  "articles/nunit/writing-tests/attributes/testfixture.html": {
    "href": "articles/nunit/writing-tests/attributes/testfixture.html",
    "title": "TestFixture | NUnit Docs",
    "summary": "TestFixture This is the attribute that marks a class that contains tests and, optionally, setup or teardown methods. Most restrictions on a class that is used as a test fixture have now been eliminated. A test fixture class: May be public, protected, private or internal. May be a static class. May be generic, so long as any type parameters are provided or can be inferred from the actual arguments. May not be abstract - although the attribute may be applied to an abstract class intended to serve as a base class for test fixtures. If no arguments are provided with the TestFixtureAttribute, the class must have a default constructor. If arguments are provided, they must match one of the constructors. If any of these restrictions are violated, the class is not runnable as a test and will display as an error. It is advisable that the constructor not have any side effects, since NUnit may construct the object multiple times in the course of a session. Beginning with NUnit 2.5, the TestFixture attribute is optional for non-parameterized, non-generic fixtures. So long as the class contains at least one method marked with the Test, TestCase or TestCaseSource attribute, it will be treated as a test fixture. Example namespace NUnit.Tests { using System; using NUnit.Framework; [TestFixture] public class SuccessTests { // ... } } Inheritance The TestFixtureAttribute may be applied to a base class and is inherited by any derived classes. This includes any abstract base class, so the well-known Abstract Fixture pattern may be implemented if desired. In order to facilitate use of generic and/or parameterized classes, where the derived class may require a different number of arguments (or type arguments) from the base class, superfluous TestFixture attributes are ignored, using the following rules: If all TestFixture attributes provide constructor or type arguments, then all of them are used. If some of the attributes provide arguments and others do not, then only those with arguments are used and those without arguments are ignored. If none of the attributes provide arguments, one of them is selected for use by NUnit. It is not possible to predict which will be used, so this situation should generally be avoided. This permits code like the following, which would cause an error if the attribute on the base class were not ignored. [TestFixture] public class AbstractFixtureBase { /* ... */ } [TestFixture(typeof(string))] public class DerivedFixture<T> : AbstractFixtureBase { /* ... */ } Parameterized Test Fixtures Test fixtures may take constructor arguments. Argument values are specified as arguments to the TestFixture attribute. NUnit will construct a separate instance of the fixture for each set of arguments. Individual fixture instances in a set of parameterized fixtures may be ignored. Set the Ignore named parameter of the reason for ignoring the instance. Individual fixture instances may be given categories as well. Set the Category named parameter of the attribute to the name of the category or to a comma-separated list of categories. Example The following test fixture would be instantiated by NUnit five times, passing in each set of arguments to the appropriate constructor. Note that there are four different constructors, matching the data types provided as arguments, and the params keyword can be used to allow passing different numbers of arguments. [TestFixture(\"hello\", \"hello\", \"goodbye\")] [TestFixture(\"zip\", \"zip\")] [TestFixture(42, 42, 99)] [TestFixture('a', 'a', 'b')] [TestFixture('A', 'A')] public class ParameterizedTestFixture { private readonly string _eq1; private readonly string _eq2; private readonly string? _neq; public ParameterizedTestFixture(string eq1, string eq2, string neq) { _eq1 = eq1; _eq2 = eq2; _neq = neq; } public ParameterizedTestFixture(string eq1, string eq2) : this(eq1, eq2, null) { } public ParameterizedTestFixture(int eq1, int eq2, int neq) { _eq1 = eq1.ToString(); _eq2 = eq2.ToString(); _neq = neq.ToString(); } // Can use params arguments (but not yet optional arguments) public ParameterizedTestFixture(params char[] eqArguments) { _eq1 = eqArguments[0].ToString(); _eq2 = eqArguments[1].ToString(); if (eqArguments.Length > 2) _neq = eqArguments[2].ToString(); else _neq = null; } [Test] public void TestEquality() { Assert.That(_eq2, Is.EqualTo(_eq1)); Assert.That(_eq2.GetHashCode(), Is.EqualTo(_eq1.GetHashCode())); } [Test] public void TestInequality() { Assert.That(_neq, Is.Not.EqualTo(_eq1)); if (_neq != null) { Assert.That(_neq.GetHashCode(), Is.Not.EqualTo(_eq1.GetHashCode())); } } } Generic Test Fixtures You may also use a generic class as a test fixture. In order for NUnit to instantiate the fixture, you must either specify the types to be used as arguments to TestFixtureAttribute or use the named parameter TypeArgs= to specify them. NUnit will construct a separate instance of the fixture for each TestFixtureAttribute you provide. Example The following test fixture would be instantiated by NUnit twice, once using an ArrayList and once using a List<int>. [TestFixture(typeof(ArrayList))] [TestFixture(typeof(List<int>))] public class GenericListTests<TList> where TList : IList, new() { private IList _list = null!; [SetUp] public void CreateList() { _list = new TList(); } [Test] public void CanAddToList() { _list.Add(1); _list.Add(2); _list.Add(3); Assert.That(_list, Has.Count.EqualTo(3)); } } Generic Test Fixtures with Parameters If a Generic fixture, uses constructor arguments, there are three approaches to telling NUnit which arguments are type parameters and which are normal constructor parameters. Specify both sets of parameters as arguments to the TestFixtureAttribute. Leading System.Type arguments are used as type parameters, while any remaining arguments are used to construct the instance. In the following example, this leads to some obvious duplication... [TestFixture(typeof(double), typeof(int), 100.0, 42)] [TestFixture(typeof(int), typeof(double), 42, 100.0)] public class SpecifyBothSetsOfArgs<T1, T2> where T1 : notnull where T2 : notnull { private readonly T1 _t1; private readonly T2 _t2; public SpecifyBothSetsOfArgs(T1 t1, T2 t2) { _t1 = t1; _t2 = t2; } [TestCase(5, 7)] public void TestMyArgTypes(T1 t1, T2 t2) { Assert.That(t1, Is.TypeOf<T1>()); Assert.That(t1, Is.LessThan(_t1)); Assert.That(t2, Is.TypeOf<T2>()); Assert.That(t2, Is.LessThan(_t2)); } } Specify normal parameters as arguments to TestFixtureAttribute and use the named parameter TypeArgs= to specify the type arguments. Again, for this example, the type info is duplicated, but it is at least more cleanly separated from the normal arguments... [TestFixture(100.0, 42, TypeArgs = new[] { typeof(double), typeof(int) })] [TestFixture(42, 100.0, TypeArgs = new[] { typeof(int), typeof(double) })] public class SpecifyTypeArgsSeparately<T1, T2> where T1 : notnull where T2 : notnull { private readonly T1 _t1; private readonly T2 _t2; public SpecifyTypeArgsSeparately(T1 t1, T2 t2) { _t1 = t1; _t2 = t2; } [TestCase(5, 7)] public void TestMyArgTypes(T1 t1, T2 t2) { Assert.That(t1, Is.TypeOf<T1>()); Assert.That(t1, Is.LessThan(_t1)); Assert.That(t2, Is.TypeOf<T2>()); Assert.That(t2, Is.LessThan(_t2)); } } In some cases, when the constructor makes use of all the type parameters NUnit may simply be able to deduce them from the arguments provided. That's the case here and the following is the preferred way to write this example... [TestFixture(100.0, 42)] [TestFixture(42, 100.0)] public class DeduceTypeArgsFromArgs<T1, T2> where T1 : notnull where T2 : notnull { private readonly T1 _t1; private readonly T2 _t2; public DeduceTypeArgsFromArgs(T1 t1, T2 t2) { _t1 = t1; _t2 = t2; } [TestCase(5, 7)] public void TestMyArgTypes(T1 t1, T2 t2) { Assert.That(t1, Is.TypeOf<T1>()); Assert.That(t1, Is.LessThan(_t1)); Assert.That(t2, Is.TypeOf<T2>()); Assert.That(t2, Is.LessThan(_t2)); } }"
  },
  "articles/nunit/writing-tests/attributes/testfixturesetup.html": {
    "href": "articles/nunit/writing-tests/attributes/testfixturesetup.html",
    "title": "TestFixtureSetUp | NUnit Docs",
    "summary": "TestFixtureSetUp Important The TestFixtureSetUp attribute has been deprecated. Use OneTimeSetUp Attribute instead."
  },
  "articles/nunit/writing-tests/attributes/testfixturesource.html": {
    "href": "articles/nunit/writing-tests/attributes/testfixturesource.html",
    "title": "TestFixtureSource | NUnit Docs",
    "summary": "TestFixtureSource TestFixtureSourceAttribute is used on a parameterized fixture to identify the source from which the required constructor arguments will be provided. The data is kept separate from the fixture itself and may be used by multiple fixtures. See Parameterized Tests for a general introduction to tests with arguments. Usage Consider a test fixture class taking two parameters in its constructor, a string and an int. We can specify the test and its data using one of the forms of TestFixtureSourceAttribute: Form 1 - [TestFixtureSource(string sourceName)] [TestFixtureSource(nameof(FixtureArgs))] public class MyTestClass { public MyTestClass(string word, int num) { ... } /* ... */ static object [] FixtureArgs = { new object[] { \"Question\", 1 }, new object[] { \"Answer\", 42 } }; } The single attribute argument in this form is a string representing the name of the source used to provide arguments for constructing the TestFixture. It has the following characteristics: It may be a field, property or method in the test class. It must be static. It must return an IEnumerable or a type that implements IEnumerable. For fields an array is generally used. For properties and methods, you may return an array or implement your own iterator. Methods may also return an IAsyncEnumerable or a type that implements IAsyncEnumerable. (NUnit 4+) Methods may be async by wrapping the return type in a Task<T>. (NUnit 3.14+) The individual items returned by the enumerator must either be object arrays or derive from the TestFixtureParameters class. Arguments must be consistent with the fixture constructor. Form 2 - [TestFixtureSource(Type sourceType, string sourceName)] [TestFixtureSource(typeof(AnotherClass), nameof(AnotherClass.FixtureArgs)] public class MyTestClass { public MyTestClass(string word, int num) { ... } ... } class AnotherClass { static object [] FixtureArgs = { new object[] { \"Question\", 1 }, new object[] { \"Answer\", 42 } }; } The first argument of the attribute in this form is a Type representing the class that will provide the test fixture data. The second argument is a string representing the name of the source used to provide test fixtures. It has the following characteristics: It may be a field, property or method in the test class. It must be static. It must return an IEnumerable or a type that implements IEnumerable. For fields an array is generally used. For properties and methods, you may return an array or implement your own iterator. Methods may also return an IAsyncEnumerable or a type that implements IAsyncEnumerable. (NUnit 4+) Methods may be async by wrapping the return type in a Task<T>. (NUnit 3.14+) The individual items returned by the enumerator must either be object arrays or derive from the TestFixtureParameters class. Arguments must be consistent with the fixture constructor. Form 3 - [TestFixtureSource(Type sourceType)] [TestFixtureSource(typeof(FixtureArgs))] public class MyTestClass { public MyTestClass(string word, int num) { /* ... */ } /* ... */ } class FixtureArgs: IEnumerable { public IEnumerator GetEnumerator() { yield return new object[] { \"Question\", 1 }; yield return new object[] { \"Answer\", 42 }; } } The Type argument in this form represents the class that provides test cases. It must have a default constructor and implement IEnumerable. The individual items returned by the enumerator must either be object arrays or derive from the TestFixtureParameters class. Arguments must be consistent with the fixture constructor. Named Parameters TestCaseSourceAttribute supports one named parameter: Category is used to assign one or more categories to every test case returned from this source. Test Case Construction In constructing tests, NUnit uses each item returned by the enumerator as follows: If it is an object deriving from TestFixtureParameters, its properties are used to provide the test case. NUnit provides the TestFixtureData class for this purpose. If it is an object[], its members are used to provide the arguments for the method. This is the approach taken in the examples above. Notes It is recommended that the SourceType not be the same as the test fixture class. It may be a nested class, however, and probably should be if the data is only used within that fixture. A generic IEnumerable and IEnumerator may be used but NUnit will actually deal with the underlying IEnumerator in the current release. The GetEnumerator method may use yield statements or simply return the enumerator for an array or other collection held by the class."
  },
  "articles/nunit/writing-tests/attributes/testfixtureteardown.html": {
    "href": "articles/nunit/writing-tests/attributes/testfixtureteardown.html",
    "title": "TestFixtureTearDown | NUnit Docs",
    "summary": "TestFixtureTearDown Important The TextFixtureTearDown attribute has been deprecated. Use OneTimeTearDown Attribute instead."
  },
  "articles/nunit/writing-tests/attributes/testof.html": {
    "href": "articles/nunit/writing-tests/attributes/testof.html",
    "title": "TestOf | NUnit Docs",
    "summary": "TestOf The TestOf attribute adds information about the class that is being tested. It can be applied to test fixtures and to tests. The constructor takes the string name or the type of the class being tested. TestOf can also be specified on a TestFixture or Test attribute. [TestFixture] [TestOf(typeof(MyClass))] public class MyTests { [Test] public void Test1() { /* ... */ } [Test] [TestOf(nameof(MySubClass))] public void Test2() { /* ... */ } } [TestFixture(TestOf = typeof(MyClass))] public class MyOtherTests { [Test] public void Test1() { /* ... */ } [Test(TestOf = typeof(MySubClass))] public void Test2() { /* ... */ } } Note You can currently only have one TestOf attribute per fixture or test."
  },
  "articles/nunit/writing-tests/attributes/theory.html": {
    "href": "articles/nunit/writing-tests/attributes/theory.html",
    "title": "Theory | NUnit Docs",
    "summary": "Theory A Theory is a special type of test, used to verify a general statement about the system under development. Normal tests are example-based. That is, the developer supplies one or more examples of inputs and expected outputs either within the code of the test or - in the case of Parameterized Tests - as arguments to the test method. A theory, on the other hand, makes a general statement that all of its assertions will pass for all arguments satisfying certain assumptions. Theories are implemented in NUnit as non-generic methods within a TestFixture, which are annotated with the TheoryAttribute. Theory methods must always have arguments and therefore appears quite similar to Parameterized Tests at first glance. However, a Theory incorporates additional data sources for its arguments and allows special processing for assumptions about that data. The key difference, though, is that theories make general statements and are more than just a set of examples. Data for Theories The primary source of data for a Theory is the Datapoint Attribute or DatapointSource Attribute. NUnit will use any class members of the required types, which are annotated with one of these attributes, to provide data for each parameter of the Theory. NUnit assembles the values for individual arguments combinatorially to provide test cases for the theory. In addition to the Datapoint and Datapoints attributes, it is possible to use any of the approaches for supplying data that are recognized on normal parameterized tests. We suggest that this capability not be overused, since it runs counter to the distinction between a test based on examples and a theory. However, it may be useful in order to guarantee that a specific test case is included. For boolean and enum arguments, NUnit can supply the data without any action by the user. All possible values are supplied to the argument. This feature is disabled if the user supplies any values for the argument. Note Because NUnit searches for datapoints based on the type of the argument, generic methods may not currently be used as theories. This limitation may be removed in a future release. See below for a workaround using a generic fixture. Assumptions The theory itself is responsible for ensuring that all data supplied meets its assumptions. It does this by use of the Assume.That(...) construct, which works just like Assert.That(...) but does not cause a failure. If the assumption is not satisfied for a particular test case, that case returns an Inconclusive result, rather than a Success or Failure. The overall result of executing a Theory over a set of test cases is determined as follows: If the assumptions are violated for all test cases, then the Theory itself is marked as a failure. If any Assertion fails, the Theory itself fails. If at least some cases pass the stated assumptions, and there are no assertion failures or exceptions, then the Theory passes. Since the user does not generally care about inconclusive cases under a theory, they are not normally displayed in the Gui. For situations where they are needed - such as debugging - the context menu for the theory provides an option to display them. Example In the following example, the Theory SquareRootDefinition verifies that the implementation of square root satisfies the following definition: Given a non-negative number, the square root of that number is always non-negative and, when multiplied by itself, gives the original number. public class SqrtTests { [DatapointSource] public double[] values = new double[] { 0.0, 1.0, -1.0, 42.0 }; [Theory] public void SquareRootDefinition(double num) { Assume.That(num >= 0.0); double sqrt = Math.Sqrt(num); Assert.That(sqrt >= 0.0); Assert.That(sqrt * sqrt, Is.EqualTo(num).Within(0.000001)); } } Theories in Generic Fixtures In a generic fixture with Type parameter T individual methods using T as a parameter type are not generic, since T has been resolved to an actual Type in instantiating the fixture instance. You may use such methods as theories and any data of the appropriate type will be used. [TestFixture(typeof(int))] [TestFixture(typeof(double))] public class TheorySampleTestsGeneric<T> { [Datapoint] public double[] ArrayDouble1 = { 1.2, 3.4 }; [Datapoint] public double[] ArrayDouble2 = { 5.6, 7.8 }; [Datapoint] public int[] ArrayInt = { 0, 1, 2, 3 }; [Theory] public void TestGenericForArbitraryArray(T[] array) { Assert.That(array.Length, Is.EqualTo(4)); } } See also Datapoint Attribute DatapointSource Attribute Parameterized Tests"
  },
  "articles/nunit/writing-tests/attributes/timeout.html": {
    "href": "articles/nunit/writing-tests/attributes/timeout.html",
    "title": "Timeout | NUnit Docs",
    "summary": "Timeout Note From version 3.12 this is also available in the .NET Standard 2.0 builds of the framework. Normally, NUnit simply runs tests and waits for them to terminate -- the test is allowed to run indefinitely. For certain kinds of tests, however, it may be desirable to specify a timeout value. The TimeoutAttribute is used to specify a timeout value in milliseconds for a test case. If the test case runs longer than the time specified it is immediately cancelled and reported as a failure, with a message indicating that the timeout was exceeded. The specified timeout value covers the test setup and teardown as well as the test method itself. Before and after actions may also be included, depending on where they were specified. Since the timeout may occur during any of these execution phases, no guarantees can be made as to what will be run and any of these phases of execution may be incomplete. If only used on a test, once a test has timed out, its teardown methods are executed. The attribute may also be specified on a fixture or assembly, in which case it indicates the default timeout for any subordinate test cases. When using the console runner, it is also possible to specify a default timeout on the command-line. Example [Test, Timeout(2000)] public void PotentiallyLongRunningTest() { /* ... */ } Note When debugging a unit test, i.e. when a debugger is attached to the process, then the timeout is not enforced. See Also MaxTime Attribute CancelAfter Attribute"
  },
  "articles/nunit/writing-tests/attributes/values.html": {
    "href": "articles/nunit/writing-tests/attributes/values.html",
    "title": "Values | NUnit Docs",
    "summary": "Values The ValuesAttribute is used to specify a set of values to be provided for an individual parameter of a parameterized test method. Since NUnit combines the data provided for each parameter into a set of test cases, data must be provided for all parameters if it is provided for any of them. By default, NUnit creates test cases from all possible combinations of the data values provided on parameters - the combinatorial approach. This default may be modified by use of specific attributes on the test method itself. Example [Test] public void ValuesAttribute_BasicExample([Values(1, 2, 3)] int x, [Values(\"A\", \"B\")] string s) { Assert.That(x, Is.GreaterThan(0)); Assert.That(s, Is.Not.Null); } The above test will be executed six times, as follows: MyTest(1, \"A\") MyTest(1, \"B\") MyTest(2, \"A\") MyTest(2, \"B\") MyTest(3, \"A\") MyTest(3, \"B\") Values with Enum or Boolean The values attribute works in a special way with Enums and Boolean parameters. When used without any arguments, the [Values] attribute on an enum parameter will automatically include all possible values of the enumeration. public enum MyEnumType { Value1, Value2, Value3 } [Test] public void ValuesAttribute_EnumExample([Values] MyEnumType myEnumArgument) { Assert.That(myEnumArgument, Is.TypeOf<MyEnumType>()); } There is the same support for Boolean values. Add the [Values] attribute to a bool and the method will be run with true and false. [Test] public void ValuesAttribute_BoolExample([Values] bool value) { // This test will run twice: once with true, once with false Assert.That(value is true or false); } See also Range Attribute Random Attribute Sequential Attribute Combinatorial Attribute Pairwise Attribute"
  },
  "articles/nunit/writing-tests/attributes/valuesource.html": {
    "href": "articles/nunit/writing-tests/attributes/valuesource.html",
    "title": "ValueSource | NUnit Docs",
    "summary": "ValueSource ValueSourceAttribute is used on individual parameters of a test method to identify a named source for the argument values to be supplied. The attribute has two public constructors. ValueSourceAttribute(Type sourceType, string sourceName); ValueSourceAttribute(string sourceName); If sourceType is specified, it represents the class that provides the data. If sourceType is not specified, the class containing the test method is used. The sourceName, represents the name of the source that will provide the arguments. It should have the following characteristics: It may be a field, a non-indexed property or a method taking no arguments. It must be a static member. It must return an IEnumerable or a type that implements IEnumerable. Methods may also return an IAsyncEnumerable or a type that implements IAsyncEnumerable. (NUnit 4+) Methods may be async by wrapping the return type in a Task<T>. (NUnit 3.14+) The individual items returned from the enumerator must be compatible with the type of the parameter on which the attribute appears. Order of Execution Individual test cases are executed in the order in which NUnit discovers them. This order does not follow the lexical order of the attributes and will often vary between different compilers or different versions of the CLR. As a result, when ValueSourceAttribute appears multiple times on a parameter or when other data-providing attributes are used in combination with ValueSourceAttribute, the order of the arguments is undefined. However, when a single ValueSourceAttribute is used by itself, the order of the arguments follows exactly the order in which the data is returned from the source. Note on Object Construction NUnit locates the test cases at the time the tests are loaded, creates instances of each class with non-static sources and builds a list of tests to be executed. Each source object is only created once at this time and is destroyed after all tests are loaded. If the data source is in the test fixture itself, the object is created using the appropriate constructor for the fixture parameters provided on the TestFixtureAttribute, or the default constructor if no parameters were specified. Since this object is destroyed before the tests are run, no communication is possible between these two phases - or between different runs - except through the parameters themselves."
  },
  "articles/nunit/writing-tests/constraints/AllItemsConstraint.html": {
    "href": "articles/nunit/writing-tests/constraints/AllItemsConstraint.html",
    "title": "AllItems Constraint | NUnit Docs",
    "summary": "AllItems Constraint AllItemsConstraint applies a constraint to each item in an IEnumerable, succeeding only if all of them succeed. An exception is thrown if the actual value passed does not implement IEnumerable. Constructor AllItemsConstraint(Constraint itemConstraint) Syntax Is.All... Has.All... Examples of Use int[] iarray = new int[] { 1, 2, 3 }; string[] sarray = new string[] { \"a\", \"b\", \"c\" }; Assert.That(iarray, Is.All.Not.Null); Assert.That(sarray, Is.All.InstanceOf<string>()); Assert.That(iarray, Is.All.GreaterThan(0)); Assert.That(iarray, Has.All.GreaterThan(0));"
  },
  "articles/nunit/writing-tests/constraints/AndConstraint.html": {
    "href": "articles/nunit/writing-tests/constraints/AndConstraint.html",
    "title": "And Constraint | NUnit Docs",
    "summary": "And Constraint AndConstraint combines two other constraints and succeeds only if they both succeed. Constructor AndConstraint(Constraint left, Constraint right) Syntax <Constraint>.And.<Constraint> Examples of Use [Test] public void AndConstraint_Examples() { Assert.That(2.3, Is.GreaterThan(2.0).And.LessThan(3.0)); int? i = 10; Assert.That(i, Is.Not.Null.And.GreaterThan(9)); } Evaluation Order and Precedence Note that the constraint evaluates the sub-constraints left to right, meaning that Assert.That(i, Is.Not.Null.And.GreaterThan(9)); where i is a nullable int will work for 10, but fail for null with the message Expected: not null and greater than 9. But was: null. Assert.That(i, Is.GreaterThan(9).And.Not.Null); will also succeed for 10, but throw an exception for null, as null cannot be compared to 9. The OrConstraint has precedence over the AndConstraint. See also OrConstraint"
  },
  "articles/nunit/writing-tests/constraints/AnyOfConstraint.html": {
    "href": "articles/nunit/writing-tests/constraints/AnyOfConstraint.html",
    "title": "AnyOf Constraint | NUnit Docs",
    "summary": "AnyOf Constraint AnyOfConstraint is used to determine whether a value is equal to any of the expected values. Note Values provided must be as parameters to the method, not as e.g. a separate array. If you are instead looking to see if a collection contains a value, see the CollectionContains Constraint. Constructor AnyOfConstraint(object[] expected) Syntax Is.AnyOf(object[] expected) Modifiers ...IgnoreCase ...IgnoreWhiteSpace // From version 4.2 ...Using(IEqualityComparer comparer) ...Using(IComparer comparer) ...Using<T>(IEqualityComparer<T> comparer) ...Using<T>(IComparer<T> comparer) ...Using<T>(Comparison<T> comparer) ...Using<T>(Func<T, T, bool> comparer) ...UsingPropertiesComparer() // From version 4.1 ...UsingPropertiesComparer( Func<PropertiesComparerConfiguration, PropertiesComparerConfiguration> configure) // From version 4.4 Examples of Use Assert.That(42, Is.AnyOf(0, -1, 42, 100)); // You can use a custom comparer as well Assert.That(myOwnObject, Is.AnyOf(myArray).Using(myComparer));"
  },
  "articles/nunit/writing-tests/constraints/AssignableFromConstraint.html": {
    "href": "articles/nunit/writing-tests/constraints/AssignableFromConstraint.html",
    "title": "AssignableFrom Constraint | NUnit Docs",
    "summary": "AssignableFrom Constraint AssignableFromConstraint tests that one type is assignable from another Constructor AssignableFromConstraint(Type) Syntax Is.AssignableFrom(Type) Is.AssignableFrom<T>() Examples of Use Assert.That(\"Hello\", Is.AssignableFrom(typeof(string))); Assert.That(5, Is.Not.AssignableFrom(typeof(string)));"
  },
  "articles/nunit/writing-tests/constraints/AssignableToConstraint.html": {
    "href": "articles/nunit/writing-tests/constraints/AssignableToConstraint.html",
    "title": "AssignableTo Constraint | NUnit Docs",
    "summary": "AssignableTo Constraint AssignableToConstraint tests that one type is assignable to another Constructor AssignableToConstraint(Type) Syntax Is.AssignableTo(Type) Is.AssignableTo<T>() Examples of Use Assert.That(\"Hello\", Is.AssignableTo(typeof(object))); Assert.That(5, Is.Not.AssignableTo(typeof(string)));"
  },
  "articles/nunit/writing-tests/constraints/AttributeConstraint.html": {
    "href": "articles/nunit/writing-tests/constraints/AttributeConstraint.html",
    "title": "Attribute Constraint | NUnit Docs",
    "summary": "Attribute Constraint AttributeConstraint tests for the existence of an attribute on a Type and then applies a constraint to that attribute. Constructor AttributeConstraint(Type type, IConstraint baseConstraint) Syntax Has.Attribute(typeof(TestFixtureAttribute))... Has.Attribute<TestFixtureAttribute>()... Examples of Use Assert.That(someObject, Has.Attribute(typeof(TestFixtureAttribute)) .Property(\"Description\").EqualTo(\"My description\")); Assert.That(someObject, Has.Attribute<TestFixtureAttribute>() .Property(\"Description\").EqualTo(\"My description\")); See also AttributeExistsConstraint"
  },
  "articles/nunit/writing-tests/constraints/AttributeExistsConstraint.html": {
    "href": "articles/nunit/writing-tests/constraints/AttributeExistsConstraint.html",
    "title": "AttributeExists Constraint | NUnit Docs",
    "summary": "AttributeExists Constraint AttributeExistsConstraint tests for the existence of an attribute on a Type. Constructor AttributeExistsConstraint(Type type) Syntax Has.Attribute(typeof(TestFixtureAttribute)) Has.Attribute<TestFixtureAttribute>() Examples of Use Assert.That(someObject, Has.Attribute(typeof(TestFixtureAttribute))); Assert.That(someObject, Has.Attribute<TestFixtureAttribute>());"
  },
  "articles/nunit/writing-tests/constraints/BinarySerializableConstraint.html": {
    "href": "articles/nunit/writing-tests/constraints/BinarySerializableConstraint.html",
    "title": "BinarySerializable Constraint | NUnit Docs",
    "summary": "BinarySerializable Constraint BinarySerializableConstraint tests whether an object is serializable in binary format. Constructor BinarySerializableConstraint() Syntax Is.BinarySerializable Examples of Use Assert.That(someObject, Is.BinarySerializable)); See also XmlSerializableConstraint Warning Binary Serialization is no longer supported in .NET 8 due to security concerns. From NUnit 4.x onward, this constraint is not available. More information can be found in these Microsoft Learn articles on BinaryFormatter's removal and on the BinaryFormatter security guide"
  },
  "articles/nunit/writing-tests/constraints/CollectionContainsConstraint.html": {
    "href": "articles/nunit/writing-tests/constraints/CollectionContainsConstraint.html",
    "title": "CollectionContains Constraint | NUnit Docs",
    "summary": "CollectionContains Constraint CollectionContainsConstraint tests that an IEnumerable contains an object. If the actual value passed does not implement IEnumerable, an exception is thrown. Constructor CollectionContainsConstraint(object) Syntax Has.Member(object) Contains.Item(object) Does.Contain(object) Modifiers ...Using(IComparer comparer) ...Using<T>(IComparer<T> comparer) ...Using<T>(Comparison<T> comparer) Examples of Use [Test] public void CollectionContains_Examples() { int[] intArray = [1, 2, 3]; string[] stringArray = [\"a\", \"b\", \"c\"]; Assert.That(intArray, Has.Member(3)); Assert.That(stringArray, Has.Member(\"b\")); Assert.That(stringArray, Contains.Item(\"c\")); Assert.That(stringArray, Has.No.Member(\"x\")); Assert.That(intArray, Does.Contain(3)); } Note Has.Member(), Contains.Item() and Does.Contain() work the same as Has.Some.EqualTo(). The last statement generates a SomeItemsConstraint based on an EqualConstraint and offers additional options such as ignoring case or specifying a tolerance. The syntax on this page may be viewed as a shortcut for specifying simpler cases."
  },
  "articles/nunit/writing-tests/constraints/CollectionEquivalentConstraint.html": {
    "href": "articles/nunit/writing-tests/constraints/CollectionEquivalentConstraint.html",
    "title": "CollectionEquivalent Constraint | NUnit Docs",
    "summary": "CollectionEquivalent Constraint CollectionEquivalentConstraint tests that two IEnumerables are equivalent - that they contain the same items, in any order. If the actual value passed does not implement IEnumerable an exception is thrown. Constructor CollectionEquivalentConstraint(IEnumerable other) Syntax Is.EquivalentTo(IEnumerable other) Modifiers ...IgnoreCase ...IgnoreWhiteSpace // From version 4.2 ...Using(IEqualityComparer comparer) ...Using(IComparer comparer) ...Using<T>(IEqualityComparer<T> comparer) ...Using<T>(IComparer<T> comparer) ...Using<T>(Comparison<T> comparer) ...Using<T>(Func<T, T, bool> comparer) ...Using<TActualElement, TExpectedElement>(Func<TActualElement, TExpectedElement, bool> comparison) ...UsingPropertiesComparer() // From version 4.1 ...UsingPropertiesComparer( Func<PropertiesComparerConfiguration, PropertiesComparerConfiguration> configure) // From version 4.4 Examples of Use int[] iarray = new int[] { 1, 2, 3 }; string[] sarray = new string[] { \"a\", \"b\", \"c\" }; Assert.That(new string[] { \"c\", \"a\", \"b\" }, Is.EquivalentTo(sarray)); Assert.That(new int[] { 1, 2, 2 }, Is.Not.EquivalentTo(iarray)); Notes To compare items in order, use Is.EqualTo()."
  },
  "articles/nunit/writing-tests/constraints/CollectionOrderedConstraint.html": {
    "href": "articles/nunit/writing-tests/constraints/CollectionOrderedConstraint.html",
    "title": "CollectionOrdered Constraint | NUnit Docs",
    "summary": "CollectionOrdered Constraint CollectionOrderedConstraint tests that an IEnumerable is ordered. If the actual value passed does not implement IEnumerable, an exception is thrown. The constraint supports both simple and property-based ordering (Ordered.By). Simple Ordering Simple ordering is based on the values of the items themselves. It is implied when the By modifier is not used. int[] iarray = new int[] { 1, 2, 3 }; Assert.That(iarray, Is.Ordered); string[] sarray = new string[] { \"c\", \"b\", \"a\" }; Assert.That(sarray, Is.Ordered.Descending); Ordering Modifiers ...Ascending ...Descending ...Using(IComparer comparer) ...Using<T>(IComparer<T> comparer) ...Using<T>(Comparison<T> comparer) By default, the order is expected to be ascending. Property-Based Ordering Property-based ordering uses one or more properties that are common to every item in the enumeration. It is used when one or more instances of the By modifier appears in the ordering expression. string[] sarray = new string[] (\"a\", \"aa\", \"aaa\"); Assert.That(sarray, Is.Ordered.By(\"Length\")); string[] sarray2 = new string[] (\"aaa\", \"aa\", \"a\"); Assert.That(sarray2, Is.Ordered.Descending.By(\"Length\")); Property-based Modifiers ...Then ...Ascending ...Descending ...By(string propertyName) ...Using(IComparer comparer) ...Using<T>(IComparer<T> comparer) ...Using<T>(Comparison<T> comparer) Ordering on Multiple Properties An ordering expression may use multiple By modifiers, each referring to a different property. The following examples assume a collection of items with properties named A and B. Assert.That(collection, Is.Ordered.By(\"A\").Then.By(\"B\")); Assert.That(collection, Is.Ordered.By(\"A\").Then.By(\"B\").Descending); Assert.That(collection, Is.Ordered.Ascending.By(\"A\").Then.Descending.By(\"B\")); Assert.That(collection, Is.Ordered.Ascending.By(\"A\").By(\"B\").Descending); Assert.That(collection, Is.Ordered.Ascending.By(\"A\").Descending.By(\"B\")); // Illegal! Notes The Then modifier divides the expression into ordering steps. Each step may optionally contain one Ascending or Descending modifier and one Using modifier. If Then is not used, each new By modifier marks the beginning of a step. The last example statement is illegal because the first group contains both Ascending and Descending. Use of Then is recommended for clarity."
  },
  "articles/nunit/writing-tests/constraints/CollectionSubsetConstraint.html": {
    "href": "articles/nunit/writing-tests/constraints/CollectionSubsetConstraint.html",
    "title": "CollectionSubset Constraint | NUnit Docs",
    "summary": "CollectionSubset Constraint CollectionSubsetConstraint tests that one IEnumerable is a subset of another. If the actual value passed does not implement IEnumerable, an exception is thrown. Constructor CollectionSubsetConstraint(IEnumerable) Syntax Is.SubsetOf(IEnumerable) Modifiers ...Using(IEqualityComparer comparer) ...Using(IComparer comparer) ...Using<T>(IEqualityComparer<T> comparer) ...Using<T>(IComparer<T> comparer) ...Using<T>(Comparison<T> comparer) ...Using<T>(Func<T, T, bool> comparer) ...Using<TSubsetElement, TSupersetElement>(Func<TSubsetElement, TSupersetElement, bool> comparison) ...UsingPropertiesComparer() // From version 4.1 ...UsingPropertiesComparer( Func<PropertiesComparerConfiguration, PropertiesComparerConfiguration> configure) // From version 4.4 Example of Use int[] iarray = new int[] { 1, 3 }; Assert.That(iarray, Is.SubsetOf(new int[] { 1, 2, 3 }));"
  },
  "articles/nunit/writing-tests/constraints/CollectionSupersetConstraint.html": {
    "href": "articles/nunit/writing-tests/constraints/CollectionSupersetConstraint.html",
    "title": "CollectionSuperset Constraint | NUnit Docs",
    "summary": "CollectionSuperset Constraint CollectionSupersetConstraint tests that one IEnumerable is a superset of another. If the actual value passed does not implement IEnumerable, an exception is thrown. Constructor CollectionSupersetConstraint(IEnumerable) Syntax Is.SupersetOf(IEnumerable) Modifiers ...Using(IEqualityComparer comparer) ...Using(IComparer comparer) ...Using<T>(IEqualityComparer<T> comparer) ...Using<T>(IComparer<T> comparer) ...Using<T>(Comparison<T> comparer) ...Using<T>(Func<T, T, bool> comparer) ...Using<TSupersetElement, TSubsetElement>(Func<TSupersetElement, TSubsetElement, bool> comparison) ...UsingPropertiesComparer() // From version 4.1 ...UsingPropertiesComparer( Func<PropertiesComparerConfiguration, PropertiesComparerConfiguration> configure) // From version 4.4 Example of Use int[] iarray = new int[] { 1, 2, 3 }; Assert.That(iarray, Is.SupersetOf(new int[] { 1, 3 }));"
  },
  "articles/nunit/writing-tests/constraints/Constraints.html": {
    "href": "articles/nunit/writing-tests/constraints/Constraints.html",
    "title": "Constraints | NUnit Docs",
    "summary": "Constraints This page lists all the constraints available in NUnit. Alphabetical List of Constraints Constraints by Category Alphabetical List of Constraints Constraint Name AllItemsConstraint AndConstraint AssignableFromConstraint AssignableToConstraint AttributeConstraint AttributeExistsConstraint AnyOfConstraint BinarySerializableConstraint CollectionContainsConstraint CollectionEquivalentConstraint CollectionOrderedConstraint CollectionSubsetConstraint CollectionSupersetConstraint DelayedConstraint DictionaryContainsKeyConstraint DictionaryContainsKeyValuePairConstraint DictionaryContainsValueConstraint EmptyCollectionConstraint EmptyConstraint EmptyDirectoryConstraint EmptyStringConstraint EndsWithConstraint EqualConstraint ExactCountConstraint ExactTypeConstraint FalseConstraint FileOrDirectoryExistsConstraint GreaterThanConstraint GreaterThanOrEqualConstraint InstanceOfTypeConstraint LessThanConstraint LessThanOrEqualConstraint NaNConstraint NoItemConstraint NotConstraint NullConstraint OrConstraint PropertyConstraint PropertyExistsConstraint RangeConstraint RegexConstraint ReusableConstraint SameAsConstraint SamePathConstraint SamePathOrUnderConstraint SomeItemsConstraint StartsWithConstraint SubPathConstraint SubstringConstraint ThrowsConstraint ThrowsNothingConstraint TrueConstraint UniqueItemsConstraint WhiteSpaceConstraint XmlSerializableConstraint Constraints by Category Collection Constraints Constraint Name AllItemsConstraint AnyOfConstraint CollectionContainsConstraint CollectionEquivalentConstraint CollectionOrderedConstraint CollectionSubsetConstraint CollectionSupersetConstraint DictionaryContainsKeyConstraint DictionaryContainsKeyValuePairConstraint DictionaryContainsValueConstraint EmptyCollectionConstraint ExactCountConstraint NoItemConstraint SomeItemsConstraint UniqueItemsConstraint Comparison Constraints Constraint Name GreaterThanConstraint GreaterThanOrEqualConstraint LessThanConstraint LessThanOrEqualConstraint RangeConstraint Compound Constraints Constraint Name AndConstraint NotConstraint OrConstraint Condition Constraints Constraint Name EmptyConstraint FalseConstraint NaNConstraint NullConstraint TrueConstraint WhiteSpaceConstraint File and Directory Constraints Constraint Name EmptyDirectoryConstraint FileOrDirectoryExistsConstraint SamePathConstraint SamePathOrUnderConstraint SubPathConstraint String Constraints Constraint Name EmptyStringConstraint EndsWithConstraint RegexConstraint StartsWithConstraint SubstringConstraint Type Constraints Constraint Name AssignableFromConstraint AssignableToConstraint ExactTypeConstraint InstanceOfTypeConstraint See also Constraint Model"
  },
  "articles/nunit/writing-tests/constraints/DelayedConstraint.html": {
    "href": "articles/nunit/writing-tests/constraints/DelayedConstraint.html",
    "title": "Delayed Constraint | NUnit Docs",
    "summary": "Delayed Constraint DelayedConstraint delays the application of another constraint until a certain amount of time has passed. In its simplest form, it replaces use of a Sleep in the code but it also supports polling, which may allow use of a longer maximum time while still keeping the tests as fast as possible. The After modifier is permitted on any constraint, and the delay applies to the entire expression up to the point where After appears. Use of a DelayedConstraint with a value argument makes no sense, since the value will be extracted at the point of call. Its intended use is with delegates and references. If a delegate is used with polling, it may be called multiple times so only methods without side effects should be used in this way. Syntax Helper Constructor Operation After(int) DelayedConstraint(Constraint, int) tests that a constraint is satisfied after a delay. After(int, int) DelayedConstraint(Constraint, int, int) tests that a constraint is satisfied after a delay using polling. Enhanced Syntax With NUnit 3.6, an enhanced syntax is available that allows expressing the delay and polling interval more fluently. After(4).Seconds After(1).Minutes.PollEvery(500).MilliSeconds Only Minutes, Seconds and MilliSeconds (note capital-S) are accepted as time modifiers. The default is to use MilliSeconds. Examples of Use [Test] public void DelayedConstraint_Examples() { bool flag = false; Task.Run(async () => { await Task.Delay(100); flag = true; }); Assert.That(() => flag, Is.True.After(200).MilliSeconds); }"
  },
  "articles/nunit/writing-tests/constraints/DictionaryContainsKeyConstraint.html": {
    "href": "articles/nunit/writing-tests/constraints/DictionaryContainsKeyConstraint.html",
    "title": "DictionaryContainsKey Constraint | NUnit Docs",
    "summary": "DictionaryContainsKey Constraint DictionaryContainsKeyConstraint is used to test whether a dictionary contains an expected object as a key. Constructor DictionaryContainsKeyConstraint(object) Syntax Contains.Key(object) Does.ContainKey(object) Does.Not.ContainKey(object) Modifiers ...WithValue(object expectedValue) As of version 4.4.0 of NUnit the other modifiers were removed as they were non-functional. NUnit's ContainKey works the same as the ContainsKey method on Dictionary It uses the comparer specified when the dictionary was created. Examples of Use var caseSensitiveDictionary = new Dictionary<string, string>(StringComparer.Ordinal) { [\"Hello\"] = \"World\", }; Assert.That(caseSensitiveDictionary, Does.ContainKey(\"Hello\")); Assert.That(caseSensitiveDictionary, Does.Not.ContainKey(\"hello\")); var caseInsensitiveDictionary = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase) { [\"Hello\"] = \"World\", }; Assert.That(caseInsensitiveDictionary, Does.ContainKey(\"Hello\")); Assert.That(caseInsensitiveDictionary, Does.ContainKey(\"hello\")); Assert.That(caseInsensitiveDictionary, Does.Not.ContainKey(\"hallo\")); // Note that the 'IgnoreCase' here is on the Value part, not the Key. Assert.That(caseInsensitiveDictionary, Does.ContainKey(\"hello\").WithValue(\"world\").IgnoreCase); See also DictionaryContainsValueConstraint DictionaryContainsKeyValuePairConstraint"
  },
  "articles/nunit/writing-tests/constraints/DictionaryContainsKeyValuePairConstraint.html": {
    "href": "articles/nunit/writing-tests/constraints/DictionaryContainsKeyValuePairConstraint.html",
    "title": "DictionaryContainsKeyValuePairConstraint Constraint | NUnit Docs",
    "summary": "DictionaryContainsKeyValuePairConstraint Constraint DictionaryContainsKeyValuePairConstraint is used to test whether a dictionary contains an expected key along with an expected corresponding value. Constructor public DictionaryContainsKeyValuePairConstraint(object key, object value) : this(new KeyValuePair<object, object>(key, value)) { } protected DictionaryContainsKeyValuePairConstraint(KeyValuePair<object, object> arg) : base(arg) { Expected = arg; } Syntax Assert.That(dictionary, new DictionaryContainsKeyValuePairConstraint(\"Hi\", \"Universe\")); Assert.That(dictionary, Does.ContainKey(\"Hola\").WithValue(\"Mundo\")); Assert.That(dictionary, Does.Not.ContainKey(\"Hello\").WithValue(\"NotValue\")); Assert.That(dictionary, new DictionaryContainsKeyValuePairConstraint(\"HI\", \"UNIVERSE\").IgnoreCase); Assert.That(dictionary, new DictionaryContainsKeyValuePairConstraint(\"HI\", \"UNIVERSE\").Using<string>((x, y) => string.Compare(x, y, StringComparison.CurrentCultureIgnoreCase))); Modifiers ...IgnoreCase ...IgnoreWhiteSpace // From version 4.2 ...Using(IComparer comparer) ...Using(IEqualityComparer comparer) ...Using<T>(IComparer<T> comparer) ...Using<T>(Comparison<T> comparer) ...Using<T>(Func<T, T, bool> comparer) ...Using<T>(IEqualityComparer<T> comparer) ...UsingPropertiesComparer() // From version 4.1 ...UsingPropertiesComparer( Func<PropertiesComparerConfiguration, PropertiesComparerConfiguration> configure) // From version 4.4 See also DictionaryContainsValueConstraint DictionaryContainsKeyConstraint"
  },
  "articles/nunit/writing-tests/constraints/DictionaryContainsValueConstraint.html": {
    "href": "articles/nunit/writing-tests/constraints/DictionaryContainsValueConstraint.html",
    "title": "DictionaryContainsValue Constraint | NUnit Docs",
    "summary": "DictionaryContainsValue Constraint DictionaryContainsValueConstraint is used to test whether a dictionary contains an expected object as a value. Constructor DictionaryContainsValueConstraint(object) Syntax Contains.Value(object) Does.ContainValue(object) Does.Not.ContainValue(object) Modifiers ...Using(IComparer comparer) ...Using(IEqualityComparer comparer) ...Using<T>(IComparer<T> comparer) ...Using<T>(Comparison<T> comparer) ...Using<T>(Func<T, T, bool> comparer) ...Using<T>(IEqualityComparer<T> comparer) ...Using<TActualValueElement, TExpected>(Func<TActualValueElement, TExpected, bool> comparison) ...UsingPropertiesComparer() // From version 4.1 ...UsingPropertiesComparer( Func<PropertiesComparerConfiguration, PropertiesComparerConfiguration> configure) // From version 4.4 Examples of Use IDictionary<int, int> idict = new IDictionary<int, int> { { 1, 4 }, { 2, 5 } }; Assert.That(idict, Contains.Value(4)); Assert.That(idict, Does.ContainValue(5)); Assert.That(idict, Does.Not.ContainValue(3)); Assert.That(mydict, Contains.Value(myOwnObject).Using(myComparer)); See also DictionaryContainsKeyConstraint DictionaryContainsKeyValuePairConstraint.md"
  },
  "articles/nunit/writing-tests/constraints/EmptyCollectionConstraint.html": {
    "href": "articles/nunit/writing-tests/constraints/EmptyCollectionConstraint.html",
    "title": "EmptyCollection Constraint | NUnit Docs",
    "summary": "EmptyCollection Constraint The EmptyCollectionConstraint tests if a Collection or other IEnumerable is empty. An ArgumentException is thrown if the actual value is not an IEnumerable or is null. Constructor EmptyCollectionConstraint() Syntax Is.Empty Examples of Use Assert.That(new int[] { }, Is.Empty); Assert.That(new int[] { 1, 2, 3 }, Is.Not.Empty); Note Is.Empty actually creates an EmptyConstraint. Subsequently applying it to an IEnumerable or ICollection causes an EmptyCollectionConstraint to be created."
  },
  "articles/nunit/writing-tests/constraints/EmptyConstraint.html": {
    "href": "articles/nunit/writing-tests/constraints/EmptyConstraint.html",
    "title": "Empty Constraint | NUnit Docs",
    "summary": "Empty Constraint EmptyConstraint tests that an object is an empty string, directory or collection. Constructor EmptyConstraint() Syntax Is.Empty Examples of Use [Test] public void EmptyConstraint_Examples() { Assert.That(\"\", Is.Empty); Assert.That(new int[] {}, Is.Empty); Assert.That(new List<string>(), Is.Empty); Assert.That(\"Hello\", Is.Not.Empty); } Notes EmptyConstraint creates and uses either an EmptyStringConstraint, EmptyDirectoryConstraint or EmptyCollectionConstraint depending on the argument tested. A DirectoryInfo argument is required in order to test for an empty directory. To test whether a string represents a directory path, you must first construct a DirectoryInfo."
  },
  "articles/nunit/writing-tests/constraints/EmptyDirectoryConstraint.html": {
    "href": "articles/nunit/writing-tests/constraints/EmptyDirectoryConstraint.html",
    "title": "EmptyDirectory Constraint | NUnit Docs",
    "summary": "EmptyDirectory Constraint The EmptyDirectoryConstraint tests if a Directory is empty. Constructor EmptyDirectoryConstraint() Syntax Is.Empty Examples of Use Assert.That(new DirectoryInfo(actual), Is.Empty); Assert.That(new DirectoryInfo(actual), Is.Not.Empty); Note Is.Empty actually creates an EmptyConstraint. Subsequently applying it to a DirectoryInfo causes an EmptyDirectoryConstraint to be created."
  },
  "articles/nunit/writing-tests/constraints/EmptyStringConstraint.html": {
    "href": "articles/nunit/writing-tests/constraints/EmptyStringConstraint.html",
    "title": "EmptyString Constraint | NUnit Docs",
    "summary": "EmptyString Constraint The EmptyStringConstraint tests if a string is empty. Constructor EmptyStringConstraint() Syntax Is.Empty Examples of Use Assert.That(string.Empty, Is.Empty); Assert.That(\"A String\", Is.Not.Empty); Note Is.Empty actually creates an EmptyConstraint. Subsequently applying it to a string causes an EmptyStringConstraint to be created."
  },
  "articles/nunit/writing-tests/constraints/EndsWithConstraint.html": {
    "href": "articles/nunit/writing-tests/constraints/EndsWithConstraint.html",
    "title": "EndsWith Constraint | NUnit Docs",
    "summary": "EndsWith Constraint EndsWithConstraint tests for an ending string. Constructor EndsWithConstraint(string expected) Syntax Does.EndWith(string expected) EndsWith(string expected) Modifiers ...IgnoreCase Examples of Use string phrase = \"Make your tests fail before passing!\"; Assert.That(phrase, Does.EndWith(\"!\")); Assert.That(phrase, Does.EndWith(\"PASSING!\").IgnoreCase); Notes EndsWith may appear only in the body of a constraint expression or when the inherited syntax is used."
  },
  "articles/nunit/writing-tests/constraints/EqualConstraint.html": {
    "href": "articles/nunit/writing-tests/constraints/EqualConstraint.html",
    "title": "Equal Constraint | NUnit Docs",
    "summary": "Equal Constraint An EqualConstraint is used to test whether an actual value is equal to the expected value supplied in its constructor, optionally within a specified tolerance. Constructor EqualConstraint(object expected) Syntax Is.EqualTo(object expected) Is.Zero // Equivalent to Is.EqualTo(0) Modifiers ...AsCollection ...IgnoreCase ...IgnoreWhiteSpace // From version 4.2 ...NoClip ...WithSameOffset ...Within(object tolerance) .Ulps .Percent .Days .Hours .Minutes .Seconds .Milliseconds .Ticks ...Using(IEqualityComparer comparer) ...Using(IComparer comparer) ...Using<T>(IEqualityComparer<T> comparer) ...Using<T>(IComparer<T> comparer) ...Using<T>(Comparison<T> comparer) ...Using<T>(Func<T, T, bool> comparer) ...Using<TActual, TExpected>(Func<TActual, TExpected, bool> comparer) ...UsingPropertiesComparer() // From version 4.1 ...UsingPropertiesComparer( Func<PropertiesComparerConfiguration, PropertiesComparerConfiguration> configure) // From version 4.4 Comparing Numerics Numerics are compared based on their values. Different types may be compared successfully if their values are equal. Using the Within modifier, numerics may be tested for equality within a fixed or percent tolerance. [Test] public void EqualConstraint_Numerics() { Assert.That(2 + 2, Is.EqualTo(4.0)); Assert.That(2 + 2 == 4); Assert.That(2 + 2, Is.Not.EqualTo(5)); Assert.That(2 + 2 != 5); Assert.That(5.0, Is.EqualTo(5)); Assert.That(5.5, Is.EqualTo(5).Within(0.5)); Assert.That(5.5, Is.EqualTo(5).Within(10).Percent); } Comparing Floating Point Values Values of type float and double are normally compared using a tolerance specified by the Within modifier. The special values PositiveInfinity, NegativeInfinity and NaN compare as equal to themselves. Floating-point values may be compared using a tolerance in \"Units in the Last Place\" or ULPs. For certain types of numerical work, this is safer than a fixed tolerance because it automatically compensates for the added inaccuracy of larger numbers. [Test] public void EqualConstraint_FloatingPoint() { Assert.That(2.1 + 1.2, Is.EqualTo(3.3).Within(.0005)); Assert.That(double.PositiveInfinity, Is.EqualTo(double.PositiveInfinity)); Assert.That(double.NegativeInfinity, Is.EqualTo(double.NegativeInfinity)); Assert.That(double.NaN, Is.EqualTo(double.NaN)); Assert.That(20000000000000004.0, Is.EqualTo(20000000000000000.0).Within(1).Ulps); } Comparing Strings String comparisons normally respect case. The IgnoreCase modifier causes the comparison to be case-insensitive. It may also be used when comparing arrays or collections of strings. [Test] public void EqualConstraint_Strings() { string hello = \"Hello!\"; Assert.That(hello, Is.Not.EqualTo(\"HELLO!\")); Assert.That(hello, Is.EqualTo(\"HELLO!\").IgnoreCase); // Ignores case in both actual and expected before comparing string[] expected = [\"Hello\", \"World\"]; string[] actual = [\"HELLO\", \"world\"]; Assert.That(actual, Is.EqualTo(expected).IgnoreCase); string actualiws = \"Hello my world is \\r\\n on fire!\"; string expectediws = \"Hellomy world \\r\\n is on fire!\"; Assert.That(actualiws, Is.EqualTo(expectediws).IgnoreWhiteSpace); // Ignores white space in both actual and expected before comparing } Sometimes we need to compare strings irrespective of white space characters, e.g.: when comparing Json strings. This can be done with the IgnoreWhiteSpace modifier. It allows using pretty formatted Json in NUnit tests regardless whether the code under test uses different formatting or no white space at all. const string prettyJson = \"\"\" \"persons\":[ { \"name\": \"John\", \"surname\": \"Smith\" }, { \"name\": \"Jane\", \"surname\": \"Doe\" } ] \"\"\"; const string condensedJson = \"\"\" \"persons\":[{\"name\":\"John\",\"surname\":\"Smith\",},{\"name\": \"Jane\",\"surname\": \"Doe\"}] \"\"\"; Assert.That(condensedJson, Is.EqualTo(prettyJson).IgnoreWhiteSpace); The above tests fails and the messages has been updated to include two carrets to indicate the mismatched location in both expected and actual values: Assert.That(condensedJson, Is.EqualTo(prettyJson).IgnoreWhiteSpace) Expected string length 122 but was 79. Strings differ at index 65. Expected: \"...,\\r\\n \"surname\": \"Smith\"\\r\\n },\\r\\n {\\r\\n \"name\": \"Jane\",\\r...\", ignoring white-space -----------------------------------------------^ But was: \"\"persons\":[{\"name\":\"John\",\"surname\":\"Smith\",},{\"name\": \"Jane\"...\" ------------------------------------------------------^ The IgnoreWhiteSpace can also be specified when comparing collections of strings. The characters ignored are the same as for the C# Char.IsWhiteSpace. Comparing DateTimes and TimeSpans DateTimes and TimeSpans may be compared either with or without a tolerance. A tolerance is specified using Within with either a TimeSpan as an argument or with a numeric value followed by a one of the time conversion modifiers: Days, Hours, Minutes, Seconds, Milliseconds or Ticks. When comparing DateTimeOffsets you can use the optional WithSameOffset modifier to check the offset along with the date and time. DateTime now = DateTime.Now; DateTime later = now + TimeSpan.FromHours(1.0); Assert.That(now, Is.EqualTo(now)); Assert.That(later, Is.EqualTo(now).Within(TimeSpan.FromHours(3.0)); Assert.That(later, Is.EqualTo(now).Within(3).Hours); Comparing Arrays, Collections and IEnumerables with AsCollection Since version 2.2, NUnit has been able to compare two single-dimensioned arrays. Beginning with version 2.4, multi-dimensioned arrays, nested arrays (arrays of arrays) and collections may be compared. With version 2.5, any IEnumerable is supported. Two arrays, collections or IEnumerables are considered equal if they have the same dimensions and if each of the corresponding elements is equal. If you want to treat two arrays of different shapes as simple collections for purposes of comparison, use the AsCollection modifier, which causes the comparison to be made element by element, without regard for the rank or dimensions of the array. Note that jagged arrays (arrays of arrays) do not have a single underlying collection. The modifier would be applied to each array separately, which has no effect in most cases. The AsCollection modifier is also useful on classes implementing both IEnumerable and IEquatable. Without the modifier, the IEquatable implementation is used to test equality. With the modifier specified, IEquatable is ignored and the contents of the enumeration are compared one by one. int[] i3 = new int[] { 1, 2, 3 }; double[] d3 = new double[] { 1.0, 2.0, 3.0 }; int[] iunequal = new int[] { 1, 3, 2 }; Assert.That(i3, Is.EqualTo(d3)); Assert.That(i3, Is.Not.EqualTo(iunequal)); int[,] array2x2 = new int[,] { { 1, 2 }, { 3, 4 } }; int[] array4 = new int[] { 1, 2, 3, 4 }; Assert.That(array2x2, Is.Not.EqualTo(array4)); Assert.That(array2x2, Is.EqualTo(array4).AsCollection); Comparing Dictionaries Two dictionaries are considered equal if The list of keys is the same - without regard to ordering. The values associated with each key are equal. You can use this capability to compare any two objects implementing IDictionary. Generic and non-generic dictionaries (Hashtables) may be successfully compared. Comparing DirectoryInfo Two DirectoryInfo objects are considered equal if both have the same path, creation time and last access time. Assert.That(new DirectoryInfo(actual), Is.EqualTo(expected)); Comparing Classes/Structures If a class/structure implements IEquatable<T> then it is up to the class to define equality. If not, then the standard .NET Equals is called which means for classes, it is reference equality and for structures it is value equality. private sealed class Person { public Person(string name, int yearOfBirth) { Name = name; YearOfBirth = yearOfBirth; } public string Name { get; } public int YearOfBirth { get; } } [Test] public void ComparePersons() { var person1 = new Person(\"Charlie\", 1985); var person2 = new Person(\"Charlie\", 1985); Assert.That(person2, Is.EqualTo(person1)); } The above test fails because even though person1 and person2 have the same property values, they are different instances. If we want to have value equality there are three options: Implement IEquality<Person> on the Person class This is not always wanted, we may require reference comparison in most code, but need value equality for NUnit tests. Specify a specific comparer. See User-Specified Comparers below. This does require writing separate comparers each time one wants to compare a class for value equality. Add the .UsingPropertiesComparer() suffix. This is a special built-in comparer which iterates over all public properties of a class and compares them one by one. It is useful to get value equality for nunit test, e.g. when serializing/deserializing instances, but when value equality is not wanted in normal code. Even if two persons are called Charlie that doesn't mean they are one and the same person. User-Specified Comparers If the default NUnit or .NET behavior for testing equality doesn't meet your needs, you can supply a comparer of your own through the Using modifier. When used with EqualConstraint, you may supply an IEqualityComparer, IEqualityComparer<T>, IComparer, IComparer<T> or Comparison<T> as the argument to Using. Assert.That(myObj1, Is.EqualTo(myObj2).Using(myComparer)); Prior to NUnit 2.6, only one comparer could be used. If multiple comparers were specified, all but one was ignored. Beginning with NUnit 2.6, multiple generic comparers for different types may be specified. NUnit will use the appropriate comparer for any two types being compared. As a result, it is now possible to provide a comparer for an array, a collection type or a dictionary. The user-provided comparer will be used directly, bypassing the default NUnit logic for array, collection or dictionary equality. class ListOfIntComparer : IEqualityComparer<List<int>> { /* ... */ } var list1 = new List<int>(); var list2 = new List<int>(); var myComparer = new ListOfIntComparer(); /* ... */ Assert.That(list1, Is.EqualTo(list2).Using(myComparer)); Properties Comparer The properties comparer is enabled when suffixing the constraint with .UsingPropertiesComparer(). It is only called for instances of the same type which do not implement IEquatable<T>. The exception is that it will be called for record types that have a compiler generated Equals implementation. The reason for this is to get better error messages in case of mismatch. This comparer iterates over all public properties of a type. For each property, it gets the value for both instances and compares them for equality. This can be recursive, e.g. if one has a class Group holding a collection of Persons. The comparer will use the specified tolerance as specified using .Within(amount) if possible. This can be useful when comparing floating point numbers of calculation results. The comparer can deal with recursive data structures, it will stop comparing if it already previously has compared two the same instances. From version 4.4 there is a new overload of UsingPropertiesComparer which allows tailoring the comparison. This overload expects delegate that accepts a PropertiesComparerConfiguration and also returns a PropertiesComparerConfiguration. Comparing Different Types By default, the PropertiesComparer only compares instances of the same type. But sometimes we want to compare the properties of a Dto object with an Domain entity. If all properties have the same name, this can be done with the AllowDifferentTypes() modifier. private record struct PersonDto(string Name, int YearOfBirth); private record struct PersonEntity(string Name, int YearOfBirth); [Test] public void CompareDifferentTypes() { var dto = new PersonDto(\"Hejlsberg\", 1960); var entity = new PersonEntity(\"Hejlsberg\", 1960); Assert.That(dto, Is.EqualTo(entity) .UsingPropertiesComparer(o => o.AllowDifferentTypes())); } Excluding some Properties for Comparison Compare Only Common Properties If our PersonEntity class has an Id property for the database key, it no longer matches the PersonDto. We would like to compare the two, but ignore the Id property. To only compare those properties available on both types, use: .CompareOnlyCommonProperties(). This method implies .AllowDifferentTypes(). private record struct PersonDto(string Name, int YearOfBirth); private record struct PersonEntity(Guid Id, string Name, int YearOfBirth); [Test] public void CompareDifferentTypesWithExcessFields() { var dto = new PersonDto(\"Hejlsberg\", 1960); var entity = new PersonEntity(Guid.NewGuid(), \"Hejlsberg\", 1960); Assert.That(dto, Is.EqualTo(entity) .UsingPropertiesComparer(o => o.CompareOnlyCommonProperties())); } Use only specified Properties Sometimes you don't want to compare all properties and you only care about some. You can do this with the Using method. There are two overloads, one expecting a string and the other a type safe Expression. The latter has the advantage that you get intellisense helping you with available property names. However, that overload is only available on some constraints which have been update with a generic type parameter. private record struct Person(string Name, int YearOfBirth); [Test] public void CompareDifferentTypesOnNameOnly() { var dto1 = new PersonDto(\"Hejlsberg\", 1960); var dto2 = new PersonDto(\"Hejlsberg\", 1966); // Specify name as a string Assert.That(dto2, Is.EqualTo(dto1).UsingPropertiesComparer( o => o.Using(\"Name\"))); // Specify name as an expression Assert.That(dto2, Is.EqualTo(dto1).UsingPropertiesComparer( o => o.Using(x => x.Name))); } Use all but some properties If you don't care about the equality of one property, like database id field, you can exclude this specifically with the Exclude method. This method also has two overloads: string and Expression. private record struct PersonEntity(Guid Id, string Name, int YearOfBirth); [Test] public void CompareDifferentTypesExcludingId() { var entity1 = new PersonEntity(Guid.NewGuid(), \"Hejlsberg\", 1960); var entity2 = new PersonEntity(Guid.NewGuid(), \"Hejlsberg\", 1960); Assert.That(entity2, Is.EqualTo(entity1).UsingPropertiesComparer( o => o.Excluding(nameof(PersonEntity.Id)))); Assert.That(entity2, Is.EqualTo(entity1).UsingPropertiesComparer( o => o.Excluding(x => x.Id))); } Mapping Property Names Sometimes the property names are different between classes. You can use the Map property to map property names from the expected to the actual name. Because the constraints are separate from the actual Assert call, you do need to specify the type of the actual instance when using the type safe Expression overload. private record struct PersonDto(string Name, int YearOfBirth); private record struct PersonEntity(string LastName, int BirthYear); [Test] public void CompareDifferentTypesWithExcessFields() { var dto = new PersonDto(\"Hejlsberg\", 1960); var entity = new PersonEntity(\"Hejlsberg\", 1960); Assert.That(dto, Is.EqualTo(entity).UsingPropertiesComparer( o => o.Map(nameof(PersonEntity.LastName), nameof(PersonDto.Name)) .Map(nameof(PersonEntity.BirthYear), nameof(PersonDto.YearOfBirth)))); Assert.That(dto, Is.EqualTo(entity).UsingPropertiesComparer( o => o.Map<PersonDto>(entity => entity.LastName, dto => dto.Name) .Map<PersonDto>(entity => entity.BirthYear, dto => dto.YearOfBirth))); } Mapping Property Values Sometimes one class doesn't have the properties the other has, but we only want to compare if the value of the other has a specific value. private sealed record Address(string House, string Street, string City, string PostalCode, string Country); private sealed record USAddress(string House, string Street, string City, string ZipCode); [Test] public void CompareMatchingDifferentAddresses() { var address = new Address(\"10\", \"CSI\", \"Las Vegas\", \"89030\", \"U.S.A.\"); var usAddress = new USAddress(\"10\", \"CSI\", \"Las Vegas\", \"89030\"); // We can supply a Value for the missing property 'Country' Assert.That(usAddress, Is.EqualTo(address).UsingPropertiesComparer( o => o.Map<Address, USAddress>(world => world.PostalCode, usa => usa.ZipCode) .Map<Address>(world => world.Country, \"U.S.A.\"))); } All USAddress instances are assumed to be in the U.S.A. To compare this with world wide addresses, they should only match if the world address' Country has the value U.S.A. We could have excluded the Country property, but then we might get matches of similar addresses in other countries. Configuring matching for nested type members The above can be combined for nested types: private sealed record Address(string House, string Street, string City, string AreaCode, string Country); private sealed record Person(string Name, Address Address); private sealed record USAddress(string House, string Street, string City, string ZipCode); private sealed record USPerson(string Name, USAddress USAddress); [Test] public void CompareMismatchedDifferentTypes() { var person = new Person(\"John Doe\", new Address(\"10\", \"CSI\", \"Las Vegas\", \"89030\", \"U.S.A.\")); var usPerson = new USPerson(\"John Doe\", new USAddress(\"10\", \"CSI\", \"Las Vegas\", \"89031\")); Assert.That(usPerson, Is.EqualTo(person).UsingPropertiesComparer( o => o.Map<Person, USPerson>(x => x.Address, y => y.USAddress) .Map<Address, USAddress>(x => x.AreaCode, y => y.ZipCode) .Map<Address>(x => x.Country, \"U.S.A.\"))); } The mapped property names and values are shown in the failure message: Assert.That(usPerson, Is.EqualTo(person).UsingPropertiesComparer( c => c.Map<Person, USPerson>(x => x.Address, y => y.USAddress) .Map<Address, USAddress>(x => x.AreaCode, y => y.ZipCode) .Map<Address>(x => x.Country, \"U.S.A.\"))) Expected: <Person { Name = John Doe, Address = Address { House = 10, Street = CSI, City = Las Vegas, AreaCode = 89030, Country = U.S.A. } }> But was: <USPerson { Name = John Doe, USAddress = USAddress { House = 10, Street = CSI, City = Las Vegas, ZipCode = 89031 } }> Values differ at property Person.Address => USPerson.USAddress: Expected: <Address { House = 10, Street = CSI, City = Las Vegas, AreaCode = 89030, Country = U.S.A. }> But was: <USAddress { House = 10, Street = CSI, City = Las Vegas, ZipCode = 89031 }> Values differ at property Address.AreaCode => USAddress.ZipCode: String lengths are both 5. Strings differ at index 4. Expected: \"89030\" But was: \"89031\" ---------------^ Notes When checking the equality of user-defined classes, NUnit first examines each class to determine whether it implements IEquatable<T> (unless the AsCollection modifier is used). If either object implements the interface for the type of the other object, then that implementation is used in making the comparison. If neither class implements the appropriate interface, NUnit makes use of the Equals override on the expected object. If you neglect to either implement IEquatable<T> or to override Equals, you can expect failures comparing non-identical objects. In particular, overriding operator == without overriding Equals or implementing the interface has no effect. The Within modifier was originally designed for use with floating point values only. Beginning with NUnit 2.4, comparisons of DateTime values may use a TimeSpan as a tolerance. Beginning with NUnit 2.4.2, non-float numeric comparisons may also specify a tolerance. Float and double comparisons for which no tolerance is specified use a default value, which can be specified with DefaultFloatingPointToleranceAttribute. If this is not in place, a tolerance of 0.0d is used. (Prior to NUnit 3.7, default tolerance was instead set via GlobalSettings.DefaultFloatingPointTolerance.) Prior to NUnit 2.2.3, comparison of two NaN values would always fail, as specified by IEEE floating point standards. The new behavior, was introduced after some discussion because it seems more useful in tests. To avoid confusion, consider using Is.NaN where appropriate. When an equality test between two strings fails, the relevant portion of both strings is displayed in the error message, clipping the strings to fit the length of the line as needed. Beginning with 2.4.4, this behavior may be modified by use of the NoClip modifier on the constraint. In addition, the maximum line length may be modified for all tests by setting the value of TextMessageWriter.MaximumLineLength in the appropriate level of setup. When used with arrays, collections or dictionaries, EqualConstraint operates recursively. Any modifiers are saved and used as they apply to individual items. A user-specified comparer will not be called by EqualConstraint if either or both arguments are null. If both are null, the Constraint succeeds. If only one is null, it fails. NUnit has special semantics for comparing Streams and DirectoryInfos. For a Stream, the contents are compared. For a DirectoryInfo, the first-level directory contents are compared. See also Assert.AreEqual DefaultFloatingPointTolerance Attribute"
  },
  "articles/nunit/writing-tests/constraints/ExactCountConstraint.html": {
    "href": "articles/nunit/writing-tests/constraints/ExactCountConstraint.html",
    "title": "ExactCount Constraint | NUnit Docs",
    "summary": "ExactCount Constraint ExactCountConstraint has two functions. In its simplest use, it simply verifies the number of items in an array, collection or IEnumerable, providing a way to count items that is independent of any Length or Count property. When used with another constraint, it applies that constraint to each item in the array, collection or IEnumerable, succeeding if the specified number of items succeed. An exception is thrown if the actual value passed does not implement IEnumerable. Constructor ExactCountConstraint(int expectedCount) ExactCountConstraint(int expectedCount, Constraint itemConstraint) Syntax Has.Exactly(int expectedCount)... Examples of Use int[] array = new int[] { 1, 2, 3 }; Assert.That(array, Has.Exactly(3).Items); Assert.That(array, Has.Exactly(2).Items.GreaterThan(1)); Assert.That(array, Has.Exactly(3).LessThan(100)); Assert.That(array, Has.Exactly(2).Items.EqualTo(1).Or.EqualTo(3)); Assert.That(array, Has.Exactly(1).EqualTo(1).And.Exactly(1).EqualTo(3)); Note The keyword Items is optional when used before a constraint but required when merely counting items with no constraint specified. See also PropertyConstraint - For constraints on the Count or Length property, e.g. Has.Count.GreaterThan(10) or Has.Length.EqualTo(6)."
  },
  "articles/nunit/writing-tests/constraints/ExactTypeConstraint.html": {
    "href": "articles/nunit/writing-tests/constraints/ExactTypeConstraint.html",
    "title": "ExactType Constraint | NUnit Docs",
    "summary": "ExactType Constraint ExactTypeConstraint tests that an object is an exact Type. Constructor ExactTypeConstraint(Type) Syntax Is.TypeOf(Type) Is.TypeOf<T>() Examples of Use [Test] public void TypeConstraint_Examples() { Assert.That(\"Hello\", Is.TypeOf<string>()); Assert.That(\"Hello\", Is.TypeOf(typeof(string))); Assert.That(\"Hello\", Is.InstanceOf<string>()); Assert.That(\"Hello\", Is.InstanceOf<object>()); Assert.That(\"Hello\", Is.AssignableTo<object>()); }"
  },
  "articles/nunit/writing-tests/constraints/FalseConstraint.html": {
    "href": "articles/nunit/writing-tests/constraints/FalseConstraint.html",
    "title": "False Constraint | NUnit Docs",
    "summary": "False Constraint FalseConstraint tests that a value is false. Constructor FalseConstraint() Syntax Is.False Example of Use Assert.That(condition, Is.False);"
  },
  "articles/nunit/writing-tests/constraints/FileOrDirectoryExistsConstraint.html": {
    "href": "articles/nunit/writing-tests/constraints/FileOrDirectoryExistsConstraint.html",
    "title": "FileOrDirectoryExists Constraint | NUnit Docs",
    "summary": "FileOrDirectoryExists Constraint FileOrDirectoryExistsConstraint tests that a File or Directory exists. Constructor FileOrDirectoryExistsConstraint() Syntax Does.Exist Does.Not.Exist Modifiers IgnoreDirectories IgnoreFiles Examples of Use [Test] public void FileConstraint_Examples() { var tempFile = Path.GetTempFileName(); File.WriteAllText(tempFile, \"test content\"); try { Assert.That(tempFile, Does.Exist); Assert.That(\"nonexistent.txt\", Does.Not.Exist); } finally { if (File.Exists(tempFile)) File.Delete(tempFile); } }"
  },
  "articles/nunit/writing-tests/constraints/GreaterThanConstraint.html": {
    "href": "articles/nunit/writing-tests/constraints/GreaterThanConstraint.html",
    "title": "GreaterThan Constraint | NUnit Docs",
    "summary": "GreaterThan Constraint GreaterThanConstraint tests that one value is greater than another. Constructor GreaterThanConstraint(object expected) Syntax Is.GreaterThan(object expected) Is.Positive // Equivalent to Is.GreaterThan(0) Modifiers ...Using(IComparer comparer) ...Using<T>(IComparer<T> comparer) ...Using<T>(Comparison<T> comparer) ...Within(object tolerance) Examples of Use [Test] public void GreaterThan_Examples() { Assert.That(7, Is.GreaterThan(3)); Assert.That(42, Is.Positive); DateTime expectedDateTime = DateTime.Now.AddMinutes(-1); DateTime myDateTime = DateTime.Now; Assert.That(myDateTime, Is.GreaterThan(expectedDateTime).Within(TimeSpan.FromSeconds(1))); }"
  },
  "articles/nunit/writing-tests/constraints/GreaterThanOrEqualConstraint.html": {
    "href": "articles/nunit/writing-tests/constraints/GreaterThanOrEqualConstraint.html",
    "title": "GreaterThanOrEqual Constraint | NUnit Docs",
    "summary": "GreaterThanOrEqual Constraint GreaterThanOrEqualConstraint tests that one value is greater than or equal to another. Constructor GreaterThanOrEqualConstraint(object expected) Syntax Is.GreaterThanOrEqualTo(object expected) Is.AtLeast(object expected) Modifiers ...Using(IComparer comparer) ...Using<T>(IComparer<T> comparer) ...Using<T>(Comparison<T> comparer) ...Within(object tolerance) Examples of Use Assert.That(7, Is.GreaterThanOrEqualTo(3)); Assert.That(7, Is.AtLeast(3)); Assert.That(7, Is.GreaterThanOrEqualTo(7)); Assert.That(7, Is.AtLeast(7)); Assert.That(myOwnObject, Is.GreaterThanOrEqualTo(theExpected).Using(myComparer)); Assert.That(myDateTime, Is.GreaterThanOrEqualTo(expectedDateTime).Within(TimeSpan.FromSeconds(1)))"
  },
  "articles/nunit/writing-tests/constraints/InstanceOfTypeConstraint.html": {
    "href": "articles/nunit/writing-tests/constraints/InstanceOfTypeConstraint.html",
    "title": "InstanceOfType Constraint | NUnit Docs",
    "summary": "InstanceOfType Constraint InstanceOfTypeConstraint tests that an object is of the type supplied or a derived type. Constructor InstanceOfTypeConstraint(Type) Syntax Is.InstanceOf(Type) Is.InstanceOf<T>() Examples of Use [Test] public void TypeConstraint_Examples() { Assert.That(\"Hello\", Is.TypeOf<string>()); Assert.That(\"Hello\", Is.TypeOf(typeof(string))); Assert.That(\"Hello\", Is.InstanceOf<string>()); Assert.That(\"Hello\", Is.InstanceOf<object>()); Assert.That(\"Hello\", Is.AssignableTo<object>()); }"
  },
  "articles/nunit/writing-tests/constraints/LessThanConstraint.html": {
    "href": "articles/nunit/writing-tests/constraints/LessThanConstraint.html",
    "title": "LessThan Constraint | NUnit Docs",
    "summary": "LessThan Constraint LessThanConstraint tests that one value is less than another. Constructor LessThanConstraint(object expected) Syntax Is.LessThan(object expected) Is.Negative // Equivalent to Is.LessThan(0) Modifiers ...Using(IComparer comparer) ...Using<T>(IComparer<T> comparer) ...Using<T>(Comparison<T> comparer) ...Within(object tolerance) Examples of Use [Test] public void LessThan_Examples() { Assert.That(3, Is.LessThan(7)); Assert.That(-5, Is.Negative); }"
  },
  "articles/nunit/writing-tests/constraints/LessThanOrEqualConstraint.html": {
    "href": "articles/nunit/writing-tests/constraints/LessThanOrEqualConstraint.html",
    "title": "LessThanOrEqual Constraint | NUnit Docs",
    "summary": "LessThanOrEqual Constraint LessThanOrEqualConstraint tests that one value is less than or equal to another. Constructor LessThanOrEqualConstraint(object expected) Syntax Is.LessThanOrEqualTo(object expected) Is.AtMost(object expected) Modifiers ...Using(IComparer comparer) ...Using<T>(IComparer<T> comparer) ...Using<T>(Comparison<T> comparer) ...Within(object tolerance) Examples of Use Assert.That(3, Is.LessThanOrEqualTo(7)); Assert.That(3, Is.AtMost(7)); Assert.That(3, Is.LessThanOrEqualTo(3)); Assert.That(3, Is.AtMost(3)); Assert.That(myOwnObject, Is.LessThanOrEqualTo(theExpected).Using(myComparer)); Assert.That(myDateTime, Is.LessThanOrEqualTo(expectedDateTime).Within(TimeSpan.FromSeconds(1)))"
  },
  "articles/nunit/writing-tests/constraints/NaNConstraint.html": {
    "href": "articles/nunit/writing-tests/constraints/NaNConstraint.html",
    "title": "NaN Constraint | NUnit Docs",
    "summary": "NaN Constraint NaNConstraint tests that a value is floating-point NaN. Constructor NaNConstraint() Syntax Is.NaN Examples of Use Assert.That(aDouble, Is.NaN); Assert.That(aDouble, Is.Not.NaN);"
  },
  "articles/nunit/writing-tests/constraints/NoItemConstraint.html": {
    "href": "articles/nunit/writing-tests/constraints/NoItemConstraint.html",
    "title": "NoItem Constraint | NUnit Docs",
    "summary": "NoItem Constraint NoItemConstraint applies a constraint to each item in a collection, succeeding only if all of them fail. An exception is thrown if the actual value passed does not implement IEnumerable. Constructor NoItemConstraint(Constraint itemConstraint) Syntax Has.None... Examples of Use int[] iarray = new int[] { 1, 2, 3 }; string[] sarray = new string[] { \"a\", \"b\", \"c\" }; Assert.That(iarray, Has.None.Null); Assert.That(sarray, Has.None.EqualTo(\"d\")); Assert.That(iarray, Has.None.LessThan(0));"
  },
  "articles/nunit/writing-tests/constraints/NotConstraint.html": {
    "href": "articles/nunit/writing-tests/constraints/NotConstraint.html",
    "title": "Not Constraint | NUnit Docs",
    "summary": "Not Constraint NotConstraint reverses the effect of another constraint. If the base constraint fails, NotConstraint succeeds. If the base constraint succeeds, NotConstraint fails. Constructor NotConstraint() Syntax Is.Not... Examples of Use public class Person { public string Name { get; set; } = \"\"; public int Age { get; set; } public string Email { get; set; } = \"\"; } [Test] public void PropertyConstraint_Examples() { var person = new Person { Name = \"John\", Age = 25, Email = \"john@example.com\" }; Assert.That(person, Has.Property(\"Name\").EqualTo(\"John\")); Assert.That(person, Has.Property(\"Age\").GreaterThan(18)); Assert.That(person, Has.Property(\"Email\").Contains(\"@\")); }"
  },
  "articles/nunit/writing-tests/constraints/NullConstraint.html": {
    "href": "articles/nunit/writing-tests/constraints/NullConstraint.html",
    "title": "Null Constraint | NUnit Docs",
    "summary": "Null Constraint NullConstraint tests that a value is null. Constructor NullConstraint() Syntax Is.Null Examples of Use [Test] public void NullConstraint_Examples() { object anObject = null; Assert.That(anObject, Is.Null); anObject = \"something\"; Assert.That(anObject, Is.Not.Null); }"
  },
  "articles/nunit/writing-tests/constraints/OrConstraint.html": {
    "href": "articles/nunit/writing-tests/constraints/OrConstraint.html",
    "title": "Or Constraint | NUnit Docs",
    "summary": "Or Constraint OrConstraint combines two other constraints and succeeds if either of them succeeds. Constructor OrConstraint(Constraint left, Constraint right) Syntax <Constraint>.Or.<Constraint> Examples of Use [Test] public void OrConstraint_Examples() { Assert.That(3, Is.LessThan(5).Or.GreaterThan(10)); Assert.That(12, Is.LessThan(5).Or.GreaterThan(10)); } Evaluation Order and Precedence Note that the constraint evaluates the sub-constraints left to right, meaning that Assert.That(i,Is.Null.Or.GreaterThan(9)); where i is a nullable int will work for both 12 and null. On the other hand, Assert.That(i, Is.GreaterThan(9).Or.Null); will only work for 12, but throw an exception for null, as null cannot be compared to 9. The OrConstraint has precedence over the AndConstraint. See also AndConstraint"
  },
  "articles/nunit/writing-tests/constraints/PropertyConstraint.html": {
    "href": "articles/nunit/writing-tests/constraints/PropertyConstraint.html",
    "title": "Property Constraint | NUnit Docs",
    "summary": "Property Constraint PropertyConstraint tests for the existence of a named property on an object and then applies a constraint test to the property value. Constructor PropertyConstraint(string name, IConstraint baseConstraint) Syntax Has.Property(string name)... // followed by further constraint syntax Examples of Use public class Person { public string Name { get; set; } = \"\"; public int Age { get; set; } public string Email { get; set; } = \"\"; } [Test] public void PropertyConstraint_Examples() { var person = new Person { Name = \"John\", Age = 25, Email = \"john@example.com\" }; Assert.That(person, Has.Property(\"Name\").EqualTo(\"John\")); Assert.That(person, Has.Property(\"Age\").GreaterThan(18)); Assert.That(person, Has.Property(\"Email\").Contains(\"@\")); } As shown in the example, certain common properties are known to NUnit and may be tested using a shorter form. The following properties are supported: Has.Length... Has.Count... Has.Message... Has.InnerException... See also PropertyExistsConstraint"
  },
  "articles/nunit/writing-tests/constraints/PropertyExistsConstraint.html": {
    "href": "articles/nunit/writing-tests/constraints/PropertyExistsConstraint.html",
    "title": "PropertyExists Constraint | NUnit Docs",
    "summary": "PropertyExists Constraint The PropertyExistsConstraint tests for the existence of a named property on an object. Constructor PropertyExistsConstraint(string name) Syntax Has.Property(string) Examples of Use Assert.That(someObject, Has.Property(\"Version\")); See also PropertyConstraint"
  },
  "articles/nunit/writing-tests/constraints/RangeConstraint.html": {
    "href": "articles/nunit/writing-tests/constraints/RangeConstraint.html",
    "title": "Range Constraint | NUnit Docs",
    "summary": "Range Constraint RangeConstraint tests that a value is in an (inclusive) range. Constructor RangeConstraint(IComparable from, IComparable to) Syntax Is.InRange(IComparable from, IComparable to) Modifiers ...Using(IComparer comparer) ...Using<T>(IComparer<T> comparer) ...Using<T>(Comparison<T> comparer) Examples of Use [Test] public void RangeConstraint_Examples() { int[] intArray = [1, 2, 3, 4, 5, 6, 7, 8, 9]; Assert.That(5, Is.InRange(1, 10)); Assert.That(42, Is.Not.InRange(1, 10)); Assert.That(intArray, Has.All.InRange(1, 10)); }"
  },
  "articles/nunit/writing-tests/constraints/RegexConstraint.html": {
    "href": "articles/nunit/writing-tests/constraints/RegexConstraint.html",
    "title": "RegexConstraint | NUnit Docs",
    "summary": "RegexConstraint RegexConstraint tests that a pattern is matched. Constructor RegexConstraint(string pattern) Syntax Does.Match(string pattern) Matches(string pattern) Modifiers ...IgnoreCase Examples of Use string phrase = \"Make your tests fail before passing!\"; Assert.That(phrase, Does.Match(\"Make.*tests.*pass\")); Assert.That(phrase, Does.Match(\"make.*tests.*PASS\").IgnoreCase); Assert.That(phrase, Does.Not.Match(\"your.*passing.*tests\")); Notes Matches may appear only in the body of a constraint expression or when the inherited syntax is used."
  },
  "articles/nunit/writing-tests/constraints/ReusableConstraint.html": {
    "href": "articles/nunit/writing-tests/constraints/ReusableConstraint.html",
    "title": "Reusable Constraint | NUnit Docs",
    "summary": "Reusable Constraint Normally constraints just work. However, attempting to reuse the same constraint in several places can lead to unexpected results. Consider the following code as an example: Constraint myConstraint = Is.Not.Null; Assert.That(\"not a null\", myConstraint); // Passes, of course Assert.That(\"not a null\", myConstraint); // Fails! What's that about? We'll save the technical explanation for later and show the solution first: ReusableConstraint myConstraint = Is.Not.Null; Assert.That(\"not a null\", myConstraint); // Passes Assert.That(\"not a null\", myConstraint); // Passes Or alternatively.. var myConstraint = new ReusableConstraint(Is.Not.Null); Assert.That(\"not a null\", myConstraint); // Passes Assert.That(\"not a null\", myConstraint); // Passes Technical Explanation In the original example, the value assigned to myConstraint is known as an unresolved constraint. In fact, it's an unresolved NullConstraint, because that was the last constraint encountered in the expression. It's associated with a Not operator that has not yet been applied. That's OK for use with Assert.That(), because the method knows how to resolve a constraint before using it. Assert.That() resolves this constraint to a NotConstraint referencing the original NullConstraint. Of course, the original reference in myConstraint is left unchanged in all of this. But the EqualConstraint it points to has now been resolved. It is now a resolved constraint and can't be resolved again by the second Assert.That(), which only sees the NullConstraint and not the NotConstraint. So, for reusability, what we want to save is the result of resolving the constraint, in this case NotConstraint => NullConstraint That's what ReusableConstraint does for us. It resolves the full expression and saves the result. Then it passes all operations on to that saved result. When to Use It Use this constraint any time you want to reuse a constraint expression and you'll be safe. If you like to take chances, you'll find that you can avoid using it in the following cases... With a simple constraint involving no operators, like... Constraint myConstraint = Is.Null; Constraint myConstraint = Is.EqualTo(42); With any constraint you construct using new, without using the \"dotted\" constraint syntax... Constraint myConstraint = new NotConstraint(new NullConstraint()); Constraint myConstraint = new AndConstraint( new GreaterThanConstraint(0), new LessThanConstraint(100)); However, there is no significant penalty to using ReusableConstraint. It makes your intent much clearer and the exceptions listed are accidents of the internal implementation and could disappear in future releases."
  },
  "articles/nunit/writing-tests/constraints/SameAsConstraint.html": {
    "href": "articles/nunit/writing-tests/constraints/SameAsConstraint.html",
    "title": "SameAs Constraint | NUnit Docs",
    "summary": "SameAs Constraint A SameAsConstraint is used to test whether the object passed as an actual value has the same identity as the object supplied in its constructor. Constructor SameAsConstraint(object expected) Syntax Is.SameAs(object expected) Examples of Use Exception ex1 = new Exception(); Exception ex2 = ex1; Assert.That(ex2, Is.SameAs(ex1)); Exception ex3 = new Exception(); Assert.That(ex3, Is.Not.SameAs(ex1));"
  },
  "articles/nunit/writing-tests/constraints/SamePathConstraint.html": {
    "href": "articles/nunit/writing-tests/constraints/SamePathConstraint.html",
    "title": "SamePath Constraint | NUnit Docs",
    "summary": "SamePath Constraint SamePathConstraint tests that two paths are equivalent. Constructor SamePathConstraint(string expectedPath) Syntax Is.SamePath(string expectedPath) Modifiers ...IgnoreCase ...RespectCase Examples of Use Assert.That(\"/folder1/./junk/../folder2\", Is.SamePath(\"/folder1/folder2\")); Assert.That(\"/folder1/./junk/../folder2/x\", Is.Not.SamePath(\"/folder1/folder2\")); Assert.That(@\"C:\\folder1\\folder2\", Is.SamePath(@\"C:\\Folder1\\Folder2\").IgnoreCase); Assert.That(\"/folder1/folder2\", Is.Not.SamePath(\"/Folder1/Folder2\").RespectCase); Notes Path constraints perform tests on paths, without reference to any actual files or directories. This allows testing paths that are created by an application for reference or later use, without any effect on the environment. Path constraints are intended to work across multiple file systems, and convert paths to a canonical form before comparing them. It is usually not necessary to know the file system of the paths in order to compare them. Where necessary, the programmer may use the IgnoreCase and RespectCase modifiers to provide behavior other than the system default. See also SubPathConstraint SamePathOrUnderConstraint"
  },
  "articles/nunit/writing-tests/constraints/SamePathOrUnderConstraint.html": {
    "href": "articles/nunit/writing-tests/constraints/SamePathOrUnderConstraint.html",
    "title": "SamePathOrUnder Constraint | NUnit Docs",
    "summary": "SamePathOrUnder Constraint SamePathOrUnderConstraint tests that one path is equivalent to another path or that it is under it. Constructor SamePathOrUnderConstraint(string expectedPath) Syntax Is.SamePathOrUnder(string expectedPath) Modifiers ...IgnoreCase ...RespectCase Examples of Use Assert.That(\"/folder1/./junk/../folder2\", Is.SamePathOrUnder(\"/folder1/folder2\")); Assert.That(\"/folder1/junk/../folder2/./folder3\", Is.SamePathOrUnder(\"/folder1/folder2\")); Assert.That(\"/folder1/junk/folder2/folder3\", Is.Not.SamePathOrUnder(\"/folder1/folder2\")); Assert.That(@\"C:\\folder1\\folder2\\folder3\", Is.SamePathOrUnder(@\"C:\\Folder1\\Folder2\").IgnoreCase); Assert.That(\"/folder1/folder2/folder3\", Is.Not.SamePathOrUnder(\"/Folder1/Folder2\").RespectCase); Notes Path constraints perform tests on paths, without reference to any actual files or directories. This allows testing paths that are created by an application for reference or later use, without any effect on the environment. Path constraints are intended to work across multiple file systems, and convert paths to a canonical form before comparing them. It is usually not necessary to know the file system of the paths in order to compare them. Where necessary, the programmer may use the IgnoreCase and RespectCase modifiers to provide behavior other than the system default. See also SamePathConstraint SubPathConstraint"
  },
  "articles/nunit/writing-tests/constraints/SomeItemsConstraint.html": {
    "href": "articles/nunit/writing-tests/constraints/SomeItemsConstraint.html",
    "title": "SomeItems Constraint | NUnit Docs",
    "summary": "SomeItems Constraint SomeItemsConstraint applies a constraint to each item in an IEnumerable, succeeding if at least one of them succeeds. An exception is thrown if the actual value passed does not implement IEnumerable. Constructor SomeItemsConstraint(Constraint itemConstraint) Syntax Has.Some... Modifiers ...IgnoreCase ...IgnoreWhiteSpace // From version 4.2 ...Using(IEqualityComparer comparer) ...Using(IComparer comparer) ...Using<T>(IEqualityComparer<T> comparer) ...Using<T>(IComparer<T> comparer) ...Using<T>(Comparison<T> comparer) ...Using<TActualCollectionElement, TExpectedElement>(Func<TActualCollectionElement, TExpectedElement, bool> comparer) ...UsingPropertiesComparer() // From version 4.1 ...UsingPropertiesComparer( Func<PropertiesComparerConfiguration, PropertiesComparerConfiguration> configure) // From version 4.4 Examples of Use int[] iarray = new int[] { 1, 2, 3 }; string[] sarray = new string[] { \"a\", \"b\", \"c\" }; Assert.That(iarray, Has.Some.GreaterThan(2)); Assert.That(sarray, Has.Some.Length.EqualTo(1));"
  },
  "articles/nunit/writing-tests/constraints/StartsWithConstraint.html": {
    "href": "articles/nunit/writing-tests/constraints/StartsWithConstraint.html",
    "title": "StartsWith Constraint | NUnit Docs",
    "summary": "StartsWith Constraint StartsWithConstraint tests for an initial string. Constructor StartsWithConstraint(string expected) Syntax Does.StartWith(string expected) StartsWith(string expected) Modifiers ...IgnoreCase Examples of Use string phrase = \"Make your tests fail before passing!\"; Assert.That(phrase, Does.StartWith(\"Make\")); Assert.That(phrase, Does.Not.StartWith(\"Break\")); Notes StartsWith may appear only in the body of a constraint expression or when the inherited syntax is used."
  },
  "articles/nunit/writing-tests/constraints/SubPathConstraint.html": {
    "href": "articles/nunit/writing-tests/constraints/SubPathConstraint.html",
    "title": "SubPath Constraint | NUnit Docs",
    "summary": "SubPath Constraint SubPathConstraint tests that one path is under another path. Constructor SubPathConstraint(string expectedPath) Syntax Is.SubPathOf(string expectedPath) Modifiers ...IgnoreCase ...RespectCase Examples of Use Assert.That(\"/folder1/./junk/../folder2\", Is.SubPathOf(\"/folder1/\")); Assert.That(\"/folder1/junk/folder2\", Is.Not.SubPathOf(\"/folder1/folder2\")); Assert.That(@\"C:\\folder1\\folder2\\Folder3\", Is.SubPathOf(@\"C:\\Folder1\\Folder2\").IgnoreCase); Assert.That(\"/folder1/folder2/folder3\", Is.Not.SubPathOf(\"/Folder1/Folder2/Folder3\").RespectCase); Notes Path constraints perform tests on paths, without reference to any actual files or directories. This allows testing paths that are created by an application for reference or later use, without any effect on the environment. Path constraints are intended to work across multiple file systems, and convert paths to a canonical form before comparing them. It is usually not necessary to know the file system of the paths in order to compare them. Where necessary, the programmer may use the IgnoreCase and RespectCase modifiers to provide behavior other than the system default. See also SamePathConstraint SamePathOrUnderConstraint"
  },
  "articles/nunit/writing-tests/constraints/SubstringConstraint.html": {
    "href": "articles/nunit/writing-tests/constraints/SubstringConstraint.html",
    "title": "Substring Constraint | NUnit Docs",
    "summary": "Substring Constraint SubstringConstraint tests for a substring. Constructor SubstringConstraint(string expected) Syntax Does.Contain(string expected) Modifiers ...IgnoreCase Examples of Use [Test] public void StringConstraint_Examples() { Assert.That(\"Hello World!\", Does.StartWith(\"Hello\")); Assert.That(\"Hello World!\", Does.EndWith(\"World!\")); Assert.That(\"Hello World!\", Does.Contain(\"lo Wor\")); Assert.That(\"Hello World!\", Does.Match(\"H.*!\")); }"
  },
  "articles/nunit/writing-tests/constraints/ThrowsConstraint.html": {
    "href": "articles/nunit/writing-tests/constraints/ThrowsConstraint.html",
    "title": "Throws Constraint | NUnit Docs",
    "summary": "Throws Constraint ThrowsConstraint is used to test that some code, represented as a delegate, throws a particular exception. It may be used alone, to merely test the type of constraint, or with an additional constraint to be applied to the exception specified as an argument. The related ThrowsNothingConstraint simply asserts that the delegate does not throw an exception. Constructors ThrowsConstraint(Type expectedType) ThrowsConstraint<T>() ThrowsConstraint(Type expectedType, Constraint constraint) ThrowsConstraint<T>(Constraint constraint) Syntax Throws.Exception Throws.TargetInvocationException Throws.ArgumentException Throws.ArgumentNullException Throws.InvalidOperationException Throws.TypeOf(Type expectedType) Throws.TypeOf<T>() Throws.InstanceOf(Type expectedType) Throws.InstanceOf<T>() Throws.InnerException Examples of Use [Test] public void ThrowsConstraint_Examples() { Assert.That(() => throw new ArgumentException(), Throws.ArgumentException); Assert.That(() => throw new InvalidOperationException(\"test\"), Throws.InvalidOperationException.With.Message.EqualTo(\"test\")); Assert.That(() => { }, Throws.Nothing); } Notes Throws.Exception may be followed by further constraints, which are applied to the exception itself as shown in the last two examples above. It may also be used alone to verify that some exception has been thrown, without regard to type. This is not a recommended practice since you should normally know what exception you are expecting. Throws.TypeOf and Throws.InstanceOf are provided as a shorter syntax for this common test. They work exactly like the corresponding forms following Throws.Exception. Throws.TargetInvocationException, Throws.ArgumentException and Throws.InvalidOperationException provide a shortened form for some common exceptions. Used alone, Throws.InnerException simply tests the InnerException value of the thrown exception. More commonly, it will be used in combination with a test for the type of the outer exception as shown in the examples above."
  },
  "articles/nunit/writing-tests/constraints/ThrowsNothingConstraint.html": {
    "href": "articles/nunit/writing-tests/constraints/ThrowsNothingConstraint.html",
    "title": "ThrowsNothing Constraint | NUnit Docs",
    "summary": "ThrowsNothing Constraint ThrowsNothingConstraint asserts that the delegate passed as its argument does not throw an exception. Constructor ThrowsNothingConstraint() Syntax Throws.Nothing Example of Use Assert.That(() => SomeMethod(actual), Throws.Nothing);"
  },
  "articles/nunit/writing-tests/constraints/TrueConstraint.html": {
    "href": "articles/nunit/writing-tests/constraints/TrueConstraint.html",
    "title": "True Constraint | NUnit Docs",
    "summary": "True Constraint TrueConstraint tests that a value is true. Constructor TrueConstraint() Syntax Is.True Example of Use [Test] public void TrueConstraint_Examples() { Assert.That(2 + 2 == 4, Is.True); Assert.That(2 + 2 == 5, Is.False); }"
  },
  "articles/nunit/writing-tests/constraints/UniqueItemsConstraint.html": {
    "href": "articles/nunit/writing-tests/constraints/UniqueItemsConstraint.html",
    "title": "UniqueItems Constraint | NUnit Docs",
    "summary": "UniqueItems Constraint UniqueItemsConstraint tests that an array, collection or other IEnumerable is composed of unique items with no duplicates. Constructor UniqueItemsConstraint() Syntax Is.Unique Modifiers ...IgnoreCase ...IgnoreWhiteSpace // From version 4.2 ...Using(IEqualityComparer comparer) ...Using(IComparer comparer) ...Using<T>(IEqualityComparer<T> comparer) ...Using<T>(IComparer<T> comparer) ...Using<T>(Comparison<T> comparer) ...Using<T>(Func<T, T, bool> comparer) ...UsingPropertiesComparer() // From version 4.1 ...UsingPropertiesComparer( Func<PropertiesComparerConfiguration, PropertiesComparerConfiguration> configure) // From version 4.4 Example of Use int[] iarray = new int[] { 1, 2, 3 }; Assert.That(iarray, Is.Unique);"
  },
  "articles/nunit/writing-tests/constraints/WhiteSpaceConstraint.html": {
    "href": "articles/nunit/writing-tests/constraints/WhiteSpaceConstraint.html",
    "title": "WhiteSpace Constraint | NUnit Docs",
    "summary": "WhiteSpace Constraint The WhiteSpaceConstraint tests if a string contains only white-space. The constraint is the equivalent of String.IsNullOrWhiteSpace White-space characters are defined by the Unicode standard as interpreted by Char.IsWhiteSpace method. Constructor WhiteSpaceConstraint() Syntax Is.WhiteSpace // From version 4.2 Examples of Use Assert.That(\" \", Is.WhiteSpace); Assert.That(\"A String\", Is.Not.WhiteSpace);"
  },
  "articles/nunit/writing-tests/constraints/XmlSerializableConstraint.html": {
    "href": "articles/nunit/writing-tests/constraints/XmlSerializableConstraint.html",
    "title": "XmlSerializable Constraint | NUnit Docs",
    "summary": "XmlSerializable Constraint XmlSerializableConstraint tests whether an object is serializable in XML format. Constructor XmlSerializableConstraint() Syntax Is.XmlSerializable Examples of Use Assert.That(someObject, Is.XmlSerializable)); See also BinarySerializableConstraint"
  },
  "articles/nunit/writing-tests/setup-teardown/SetUp-and-TearDown-Changes.html": {
    "href": "articles/nunit/writing-tests/setup-teardown/SetUp-and-TearDown-Changes.html",
    "title": "SetUp And TearDown Changes | NUnit Docs",
    "summary": "SetUp And TearDown Changes This page describes significant changes in SetUp and TearDown in NUnit 3.0 Existing NUnit 2.6.4 attributes used for SetUp and TearDown were SetUpAttribute TearDownAttribute TestFixtureSetUpAttribute TestFixtureTearDownAttribute SetUpFixtureAttribute Taken together, these attributes provided per-test setup and teardown at the fixture level and one-time setup and teardown at the fixture, namespace and assembly levels. These features were somewhat confusing: SetUpFixture seems not very well understood by users in general. TestFixtureSetUp and TestFixtureTearDown could do with better names. SetUp and TearDown designate per-test setup/teardown within a test fixture, one-time setup/teardown within a setup fixture For NUnit 3.0 we standardized the use of attributes for setup and teardown and renamed some of them to make their function clearer. Attribute Usage SetUpAttribute is now used exclusively for per-test setup. TearDownAttribute is now used exclusively for per-test teardown. OneTimeSetUpAttribute is used for one-time setup per test-run. If you run n tests, this event will only occur once. OneTimeTearDownAttribute is used for one-time teardown per test-run. If you run n tests, this event will only occur once SetUpFixtureAttribute continues to be used as at before, but with changed method attributes. Attribute Usage by Fixture Type TestFixture SetUpFixture OneTimeSetUp Supported Supported OneTimeTearDown Supported Supported TestFixtureSetUp Deprecated Not Allowed TestFixtureTearDown Deprecated Not Allowed SetUp Supported Not Allowed TearDown Supported Not Allowed Backward Compatibility TestFixtureSetUpAttribute and TestFixtureTearDownAttribute continue to be supported as synonyms for OneTimeSetUpAttribute and OneTimeTearDownAttribute in test fixtures, but are deprecated. Since SetUpAttribute and TearDownAttribute are used in two different ways, it's not possible to simply deprecate their usage in SetUpFixture. They have been disallowed in that context, which is a breaking change. How Setup and TearDown Methods Are Called Multiple SetUp, OneTimeSetUp, TearDown and OneTimeTearDown methods may exist within a class. The rules for how the setup methods are called will be the same in NUnit 3.0 as in NUnit 2.6. However, there is a change in the calling of the teardown methods. Setup methods (both types) are called on base classes first, then on derived classes. If any setup method throws an exception, no further setups are called. This is the same as in NUnit 2.6. Teardown methods (again, both types) are called on derived classes first, then on the base class. In NUnit 2.6, all teardown methods were called so long as any setup method was called. It was entirely up to the teardown method to determine how much of the initialization took place. In NUnit 3.0, the teardown methods at any level in the inheritance hierarchy will be called only if a setup method at the same level was called. The following example is illustrates the difference. public class BaseClass { [SetUp] public void BaseSetUp() { /* ... */ } // Exception thrown! [TearDown] public void BaseTearDown() { /* ... */ } } [TestFixture] public class DerivedClass : BaseClass { [SetUp] public void DerivedSetUp() { /* ... */ } [TearDown] public void DerivedTearDown() { /* ... */ } [Test] public void TestMethod() { /* ... */ } } Assume that an exception is thrown in BaseSetUp. In NUnit 2.6, methods would be executed as follows: BaseSetUp DerivedTearDown BaseTearDown In NUnit 3.0, execution will proceed as follows: BaseSetUp BaseTearDown This is potentially a breaking change for some users. Unresolved Issues We need to define how setup and teardown methods are ordered with respect to the newly introduced Action Attributes and how they interact."
  },
  "articles/nunit/writing-tests/setup-teardown/index.html": {
    "href": "articles/nunit/writing-tests/setup-teardown/index.html",
    "title": "SetUp and TearDown | NUnit Docs",
    "summary": "SetUp and TearDown Attribute Usage SetUpAttribute is now used exclusively for per-test setup. TearDownAttribute is now used exclusively for per-test teardown. OneTimeSetUpAttribute is used for one-time setup per test-run. If you run n tests, this event will only occur once. OneTimeTearDownAttribute is used for one-time teardown per test-run. If you run n tests, this event will only occur once SetUpFixtureAttribute continues to be used as at before, but with changed method attributes. Attribute Usage by Fixture Type TestFixture SetUpFixture OneTimeSetUp Supported Supported OneTimeTearDown Supported Supported TestFixtureSetUp Deprecated Not Allowed TestFixtureTearDown Deprecated Not Allowed SetUp Supported Not Allowed TearDown Supported Not Allowed How Setup and TearDown Methods Are Called Multiple SetUp, OneTimeSetUp, TearDown and OneTimeTearDown methods may exist within a class. Setup methods (both types) are called on base classes first, then on derived classes. If any setup method throws an exception, no further setups are called. Teardown methods (again, both types) are called on derived classes first, then on the base class. The teardown methods at any level in the inheritance hierarchy will be called only if a setup method at the same level was called. The following example illustrates the difference. public class BaseClass { [SetUp] public void BaseSetUp() { /* ... */ } // Exception thrown! [TearDown] public void BaseTearDown() { /* ... */ } } [TestFixture] public class DerivedClass : BaseClass { [SetUp] public void DerivedSetUp() { /* ... */ } [TearDown] public void DerivedTearDown() { /* ... */ } [Test] public void TestMethod() { ... } } Execution will proceed as follows: BaseSetUp BaseTearDown rather than BaseSetUp DerivedTearDown BaseTearDown See also: SetUp and TearDown Changes"
  },
  "articles/vs-test-adapter/Adapter-Engine-Compatibility.html": {
    "href": "articles/vs-test-adapter/Adapter-Engine-Compatibility.html",
    "title": "Compatibility of the Test Adapter with the Test Engine | NUnit Docs",
    "summary": "Compatibility of the Test Adapter with the Test Engine The NUnit3TestAdapter has an embedded NUnit.Engine package. This means that you don't need to install the engine separately, and you don't need to add a reference to the engine in your test project. You should never add an extra reference to the NUnit.Engine when using the adapter in a project, as that may cause the adapter to malfunction. @CharliePoole has written a blog post about the compatibility of the adapter with the engine, explaining how it works and how you should work with both the console, engine and adapter. The table below shows the embedded engine versions for the different adapter versions, extended from Charlie's blog post. Adapter version Embedded engine version 5.0.0 3.18.1 4.6.0 3.18.1 4.5.0 3.15.4 4.4.2 3.15.3-dev-build 4.4.0 3.16.3 4.3.2 3.15.5 4.3.1 3.15.2 4.2.1 3.13.2 4.2 3.13 4.0-4.1 3.12 3.17 3.11.1 3.14-3.16.1 3.10 3.8-3.13 3.10 3.7 3.6 3.5-3.6.1 3.5 3.4 3.4.1 3.2 3.2.1 3.0 3.0.1 Using the console If, for some unknown reason, you really badly want to use the NUnit.Console, and you really want to add it as a package reference instead of just installing it globally, you should use the exact same version as listed for the engine in the table above. Note that most of what the console can do, can be done using the dotnet test command with the appropriate runsettings added, see Tips&Tricks. Warning If you try to add another engine version package, it may seem that the adapter and test are still working. That is just by luck, and it does so because the interfaces between the version you have added are the same as the embedded version. But if you try to use a feature that is not in the embedded version, it will fail. Most likely you will see messages about \"no tests found\", or it may simply crash during test. Warning Version 4.4.1 use an engine version that is not released yet. This is because the engine has a bug that prevents it from working with the adapter. The bug is fixed in the engine, but the fix is not yet released. The adapter will be updated to use the released engine version as soon as it is released. You may try to use 3.15.2, but we can currently not confirm that it works."
  },
  "articles/vs-test-adapter/Adapter-Installation.html": {
    "href": "articles/vs-test-adapter/Adapter-Installation.html",
    "title": "Adapter Installation | NUnit Docs",
    "summary": "Adapter Installation You'll need to install the adapter as a NuGet package for each of your test projects. Installing the NuGet Package You will most likely want to add a new NUnit Test Project to your solution. The easiest way is to use the dotnet command on the command line. Go to your project root and where you want to add your project. Create a folder for the project with a name matching what your new test project should be named. Then run the command dotnet new nunit. You will now get a complete nunit test project with the same name as the folder. You will also have a template unit test class there as a starter. If you have a Visual Studio solution file in the root folder, you can go there and add the new nunit csproj easily: Assume you are at a solution root, and you either have a solution file, or have just been adding it with dotnet new sln. md Whatever.Test cd Whatever.Test dotnet new nunit cd .. dotnet sln add Whatever.Test\\Whatever.Test.csproj And you're ready to go ! Manually Adding the Adapter as a Package Reference to Your Test Projects When adding packages manually, we recommended installing the framework, the adapter, and the analyzer for optimal out-of-the-box functionality. The adapter and the framework are required. The analyzer will help during development, but is not strictly required to make your project work. coverlet.collector is the recommended code coverage package you should go for. You should ensure you also reference Microsoft.NET.Test.Sdk as well; it is required for test discoverability. Open your test project csproj file Add the necessary package references as shown in the snippet example below (NOTE: these are the current versions at time of writing; you'll want to install the latest versions.) <ItemGroup> <PackageReference Include=\"Microsoft.NET.Test.Sdk\" Version=\"17.4.0\" /> <PackageReference Include=\"NUnit\" Version=\"3.13.3\" /> <PackageReference Include=\"NUnit3TestAdapter\" version=\"4.3.1\" /> <PackageReference Include=\"coverlet.collector\" Version=\"3.2.0\" /> <PackageReference Include=\"NUnit.Analyzers\" Version=\"3.5.0\" /> </ItemGroup> Note: You don't need to, nor should you, add any nunit.console or any other runner package Working with the Visual Studio Nuget manager If you have a legacy project type, or prefer working outside of the command line, you can also use the Visual Studio 'Manage NuGet packages in the solution' menu option. It can also be used for the new SDK projects, but you may find it faster to open the csproj and copy/paste the references in. With an active solution in Visual Studio, follow these steps: From the Tools menu, use Library Package Manager and select Manage NuGet packages for solution In the left panel, select Online Locate (search for) NUnit3Test Adapter in the center panel and highlight it Click Install In the Select Projects dialog, select all test projects in your solution."
  },
  "articles/vs-test-adapter/Adapter-License.html": {
    "href": "articles/vs-test-adapter/Adapter-License.html",
    "title": "License - NUnit and NUnit3 Test Adapters for Visual Studio | NUnit Docs",
    "summary": "License - NUnit and NUnit3 Test Adapters for Visual Studio MIT License Copyright (c) 2011-2021 Charlie Poole, 2014-2023 Terje Sandstrom Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE."
  },
  "articles/vs-test-adapter/Adapter-Source-Stepping.html": {
    "href": "articles/vs-test-adapter/Adapter-Source-Stepping.html",
    "title": "Adapter Source Stepping | NUnit Docs",
    "summary": "Adapter Source Stepping As of version 3.10, the NUnit3TestAdapter NuGet package and VSIX contain source-indexed PDBs for the adapter. Debuggers can step into the source code, set breakpoints, watch variables, etc. It’s easy to drop into NUnit adapter code any time you want to understand what’s going on. If you’re getting ready to report a bug in the adapter, figuring out how to create a minimal repro is much easier since you aren’t dealing with a black box! How to step into adapter source in the Visual Studio debugger The NUnit adapter PDBs are source-linked and work with Visual Studio 2017 or later. Turn off Debug > Options > ‘Enable Just My Code.’ Note This is something you’ll want to leave on and only turn off when you want to step into source that isn’t contained in your solution. (Next time you can make this faster by installing the excellent extension Just My Code Toggle. This allows you to set a keyboard shortcut along with adding a toolbar button and call stack context menu item.) If needed, turn on Debug > Options > ‘Enable Source Link support.’ This can usually be left on. Congratulations! You can now use the debugger to step into method calls to the NUnit adapter and to set breakpoints and watch variables in the source! Keep in mind that it’s still a release build of the adapter, so variables and sequence points may not be available depending on runtime optimizations."
  },
  "articles/vs-test-adapter/AdapterV2-Release-Notes.html": {
    "href": "articles/vs-test-adapter/AdapterV2-Release-Notes.html",
    "title": "Adapter V2 Release Notes | NUnit Docs",
    "summary": "Adapter V2 Release Notes NUnit Test Adapter for Visual Studio - Version 2.3.0 - June 8, 2020 NUnit Test Adapter for Visual Studio - Version 2.3.0-beta01 - May 7, 2020 Updates the NUnit framework to 2.7.1 #186 How to change used NUnit 2 version of test adapter to e.g. v2.7.1 ? #184 Update NUnit library to 2.7.1 Thanks to BobSilent for #188 solving #184 and #186. Bugs 189 NUnit adapter is failing when PropertyAttribute is used with NULL value NUnit Test Adapter for Visual Studio - Version 2.2.0 - June 5, 2019 Features #180 NUnit 2 test adapter does not support Visual Studio 2019 #175 NuGet Package : Add repository metadata. Thanks to MaximRouiller for the PR #174 NUnitTestAdapter 2.1.1 not working with Visual Studio 2017 15.8.0 Bugfixes #147 Fails to resolve assembly for base type of TestFixture if placed in a different dll #178 Test Explorer Picks up Zero Tests in VS 2017 for NUnit 2 NUnit Test Adapter for Visual Studio - Version 2.1.1 - March 19, 2017 Hotfix release Bug Fixes #142 NUnit Test Adapter 2.1 doesn't work with projects that target .NET Framework 3.5 / CLR 2.0 #144 Adapter requires test project PDBs to be generated for tests to be executed NUnit Test Adapter for Visual Studio - Version 2.1 - March 4, 2017 Features #135 Support for VS 2017 #127 Change adapter package to use tools directory #116 Use Mono.Cecil to retrieve source code locations Bug Fixes #84 NUnit load failure #87 Can't overload async/await methods Notes The NUnit V2 adapter does not support the Live Unit Testing feature in VS 2017. That support is only included with the NUnit V3 adapter. The package including both the adapter and the framework are discontinued. Please install the separate packages instead when upgrading. NUnit Test Adapter for Visual Studio - Version 2.0 - April 1, 2015 Features Tested for up to VS2015 Pre-release CTP 6 Updated to use NUnit 2.6.4 Adapter does not try to discover tests if the nunit.framework version is 3.0 or greater Bug Fixes #61 Confusing NUnit version message made clearer #62 Adapter uses shadowcopy setting in discoverer but not in the executor NUnit Test Adapter for Visual Studio (RTM) - Version 1.2 - September 17, 2014 Features Tested for up to VS2013 Update 3 Bugs 39 and 40 was inability to run under VS2012. This is now fixed. Bug Fixes #24 Long-running tests ignored #34 Adapter causes ArgumentException to be thrown by Microsoft logger proxy's SendMessage method #37 TestExecution throws Exception System.InvalidOperationException in TFS Build #38 NUnit only accepts absolute paths to test assembly #39 VSTest unable to find NUnit tests since 1.1.0.0 #40 NUnit version 1.1.0.0 is broken with test class which ran under 1.0.0.0 NUnit Test Adapter for Visual Studio (RTM) - Version 1.1 - April 26, 2014 Features Support for NUnit 2.6.3 Tested for up to VS2013 Update 2 RC Shadow copy now disabled by default, see issue #7 Unable to disable shadow copy. Registry settings added for some customization options, see Tips and Tricks All code moved to github Bug Fixes #13 Category attribute not working with TFS test case filter #21 Xamarin.iOS NUnit project causes adapter to throw NUnit Test Adapter for Visual Studio (RTM) - Version 1.0 - September 12, 2013 Features This is the release version 1.0 of the test adapter. Bug Fixes #1208148 The test result output node is not shown for debug/trace statements NUnit Test Adapter for Visual Studio (RC) - Version 0.97 - September 12, 2013 Features This is the release candidate for version 1.0 of the test adapter. Bug Fixes #1208161 NUnit Test Adapter runs [Explicit] unit tests in TFS Build #1210536 No Source Available for Async Tests #1165188 Clicking \"Run Selected Tests\" doesn't show Trace.WriteLine() output NUnit Test Adapter for Visual Studio (Beta 6) - Version 0.96 - June 28, 2013 Features Support for Visual Studio 2013 Preview Bug Fixes #1189268 Profile a test will crash with exception NUnit Test Adapter for Visual Studio (Beta 5) - Version 0.95.2 - June 7, 2013 Bug Fixes #1188000, adapter don't work with solutions with only .net 2.0/3.5 project NUnit Test Adapter for Visual Studio (Beta 5) - Version 0.95.1 Hotfix- May 28, 2013 Bug Fixes Hotfix for debug issue NUnit Test Adapter for Visual Studio (Beta 5) - Version 0.95 - May 10, 2013 Features #1174925 Add support for installing the adapter from NuGet Bug Fixes #1155617 Grouping by class name in VS 2012 doesn't work #1165359 Exception after building Coded UI test #1116747 vstest.executionengine.x86.exe does not terminate #1093178 Eliminate unnecessary files from VSIX NUnit Test Adapter for Visual Studio (Beta 4) - Version 0.94 - December 22, 2012 Features Works with Visual Studio 2012 Update 1 as well as the RTM. Supports filtering and sorting tests by Traits under Update 1. Supports use of standard filter expressions when running under TFS Update 1. NUnit Categories specified on the fixture class are now recognized and honored. Bug Fixes 1074891 Can't test multiple assemblies referencing different NUnit versions 1075893 Test execution fails if solution contains native C++ project 1076012 No source information found for async test methods 1087629 TestFixture Category not being recognized as traits in VS2012 update 1 1091020 Adapter doesn't support TFS Build traits/test case filtering NUnit Test Adapter for Visual Studio (Beta 3-2) - Version 0.93.2 - November 2, 2012 Bug Fixes 1074544 Failures in Test Discovery not reporting sufficient information NUnit Test Adapter for Visual Studio (Beta 3-1) - Version 0.93.1 - October 26, 2012 Bug Fixes 1072150 NUnit adapter 0.93 won't run selected tests NUnit Test Adapter for Visual Studio (Beta 3) - Version 0.93 - October 24, 2012 Features Works with Visual Studio 2012 RTM. Some features require the November CTP update. The adapter now uses NUnit 2.6.2. Among other things, this allows us to support async test methods. See the NUnit Release Notes for more info. Source file and line number can now be found for test cases that have an alternate name set. Console output from tests is now displayed in the Visual Studio Output window. TestFixtureSetUp and TestFixtureTearDown errors are now displayed in the Output window. The caret line (------^) is no longer displayed in the IDE since it depends on use of a fixed font. Tests may now be grouped and filtered by Category (only under the November CTP update for VS2012). Bug Fixes 1021144 Text output from tests not displayed in Visual Studio IDE 1033623 Not possible to include or exclude tests based on [Category] attribute Released 1040779 Null reference exception on generic test fixtures 1064620 Support async test methods 1065209 Should call both RecordEnd and RecordResult at end of a test 1065212 Upgrade NUnit to 2.6.2 1065223 Error messages assume a fixed font, but don't get one 1065225 No display for TestFixtureSetUp/TearDown or SetUpFixture errors 1065254 Cannot open test from Test Explorer for tests in a Parameterized Test Fixture 1065306 Generic Fixtures aren't discovered. 1066393 Unable to display source for test cases with an alternate name set 1066518 Executed fast test appears in Not Run category in Test Explorer NUnit Test Adapter for Visual Studio (Beta 2) - Version 0.92 - May 3, 2012 Features Works with Visual Studio 2012 Release Candidate Uses NUnit 2.6 Bug Fixes 992837 Unable to Debug using VS Test Adapter 994146 Can't run tests under .NET 2.0/3.5 NUnit Test Adapter for Visual Studio (Beta 1) - Version 0.91 - February 29, 2012 Features Built against Visual Studio 11 Beta 1 Uses NUnit 2.6 NUnit Test Adapter for Visual Studio (Alpha) - Version 0.90 - February 21, 2012 Features First release of the test adapter. Compatible with the Visual Studio 11 Developer Preview. Uses NUnit 2.6."
  },
  "articles/vs-test-adapter/AdapterV3-Release-Notes.html": {
    "href": "articles/vs-test-adapter/AdapterV3-Release-Notes.html",
    "title": "Adapter V3 Release Notes | NUnit Docs",
    "summary": "Adapter V3 Release Notes NUnit3 Test Adapter for Visual Studio - Version 3.17.0 - July 11, 2020 This release has a series of enhancements and bugfixes. There have been two 3.17 beta releases (beta.1 and beta.2) published earlier on nuget.org. A major bugfix is that the console output now is properly appearing. There are also a series of fixes for corner cases. StopOnError can be very useful to reduce time of long test runs that are failing. The ability to set custom paths for the test code can be useful with data driven tests, where you want to point to the data file (and line number therein) instead of the default C# test code. See here for all details on the settings. Features and Enhancements 640 Allow use of FullName as the DisplayName for Converted Tests 675 Ability to set StopOnError via .runsettings 723 and 735 CodeFilePath like in nunit2 and TestCaseData: Missing Feature \"Jump to File\" 740 Allow Warnings to be mapped to any outcome 758 Feature Request: Adapter to support NonTestAssemblyAttribute Resolved issues/bugs 301 Issue Revisited: Console Output 343 Console.WriteLine() does not write to console when runningdotnet test 697 Test adapter props files should not add assemblies to Content ItemGroup 737 An assembly specified in the application dependencies manifest was not found 745 NUnit engine IDriverFactory extensions don't load using the adapter. Thanks to aolszowka for PR 749 750 ShadowCopyFiles doesn't work on .NET Framework. Thanks to DavidSimner for PR 751 Internal development stuff 746 EditorConfig for *.props Types. Thanks to aolszowka for PR 747 753 EditorConfig for *.csproj Types. Thanks to aolszowka for PR 754 NUnit3 Test Adapter for Visual Studio - Version 3.17.0-beta.2 - June 8, 2020 This is the 2nd beta for 3.17, published on Nuget. Features and Enhancements 758 Feature Request: Adapter to support NonTestAssemblyAttribute 740 Allow Warnings to be mapped to any outcome 640 Allow use of FullName as the DisplayName for Converted Tests Resolved issues/bugs 750 ShadowCopyFiles doesn't work on .NET Framework. Thanks to DavidSimner for PR 751 745 NUnit engine IDriverFactory extensions don't load using the adapter. Thanks to aolszowka for PR 749 Internal development stuff 746 EditorConfig for *.props Types. Thanks to aolszowka for PR 747 753 EditorConfig for *.csproj Types. Thanks to aolszowka for PR 754 NUnit3 Test Adapter for Visual Studio - Version 3.17.0-beta.1 - April 19, 2020 This is the first beta release published on Nuget. It contains new features and some bugfixes. Features and Enhancements 675 Ability to set StopOnError via .runsettings 723 and 735 CodeFilePath like in nunit2 and TestCaseData: Missing Feature \"Jump to File\" Resolved issues/bugs 301 Issue Revisited: Console Output 343 Console.WriteLine() does not write to console when runningdotnet test 697 Test adapter props files should not add assemblies to Content ItemGroup 737 An assembly specified in the application dependencies manifest was not found NUnit3 Test Adapter for Visual Studio - Version 3.16.1 - January 16, 2020 This release is a hotfix release intended to fix three major issues: 686 NUnit3TestAdapter3.16. dotnet filter argument is not applied 690 Can run only one test case from combinatorial test 692 NUnit Test Adaptor 3.16.0 never displays results of test under Visual Studio 2015 Together with these, the following issues are changed: 676 Test cases are skipped with TestCaseSource under Visual Studio 2019. This works under 3.16.0, but need the changes below in a runsettings file under 3.16.1 Note that this hotfix changes some of the new defaults introduced in 3.16.0. These can be set back using the two new runsettings UseParentFQNForParametrizedTests and UseNUnitIdforTestCaseId NUnit3 Test Adapter for Visual Studio - Version 3.16.0 - January 3, 2020 This release has three major changes. The support for .NET Core 1.* has been removed. This is done to open up more functionality for the later .NET Core versions. Also, since .NET Core 1.* is no longer supported by Microsoft, we decided to remove the support too. If you do have .NET Core 1.* solutions and can't upgrade, you should stay with the the adapter 3.15.1 or lower. The change also means we now support dump files in .NET Core :-). It also means the total size of the package has been reduced by around 30%. The filter syntax issues we've had with special names and characters have been mostly solved, thanks to excellent work by John M.Wright. The filter syntax is now closer to a correct FQN (Full Qualified Name), but this might cause some issues with your own filter in some rare cases. The fix done resolves a lot of issues, all of them listed below. For a detailed explanation of what has been done, see the Pull Request #668. You can now use the NUnit filter syntax, either from command line or through settings in the runsettings file. This was due to an idea by Michael Letterle and a subsequent implementation Pull Request #669. Michael also wrote a great blog post to explain how this works, and how he arrived at the solution. For more information see the NUnit Test Selection Language. Resolved issues All the following are solved by Pull Request #668 622 An exception occurred while invoking executor 'executor://nunit3testexecutor/': Incorrect format for TestCaseFilter Error: Missing ')' 549 Invalid characters in test name breaks test runner 607 VS Test Explorer does not show results for test cases that have custom names 613 TestCaseSource tests get wrongly displayed 672 VS Test Explorer fails to run tests with test cases mocked with NSubstitute 644 Test Explorer shows excess class name for tests with multiple TestCaseAttribute 615 Dynamic TestCaseSource from reflection are not listed as sub-tests of the test method The following are resolved (fully or partially) by Pull Request 669 655 How to run parameterized NUnit tests on .NET Core? 425 Partly resolved using NUnit Test Selection Language. Run only specific tests when using dotnet test? The following is also resolved, but can't repro the original 582 TestCase with enclosed double quotes error Other resolved issues 679 Build.cake does not work in a pure visual studio preview installation. Fixed by PR #680 by Ove Bastiansen NUnit3 Test Adapter for Visual Studio - Version 3.15.1 - August 30, 2019 This is a hotfix release due to some issues with special cases in NUnit, causing the tests to not run. The major difference is that this release makes PreFiltering which was introduced in 3.15, optional - and default off. It can be enabled by setting PreFilter to true in a runsettings file. Resolved Issues 651 Add feature flag to enable/disable pre-filtering. This one contains the links to the issues below: 648 NUnit3TestAdapter 3.15.0 fails to run test: \"NUnit failed to load\" (when using NUnit framework less than version 3.11) 649 NUnit3TestAdapter 3.15 OneTimeSetUp not working anymore (When a SetupFixture is being used) 650 NUnit3TestAdapter 3.15 not running tests with custom TestCaseSource (when using SetName instead of SetArgDisplayNames) NUnit3 Test Adapter for Visual Studio - Version 3.15 - August 23, 2019 This release is a major performance improvement release. When used from Visual Studio, and used with a selection of tests, it will significantly speed up the discovery of those. Note that discovery is also a part of the execution, so you will also see the performance improvement for execution. It will be mostly noticeable when you have a large set of tests. Features and Enhancements 529 Use framework prefilter for massive perf improvement when running fraction of tests. Thanks to MatthewBeardmore for the Pull request and patience Resolved Issues 645 NUnit3TestAdapter 3.14.0 includes NUnit3.TestAdapter.dll versioned 3.13. Version number of dll corrected to match package version 3.15 580 Fix licenseUrl in nuspec, will be deprecated NUnit3 Test Adapter for Visual Studio - Version 3.14 - August 8, 2019 Features and Enhancements 609 Request to change working directory from Windows/System32 to another directory and 303 Directory.GetCurrentDirectory is C:\\WINDOWS\\system32 for NUnit3TestAdapter. If your current directory points to either Windows directory or the Program Files folders, it will be redirected to your temp folder. 621 TestContext.Progress output. It will only go to the console, not the test output. 222 NUnit3TestAdapter errors when running xUnit tests. Thanks to nvborisenko for the Pull Request Resolved Issues 629 NUnit3TestAdapter errors when running xUnit tests 630 Assert.Multiple produces new tests in the report if inner assertions fail. Thanks again to nvborisenko for the Pull Request Comments This version also includes the latest version 3.10 of the NUnit.Engine.dll NUnit3 Test Adapter for Visual Studio - Version 3.13 - February 20, 2019 This release focuses on producing NUnit test result XML which can be useful when you need reports using tools that support the NUnit format. This can be enabled using a new setting in the runsettings file. The VSIX is also made compatible with the upcoming VS 2019. Please note support for the VSIX is being deprecated in Visual Studio, and we strongly recommend you to change your test projects to use the NuGet adapter version. The NUnit internal properties have been \"over-populating\" in the Test Explorer. These are now filtered out, although you may still see these when you have Source Based Discovery (SBD) turned on (which is the default in VS). Once you have run, they will be gone. We expect this part of the issue (SBD) to be fixed in VS. If you still want to see the properties, you can enable that again setting a runsettings property ShowInternalProperties to true. Enhancements 323 Add support for producing XML test results in NUnit format 474 Skip surfacing certain properties as UI groupings (Internal NUnit properties are no longer visible in Test Explorer) 590 Support for Visual Studio 2019 (VSIX) Resolved Issues 302 BadImageFormatException building solution with unmanaged projects) Extra fix for this, see PR 592 Issue302 native execution in execution. Thanks to Oski Kervinen for fixing this. 596 TestOutputXml should handle relative paths relative to the Workfolder 600 TestOutputXml setting ignored on netcore2.1, works on net461 Other fixes 599 Url in the repo header pointing to nunit.org changed to https, also some other similar changes other places. Thanks to Julian Verdurmen for fixing these. NUnit3 Test Adapter for Visual Studio - Version 3.12 - December 19, 2018 Enhancements 215 Generate NUnit xml file of test results, specified in .runsettings file for reporting 573 NUnit3TestDiscoverer Could not load file or assembly 'nunit.engine' NUnit3 Test Adapter for Visual Studio - Version 3.11.2 - November 22, 2018 This is a yet another hotfix release to fix the missing categories issue. Resolved Issues 568 NUnit3TestAdapter 3.11.1 TestCategory from VSTest no longer working (No tests selected) Reopened issues This issue was fixed, with a workaround, in 3.11 but had unforeseen consequences, and has been reopened as of this release 506 Test categories aren't propagated to vstest trx logs This probably need to be fixed in VSTest itself. NUnit3 Test Adapter for Visual Studio - Version 3.11.1 - November 21, 2018 This is a hotfix release to fix the duplicated traits issue. Resolved Issues 559 Duplicating tags in Test Explorer when using NUnit3TestAdapter 3.11.0 561 Test task aborted when using TestCategory filters NUnit3 Test Adapter for Visual Studio - Version 3.11 - October 28, 2018 Features PR 500 NUnit3VsAdapter to support managed sources only based on RFC (Thanks to mayankbansal018 for this PR) 543 Adapter should pass Error and Progress messages to vstest engine as well as stdOut messages (Thanks to NikolayPianikov for PR 544). Also fixes this TeamCity issue Mono.Cecil is now embedded with the adapter, so user dependencies are no longer overwritten. Indentation of the test log format makes it easier to see what information belongs to which assembly. Quiet mode added, if you don't want all the information, see Tips and Tricks. Resolved Issues 426 Exception thrown while loading tests if In-Proc VSTest DataCollector is used (Thanks to drognanar for PR 510 ) 490 Fix Causes Build Error (Somewhat Indirectly) by published pdb files from Issue 461 494 TestContext.AddTestAttachment does not work on Linux environment with specified dotnet logger (Thanks to Kira-Lappo for PR 527) 495 Category as filter not working in single agent flow in vstest task 506 Test categories aren't propagated to vstest trx logs 516 ArgumentException when whitespace sent to logger 538 NuGet Package : Add repository metadata (Thanks to MaximRouiller for PR 539) 540 Missing null check before runner dispose Notes 518 NUnit VSIX test adapters deprecation notice added. NUnit will still deliver a vsix for this version. NUnit3 Test Adapter for Visual Studio - Version 3.10 - March 5, 2018 Features 461 Publish symbols with the adapter for debugging into the adapter and NUnit Resolved Issues 47 Adapter runs explicit tests when TFS TestCaseFilter is used 296 Mono.Cecil causes OutOfMemoryException with new .csproj PDBs 310 Consistent Category Display in Test Explorer Window 365 An exception occurred while invoking executor: Could not load file or assembly System.Runtime.InteropServices.RuntimeInformation (Thanks to halex2005 for PR 418) 419 Test result is Skipped when an exception has been thrown and the only warning is in TearDown 444 Dump file is not created when the test crashes 452 Adapter does not seem to respect any TestCategory filtering 460 Failure to load dependency assembly causes hang Also see Release Readiness Review Special thanks Special thanks to : Joseph Musser for awesome work on this release, and to Loren Halvorsen for the workaround for VSTest issue 261. NUnit3 Test Adapter for Visual Studio - Version 3.9 - October 29, 2017 Change in supported versions This version supports Visual Studio from version 2012, Update 1 and upwards, and all subsequent versions in 2013, 2015 and 2017. Visual Studio 2012 RTM is then no longer supported. Features 390 Pass DisableAppDomain and DisableParallelization settings to the Engine 392 Improve performance of discovery (Thanks to Navin (Microsoft) for PR 393, PR 406 ) 394 The adapter tests are updated to use NUnit 3.8.1 Resolved Issues 372 netcoreapp + CultureInfo.CurrentCulture = bad time (Thanks to Aaron Housh (Dispersia) for PR 380 ) 386 DateTime.Parse issue during test discovery with certain cultures (Also fixed by PR 380 ) 302 BadImageFormatException building solution with unmanaged projects NUnit3 Test Adapter for Visual Studio - Version 3.8 - July 19, 2017 Features The adapter now support running .net core projects. See this post for details. Note: Only supported by the nuget adapter, not the vsix. The adapter now uses version 3.7 of the engine to run tests (360) Attachments can be added to tests (358) Prepared for new upcoming Test Explorer functionality, as documented in this RFC (351) Resolved Issues 298 \\(RANDOM_SEED\\) is appearing in non-test project build output 259 An exception occurred while invoking executor 'executor://nunit3testexecutor/' 314 Any TestFixture deriving from a base-class which defines unit-tests will fail when the base-class is from another class-library 231 Improved message on failed loading. See also PR 309 338 Unhandled Exception when running through vstest.console.exe /listtests NUnit3 Test Adapter for Visual Studio - Version 3.7 - January 25, 2017 Features The adapter now uses version 3.6 of the engine to run tests Warning messages are displayed. Note that Visual Studio currently lists them as skipped. Multiple assertion failures in a Multiple Assert block are displayed. Resolved Issues 218 No tests found to run when TestFixture is a nested class 256 Rename \\(RANDOM_SEED\\) 258 Modify adapter to display multiple assert information 268 Make the Icon Larger 272 URL for \"More information\" should point to correct landing page 273 Report Warnings in VS adapter 276 Adapter requires test project PDBs to be generated for tests to be executed 288 Test parameters containing semicolons are truncated NUnit3 Test Adapter for Visual Studio - Version 3.6.1 - December 5, 2016 Note This was a hotfix release of the vsix package only, fixing an issue that prevented it from installing under VS2012 and 2013. Resolved Issues 260 VSIX no longer visible in Visual Studio 2012 NUnit3 Test Adapter for Visual Studio - Version 3.6 - November 15, 2016 Features Adds support for Visual Studio \"15\" Resolved Issues 253 Warnings about \\(RANDOM_SEED\\) during build 262 Support for VS 15 NUnit3 Test Adapter for Visual Studio - Version 3.5 - October 22, 2016 Features The adapter now uses version 3.5 of the NUnit engine The NuGet package is now installed as a tool and no longer creates unnecessary references in the project Resolved Issues 97 Tests with dynamic/random parameters are never run closed:done is:bug pri:normal 204 If a test writes to Console.Error, the test passes but the session fails 220 Visual Studio Test Adapter - Writing to test output throws an error 221 Change adapter package to use tools directory 236 Update adapter to use Version 3.5 of the Engine 238 Just warn upon failing to restore random seed 239 Remove Error-level log messages from adapter where we don't want run to fail 243 NuGet package and copy local NUnit3 Test Adapter for Visual Studio - Version 3.4.1 - August 5, 2016 Features We now use Cake to build and package the adapter. Resolved Issues 198 Create Cake script for build 202 NUnit3 Test Adapter not running all tests in Visual Studio 2015 205 Adapter fails to find Mono.Cecil when targeting .NET 3.5 NUnit3 Test Adapter for Visual Studio - Version 3.4 - July 2, 2016 Features The adapter now uses the NUnit 3.4.1 TestEngine. TestRunParameters may now be provided in the .runsettings file. Immediate text output from tests now displays in the Output window. This includes any output produced through Console.Error, TestContext.Error or TestContext.Progress. Resolved Issues 132 Print to console not shown with v3 of adapter 138 Cannot run navigation tests under the console runner 145 Implement TestRunParameters inside .runsettings for runtime parameters 180 Upgrade to NUnit 3.4.1 181 Can't run requiring a 32-bit process 183 Use Mono.Cecil to retrieve source code locations 190 NUnit30Settings.xml is used by other process leads to hidden tests 192 Corrupt NUnit3Settings.xml causes crash NUnit3 Test Adapter for Visual Studio - Version 3.2 - June 3, 2016 Features The adapter now uses the NUnit 3.2.1 TestEngine. Resolved Issues 131 NUnit test adapter not running all tests - only on VS2015 135 Upgrade TestEngine to 3.2.1 162 Visual Studio 15 support 163 No source location when inheriting test methods from base test fixture 174 Clarify that NUnit v2 tests are not discovered by v3 adapter 176 More Information link in vsix broken NUnit3 Test Adapter for Visual Studio - Version 3.0 - April 2, 2016 Features This is the final production release of the 3.0 adapter. It continues to use the 3.0.1 release of the NUnit TestEngine. The adapter now uses a .runsettings file for all optional settings. Registry entries used in the CTP releases are no longer used. Resolved Issues 49 Need a way to specify test settings 52 Having ApartmentAttribute on both classes and methods causes test runner to hang 85 Failure to run tests under vstest.console from VS2015 92 Provide option to run in parallel for parallelized tests 120 The ability to set the LevelOfParallelism attribute through the VS adapter 153 TFS Filter that matches no names runs all tests NUnit3 Test Adapter for Visual Studio - Version 3.0 CTP 9 - April 2, 2016 Features The adapter continues to use the 3.0.1 release of the NUnit TestEngine. Resolved Issues 2 CI Build 34 Identifying Non-Primitive Parameterized Inputs in Adapter vs Console 50 NuGet version install script doesn't work with VS 2015 66 Build the adapter in AppVeyor 84 CopyLocal=False is an issue in a specific use case 94 More Information Link in Adapter Broken 96 Working directory is set to VS TestWindow extension directory 102 Package VS2012 assemblies as a private NuGet Package 104 Can't overload async/await methods with NUnit Test Adapter 106 Explicit tests appear as warnings in NUnit 3.0 109 NUnit 2 tests are detected as errors 112 Test adapter fails to load an assembly that references a class from NUnit.Framework but contains no tests 117 Version 3.0.8.0 as NuGet package only. No tests detected in Visual Studio 2015 118 Corrupted ignore.addins file in installation NUnit3 Test Adapter for Visual Studio - Version 3.0 CTP 8 - December 2, 2015 Features The adapter now uses the 3.0.1 release of the NUnit TestEngine. Resolved Issues 81 Cannot run tests with '>' in name 86 Generic Test Fixtures are not getting triggered 88 Upgrade adapter to use NUnit 3.0.1 NUnit3 Test Adapter for Visual Studio - Version 3.0 CTP 7 - November 16, 2015 Features The adapter now uses the released NUnit 3.0 TestEngine. Resolved Issues 75 Update adapter to use final release of NUnit 3.0 NUnit3 Test Adapter for Visual Studio - Version 3.0 CTP 6 - November 10, 2015 Features This release continues to use the NUnit RC 2 Engine. Resolved Issues 14 NUnit Adapter throws System.Reflection.TargetInvocationException, even if the solution build is OK 56 Exception System.Reflection.TargetInvocationException after NUnit 3.0.0-beta-5 upgrade 68 NUnit3TestExecutor.MakeTestFilter does not create valid xml 69 NUnit 3.0.0-rc-2 : System.Reflection.TargetInvocationException 70 NUnit3TestExecutor.MakeTestFilter creates element not handled by NUnit.Framework.Internal.TestFilter NUnit3 Test Adapter for Visual Studio - Version 3.0 CTP 5 - November 9, 2015 Features This release uses the NUnit RC 2 Engine. Resolved Issues 27 Async void methods do not show up as not runnable 43 Remove Wrappers for Engine Classes 45 Remove workaround for tests not sending events 53 Replace core engine 57 Confusing message when an NUnit V2 test is detected NUnit3 Test Adapter for Visual Studio - Version 3.0 CTP 4 - July 20, 2015 Features This release continues to use the NUnit 3.0 beta-2 engine but is nevertheless able to run tests that reference NUnit 3.0 beta-3 framework. When a debugger is attached, only a single worker thread is used to run tests. The adapter now compensates for the fact that NUnit does not send results for tests that were skipped due to an attribute on the fixture by generating those results itself. Resolved Issues 16 Adapter does not detect C++/CLI assemblies 26 Ignored test case does not show up as ignored 33 Inconsistent display behavior in Test Explorer 36 Option to set number of worker threads NUnit3 Test Adapter for Visual Studio - Version 3.0 CTP 3 - May 22, 2015 Features This release was issued to correct a problem with locking of assemblies in ctp-2. Resolved Issues 29 Latest test adapter locking dlls NUnit3 Test Adapter for Visual Studio - Version 3.0 CTP 2 - May 16, 2015 Features The adapter now uses the new nunit.core.engine to load and run tests, eliminating ad-hoc code that worked directly with the framework. This will allow us to much greater flexibility in the future. The adapter has been upgraded to use the beta-2 release of the NUnit core engine. Because the API has changed from beta-1, the adapter can only run tests built against the beta-2 release of NUnit. Resolved Issues 13 Adapter will not load as a NuGet package 17 Can't read app.config settings within test methods 18 Separate NUnit3TestDemo from NUnitTestAdapter solution 19 Use core engine 20 Upgrade NUnit to beta-2 NUnit3 Test Adapter for Visual Studio - Version 3.0 CTP 1 - April 6, 2015 Features Initial release of the test adapter using NUnit 3.0. Note that the adapter may not be used to run tests written against earlier versions of NUnit. The original adapter is still available for that purpose and both adapters may be installed if necessary. NUnit Test Adapter for Visual Studio - Version 2.0 - April 1, 2015 Features Tested for up to VS2015 Pre-release CTP 6 Updated to use NUnit 2.6.4 Adapter does not try to discover tests if the nunit.framework version is 3.0 or greater Bug Fixes #61 Confusing NUnit version message made clearer #62 Adapter uses shadowcopy setting in discoverer but not in the executor NUnit Test Adapter for Visual Studio (RTM) - Version 1.2 - September 17, 2014 Features Tested for up to VS2013 Update 3 Bugs 39 and 40 was inability to run under VS2012. This is now fixed. Bug Fixes #24 Long-running tests ignored #34 Adapter causes ArgumentException to be thrown by Microsoft logger proxy's SendMessage method #37 TestExecution throws Exception System.InvalidOperationException in TFS Build #38 NUnit only accepts absolute paths to test assembly #39 VSTest unable to find NUnit tests since 1.1.0.0 #40 NUnit version 1.1.0.0 is broken with test class which ran under 1.0.0.0 NUnit Test Adapter for Visual Studio (RTM) - Version 1.1 - April 26, 2014 Features Support for NUnit 2.6.3 Tested for up to VS2013 Update 2 RC Shadow copy now disabled by default, see issue #7 Unable to disable shadow copy. Registry settings added for some customization options, see Tips and Tricks All code moved to github Bug Fixes #13 Category attribute not working with TFS test case filter #21 Xamarin.iOS NUnit project causes adapter to throw NUnit Test Adapter for Visual Studio (RTM) - Version 1.0 - September 12, 2013 Features This is the release version 1.0 of the test adapter. Bug Fixes #1208148 The test result output node is not shown for debug/trace statements NUnit Test Adapter for Visual Studio (RC) - Version 0.97 - September 12, 2013 Features This is the release candidate for version 1.0 of the test adapter. Bug Fixes #1208161 NUnit Test Adapter runs [Explicit] unit tests in TFS Build #1210536 No Source Available for Async Tests #1165188 Clicking \"Run Selected Tests\" doesn't show Trace.WriteLine() output NUnit Test Adapter for Visual Studio (Beta 6) - Version 0.96 - June 28, 2013 Features Support for Visual Studio 2013 Preview Bug Fixes #1189268 Profile a test will crash with exception NUnit Test Adapter for Visual Studio (Beta 5) - Version 0.95.2 - June 7, 2013 Bug Fixes #1188000, adapter don't work with solutions with only .net 2.0/3.5 project NUnit Test Adapter for Visual Studio (Beta 5) - Version 0.95.1 Hotfix- May 28, 2013 Bug Fixes Hotfix for debug issue NUnit Test Adapter for Visual Studio (Beta 5) - Version 0.95 - May 10, 2013 Features #1174925 Add support for installing the adapter from NuGet Bug Fixes #1155617 Grouping by class name in VS 2012 doesn't work #1165359 Exception after building Coded UI test #1116747 vstest.executionengine.x86.exe does not terminate #1093178 Eliminate unnecessary files from VSIX NUnit Test Adapter for Visual Studio (Beta 4) - Version 0.94 - December 22, 2012 Features Works with Visual Studio 2012 Update 1 as well as the RTM. Supports filtering and sorting tests by Traits under Update 1. Supports use of standard filter expressions when running under TFS Update 1. NUnit Categories specified on the fixture class are now recognized and honored. Bug Fixes 1074891 Can't test multiple assemblies referencing different NUnit versions 1075893 Test execution fails if solution contains native C++ project 1076012 No source information found for async test methods 1087629 TestFixture Category not being recognized as traits in VS2012 update 1 1091020 Adapter doesn't support TFS Build traits/test case filtering NUnit Test Adapter for Visual Studio (Beta 3-2) - Version 0.93.2 - November 2, 2012 Bug Fixes 1074544 Failures in Test Discovery not reporting sufficient information NUnit Test Adapter for Visual Studio (Beta 3-1) - Version 0.93.1 - October 26, 2012 Bug Fixes 1072150 NUnit adapter 0.93 won't run selected tests NUnit Test Adapter for Visual Studio (Beta 3) - Version 0.93 - October 24, 2012 Features Works with Visual Studio 2012 RTM. Some features require the November CTP update. The adapter now uses NUnit 2.6.2. Among other things, this allows us to support async test methods. See the NUnit Release Notes for more info. Source file and line number can now be found for test cases that have an alternate name set. Console output from tests is now displayed in the Visual Studio Output window. TestFixtureSetUp and TestFixtureTearDown errors are now displayed in the Output window. The caret line (------^) is no longer displayed in the IDE since it depends on use of a fixed font. Tests may now be grouped and filtered by Category (only under the November CTP update for VS2012). Bug Fixes 1021144 Text output from tests not displayed in Visual Studio IDE 1033623 Not possible to include or exclude tests based on [Category] attribute Released 1040779 Null reference exception on generic test fixtures 1064620 Support async test methods 1065209 Should call both RecordEnd and RecordResult at end of a test 1065212 Upgrade NUnit to 2.6.2 1065223 Error messages assume a fixed font, but don't get one 1065225 No display for TestFixtureSetUp/TearDown or SetUpFixture errors 1065254 Cannot open test from Test Explorer for tests in a Parameterized Test Fixture 1065306 Generic Fixtures aren't discovered. 1066393 Unable to display source for test cases with an alternate name set 1066518 Executed fast test appears in Not Run category in Test Explorer NUnit Test Adapter for Visual Studio (Beta 2) - Version 0.92 - May 3, 2012 Features Works with Visual Studio 2012 Release Candidate Uses NUnit 2.6 Bug Fixes 992837 Unable to Debug using VS Test Adapter 994146 Can't run tests under .NET 2.0/3.5 NUnit Test Adapter for Visual Studio (Beta 1) - Version 0.91 - February 29, 2012 Features Built against Visual Studio 11 Beta 1 Uses NUnit 2.6 NUnit Test Adapter for Visual Studio (Alpha) - Version 0.90 - February 21, 2012 Features First release of the test adapter. Compatible with the Visual Studio 11 Developer Preview. Uses NUnit 2.6."
  },
  "articles/vs-test-adapter/AdapterV4-Release-Notes.html": {
    "href": "articles/vs-test-adapter/AdapterV4-Release-Notes.html",
    "title": "Adapter Release Notes | NUnit Docs",
    "summary": "Adapter Release Notes NUnit3 Test Adapter for Visual Studio and Dotnet - Version 5.1.0 - August 6, 2025 There are 10 issues fixed in this release. Enhancements 1266 Unable to pass test parameters via command line argument when using MTP. Thanks to NUnit Team member Terje Sandstrom for PR 1272 1248 How to completely suppress the Stack Trace in Test Results?. Thanks to NUnit Team member Terje Sandstrom for PR 1249 Bug fixes 1267 Incompatibility with MTP mode in .NET 10 SDK. Thanks to Youssef Victor for PR 1262 1261 Retry extension - no tests discovered with NUnit runner. Thanks to Youssef Victor for PR 1260 1258 Categories aren't shown in Visual Studio when MTP is on. Thanks to Youssef Victor for PR 1273 1251 Condition on TestingPlatformBuilderHook doesn't look correct. Thanks to Youssef Victor for PR 1253 1247 is there any way to treat an unhandled exception in a tear down as an error instead of a warning?. Thanks to Simon Cropp for PR 1246 1170 Version 5-beta crashes with nullref exception. Thanks to Amaury Levé for PR 1171 Deprecated features None The following issues are marked as breaking changes None Acknowledgements We want to express our heartfelt gratitude to everyone who has contributed to this release by reporting bugs, suggesting enhancements, and providing valuable feedback. Your efforts help make NUnit better for the entire community. A special thank you to the following reporters for identifying issues: Jonas Erler Philipp Naused Simon Cropp softworkz Terje Sandstrom victorburckel Youssef Victor and to the commenters who engaged in discussions and offered further insights: Amaury Levé CharliePoole errarr Jakub Jares Jonas Erler Michael Kriese Philipp Naused Simon Cropp softworkz Terje Sandstrom victorburckel Youssef Victor NUnit3 Test Adapter for Visual Studio and Dotnet - Version 5.0.0 - February 7, 2025 This major release introduce support for the new Microsoft Testing Platform. Enhancements 1152 Microsoft Testing Platform for NUnit You can find more information at this article on NUnit and Microsoft Testing Platform Breaking changes Althought this is a major version, there is no direct breaking changes when using it without enabling the MTP. Using it with MTP enabled will change some parts of how to use it, see the documentation for details. NUnit3 Test Adapter for Visual Studio and Dotnet - Version 4.6.0 - July 26, 2024 There are 10 issues fixed in this release. Enhancements 1138 Add partition filter parsing to the adapter. 1114 Is test result file creation now supported by NUnit using dotnet test?. 1188 Add support for ThrowOnEachFailureUnderDebugger setting Bug fixes 1186 Failure during unit test discovery doesn't cause entire test suite to fail. 1110 ConsoleOut=1 should be default. 1109 ConsoleOut=0 should turn off console output but doesn't. Refactorings 1115 Use mutex for file determination in TestOutputXml. Internal fixes 1163 Update packages and clean up new warnings. 1159 Remove azure pipeline and appveyor builds. 1158 Acceptance tests not working after NUnit 4 was released. Deprecated features None Others 1122 testcentric.engine.metadata (vulnerable dependency). The following issues are marked as breaking changes 1110 ConsoleOut=1 should be default. Change from former where ConsoleOut=2 was default. NUnit3 Test Adapter for Visual Studio and Dotnet - Version 4.5.0 - May 30, 2023 This is a version supporting the upcoming NUnit version 4. It uses a released version of the NUnit.Engine, version 3.15.4. 1080 Allow the adapter to be used with NUnit version 4 1100 Allow to debug parallel tests NUnit3 Test Adapter for Visual Studio - Version 4.4.2 - Mar 1, 2023 This is a hotfix for the 4.4.0 version. The 4.4.0 included the NUnit.Engine 3.16.3, which uses an external package for loading assemblies. It turns out the engine fails for certain types of loading, in particular when an assembly is loaded by reflection. In order to fix this, this version have reverted to a version of the NUnit.Engine based on 3.15.2, which does not have this way of loading assemblies. The included Engine is not available as a separate package, but if you use anything that needs the engine package (like the NUnit.Console), version 3.15.2 should work. The embedded engine handles the .net 8 the same way as with the 4.4.0 adapter. The following issues, all related to the same problem, are fixed in this release: 1065 WebHostBuilder.ConfigureServices method not found when using version 4.4.0 1066 Breaking change for TestAssemblyLoadContext 1069 Any type loaded from assembly at runtime does not match compile-time type 1070 NUnit failed to load test assembly after upgrading from 4.3.1 to 4.4.0 Thanks to everyone that reported in, and special thanks to everyone that provided repro solutions for the problem. NUnit3 Test Adapter for Visual Studio - Version 4.4.0 - Feb 26, 2023 :warning: This version has been unlisted on NuGet, please use version 4.4.2 instead. The main focus is the support for .Net 8. This version of the adapter will accept any higher version of the .net, also future higher versions than .net 8. The following issues are fixed in this release: 1049 .Net Framework tests fails when .Net 8 is present on system 1037 TestContext.Progress shows up as Warning in TFS/Azure Dev Ops. Thanks to mharwig for the PR. Beta release A beta release, Version 4.4.0-beta.1, was released on Feb 23, 2023. There is no changes between this and the previous beta release, except for updates of packages for the test projects. NUnit3 Test Adapter for Visual Studio - Version 4.3.2 - Des 9, 2023 A hotfix release for issue #1144. The adapter could not work running under .net 8 due to the use of an older NUnit.Engine. The engine has been updated to version 3.15.5 1144 Fixed by team. NUnit3 Test Adapter for Visual Studio - Version 4.3.1 - Nov 19, 2022 This is a hotfix release for three major and critical problems: .Net Framework (4.8 and lower) would crash due to InternalTracelog files trying to be written to the Program Files directory. InternalTracelog files would appear in root of solution TestOutputXml did not work correctly when specified In order to get these fixed the support for netcore2.1 had to be dropped. This version is also now unsupported by Microsoft, so the adapter follows that. 987 Regression on this issue due to the InternalTracelog files 1026 Current directory C:\\WINDOWS\\system32 again 1027 Test Explorer is finding tests, but not running them after upgrading to NUnit3TestAdapter v4.3.0 1028 Test discovery emits zero length internaltrace log file per project 1030 Problem if OutputXmlFolderMode setting is not in .runsettings 1031 TestOutputXml regressions Credits Thanks to Jan Inge Dalsbø, Taylor Willis, Kai Nadler, Barnabas Lakner, sandrohanea, Elliot Prior, Todd Ogin, Evheniyrz, Manfred Brands, Boris Drajer, Ken V, Mike Vorhees for all the help with reporting the issues, reproducing them, analysis and diagnostics, and confirming that 4.3.1 resolves the issues. Your help is really appreciated! NUnit3 Test Adapter for Visual Studio - Version 4.3.0 - Oct 29, 2022 This version is for support of the .net 7 framework. See an overview of supported frameworks here. The support is due to the updated embedded NUnit.Engine version 3.15.2. 987 System.ArgumentException: Unknown framework version 7.0 Other bugs fixed: 990 Missing output with failed test stack traces for Assert.Multiple 997 TRX report file folder inconsistent with XML report folder using .runsettings file. Note that a new runsettings flag has been added for supporting this, see OutputXmlFolderMode. NUnit3 Test Adapter for Visual Studio - Version 4.2.1 - Jan 21, 2022 This is a hotfix release for 941 When running dotnet test with filter, all tests are run and all console output is logged. This fix applies to test projects where all tests are excluded by a test item filter. Previously, as of v4.2.0, all tests were unintentionally run. Note that this issue did not affect category filters. NUnit3 Test Adapter for Visual Studio - Version 4.2.0 - Dec 19, 2021 This is a bug fix release, with the following fixes: 818 Known Vulnerability in System.Xml.XPath.XmlDocument 912 Explicit runs when using NUnit-filters 'cat!=FOO' 914 AddTestAttachment does not work anymore in VS2022 918 New DiscoveryMode doesn't play nicely with TestFixtureSource - Missing GenericFixture 919 VSTest test case filter does not work with parentheses 929 Lots of warnings logged when filter matches no tests 'cat=BAZ', including other issues in the same. Thanks to @runehalfdan for a lot of help reproducing and verifying these issues. Fixing this also improved performance, and cleared out issues with Explicit tests. 934 Console output no longer output by dotnet test -v n. Engine update The NUnit.Engine has been updated to version 3.13 in this release. See engine release notes for details. Development The debugging of an adapter has been made simpler, using just a runsetting to enable it. See this post for details on the process. NUnit3 Test Adapter for Visual Studio - Version 4.1.0 - Nov 8, 2021 This is a bug fix release, with the following fixes: 516 ArgumentException when whitespace sent to logger. Thanks to Matt Jones - mthjones for a very good repro, that helped nail this down! 865 Breaking changing in 3.17 on \"Exception encountered unloading application domain\" 869 NUnitTestAdapter - Discovery exception 884 NUnit3TestAdapter 4.0.0 - DiscoveryException: Not a TestFixture, SetUpFixture or TestSuite, but ParameterizedFixture NUnit3 Test Adapter for Visual Studio - Version 4.0.0 - June 6, 2021 This major release contains a series of changes, and also underlying changes in the adapter. This is currently the version that will support Visual Studio 2022. The earlier versions will initially not support VS 2022. (There is a currently unknown issue that blocks the 3.X series for VS 2022. It is currently unclear if the Visual Studio team may be able to fix this issue. Any fix from the adapter side will include an upgrade, and then the 4.X series is the solution for that.) Explicit works now for all versions of Visual Studio. This is covered by several issues, see below on alpha and beta release notes. See the alpha and beta release notes below for more issues and features that have been resolved and is included in this major release. The following additional features have been implemented in the final release. 671 Exception in OneTimeSetUp has no stack trace 843 Reporting random seed for a test case 863 The Test Name is by default added to the console output for tests. It can be turned off by the UseTestNameInConsoleOutput property. The following additional issue has been resolved: 779 Filtering tests with any \"PropertyAttribute\" 852 NullReferenceException in ExtractTestFixture in v4.0.0-beta2. NUnit3 Test Adapter for Visual Studio - Version 4.0.0-beta.2 - April 6, 2021 This will be a short beta.2, given we don't hit on any intricate issues. A major change in this version is the upgrade of the NUnit.Engine to version 3.12, and thus Mono.Cecil is no longer used. Instead it has a reduced version (based on Mono.Cecil) packed into TestCentric.engine.metadata doing the same job with navigation data. The following issues have been resolved: 824 \"Not a TestFixture or TestSuite, but SetUpFixture\" exception is being thrown in case of more than one SetUpFixture 811 \"System.FormatException: The UTC representation of the date falls outside the year range 1-9999\" from skipped test in Eastern European time zone. Thanks to KalleOlaviNiemitalo for suggesting the fix. Also a performance improvement was done, thanks to Pakrym for the PR 821 NUnit3 Test Adapter for Visual Studio - Version 4.0.0-beta.1 - Nov 20, 2020 This beta is based on the earlier alpha version, and includes new fixes, some reported in the alpha. A great thank you to those who reported and checked out the fixes in the alpha! The alpha has more than 32000 downloads, with only a few issues reported, so we feel safe to move up to a beta. The time for beta will be much shorter, so we might be able to release a final 4.0.0 version before end of 2020. We have also been able to shoehorn some new features into the release. 770 \"Not a TestFixture, but TestSuite\" error when using un-namespaced SetupFixture. 774 Tests not executed if Console.WriteLine() is used. 780 NUnit3TestAdapter 3.17.0 empty output file regression? 781 An exception occurred while test discoverer 'NUnit3TestDiscoverer' was loading tests. Exception: Object reference not set to an instance of an object, with VS2015. 785 Seemingly redundant dependency on Microsoft.DotNet.InternalAbstractions. Thanks to teo-tsirpanis for PR 790. 786 When using TRX logger, should warn about incompatible test adapter across .NET Framework and .NET Core and/or log where an adapter is located. 788 Documentation: Broken links in user guide [vs-test-adapter/Resources.html]. 797 Proprietary licensed files 800 Rerun in azure devops overwrites last test results xml. Thanks to netcorefactory for PR 799. NUnit3 Test Adapter for Visual Studio - Version 4.0.0-alpha.1 - July 12, 2020 This is an early pre-release version. The code has been rewritten/refactored in order to get some of the more complex issues fixed. It does pass all the automatic tests we have, but there are still more tests we would like to take it through, before we release a beta. We would really appreciate it if you give this alpha a spin. and report whatever you find back to us. The major fixes now are Explicit runs are fully back, both in Visual Studio and on command line with dotnet test and vstest.console. Further there has been a significant performance improvement for large test sets, and in particular when you run with categories or other filters. For those interested in details, some of this has been achieved by converting the VSTest type of filters to NUnit native filters (Thanks to Charlie Poole for his excellent contribution here.). 497 Dotnet test with category filter is slow with a lot of tests 545 Setting TestCaseSource to Explicit makes other tests in fixture explicit 612 It is not possible to run an explicit test from Test Explorer 658 Explicit tests are automatically run in Visual Studio 2019 767 Replace use of VSTest filters with NUnit filters"
  },
  "articles/vs-test-adapter/Debugging.html": {
    "href": "articles/vs-test-adapter/Debugging.html",
    "title": "Debugging the NUnit3TestAdapter | NUnit Docs",
    "summary": "Debugging the NUnit3TestAdapter Enable Tracing Before debugging the adapter, check the trace outputs, which can be enabled using runsettings, either from a file or the command line. Enable the following features: <DumpXmlTestDiscovery>true</DumpXmlTestDiscovery> <DumpXmlTestResults>true</DumpXmlTestResults> This will create a Dump folder under the executing bin directory, containing one file for each setting. These files include both the input from the testhost and the resulting data returned by the framework/engine. Enabling debugging Debugging the adapter is done by first creating a debug version of the adapter. You can then enable a debug run by passing one of the NUnit debug settings using runsettings. The symbols are: NUnit.DebugExecution NUnit.DebugDiscovery NUnit.Debug The last setting is equal to setting both of the two above. From command line, you can set these by adding dotnet test -- NUnit.DebugExecution=true If you want to do this using Visual Studio, you must add a runsettings file, and add these settings there to the NUnit section. A detailed explanation of the process can be found in this blog post Debugging earlier versions See this blog post for details on that process."
  },
  "articles/vs-test-adapter/Index.html": {
    "href": "articles/vs-test-adapter/Index.html",
    "title": "Visual Studio Test Adapter | NUnit Docs",
    "summary": "Visual Studio Test Adapter The NUnit 3 Test Adapter allows you to run NUnit 3 and 4 tests inside Visual Studio or with dotnet on the command line. The current release is designed to work with Visual Studio 2012, 2013, 2015, 2017, 2019 and 2022. Some features are not available under VS2012 RTM. It also works from the command line using either vstest.console or dotnet test. The current release works with .net framework 3.5 and higher, with .net core 3.*, and with .net 5, .net 6, and .net 7. Releases of Visual Studio prior to VS 2012 did not have the ability to directly run tests built with Open Source testing frameworks like NUnit. Download Released versions Download Pre-release versions The adapter is delivered as a nuget package to be installed into all test projects. Note Up to version 3.17 there is also a VSIX extension version, which was used earlier for Visual Studio up to version 2019. The support for this has been deprecated, and the existing VSIX version does not work for VS 2022. The recommendation is to avoid this altogether and use the nuget version. It is not possible to run NUnit 2.x tests using this adapter. Use the original adapter for that purpose. If you need to work with projects using NUnit 2.x and other projects using NUnit 3, you may install both versions of the adapter."
  },
  "articles/vs-test-adapter/Known-Problems.html": {
    "href": "articles/vs-test-adapter/Known-Problems.html",
    "title": "Known Problems | NUnit Docs",
    "summary": "Known Problems Using both the VSIX adapter and nuget adapters at the same time can lead to discovery issues; see nunit3-vs-adapter/issues #769. The resolution is to uninstall the VSIX adapter, and only use the nuget adapters. The VSIX adapters are being deprecated in later VS versions. Support for Explicit keyword 1 Adapter versions in the 4.XX series support the explicit keyword in all Visual Studio versions. 2 Adapter versions in the 3.XX series: From version 16.2 (Visual Studio 2019) the Explicit keyword is no longer explicitly supported by Visual Studio. If you want to use it, it does exist as a Category, so you can use it as a category filter. There is no test status in Visual Studio corresponding to NUnit's Inconclusive result, so tests with this result are reported as Not Run. Click on the individual test to see the result. Theories are reported as individual cases, rather as a single unit. In NUnit, tests have names, which are not necessarily unique. Visual Studio wants the names to be unique. So if two tests have the same name, VS displays a warning message in the output window. The message may be ignored. Two separate results will be shown under the single test in the explorer pane. Startup performance is substantially improved but is still slower than using NUnit directly. Applies to pre-VS2017: When using a VSIX adapter and the NuGet adapter, the VSIX adapter will be used regardless of the NuGet adapter version. Workaround: Make sure you have upgraded VSIX adapter to latest version, or uninstalled it if you have the NuGet adapter in a solution. The adapter will display its version number in the Output window under Tests. Avoid using the VSIX adapter for VS2017 and upwards. It is being deprecated, but is still supported optionally in VS2019. Visual Studio 2017 Live Unit Testing require NUnit3. The NUnit2 adapter doesn't support Live Unit Testing. Exception: Could not load file or assembly 'nunit.engine' - Is caused by an incomplete copy of the adapter in the Visual Studio cache. Close Visual Studio and delete C:\\Users\\username\\AppData\\Local\\Temp\\VisualStudioTestExplorerExtensions\\NUnit3TestAdapter.{{version}} Issues with other tools Versions of ReSharper earlier than the 8.2 version has an issue with the NuGet adapter, which will prevent NUnit tests from running. Make sure you have updated Reshaper to at least version 8.2. ReSharper version 2018.1 are not able to work with adapter versions >= 3.12. This is fixed in 2018.3. See Issue638 for details."
  },
  "articles/vs-test-adapter/NUnit-And-Microsoft-Test-Platform.html": {
    "href": "articles/vs-test-adapter/NUnit-And-Microsoft-Test-Platform.html",
    "title": "NUnit and Microsoft.Testing.Platform | NUnit Docs",
    "summary": "NUnit and Microsoft.Testing.Platform Overview Microsoft.Testing.Platform (MTP) is the new platform for testing from Microsoft. Test projects can be run as executables, as with NUnitLite currently. There is no longer a test runner; the executable is the test runner. It will take time to develop feature parity with NUnit's current system, and there are many historical factors to consider. But, the NUnit team recognizes that in the meantime, there needs to be a bridge between these two. In NUnit, the NUnit3TestAdapter contains what is necessary to run the MTP using the existing test runners. This means we have two modes of MTP operation: either use the new platform but not as an executable, or use it as an executable too. Changing a Project to Use MTP To change a current test project to use MTP, you need to use version 5.0 or greater of the NUnit3TestAdapter. Note that this version can run both with and without MTP, and you can easily switch between them by setting two project properties. In a property group (use the top-level one), add the following two properties: <EnableNUnitRunner>true</EnableNUnitRunner> <OutputType>Exe</OutputType> The first property, EnableNUnitRunner, enables the MTP. The second enables it to also run as an executable (but it doesn't prevent you from using it in Test Explorer or through dotnet test. Switching from VSTest to dotnet test You can switch between VSTest and dotnet test using a property in your csproj (or Directory.Build.props): <TestingPlatformDotnetTestSupport>true</TestingPlatformDotnetTestSupport> See this article for more information. Information on the Microsoft.Testing.Platform Microsoft.Testing.Platform Use Microsoft.Testing.Platform with dotnet test Microsoft.Testing.Platform Architecture NUnit Samples Adapter issue for implementing MTP"
  },
  "articles/vs-test-adapter/Resources.html": {
    "href": "articles/vs-test-adapter/Resources.html",
    "title": "Resources | NUnit Docs",
    "summary": "Resources Further information For more information see the blogs by Charlie Poole, Rob Prouse and Terje Sandstrom The MSDN ALM blog post series on How to Manage Unit Tests in Visual Studio 2012 Update 1 is useful for later versions as well: Part 1: Using Traits in the Unit Test Explorer Part 2: Using Traits with different test frameworks in the Unit Test Explorer Part 3: Unit testing with Traits and code coverage in Visual Studio 2012 using the TFS Build For Information on testing .Net core see Testing .NET Core with NUnit in Visual Studio 2017 Reporting Problems Bugs should be reported using the issue tracker on Github."
  },
  "articles/vs-test-adapter/Supported-Frameworks.html": {
    "href": "articles/vs-test-adapter/Supported-Frameworks.html",
    "title": "Supported Frameworks | NUnit Docs",
    "summary": "Supported Frameworks The table below shows the supported adapter versions for a given framework version. Framework version Supported by Adapter versions Comment Net Core 1.0 3.8 - 3.15.1 Net Core 2.0 3.8 - 3.15.1 Net Core 2.1 3.8 - 4.3.0 Net Core 2.2 3.8 - 4.3.0 Net Core 3.0 3.8 - 4.3.0 Net Core 3.1 3.8 - up to latest Net Framework 3.5 All up to 4.3.X Net Framework 4.X-4.6.1 All up to 4.3.X Net Framework 4.6.2 - 4.8 3.8 - up to latest Net 5 Works with 3.15.1 and upwards May also work with earlier versions, but not tested Net 6 Works with 4.1 and upwards May also work with earlier versions, but not tested Net 7 Works with 4.3 and upwards Net 8+ Works with 4.3.2 and upwards The adapter is shipped with two different versions of the test framework. The first is the full framework version, which is used for .NET Framework based test projects. The second is the .NET (Core) version, which is used for .NET Core 1.0, 2.0, 2.1, 2.2, 3.0, 3.1, 5.0, 6.0, 7.0, 8.0 and upwards. The different versions of the adapter supports different versions of the test framework. The table above shows the supported versions. Version 4.3.2 of the adapter will support future versions of .net, as long as there are no breaking changes. (Earlier versions have been blocking that based on the table above). The included versions are as shown below, only the versions where changes are done are listed. Adapter version .NET framework version .NET (core) version Comment 3.8 3.5 1.0 Some versions included 2.0 too 3.16.0 3.5 2.1 4.3.1 3.5 3.1 4.4.0 4.6.2 3.1 Traps Microsoft.NET.Test.Sdk 17.4.0 is not compatible with .NET Framework lower than 4.6.2 Tips See Adapter/Engine compatibility for information on which engine versions are being used with the adapter."
  },
  "articles/vs-test-adapter/Tips-And-Tricks.html": {
    "href": "articles/vs-test-adapter/Tips-And-Tricks.html",
    "title": "Tips and Tricks | NUnit Docs",
    "summary": "Tips and Tricks NUnit 3 dotnet test and VS Test .runsettings configuration Certain NUnit Test Adapter settings are configurable using a .runsettings file. The following options are available: Key Type Options Default InternalTraceLevel enum Off, Error, Warning, Info, Verbose, Debug Nothing => Off NumberOfTestWorkers int nr of workers -1 ShadowCopyFiles bool True, False False Verbosity int -1, 0-5 . -1 means quiet mode 0 UseVsKeepEngineRunning bool True, False False BasePath string path ? PrivateBinPath string directory1;directory2;etc ? RandomSeed int seed integer random DefaultTimeout int timeout in mS, 0 means infinite 0 DefaultTestNamePattern string Pattern for display name {m}{a} WorkDirectory string specify directory Test assembly location TestOutputXml string specify directory Test Result Xml output folder OutputXmlFolderMode enum UseResultDirectory,RelativeToResultDirectory,RelativeToWorkFolder,AsSpecified RelativeToWorkFolder DumpXmlTestDiscovery bool Enable dumping of NUnit discovery response xml false DumpXmlTestResults bool Enable dumping of NUnit execution response xml false PreFilter bool Enable pre-filtering to increase performance for Visual Studio testing false ShowInternalProperties bool Turn on showing internal NUnit properties in Test Explorer false Where string NUnit Filter expression UseParentFQNForParametrizedTests bool Enable parent as FQN for parametrized tests false UseNUnitIdforTestCaseId bool Uses NUnit test id as VSTest Testcase Id, instead of FullyQualifiedName false ConsoleOut int Sends standard console output to the output window 1 UseTestNameInConsoleOutput bool Adds name of test as a prefix in the output window for console output true StopOnError bool Stops on first error false SkipNonTestAssemblies bool Adapter supports NonTestAssemblyAttribute true MapWarningTo enum Map Assert.Warn to either Passed, Failed or Skipped Skipped DisplayName enum Set what a DisplayName is, options: Name, FullName or FullNameSep Name FullnameSeparator string FullNameSep separator ':' DiscoveryMethod enum How execution discovery is done, options are Legacy or Current Current AssemblySelectLimit int Number of tests accepted before filters are turned off 2000 NewOutputXmlFileForEachRun bool Creates a new file for each test run false IncludeStackTraceForSuites bool Includes stack trace for failures in suites, like exceptions in OneTimeSetup and OneTimeTearDown true IncludeStackTrace bool Includes stack trace for all failures true ExplicitMode enum Changes handling of explicit tests, options are Strict or Relaxed Strict SkipExecutionWhenNoTests bool Skip execution if no tests are found false AllowParallelWithDebugger bool Allow parallel execution when debugger is attached false ThrowOnEachFailureUnderDebugger bool false Visual Studio templates for runsettings You can install item templates for runsettings in Visual Studio (applies to version 2017, 2019 and upwards) which includes the NUnit settings mentioned here. Note that there are available separate installs for earlier Visual Studio versions, links to these can be found in the above. Example implementation See https://github.com/nunit/nunit3-vs-adapter/blob/8a9b8a38b7f808a4a78598542ddaf557950c6790/demo/demo.runsettings NUnit .runsettings implementation https://github.com/nunit/nunit3-vs-adapter/blob/master/src/NUnitTestAdapter/AdapterSettings.cs#L143 Details DefaultTestNamePattern The default format used to provide test names, expressed as an NUnit Template Based Test Name Pattern. WorkDirectory Our WorkDirectory is the place where output files are intended to be saved for the run, whether created by NUnit or by the user, who can access the work directory using TestContext. It's different from TestDirectory, which is the directory containing the test assembly. For a run with multiple assemblies, there could be multiple TestDirectories, but only one WorkDirectory. User sets work directory to tell NUnit where to put stuff like the XML or any text output. User may also access it in the code and save other things there. Think of it as the directory for saving stuff. TestOutputXml If this is specified, the adapter will generate NUnit Test Result Xml data in the folder specified here. If not specified, no such output will be generated. The folder can be An absolute path A relative path, which is then relative to either WorkDirectory, or if this is not specified, relative to the current directory, as defined by .net runtime. (From version 3.12) OutputXmlFolderMode This setting sets which folder the TestOutputXml will be going to. The default is the RelativeToWorkFolder (see WorkDirectory) above. The option UseResultDirectory will put the results in the same directory as the Trx files, the overall specified test result directory. The last option is the RelativeToResultDirectory, which is normally some path below the result directory. The last option is AsSpecified, which should be used when TestOutputXml is an absolute path. (From version 4.3.0) The last option AsSpecified is set automatically when TestOutputXml is an absolute path. (From version 4.3.1) InternalTraceLevel This setting is a diagnostic setting forwarded to NUnit, and not used by the adapter itself. For further information see the NUnit Tracelevel documentation NumberOfTestWorkers This setting is sent to NUnit to determine how parallelization should be performed. Note in particular that NUnit can either run directly or for parallel runs use queue of threads. Set to 0, it will run directly, set to 1 it will use a queue with a single thread. ShadowCopyFiles This setting is sent to NUnit to enable/disable shadow-copying. Verbosity This controls the outputs from the adapter to the Visual Studio Output/Tests window. A higher number includes the information from the lower numbers. It has the following actual levels: -1 : Quiet mode. Only shows errors and warnings. 0 : Default, normal information verbosity 1-3: Some more information from setting are output (in particular regarding parallelization) 4: Outputs the values from the runsettings it has discovered. 5: Outputs all debug statements in the adapter UseVsKeepEngineRunning This setting is used by the adapter to signal to the VSTest.Execution engine to keep running after the tests have finished running. This can speed up execution of subsequent test runs, as the execution engine already is loaded, but running the risks of either holding onto test assemblies and having some tests not properly cleaned out. The settings is the same as using the Visual Studio Test/Test Settings/Keep Test Execution Engine running. DumpXmlTestDiscovery and DumpXmlTestResults These settings are used to dump the output from NUnit, as it is received by the adapter, before any processing in the adapter is done, to disk. It is part of the diagnostics tools for the adapter. You can find the files under your current output folder, in a sub-folder named Dump. (Note: This is not the same as the TestResults folder, this data is not test results, but diagnostics dumps) PreFilter A pre-filter will improve performance when testing a selection of tests from the Test Explorer. It is default off, because there are issues in certain cases, see below. If you don't have any of the cases below, you can turn PreFilter on. Your code contains a SetupFixture #649 Your code uses a TestCaseSource and uses SetName to set the display name instead of SetArgDisplayNames #650 You are using a version of NUnit lower than 3.11 #648 If you just need to add this, you can add a runsettings file (any filename, extension .runsettings) containing: <RunSettings> <NUnit> <PreFilter>true</PreFilter> </NUnit> </RunSettings> (From version 3.15.1) ShowInternalProperties The NUnit internal properties have been \"over-populating\" in the Test Explorer. These are default filtered out, although you may still see these when you have Source Based Discovery (SBD) turned on (which is the default in VS). Once you have run test execution, they will be gone. We expect this part of the issue (SBD) to be fixed in VS. If you still want to see them, set this property to true. Where A NUnit Test Selection Language filter can be added to the runsettings file. The details are described in this blog post Using the runsettings should be like: <RunSettings> <NUnit> <Where>cat == SomeCategory or method == SomeMethodName or namespace == My.Name.Space or name == 'TestMethod(5)'</Where> </NUnit> </RunSettings> Note that the Where statement does not work for the Visual Studio Test Explorer, as it would generate a conflict with the test list the adapter receives. It is intended for use with command line tools, dotnet test or vstest.console. (From version 3.16.0) UseParentFQNForParametrizedTests Setting this may give more stable results when you have complex data driven/parametrized tests. However, when this is set selecting a single test within such a group, means that all tests in that group is executed. Note that this often has to be set together with UseNUnitIdforTestCaseId (From version 3.16.1) UseNUnitIdforTestCaseId The default setting is false, causes the VSTest Testcase ID to be based on the NUnit fullname property, which is nearly equal to a FullyQualifiedName. The fullname is also set into the Testcase FullyQualifiedName property. By setting this property true, it shifts to using the NUnit id as the basis for the testcase id. This may in certain cases give more stable results, and are more correct. However, it has been seen to also have adverse effects, so use with caution. (From version 3.16.1) ConsoleOut When set to 1 or 2 (1 is default), will send Console standard output to the Visual Studio Output/Test window, and also with dotnet test, it will appear in the output. Note The ConsoleOut default changed from 2 to 1 in v4.6.0 Disable this by setting it to 0, which is also the default for version earlier than 3.17.0. The value 1 sends it out as Information, while 2 sends it out as Warning. Using dotnet test with ConsoleOut=1 (Information) (dotnet test -- NUnit.ConsoleOut=1), nothing will appear in the output. Setting ConsoleOut=2 (Warning) the message will be shown. Adding the logger dotnet test -l \"console;verbosity=detailed\" -- NUnit.Consoleout=1 the message will be shown. See Issue 343 for more information and discussion In earlier versions you had to use -v n, but that is no longer required. In order to silence it in dotnet test you have to do: dotnet test -- NUnit.ConsoleOut=0 (Note the space after --. ) (From version 3.17.0, Modified in 4.2.0) UseTestNameInConsoleOutput When set to true, the default, the name of the test is added as a prefix in front of each console line output. This only applies to the output in the output window. (From version 4.0.0) StopOnError When enabled (set to true), the tests will stop after the first test failed. Useful when working with a system with many tests running for a long time, where a few fails. It can then speed up by stopping at the first one. See Issue 675 for more information and discussion (From version 3.17.0) MapWarningTo Assert Warnings will default map to Skipped, but you can set this to any other state, using MapWarningTo. The options are: Passed, Failed or Skipped. (From version 3.17.0) SkipNonTestAssemblies If the attribute NonTestAssembly is added in an assembly, it will be skipped from further testing. If RTD is enabled in Visual Studio, the tests will be displayed, but running will skip them. See explanation for the NonTestAssembly Attribute, and Issue explanation here. (From version 3.17.0) (Default changed to true from 4.0.0) DisplayName The default for Test Explorer DisplayName is to use the Name of the test, which normally is the method name. Using DisplayName you can change between Name, FullName or FullNameSep. The last one will then use the FullNameSeparator,which defaults to ':'. See Issue 640 for explanations of use and sample code here. (From version 3.17.0) FullNameSeparator The separator character used when DisplayName is FullNameSep. It is default ':', but can be changed to anything. (From version 3.17.0) DiscoveryMethod The 4.0 version of the NUnit3TestAdapter has a rewritten discovery mechanism and also other redesigns/refactoring done. This setting let you switch back to the old form of discovery, using the setting Legacy. The default value is Current. The Current setting enables the Explicit feature back. It also performs better (approx 30% faster for large test sets). It might affect certain special cases, so therefore you can switch back. (From version 4.0.0) AssemblySelectLimit If you run from the IDE (Visual Studio) the adapter will receive a list of tests to process. This is heavy when the number of tests are large. If the number of tests exceeds this limit, the list will be skipped and all tests in the assembly will be run (except those tests that are Explicit or Ignored). This might have an adverse effect if you select a category and you have more than 2000 tests, the category setting will be ignored. In that case, just increase this limit to higher than your number of tests. You might also receive a list from the command line, and in that case it will also be skipped the same way. Here the category will be honored since the category filter will be converted to a NUnit filter. (From version 4.0.0) NewOutputXmlFileForEachRun Default behavior is to produce one test output file which is being overwritten for each run Setting this to true, the adapter produces a new test output file for each run, numbering them sequentially. Default is false. The background is the following scenario, as described by netcorefactory in Issue 800: \"Running test in azure devops one can choose to rerun failed ( flaky ) tests. Mostly when running (selenium) e2e tests this becomes important. The .xml results file is currently overwritten each retry run. Other test coverage tooling dependent on this file receives only latest run results. Better to allow the possibility to deliver a results file per run.\" (From version 4.0.0) IncludeStackTraceForSuites Exceptions outside test cases are reported with its stack trace included in the message. One example here is exceptions in OneTimeSetUp and OneTimeTearDown. They belong to the outer suite, and their exceptions are reported as part of the message. This option includes the stack trace in that message. If this becomes too much information, this option turns the stack trace reporting off. Default is true. (From version 4.0.0) IncludeStackTrace This is default true. If turned off (false) it will stop outputting any stacktraces. This is in cases where you just want to reduce the total output and don't need the stacktrace information. (From version 5.1.0) ExplicitMode This setting can be either Strict or Relaxed. The default is Strict, which means that Explicit tests can only be run with other Explicit tests, and not mixed with non-Explicit tests. The Relaxed mode is the original NUnit mode, where if you select a category, a class or a set of tests, both explicit and non-explicit tests will be run. From Visual Studio Test Explorer there are no longer (since VS2019) any way of separating between a Run-All and run selected tests, so Relaxed mode doesn't work properly. It may or may not work for command line tests, dependent upon how your tests are set up and run. (From version 4.2.0) SkipExecutionWhenNoTests If set, this setting will skip execution for an assembly if no tests are found during the pre-execution discovery phase. It will give you a small performance boost, but if you skip the execution, this assembly will not generate any log files. The default is false. (From version 4.2.0) AllowParallelWithDebugger If set, this setting will allow parallel execution of tests even if the debugger is attached. The default is false. (From version 4.5.0) ThrowOnEachFailureUnderDebugger If set, this setting will surface an assertion exception for each failure in an Assert.Multiple block if the debugger is attached. The default is false. See docs for more info. (From version 4.6, require NUnit from 4.2) Some further information on directories (From comment on issue 575 by Charlie ) NUnit also supports TestContext.TestDirectory, which is the directory where the current test assembly is located. Note that if you have several test assemblies in different directories, the value will be different when each one of them accesses it. Note also that there is no way you can set the TestDirectory because it's always where the assembly is located. The BasePath is a .NET thing. It's the base directory where assemblies are searched for. You can also have subdirectories listed in the PrivateBinPath. NUnit takes care of all this automatically now, so the old console options are no longer supported. For finding things you want to read at runtime, the TestDirectory and the BasePath will usually be the same thing. Registry Settings Note As of the 3.0 final release, the registry settings are no longer recognized. Instead, use settings in the .runsettings file. NUnit 2.x NUnit 2.X does not support runsettings. Registry Settings for NUnit 2.x Certain settings in the registry affect how the adapter runs. All these settings are added by using RegEdit under the key HKCU\\Software\\nunit.org\\VSAdapter. ShadowCopy By default NUnit no longer uses shadowcopy. If this causes an issue for you shadowcopy can be enabled by setting the DWORD value UseShadowCopy to 1. KeepEngineRunning By default the NUnit adapter will \"Kill\" the Visual Studio Test Execution engine after each run. Visual Studio 2013 and later has a new setting under its top menu, Test | Test Settings | Keep Test Execution Engine Running. The adapter normally ignores this setting. In some cases it can be useful to have the engine running, e.g. during debugging of the adapter itself. You can then set the adapter to follow the VS setting by setting the DWORD value UseVsKeepEngineRunning to 1. Verbosity for NUnit 2.x Normally the adapter reports exceptions using a short format, consisting of the message only. You can change it to report a verbose format that includes the stack trace, by setting a the DWORD value Verbosity to 1."
  },
  "articles/vs-test-adapter/Trace-and-Debug.html": {
    "href": "articles/vs-test-adapter/Trace-and-Debug.html",
    "title": "How to enable Trace and Debug output | NUnit Docs",
    "summary": "How to enable Trace and Debug output Trace and Debug output is by default not sent to the console output, or anywhere else. If you want to have this output, you must add a TraceListener as documented in this article on trace and debug output."
  },
  "articles/vs-test-adapter/Usage.html": {
    "href": "articles/vs-test-adapter/Usage.html",
    "title": "Usage | NUnit Docs",
    "summary": "Usage In preparation for using the test adapter, make sure that the Unit Test Explorer is shown in your window. If you don't see it, use the menu ( Test | Windows | Test Explorer ) to show it and position the window where you would like it within Visual Studio. When you initially open a solution, no tests will be displayed. After compiling the assemblies in the solution, Visual Studio will interact with the NUnit Test Adapter to discover tests and a list of them will be shown in the Test Explorer. Click on Run All in the Test Explorer to run all the tests. You may also select one or more tests in the list and run them by right-clicking and using the context menu. The context menu also contains entries for debugging tests and for navigating to the source code of a test. Tests may be grouped by Duration and Outcome under VS2012 RTM and also by Traits and Project using Update 1 or later, and Class using Update 2 or later. NUnit translates any Categories and Properties used on your tests to Visual Studio as Traits. Tests may be filtered in Visual Studio under Update 1 or later by Trait, Project, Error Message, File Path, Fully Qualified Name, Output and Outcome. Use the search edit box at the top of the list of tests to specify a filter. Tests may be organized by play lists in Visual Studio under Update 2 or later. Playlists are more or less equal to the old test lists from VS 2010. Parameterized tests will show up as separate test cases for each set of parameters. For settings options, see the Tips and Tricks"
  },
  "articles/vs-test-generator/TestGenerator-Installation.html": {
    "href": "articles/vs-test-generator/TestGenerator-Installation.html",
    "title": "TestGenerator Extension for NUnit in Visual Studio Installation | NUnit Docs",
    "summary": "TestGenerator Extension for NUnit in Visual Studio Installation You can download this extension from inside Visual Studio, choosing Tools/Extensions and Updates and search for Test Generator. You will then find the appropriate extension for VS 2015 or VS 2017/2019. For Visual Studio 2022 You can download from the marketplace Visual Studio Gallery or from the GitHub Release page For Visual Studio 2017/2019 You can download from the marketplace Visual Studio Gallery or from the GitHub Release page For Visual Studio 2015 You can download from the marketplace Visual Studio Gallery or from the GitHub Release page"
  },
  "articles/vs-test-generator/TestGenerator-Release-Notes-VS2015.html": {
    "href": "articles/vs-test-generator/TestGenerator-Release-Notes-VS2015.html",
    "title": "TestGenerator Release Notes - VS2015 | NUnit Docs",
    "summary": "TestGenerator Release Notes - VS2015 TestGenerator Extension for NUnit in Visual Studio 2015 - Version 1.1 - March 5, 2017 Bugs and minor fixes #6 NUnit3 tests using removed ExpectedException attribute #10 Specify NUnit versions as v2 and v3 #11 Update more information link #14 Update NUnit version (will use latest version) Notes The TestGenerator extension is released as separate VSIXes for VS 2015 and VS 2017/2019. See Installation for details. The Version 2.X is for VS2017/2019, the Version 1.X is for VS 2015."
  },
  "articles/vs-test-generator/TestGenerator-Release-Notes-VS2017-VS2019.html": {
    "href": "articles/vs-test-generator/TestGenerator-Release-Notes-VS2017-VS2019.html",
    "title": "TestGenerator Release Notes - VS 2017 and 2019 | NUnit Docs",
    "summary": "TestGenerator Release Notes - VS 2017 and 2019 TestGenerator Extension for NUnit in Visual Studio 2017 and 2019 - Version 2.3 - September 20, 2019 Features PR 33 [Create Unit Test] Fixing package versions. This is needed in order to work for .net core projects. With Visual Studio 2019, Update 3, it is possible to use this extension to create tests. TestGenerator Extension for NUnit in Visual Studio 2017/2019 - Version 2.1 - November 22, 2018 Visual Studio 2017 15.9 and forward should have the adapter added to each test project. This release ensures that by fixing #25. Features 25 Add the test adapter as part of the package. Thanks to yowko for the PR TestGenerator Extension for NUnit in Visual Studio 2017/2019 - Version 2 - March 5, 2017 Features #8 Support for VS 2017/2019 Bugs and minor fixes #6 NUnit3 tests using removed ExpectedException attribute #10 Specify NUnit versions as v2 and v3 #11 Update more information link #14 Update NUnit version (will use latest version) Notes The TestGenerator extension is released as separate VSIXes for VS 2015 and VS 2017/2019. See Installation for details. The Version 2 is for VS2017/2019, the Version 1 is for VS 2015."
  },
  "articles/vs-test-generator/TestGenerator-Release-Notes.html": {
    "href": "articles/vs-test-generator/TestGenerator-Release-Notes.html",
    "title": "TestGenerator Release Notes - VS 2022 | NUnit Docs",
    "summary": "TestGenerator Release Notes - VS 2022 TestGenerator Extension for NUnit in Visual Studio 2022 - Version 3.0 - March 7, 2023 This version is an x64 only release. It is compatible with Visual Studio 2022. Fixes 41 Add Support for VS2022 47 Remove NUnit 2"
  },
  "articles/vs-test-generator/Visual-Studio-Test-Generator.html": {
    "href": "articles/vs-test-generator/Visual-Studio-Test-Generator.html",
    "title": "Visual Studio Test Generator | NUnit Docs",
    "summary": "Visual Studio Test Generator This is an extension for Visual Studio 2015, 2017/2019 and 2022 that extends the test functionality to allow you to create unit tests and IntelliTests. This extension extends the built in test generator functionality allowing developers to generate tests using NUnit 2.6.x (not for VS2022) or NUnit 3.X. Please note that IntelliTest is only available in Visual Studio Enterprise edition. Other versions of Visual Studio only have the Create Unit Tests menu option. Download You can download this extension in Visual Studio using Tools | Extensions and Updates... and searching for Test Generator NUnit Extension. You can also download from the Visual Studio Gallery for VS 2015 and here for VS 2017, or from the GitHub Releases Page. How to Use For more information on using IntelliTest and this extension, please see the Microsoft documentation. Right-Click to Create Tests Select NUnit from the Test Framework dropdown"
  },
  "articles/xamarin-runners/Getting-Started-in-Visual-Studio-for-Mac.html": {
    "href": "articles/xamarin-runners/Getting-Started-in-Visual-Studio-for-Mac.html",
    "title": "Getting Started In Visual Studio For Mac | NUnit Docs",
    "summary": "Getting Started In Visual Studio For Mac If you're using Visual Studio for Mac the NUnit templates extension can't be used. This guide assumes that you have a solution with either a PCL or a Shared project and a number of platform specific projects. It doesn't matter if you're using Xamarin.Forms or Xamarin.iOS/Xamarin.Android directly. Your solution might look something like this: Project Solution ...Project (Contains Shared Code) ...Project.iOS ...Project.Android Shared Test Project First, create a new PCL that holds your shared testing code, so the test code doesn't end up in production builds. Right Click on the Project Solution and Add a new project using the Cross-Platform Shared Library Template. Use Project.Tests as a name. Afterwards, your solution should look like this: Project Solution ...Project (Contains Shared Code) ...Project.iOS ...Project.Android ...Project.Tests (Holds your testing code) Edit the references of the newly created test project so that it contains a reference to the standard PCL. Afterwards, add a NuGet dependency on NUnit by right-clicking on Project.Tests and selection Add -> Add NuGet Package. Note Ensure you reference the same version of NUnit as the version of nunit.xamarin you are using. e.g. If you are using nunit.xamarin 3.0.1, add the v3.0.1 NUnit NuGet package. Afterwards, your test project is ready. Platform runners In order to run the tests it's necessary to create a project for each platform you'd like to support (iOS, Android and so on). Do so using the standard Xamarin templates for new platform projects. It's probably sensible to use a naming scheme like Project.Tests.iOS for the individual test projects do keep your solution structured. Project Solution ...Project (Contains Shared Code) ...Project.iOS ...Project.Android ...Project.Tests (Holds your testing code) ...Project.Tests.iOS ...Project.Tests.Android The NUnit.Xamarin runners are built using Xamarin.Forms, so you need to add NUnit, NUnit.Xamarin and Xamarin.Forms as NuGet dependencies to the newly created projects. It's also necessary to add a reference to the shared test project containing the tests. If you've followed the steps above, you can now replace the AppDelegate.cs or MainActivity.cs with the code shown below. Since your tests are not in the same assembly as the runner it's a good idea to create a canary test class in the Shared Test Projects that you can use to reference the test assembly explicitly. In the example below, the name of this class is MyTest.cs. Android MainActivity.cs [Activity(Label = \"NUnit 3\", MainLauncher = true, Theme = \"@android:style/Theme.Holo.Light\", ConfigurationChanges = ConfigChanges.ScreenSize | ConfigChanges.Orientation)] public class MainActivity : global::Xamarin.Forms.Platform.Android.FormsApplicationActivity { protected override void OnCreate(Bundle savedInstanceState) { base.OnCreate(savedInstanceState); global::Xamarin.Forms.Forms.Init(this, savedInstanceState); // This will load all tests within the current project var nunit = new NUnit.Runner.App(); // If you want to add tests in another assembly //nunit.AddTestAssembly(typeof(MyTests).Assembly); // Do you want to automatically run tests when the app starts? nunit.Options = new TestOptions { AutoRun = true }; LoadApplication(nunit); } } iOS AppDelegate.cs [Register(\"AppDelegate\")] public partial class AppDelegate : global::Xamarin.Forms.Platform.iOS.FormsApplicationDelegate { // // This method is invoked when the application has loaded and is ready to run. In this // method you should instantiate the window, load the UI into it and then make the window // visible. // // You have 17 seconds to return from this method, or iOS will terminate your application. // public override bool FinishedLaunching(UIApplication app, NSDictionary options) { global::Xamarin.Forms.Forms.Init(); // This will load all tests within the current project var nunit = new NUnit.Runner.App(); // If you want to add tests in another assembly //nunit.AddTestAssembly(typeof(MyTests).Assembly); // Do you want to automatically run tests when the app starts? nunit.Options = new TestOptions { AutoRun = true }; LoadApplication(nunit); return base.FinishedLaunching(app, options); } }"
  },
  "articles/xamarin-runners/Getting-Started-in-Visual-Studio.html": {
    "href": "articles/xamarin-runners/Getting-Started-in-Visual-Studio.html",
    "title": "Getting Started In Visual Studio | NUnit Docs",
    "summary": "Getting Started In Visual Studio The easiest way to get started is to install the NUnit Templates extension for Visual Studio. It will add project templates for the various Xamarin platforms. For more general information, see Testing Xamarin Projects using NUnit 3. Getting started In your solution; Add new test projects to your solution. These project types are included in the NUnit Templates Extension: NUnit 3 Test Project (Android). NUnit 3 Test Project (iOS), NUnit 3 Test Project (Universal Windows) Write your unit tests in this project, in a portable project, or in a shared project, referencing the project with the tests. Build and run the tests on your device or emulator If your tests are in a separate portable project, note that: You need to add that assembly to the NUnit.Runner.App in the startup code nunit.AddTestAssembly(typeof(MyTests).Assembly); Your portable project must reference the same NUnit Framework version as your nunit.xamarin version, e.g. if using nunit.xamarin 3.01, reference nunit.framework 3.01. The startup code for each platform is as follows; Android MainActivity.cs [Activity(Label = \"NUnit 3\", MainLauncher = true, Theme = \"@android:style/Theme.Holo.Light\", ConfigurationChanges = ConfigChanges.ScreenSize | ConfigChanges.Orientation)] public class MainActivity : global::Xamarin.Forms.Platform.Android.FormsApplicationActivity { protected override void OnCreate(Bundle savedInstanceState) { base.OnCreate(savedInstanceState); global::Xamarin.Forms.Forms.Init(this, savedInstanceState); // This will load all tests within the current project var nunit = new NUnit.Runner.App(); // If you want to add tests in another assembly //nunit.AddTestAssembly(typeof(MyTests).Assembly); // Do you want to automatically run tests when the app starts? nunit.Options = new TestOptions { AutoRun = true }; LoadApplication(nunit); } } iOS AppDelegate.cs [Register(\"AppDelegate\")] public partial class AppDelegate : global::Xamarin.Forms.Platform.iOS.FormsApplicationDelegate { // // This method is invoked when the application has loaded and is ready to run. In this // method you should instantiate the window, load the UI into it and then make the window // visible. // // You have 17 seconds to return from this method, or iOS will terminate your application. // public override bool FinishedLaunching(UIApplication app, NSDictionary options) { global::Xamarin.Forms.Forms.Init(); // This will load all tests within the current project var nunit = new NUnit.Runner.App(); // If you want to add tests in another assembly //nunit.AddTestAssembly(typeof(MyTests).Assembly); // Do you want to automatically run tests when the app starts? nunit.Options = new TestOptions { AutoRun = true }; LoadApplication(nunit); return base.FinishedLaunching(app, options); } } Windows 10 Universal MainPage.xaml <forms:WindowsPage x:Class=\"NUnit.Runner.Tests.MainPage\" xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\" xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\" xmlns:local=\"using:NUnit.Runner.Tests\" xmlns:d=\"http://schemas.microsoft.com/expression/blend/2008\" xmlns:mc=\"http://schemas.openxmlformats.org/markup-compatibility/2006\" xmlns:forms=\"using:Xamarin.Forms.Platform.WinRT\" mc:Ignorable=\"d\"> <Grid Background=\"{ThemeResource ApplicationPageBackgroundThemeBrush}\"> </Grid> </forms:WindowsPage> MainPage.xaml.cs public sealed partial class MainPage : WindowsPage { public MainPage() { InitializeComponent(); // Windows Universal will not load all tests within the current project, // you must do it explicitly below var nunit = new NUnit.Runner.App(); // If you want to add tests in another assembly, add a reference and // duplicate the following line with a type from the referenced assembly nunit.AddTestAssembly(typeof(MainPage).GetTypeInfo().Assembly); // Do you want to automatically run tests when the app starts? nunit.Options = new TestOptions { AutoRun = true }; LoadApplication(nunit); } } App.xaml.cs protected override void OnLaunched(LaunchActivatedEventArgs e) { // <SNIP> Frame rootFrame = Window.Current.Content as Frame; // Do not repeat app initialization when the Window already has content, // just ensure that the window is active if (rootFrame == null) { // Create a Frame to act as the navigation context and navigate to the first page rootFrame = new Frame(); rootFrame.NavigationFailed += OnNavigationFailed; // ==> ADD THIS LINE <== Xamarin.Forms.Forms.Init(e); if (e.PreviousExecutionState == ApplicationExecutionState.Terminated) { // TODO: Load state from previously suspended application } // Place the frame in the current Window Window.Current.Content = rootFrame; } // <SNIP> }"
  },
  "articles/xamarin-runners/index.html": {
    "href": "articles/xamarin-runners/index.html",
    "title": "NUnit Xamarin Runners | NUnit Docs",
    "summary": "NUnit Xamarin Runners The NUnit Xamarin Runners provide NUnit 3 test runners for Xamarin and mobile devices. See Testing Xamarin projects using NUnit 3 for more general information. Options Runner options are set inside a TestOptions object. For example: var nunit = new NUnit.Runner.App(); nunit.Options = new TestOptions { AutoRun = true }; The following options are available: Option Version added Type Usage AutoRun 3.0 Boolean If True, the tests will run automatically when the app starts, otherwise you must run them manually. TerminateAfterExecution 3.6.1 Boolean If True, app will exit cleanly after test execution. TcpWriterParameters 3.6.1 TcpWriterInfo Provide a TCP listener host and port, sends result as XML to the listening server. Takes a TcpWriterInfo - see below. CreateXmlResultFile 3.6.1 Boolean If True, create a xml file containing results. ResultFilePath 3.6.1 String Specify file path to save xml result file. TcpWriterInfo TcpWriterInfo takes three parameters: hostname, port, and an optional timeout in seconds (default 10). TcpWriterParameters = new TcpWriterInfo(\"192.168.0.108\", 13000, 10);"
  },
  "index.html": {
    "href": "index.html",
    "title": "NUnit Documentation Site | NUnit Docs",
    "summary": "NUnit Documentation Site This web site contains the documentation for all active NUnit projects as well as developer documentation for those working on NUnit or wishing to do so. User Documentation NUnit covers the core tools of NUnit, including the framework, NUnitLite, and the console runner. NUnit VS Adapter covers the test adapters for Visual Studio and .Net. NUnit Analyzers covers the NUnit Analyzers. NUnit VS Test Generator covers the Visual Studio extension for generating tests in both NUnit V2 and V3. NUnit Xamarin Runners covers the NUnit test runners for Xamarin and mobile devices. NUnit Engine covers the NUnit Engine, the central component all test runners are built around. Developer Documentation Team practices describe how NUnit works and how our teams work. Specifications are descriptions of features we plan to add."
  }
}