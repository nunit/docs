{
  "articles/developer-info/Best-practices-for-XML-documentation.html": {
    "href": "articles/developer-info/Best-practices-for-XML-documentation.html",
    "title": "Best Practices for XML Documentation | NUnit Docs",
    "keywords": "Best Practices for XML Documentation XML documentation has a significant impact on the end user's experience. Unlike other parts of the code, XML comments (as well as exception messages) are user-facing and highly visible. They can save valuable time and even make the difference for an end user between a confusing debugging session and no debugging needed in the first place. Polished and informative XML documentation provides a noticeably positive experience. Sentences Always end sentences with proper punctuation, typically a period. If there aren't enough words to form a sentence, it's likely that they are redundant. Try to add enough context to make a sentence to avoid anemic documentation. Rather than The comparer , say Used to compare the <paramref name=\"items\"/>. The added clarity is desirable. <see> , <paramref> and <typeparamref> Use <see cref=\"TypeOrMember\"/> , <paramref name=\"parameterName\"/> and <typeparamref name=\"T\"/> whenever possible. The compiler checks the validity of the names and overloads. Future refactoring can be done with confidence that you aren't leaving the docs out of date. This also provides a seamless experience by creating links in the Object Browser and intellisense and colorizes intellisense. Consider using <see langword=\"null\"/> for keywords to maintain the seamlessness. <summary> Add a <summary> tag for each public type and member. However, prefer to give each type and member a really communicative name. If those names end up covering all the user could need to know, remove the <summary> tag (if this does not cause a build warning) to avoid super redundant documentation. If they do not, add relevant details. <param> and <typeparam> Add a <param> tag for each parameter describing what effect it has (rather than what it is ). However, prefer to give each parameter a really communicative name. If those names end up covering all the user could need to know about all the parameters, remove all the <param> tags to avoid super redundant documentation. If they do not, add relevant details to each <param> to the extent possible. The same applies to <typeparam> tags. They are shown by intellisense as the user enters type parameter lists exactly the way <param> descriptions are shown as the user enters method parameter lists. <typeparam> elements are just as important on generic methods as they are on generic type definitions. <returns> and <value> Don't spend any time on the <returns> or <value> tags since the contents are not typically seen. Important details should all be in the <summary> . If the IDE auto-inserts them, just remove them. Empty tags Do not leave any empty tags. Either remove them or fill them out. This includes the compiler's all-or-none <param> and <typeparam> tag enforcement. <exception> Consider documenting things that lead to exceptions being thrown using the <exception> tag. This can really get the end user up to speed on things that aren't immediately obvious from the method signature. Sadly intellisense will only show the <exception> type thrown, not the message, so for important messages it's good to also include the message a second time in the summary: /// <summary> /// Does foo. If <see cref=\"OtherProperty\"/> is not set, throws <see cref=\"InvalidOperationException\"/>. /// </summary> /// <exception cref=\"InvalidOperationException\">Thrown when <see cref=\"OtherProperty\"/> is not set.</exception>"
  },
  "articles/developer-info/Coding-Standards.html": {
    "href": "articles/developer-info/Coding-Standards.html",
    "title": "Coding Standards | NUnit Docs",
    "keywords": "Coding Standards In order to keep the code consistent, we follow certain conventions. Many of the choices we have made are somewhat arbitrary and could easily have gone another way. At this point, most of these conventions are already well-established, so please don't re-open a discussion about them unless you have new issues to present. Notice that these standards are all stylistic. Do not write standards that tell people how to program. For example, we don't need a standard that tells us to always dispose of disposable objects because that's part of the normal \"standard\" for C# programming. In other words, these standards are about relatively trivial things that we have all agreed to do the same way. Making Changes If you do want to make changes, please initiate a discussion of what you want to change on the developer list first. If you are intending to standardize more things than we usually standardize, it's wise to discuss it first to avoid wasting time! General - Please Read This Follow these guidelines unless you have an extremely good reason not to. Add a comment explaining why you are not following them so others will know your reasoning. Don't make arbitrary changes in existing code merely to conform them to these guidelines. Normally, you should only change the parts of a file that you have to edit in order to fix a bug or implement new functionality. In particular, don't use automatic formatting to change an entire file at once as this makes it difficult to identify the underlying code changes when we do a code review. In cases where we make broad changes in layout or naming, they should be committed separately from any bug fixes or feature changes in order to keep the review process as simple as possible. That said, we don't do this very often, since we have real work to do! Visual Studio can be set up to match the coding standards by importing the nunit.vssettings file from this repository. This file will only change the C# indentation and formatting settings. It will not modify any other Visual Studio settings. It can be imported into Visual Studio 2010 and later by going to Tools | Import and Export Settings... Copyright NUnit is licensed under the MIT / X11 license. Each file is prefixed by the NUnit Copyright Notice enclosed in appropriate comment characters for the language of the file. Notes Charlie Poole is the copyright holder for the NUnit code on behalf of the NUnit community, at least until some other arrangement is made. Do not place your name on the copyright line if you wish to contribute code. The year given is the year of the file's creation. Subsequently, as copyrightable (non-trivial) changes are made, additional years or ranges of years may be added. For example, some file might include the statement Copyright (c) 2007-2015 Charlie Poole . Do not update the copyright years when no changes or only trivial changes are made to a file. Language Level Each NUnit project sets its own C# language level. We generally aim to keep the code buildable by folks who don't necessarily have the latest compilers, so this is sometimes not the very latest level. Currently, the maximum level for most NUnit projects is C# 6. Note that targeting a particular level of C# does not mean that all features are available. Features are limited based on the framework targeted as well. For example, the engine currently targets .NET 2.0, which means that System.Linq extensions cannot be used in the code. Layout Namespace, Class, Structure, Interface, Enumeration and Method Definitions Place the opening and closing braces on a line by themselves and at the same level of indentation as their parent. public class MyClass : BaseClass, SomeInterface { public void SomeMethod(int num, string name) { // code of the method } } An exception may be made if a method body or class definition is empty public virtual void SomeMethod(int num, string name) { } public class GadgetList : List<Gadget> { } Property Definitions Prefer automatic backing variables wherever possible public string SomeProperty { get; private set; } If a getter or setter has only one statement, a single line should normally be used public string SomeProperty { get { return _innerList.SomeProperty; } } If there is more than one statement, use the same layout as for method definitions public string SomeProperty { get { if (_innerList == null) InitializeInnerList(); return _innerList.SomeProperty; } } Spaces Method declarations and method calls should not have spaces between the method name and the parenthesis, nor within the parenthesis. Put a space after a comma between parameters. public void SomeMethod(int x, int y) { Console.WriteLine(\"{0}+{1}={2}\", x, y, x + y); } Control flow statements should have a space between the keyword and the parenthesis, but not within the parenthesis. for (int i = 1; i < 10; i++) { // Do Something } There should be no spaces in expression parenthesis, type casts, generics or array brackets, but there should be a space before and after binary operators. int x = a * (b + c); var list = new List<int>(); list.Add(x); var y = (double)list[0]; Indentation Use four consecutive spaces per level of indent. Don't use tabs - except where the IDE can be set to convert tabs to four spaces. In Visual Studio, set the tab size to 4, the indent size to 4 and make sure Insert spaces is selected. Indent content of code blocks. In switch statements, indent both the case labels and the case blocks. Indent case blocks even if not using braces. switch (name) { case \"John\": break; } Newlines Methods and Properties should be separated by one blank line. Private member variables should have no blank lines. Blocks of related code should have not have any blank lines. Blank lines can be used to visually group sections of code, but there should never be multiple blank lines. If brackets are not used on a control flow statement with a single line, a blank line should follow. public static double GetAttribute(XmlNode result, string name, double defaultValue) { var attr = result.Attributes[name]; double attributeValue; if (attr == null || !double.TryParse(attr.Value, NumberStyles.Any, CultureInfo.InvariantCulture, out attributeValue)) return defaultValue; return attributeValue; } Naming The following table shows our naming standard for various types of names. All names should be clear enough that somebody unfamiliar with the code can learn about the code by reading them, rather than having to understand the code in order to figure out the names. We don't use any form of \"Hungarian\" notation. For items that may vary by project, the projectâ€™s root .editorconfig and solution DotSettings may provide the defaults and diagnostics expected for PRs in that project. Named Item Naming Standard Notes Namespaces PascalCasing Types PascalCasing For framework types with a special C# name, we use the C# name. So... int rather than System.Int32. Methods PascalCasing Properties PascalCasing Events PascalCasing Public and Protected Fields PascalCasing(with allowance for API compatibility) Includes constant fields.Public and protected variable fields should be avoided. Private and Internal Fields (may vary by project) Includes constant fields.Do not use this with fields designated by a leading underscore. Keep each file to the same standard, renaming when changes are made.Use readonly wherever appropriate for private fields. Parameters camelCasing Local Variables camelCasing Comments Use doc comments on all publicly accessible members. Keep the audience in mind. For example, comments on publicly used framework methods or attributes should be written for easy understanding by users, while comments on internal methods should target folks who work on NUnit. Don't comment what is obvious. Do comment unusual algorithms and the reasoning behind some choices made. Use TODO comments when needed, but make sure to go back periodically and do whatever it is! File Organization Normally, have one public type per source file. An exception is made for a simple enumeration, which is used in the interface of the public type and seems to \"belong\" to it. Example: TestResult and ResultState Name the source file after the public type it represents. The Directory hierarchy and Namespace hierarchy should match. For example, if the root namespace for a project is NUnit.Framework , files in the Constraints subdirectory should be in the NUnit.Framework.Constraints namespace. Wherever possible, classes should be laid out in the following order, Private member variables Constructors Dispose Public Properties Protected Properties Private Properties Public Methods Protected Methods Private Methods Using statements should be sorted as follows: All System namespaces All Other namespaces, including NUnit's It is permissible, but not required, to place using statements inside the namespace block, in shortened form, for namespaces that are descendants of the namespace itself. Note that the compiler will permit other uses of shortened namespaces within the namespace block, but we prefer to limit ourselves to descendants. Non-descendant namespaces should be listed in full form in the main using block. using System; using System.Collections; using System.Collections.Generic; using System.IO; using NUnit.Engine.Interfaces; using NUnit.Engine.Internal.Execution; // OK, but inside the namespace is preferred namespace NUnit.Engine.Internal { using Execution; // Preferred location /* ... */ } Use of Regions [Needs to be filled in] Use of the var keyword The var keyword should be used where the type is obvious to someone reading the code, for example when creating a new object. Use the full type whenever the type is not obvious, for example when initializing a variable with the return value of a method. var i = 12; var list = new List<int>(); Foo foo = GetFoo(); ``"
  },
  "articles/developer-info/Contributions.html": {
    "href": "articles/developer-info/Contributions.html",
    "title": "Contributions | NUnit Docs",
    "keywords": "Contributions This page contains guidelines to follow when evaluating and accepting contributions in form of source code from other developers. Shape All proposed changes to the code should come in the form of GitHub pull requests. Pull requests are built automatically on the build server and they make it easy to track the origin of any change. Quality When appropriate, pull requests should contain enough unit tests to provide coverage for the changes they introduce. Because pull requests are built automatically on the build server it is important to check that the changes pass all tests. Ideally pull requests should contain only few commits which address directly the issue or feature. Integrating There are several ways a pull request can be integrated into NUnit's repository: Pull requests can be merged automatically using GitHub's Web interface. This is an option only if they are clean of useless commits which would only cause confusion and clutter the history for no good reason. Merging pull requests using GitHub Web interface creates a merge commit even when fast-forward would be possible. Pull requests can be merged manually once they've been checked out locally. Usually this would result in a fast-forward commit if no other changes appeared in the branch where the pull request is being integrated. In other cases you may still have the option to rebase the changes rather than merging. Although a linear history is nice, it's probably even better to force a merge instead, because it records more clearly where those changes came from and also because it automatically closes the pull request (although there may be GitHub hooks to close the pull request, perhaps mentioning its # in the commit message, which I'm not aware of). Usually it is preferable to use GitHub's automatic merge, and if the pull request does not comply with the few commits rule ask the contributor to sanitize it before doing it yourself. Avoid committing contributions by repeating the changes in the pull request manually, because this loses track of the origin of changes. Special reviews Anyone submitting a PR can ask for extra review or review by a particular person. Just say so in the PR indicating what needs special review. If you want someone particular to review it, use @ notation. By default, any PR is eligible to merge after it is reviewed as OK. If anyone wants to create a PR early to get feedback on the code, then he should say so right at the top of the PR. Cleaning up After a pull request has been integrated remember to close associated issues, when appropriate and if such issues exist. If a pull request has been integrated manually remember to close the pull request afterwards. The branch of a pull request, in case it belongs to the NUnit's repository might be deleted as well. GitHub provides the option to do so in the Web user interface. Be careful before deleting a branch that the author may have intended the branch to be long-lived. Notes For contributions from within the team, using branches on the NUnit repository rather than clones, don't forget to delete the branches once merged unless they need to hang around for long-running work"
  },
  "articles/developer-info/Issue-Tracking.html": {
    "href": "articles/developer-info/Issue-Tracking.html",
    "title": "Issue Tracking | NUnit Docs",
    "keywords": "Issue Tracking We use the GitHub issue tracker to keep track of our ongoing work. We supplement GitHub's native issue handling by using ZenHub , which provides a number of additional features. Workflow We use a ZenHub Board with a standard set of pipelines to track the flow of work in each repo. Our standard set of pipeline columns are slightly different from the ZenHub default: New Issues All issues start as new. We like to review them as quickly as possible. Some issues can be immediately closed while others need to be categorized for further work. We usually assign at least an is and a priority label (see below) to every issue and then move it to either the Discussion or the Backlog column. Discussion These are items that require some discussion, either about whether we want to do them or how they should be implemented. Some items here may require confirmation or design as well. Backlog This is our product backlog consisting of all the issues we want to get done now or in the future. In the past, we have often put things we didn't really want to do in our Backlog, assigning them a low priority. While this avoids having to say no to the requester, it doesn't do them any real service. Putting an issue into the Backlog should mean that it will eventually make it to a release. To Do These are things we are ready to get working on right now and represent a suggestion to developers as to what to choose to work on next. Most but not all of them will be scheduled for the next milestone. This is a good place to keep issues that are blocking other work, so as to encourage developers to get the issue done. Note Since the number of people actively working on a given project varies, we can't establish a fixed number of items to keep in this column. The project lead should try to keep it to a reasonable size, generally no more than twice the number of active developers. If it seems to be growing too rapidly, some of the issues should be moved to the backlog. In Progress These are issues that somebody is already working on. That person should be shown as assigned to the issue and would normally be the one to move the issue into this column. Done When all work is done and the person doing it feels it is ready to be merged, the issue should be moved to this column. It remains there while comments are discussed and small changes are made. If the comments will lead to significant rework, then move the issue back to In Progress. Closed Issues go here automatically when they are closed. Issue Assignment Normally, committers self-assign items they want to work on. Please don't assign something to yourself and then let it sit. As a matter of courtesy, nobody else will start working on something that is assigned to you, so the result is that the work won't get done. GitHub won't let non-committers assign issues to themselves (or anyone) so if a contributor wants to work on an issue, they should post a comment to that effect. One of the committers will make the assignment. In many cases, the assignment will be shared between the contributor and a committer who is providing mentoring for them. If an issue that is assigned to you then you should do what needs to be done. For example, if it's in the discussion column, then it's up to you to make sure the discussion happens and progresses to a conclusion. If it's marked confirm then you should confirm it. If it's marked design then you should do the design and get it reviewed. And, of course, if it's ready for implementation you should do that! Issue Labels We try to use a standard set of labels across all the NUnit repositories. In some cases, an individual project may not yet have been converted to use these labels, but we expect to do so soon. That said, don't stress about whether something is a bug or an enhancement, normal versus low priority, etc. Just pick one. If things change later, the label can be changed as well. This is only intended to help us organize a relatively large number of issues, not to give us extra work. What it is Labels starting with is: indicate the nature of the issue. Only one should be used, based on the judgment of the committer who assigns the label. If there is no is: label, then we presumably don't know what the item is and should not be working on it! is:bug Something that isn't working as designed. is:docs Solely pertaining to the documentation or sample code. is:enhancement An addition or improvement to an existing feature. is:feature An entirely new feature. is:idea An idea about something we might do. We discuss these until they are either dropped or turned into a feature or enhancement we can work on. is:question Just a question - we discourage these as issues but they do happen. is:build Something to do with how we build the software, scripts, etc. is:refactor What it says: refactoring that is needed. Priority Labels starting with pri: indicate the priority of an issue. Pick just one, please. Priority may, of course, change over time, as items become more or less important to us. If no priority is assigned, we shouldn't be working on it. pri:critical Should only apply to bugs, which need to be fixed immediately, dropping everything else. At times, we will even speed up the release cycle due to a critical bug. pri:high High priority - implement as soon as possible. pri:normal Standard priority - implement when we can. pri:low Low priority - implement later or not at all. PRs and issues that need attention The goal with these is to keep team members from having to do tedious re-scanning to figure out the state of each long-lived PR or issue as well as increasing awareness. awaiting:contributor : Blocked until the contributor responds to the team's request for changes. awaiting:team : Blocked until a team member responds to a question or problem. awaiting:discussion : Blocked until the team comes to consensus on a design question. awaiting:review : Blocked until an additional team member approves or requests changes. Close Reason Labels starting with closed: indicate the status of the bug at closing and should only appear on closed bugs. Please remember to apply one of these when closing a bug as it makes it easier to review the list of closed bugs without opening each one to see what the disposition was. closed:done The work called for is done, i.e. the bug is fixed or the feature/enhancement is implemented. closed:duplicate The issue is a duplicate of one that we are working. A comment should indicate the issue number. closed:notabug The issue (generally a bug) is not valid or the feature already exists. There should be an explanatory comment. closed:norepro While the issue (generally a bug) may exist on the user's system, we have tried and are unable to reproduce it. If somebody later figures out a repro, the issue can be reopened. closed:wontfix The issue is possibly valid but we don't intend to implement it. It may be out of scope for the project or inconsistent with the values and priorities of the project. There should be an explanatory comment. Other Labels confirm Somebody should verify that the issue actually exists and then remove the label. In some cases, a bug may have been reported against an older version of NUnit and needs to be checked out using the current code. blocked The issue cannot be worked on until something else happens, external to the project. There should be a comment on the issue indicating what that something is. design Some design decisions need to be made before this can really be worked on. Sometimes this label may be applied before anything happens and other times the work may have started but reached a point where design decisions need to be made involving others in the team. up-for-grabs Indicates a backlog issue ready for implementation where we would love for the wider community to jump in and be assigned! Whoever adds this label should couple it with a comment suggesting what code to look at and a general approach to working the issue. easyfix Indicates an issue that is expected to take no more than a few nights' work. Epics Where appropriate, we make use of the ZenHub Epic feature to create issues that include a number of sub-issues. For example, when we split the original NUnit repository into separate framework and engine repositories, we created an epic that included a number of separate issues that had to be completed in order to accomplish the split smoothly. Milestones We use GitHub Milestones to represent future releases. Generally milestones are created by the project or team leader, who also decides what issues to place into the milestone. Our practice is to only schedule a limited number of key features in advance for each milestone, rather than trying to \"fill\" the milestone with the amount of work we think can be completed. Other work is only added to the next milestone after it has been completed. We do it this way because the amount of time developers have to spend on our projects can vary considerably over the course of time. We never know how much work will be done in a given period. Since we can't predict both the timing and the content of each release, we have chosen to hold the time constant and vary the content."
  },
  "articles/developer-info/Notes-Toward-NUnit-4.0.html": {
    "href": "articles/developer-info/Notes-Toward-NUnit-4.0.html",
    "title": "Notes Toward NUnit 4.0 | NUnit Docs",
    "keywords": "Notes Toward NUnit 4.0 This page describes plans for the next major releases of NUnit, focusing on major changes we expect to make. Extensions With the release of nunit3-console 4.0, we intend to stop distributing the teamcity-event-listener bundled with with the console as a standard extension. We will continue to support the --teamcity option in the console runner when the extension is installed separately by the user. API possibilities https://github.com/nunit/nunit/issues/2437"
  },
  "articles/developer-info/NUnit-Copyright-Notice.html": {
    "href": "articles/developer-info/NUnit-Copyright-Notice.html",
    "title": "NUnit Copyright Notice | NUnit Docs",
    "keywords": "NUnit Copyright Notice // *********************************************************************** // Copyright (c) yyyy Charlie Poole // // Permission is hereby granted, free of charge, to any person obtaining // a copy of this software and associated documentation files (the // \"Software\"), to deal in the Software without restriction, including // without limitation the rights to use, copy, modify, merge, publish, // distribute, sublicense, and/or sell copies of the Software, and to // permit persons to whom the Software is furnished to do so, subject to // the following conditions: // // The above copyright notice and this permission notice shall be // included in all copies or substantial portions of the Software. // // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, // EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND // NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE // LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION // OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION // WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. // ***********************************************************************"
  },
  "articles/developer-info/Packaging-Extensions.html": {
    "href": "articles/developer-info/Packaging-Extensions.html",
    "title": "Packaging Extensions | NUnit Docs",
    "keywords": "Packaging Extensions The NUnit Console/Engine currently ships with the following extensions, NUnit.Extension.NUnitProjectLoader NUnit.Extension.VSProjectLoader NUnit.Extension.NUnitV2ResultWriter NUnit.Extension.NUnitV2Driver NUnit.Extension.TeamCityEventListener All but the TeamCityEventListener are built and shipped by the NUnit team. These extensions must be built and released before building and releasing the Console/Engine, but only if they are changed and a release is planned. For the 3.5 release, all extensions will be built and released with the console. Future releases of each extension will be on an as-needed basis and the version numbers of the extensions and the console/engine will diverge over time. Create a Release Branch All work on releases should be done on a branch. Fetch and pull latest from master Create a branch in the form release-3.5 As you make the changes below, push the branch to GitHub and create a Pull Request to allow other team members to review your changes. Do not merge this branch/PR , we will create a separate PR to merge the changes back into master. Make Sure it Works Close all instances of Visual Studio or other IDE to ensure that no changes are left unsaved. Do a clean build and run all the tests on Windows. You may use the command below or three separate commands if preferred. If you encounter errors at any stage, you're not actually ready to release! build.cmd -Target=Clean build.cmd -Target=Test Repeat the build on a Linux system, if available. If this is not possible, be sure to scrutinize the results from the Travis CI build carefully. On Linux, you may use the command ./build -Target=Test Make sure that the most recent commits of master passed all tests in the CI builds. Check the builds on both Travis and AppVeyor. Review Milestone Status Check the milestone for the current release to see that there are no open issues. Any issues that are not going to be in this release should be moved to a future milestone. This may be the time to create the next milestone. Make sure that completed issues are marked with the appropriate 'closed' label depending on disposition. The release notes will end up reflecting issues marked closed:done. Check all future open milestones for completed issues. Anything that is completed will be included in this release so change its milestone to the current release. Check Versioning AssemblyVersion and AssemblyFileVersion are set in src\\extension\\Properties\\AssemblyInfo.cs and should match the version in build.cake . These values are normally incremented after a release, but should be checked. Update Copyright Year The copyright year in all the source files is only updated as they are changed, but the copyright in the [assembly: AssemblyCopyright(\"...\")] should be updated to the year of the release. If necessary, update the year in the general copyright notice LICENSE.txt . The .nuspec files in solution root contains a copyright line, which should also be updated. Notices at the top of each source code file are only updated when copyrightable changes are made to the file, not at the time of release. Push All Changes Make sure the release branch and any changes are pushed to GitHub, reviewed in a PR and all CI servers are passing. Creating the Release Clear the package directory to avoid confusion: erase package\\* This is not absolutely required, but will be helpful if you have other release packages present in the directory. You should be working on the release branch. Do a pull to make sure you have everything up to date. If changes of any significance were merged, you should test again before creating the release. Ensure that the release build is up to date. If you have any doubt whether the latest code changes have actually been built, do a clean build. If the build is up to date you may skip this step. build -Target Build Create the packages by running: build -Target Package Verify that the correct package has been created in the package sub-directory. NUnit..Extension.{NAME}.{VERSION}.nupkg Testing the Release Open the NuGet package from the package sub-directory using NuGet Package Explorer . Inspect the package metadata for errors and check that the tools folder contains the extension dll and any dependent assemblies. Next install the extension into a project with the NUnit.ConsoleRunner package and make sure you can run tests. If you are releasing the V2 driver, run NUnit 2 tests. If you are releasing the V2 Result Writer, write out V2 results. Archiving the Release Packages are archived on nunit.org in the downloads directory. Create a new sub-folder under downloads/extensions/v3/EXTENSION_NAME for the release. Upload all the package files into that directory. Publishing the Release Github Log onto Github and go to the extension repository. Select Releases and then click on the \"Draft a new release\" button. Enter a tag to be used for the release in the format v3.x.y Select your release branch as the target for the tag. Enter a title for the release, like NUnit Project Loader Extension 3.5 release. If you type 'N' you'll get some hints. Add a description of the release. It will be easier if you have prepared this in advance and can just paste it in. If this is an Alpha or Beta release, check the box that indicates a pre-release. Upload the nupkg package you created. Click the \"Publish release\" button to publish the release on Github. NuGet Sign on to nuget.org. Select Upload package. Browse to the location of the nupkg you created and upload it. Verify that the info is correct and click the \"Submit\" button. Merge into Master Close your release Pull Request Create a new branch off of your release branch Increment the version in the various locations. For example 3.5 -> 3.6. See the Update Package Versions section above. Push your changes to GitHub Create a pull request from your branch making sure it is based off master Notify Users Send notifications to the mailing list and twitter if the changes to the extension warrant it. Close the Milestone The milestone representing this release should be closed at this time."
  },
  "articles/developer-info/Packaging-the-Console-and-Engine.html": {
    "href": "articles/developer-info/Packaging-the-Console-and-Engine.html",
    "title": "Packaging the Console and Engine | NUnit Docs",
    "keywords": "Packaging the Console and Engine Note TODO: This documentation was copied from the original packaging info and needs to be updated for packaging just the Console and Engine. This note describes how to create release packages for the NUnit console runner and test engine. Currently, all the builds and packaging must be done on a single Windows machine. This is likely to change in the future as we add more platforms. Software Prerequisites Various software combinations and environments may be used to build the NUnit 3 console runner and engine. Our standard environment is Visual Studio 2017 15.6+ Community Edition. Preparing for Release Merge latest into the release branch Fetch and pull latest from master Checkout the release branch and merge master Do not merge the release branch , we will create a separate PR to merge the changes back into master. Make Sure it Works Close all instances of Visual Studio or other IDE to ensure that no changes are left unsaved. Do a clean build and run all the tests on Windows. You may use the command below or three separate commands if preferred. If you encounter errors at any stage, you're not actually ready to release! build.cmd -Target=Clean build.cmd -Target=Test Repeat the build on a Linux system, if available. If this is not possible, be sure to scrutinize the results from the Travis CI build carefully. On Linux, you may use the command ./build -Target=Test Make sure that the most recent commits of master passed all tests in the CI builds. Check the builds on both Travis and AppVeyor. Check on TeamCity once we get that build working again. Review Milestone Status Check the milestone for the current release to see that there are no open issues. Any issues that are not going to be in this release should be moved to a future milestone. This may be the time to create the next milestone. Make sure that completed issues are marked with the appropriate 'closed' label depending on disposition. The release notes will end up reflecting issues marked closed:done. Check all future open milestones for completed issues. Anything that is completed will be included in this release so change its milestone to the current release. Check Assembly Versioning AssemblyVersion and AssemblyFileVersion are set separately for the framework, engine, engine api and console runner. Each is kept in a separate file and they may be updated separately. Using the 3.4.1 release as an example, version information would be set as follows: Component | File to Update | AssemblyVersion | AssemblyFileVersion --------------------- | ------------------- | --------------- | ------------------- Engine | EngineVersion.cs | 3.4.1.0 | 3.4.1.0 Engine API | EngineApiVersion.cs | 3.0.0.0 | 3.4.1.0 Console | ConsoleVersion.cs | 3.4.1.0 | 3.4.1.0 Notes The Engine API AssemblyVersion is fixed and will not be changed unless it becomes necessary to modify the API in a non-additive manner. These values will normally already be correct for the release, since they should have been set immediately following the prior release. Update Copyright Year The copyright year in all the source files is only updated as they are changed, but the copyright in the [assembly: AssemblyCopyright(\"...\")] and the copyright text displayed by nunit3-console and nunitlite should be updated to the year of the release. Search for AssemblyCopyright in the solution and update it where needed, then check Program.cs in nunit3-console for default values used when no attribute is found. If necessary, update the year in the general copyright notice LICENSE.txt. Note that these copyright notices refer to each of the packages in their entirety. Each of the .nuspec files in the nuget subdirectory contains a copyright line, which should also be updated. Notices at the top of each source code file are only updated when copyrightable changes are made to the file, not at the time of release. Update Package Versions The package version is updated in the build.cake file. The following lines appear near the beginning of the file. Update the versions and modifiers if necessary. Normally, they will already have been set correctly. var version=\"3.4.1\"; var modifier=\"\" The version variables are three-part version numbers that follow the basic principles of semantic versioning . Since we publish a number of nuget packages, we use the nuget implementation of semantic versioning. For NUnit, the major version is updated only rarely. Normal releases will update the minor version and set the third component to zero. The third component is incremented when \"hot fixes\" are made to a production release or for builds created for a special purpose. For pre-release versions, a non-empty modifier is specified. This is a suffix added to the version. Our standard suffixes are currently -alpha-n , -beta-n and -rc-n The build script adds an additional suffix of -dbg to any packages created using a Debug build. Note The first alpha, beta or rc release may omit the -n . In that case, any following alpha, beta or rc should use -2 . Update CHANGES File The CHANGES.txt file in the project root contains all relevant changes for each release. It contains the same information as the release notes in the project documentation, in text format. Because the CHANGES file includes the date of the release, you must know when the release is coming out in order to edit it. Otherwise, it will be necessary to make a final change to the file at the point of making the release. Create new sections in the CHANGES file to match those for prior releases. To ensure that all changes are included, review closed issues in the current and any future milestones. If an issue for a previous milestone was actually completed and closed, move it to the current milestone, since that's where it is being released. Include all issues resolved as closed:done in the issues section of the file. Significant feature additions and changes should be documented, even if they are also listed with issue numbers. Reviewing commits and merged pull requests may help in catching additional changes. You should commit the CHANGES file separately from the version number changes since that commit will be merged back into master while the version changes will not. Update the Documentation The Release Notes section of the documentation site should match the content of the CHANGES.txt file except for any format differences. Note Now that the documentation is being kept in a web site generated by github markdown, it may be possible to use the github markdown text directly in this file for future releases. For any significant changes to how NUnit is used or what it does, the appropriate pages of the documentation should be updated or new pages created. If you do this in advance of the release (which is actually a good idea) you should do it in a way that the new documentation is not visible until the release is actually made. Push All Changes If you made any changes to the files in git as part of the preceding steps. Make sure you have pushed them and they have been reviewed in the PR. Creating the Release Clear the package directory to avoid confusion: erase package\\* This is not absolutely required, but will be helpful if you have other release packages present in the directory. You should be working on the release branch. Do a pull to make sure you have everything up to date. If changes of any significance were merged, you should test again before creating the release. Create the packages by running: build -Target Package Verify that the correct packages have been created in the package sub-directory: NUnit.Console.VERSION.nupkg NUnit.ConsoleRunner.VERSION.nupkg NUnit.Engine.VERSION.nupkg NUnit.Engine.Api.VERSION.nupkg NUnit.Engine.Tool.VERSION.nupkg (Do not release) NUnit.Runners.VERSION.nupkg Testing the Release The degree to which each package needs testing may vary depending on what has been changed. Usually, you should install all the NuGet packages into a test project, verifying that the Archiving the Release Packages are archived on nunit.org in the downloads directory. Create a new sub-folder under downloads/nunit/v3 for the release. Upload all the package files into that directory. Publishing the Release Github Log onto Github and go to the main NUnit repository at https://github.com/nunit/nunit . Select Releases and then click on the \"Draft a new release\" button. Enter a tag to be used for the release. Currently our tags are simply the version of the release, like 3.0.0-alpha-5. If you start typing with '3' you'll get a list of earlier release tags so you can see the format. Select your release branch as the target for the tag. Enter a title for the release, like NUnit 3.0 RC release. If you type 'N' you'll get some hints. Add a description of the release. It will be easier if you have prepared this in advance and can just paste it in. If this is an Alpha or Beta release, check the box that indicates a pre-release. Upload the packages you created earlier either directly from the package directory or from their archive location. Note that we upload all the packages, including those that are also published on NuGet. Click the \"Publish release\" button to publish the release on Github. NuGet Sign on to nuget.org. Select Upload package. Browse to the location of the NUnit.Console.VERSION.nupkg you created and upload it. Verify that the info is correct and click the \"Submit\" button. Repeat steps 2-4 for the other NuGet packages. Do not upload NUnit.Engine.Tool.VERSION.nupkg. Merge into Master Close your release Pull Request Create a new branch off of your release branch Increment the version in the various locations from the even release to the SemVer odd dev release number. For example 3.2 -> 3.3. See the Update Package Versions section above. Push your changes to GitHub Create a pull request from your branch making sure it is based off master Website If changes to the website have been accumulated in a branch, now is the time to merge it and upload the pages to the site. Notify Users Send notifications to the mailing list and twitter. Close the Milestone The milestone representing this release should be closed at this time."
  },
  "articles/developer-info/Packaging-the-Framework.html": {
    "href": "articles/developer-info/Packaging-the-Framework.html",
    "title": "Packaging the Framework | NUnit Docs",
    "keywords": "Packaging the Framework This note describes how to create release packages for the NUnit Framework. Currently, all the builds and packaging must be done on a single Windows machine. This is likely to change in the future as we add more platforms. Note These instructions assume that you are creating releases for SilverLight and the Compact Framework at the same time as the general release. If that's not the case, you may skip the steps marked CF or SL. To release either build separately, perform those steps in sequence. Software Prerequisites Various software combinations and environments may be used to build NUnit components. The following software is what we have used and tested for building everything and creating the release packages. We'll add options to the list as we find them. Visual Studio 2017 with the NuGet Package manager. .NET Core 1.1.4 Preparing for Release Create a Release Branch All work on releases should be done on a branch. Fetch and pull latest from master Check out the release branch Merge latest into the release branch As you make the changes below, push the branch to GitHub and create a Pull Request to allow other team members to review your changes. Do not merge the release branch or PR , we will create a separate PR to merge the changes back into master. Make Sure it Works Close all instances of Visual Studio or other IDE to ensure that no changes are left unsaved. Do a clean build and run all the tests on Windows. You may use the command below or three separate commands if preferred. If you encounter errors at any stage, you're not actually ready to release! build.cmd -Target=Clean build.cmd -Target=Test Repeat the build on a Linux system, if available. If this is not possible, be sure to scrutinize the results from the Travis CI build carefully. On Linux, you may use the command ./build -Target=Test Make sure that the most recent commits of master passed all tests in the CI builds. Check the builds on both Travis and AppVeyor. Review Milestone Status Check the milestone for the current release to see that there are no open issues. Any issues that are not going to be in this release should be moved to a future milestone. This may be the time to create the next milestone. Make sure that completed issues are marked with the appropriate 'closed' label depending on disposition. The release notes will end up reflecting issues marked closed:done. Check all future open milestones for completed issues. Anything that is completed will be included in this release so change its milestone to the current release. Check Assembly Versioning AssemblyVersion and AssemblyFileVersion are set separately for the framework, engine, engine api and console runner. Each is kept in a separate file and they may be updated separately. Using the 3.4.1 release as an example, version information was set as follows: Component | File to Update | AssemblyVersion | AssemblyFileVersion --------------------- | ------------------- | --------------- | ------------------- Framework | FrameworkVersion.cs | 3.6.0.0 | 3.6.0.0 Update Copyright Year The copyright year in all the source files is only updated as they are changed, but the copyright in the [assembly: AssemblyCopyright(\"...\")] and the copyright text displayed by nunitlite should be updated to the year of the release. Search for AssemblyCopyright in the solution and update it where needed, then check TextUI.cs in nunitlite-runner for default values used when no attribute is found. If necessary, update the year in the general copyright notice LICENSE.txt. Note that these copyright notices refer to each of the packages in their entirety. Each of the .nuspec files in the nuget subdirectory contains a copyright line, which should also be updated. Notices at the top of each source code file are only updated when copyrightable changes are made to the file, not at the time of release. Update Package Versions The package version is updated in the build.cake file. The following lines appear near the beginning of the file. Update the versions and modifiers as necessary. var version=\"3.6.0\"; var modifier=\"\" The version variables are three-part version numbers that follow the basic principles of semantic versioning . Since we publish a number of NuGet packages, we use the NuGet implementation of semantic versioning. For NUnit, the major version is updated only rarely. Normal releases will update the minor version and set the third component to zero. The third component is incremented when \"hot fixes\" are made to a production release or for builds created for a special purpose. For pre-release versions, a non-empty modifier is specified. This is a suffix added to the version. Our standard suffixes are currently -alpha-n , -beta-n and -rc-n The build script adds an additional suffix of -dbg to any packages created using a Debug build. Note The first alpha, beta or rc release may omit the -n . In that case, any following alpha, beta or rc should use -2 . Update CHANGES File The CHANGES.md file in the project root contains all relevant changes for each release. It contains the same information as the release notes in the project documentation, in text format. Because the CHANGES file includes the date of the release, you must know when the release is coming out in order to edit it. Otherwise, it will be necessary to make a final change to the file at the point of making the release. Create new sections in the CHANGES file to match those for prior releases. To ensure that all changes are included, review closed issues in the current and any future milestones. If an issue for a previous milestone was actually completed and closed, move it to the current milestone, since that's where it is being released. Include all issues resolved as closed:done in the issues section of the file. Significant feature additions and changes should be documented, even if they are also listed with issue numbers. Reviewing commits and merged pull requests may help in catching additional changes. You should commit the CHANGES file separately from the version number changes since that commit will be merged back into master while the version changes will not. Update the Documentation The Release Notes section of the documentation site should match the content of the CHANGES.txt file except for any format differences. Note Now that the documentation is being kept in a github site, it may be possible to use the github markdown text directly in this file for future releases. For any significant changes to how NUnit is used or what it does, the appropriate pages of the documentation should be updated or new pages created. If you do this in advance of the release (which is actually a good idea) you should do it in a way that the new documentation is not visible until the release is actually made. Regenerate the Public API Files TODO: Add detail during the next release... During each release, we will have to manually delete the entire contents of each of the eight Shipped/Unshipped files, then use the light bulb fix on the warnings in the error list to repopulate the Unshipped files, then cut the contents of each Unshipped file and paste Push All Changes If you made any changes to the files in git as part of the preceding steps. Make sure you have pushed them and they have been reviewed in the PR. Creating the Release Clear the package directory to avoid confusion: erase package\\* This is not absolutely required, but will be helpful if you have other release packages present in the directory. You should be working on the release branch. Do a pull to make sure you have everything up to date. If changes of any significance were merged, you should test again before creating the release. Ensure that the release build is up to date. If you have any doubt whether the latest code changes have actually been built, do a clean build. If the build is up to date you may skip this step. build -Target Build Create the image directory build -Target CreateImage You do this to ensure that the latest build is used for packaging. If the images directory does not already contain a subdirectory named for this release (package version and suffix) you may skip this step as a new one will be created automatically. Create the packages by running: build -Target Package Verify that the correct packages have been created in the package sub-directory: NUnit-VERSION.zip NUnit.VERSION.nupkg NUnitLite.VERSION.nupkg Testing the Release The degree to which each package needs testing may vary depending on what has been changed. Here is a minimal set of tests for each package. Binary Zip Unzip the file, change into the bin directory and use an install of the console to run all the tests. ``` nunit3-console.exe net-2.0\\nunit.framework.tests.dll nunit3-console.exe net-3.5\\nunit.framework.tests.dll nunit3-console.exe net-4.0\\nunit.framework.tests.dll nunit3-console.exe net-4.5\\nunit.framework.tests.dll portable\\nunitlite-runner.exe portable\\nunit.framework.tests.dll portable\\nunitlite.tests.exe ``` NuGet Packages Create a test project. Install the packages and verify that they apply to the project correctly. Run tests. Archiving the Release Packages are archived on nunit.org in the downloads directory. Create a new sub-folder under downloads/nunit/v3 for the release. Upload all the package files into that directory. Note We need to develop a plan for additionally archiving the image directory. For the moment, the binary zip package provides a backup but it's possible that the two may diverge in the future. Publishing the Release Github Log onto Github and go to the main NUnit repository at https://github.com/nunit/nunit . Select Releases and then click on the \"Draft a new release\" button. Enter a tag to be used for the release. Currently our tags are simply the version of the release, like 3.0.0-alpha-5. If you start typing with '3' you'll get a list of earlier release tags so you can see the format. Select your release branch as the target for the tag. Enter a title for the release, like NUnit 3.0 RC release. If you type 'N' you'll get some hints. Add a description of the release. It will be easier if you have prepared this in advance and can just paste it in. If this is an Alpha or Beta release, check the box that indicates a pre-release. Upload the packages you created earlier either directly from the package directory or from their archive location. Note that we upload all the packages, including those that are also published on NuGet. Click the \"Publish release\" button to publish the release on Github. NuGet Sign on to nuget.org. Select Upload package. Browse to the location of the NUnit.VERSION.nupkg you created and upload it. Verify that the info is correct and click the \"Submit\" button. Repeat steps 2-4 for NUnitLite.VERSION.nupkg Merge into Master Close your release Pull Request Create a new branch off of your release branch Increment the version in the various locations. For example 3.5 -> 3.6. See the Update Package Versions section above. Push your changes to GitHub Create a pull request from your branch making sure it is based off master Website If changes to the website have been accumulated in a branch, now is the time to merge it and upload the pages to the site. Notify Users Send notifications to the mailing list and twitter. Close the Milestone The milestone representing this release should be closed at this time."
  },
  "articles/developer-info/Packaging-the-Installer.html": {
    "href": "articles/developer-info/Packaging-the-Installer.html",
    "title": "Packaging the Installer | NUnit Docs",
    "keywords": "Packaging the Installer Before packaging the installer, you must first package and release the Console and Engine. See Packaging the Console and Engine Prepare the Release Get latest from master Update CHANGES.TXT. Set the date of the release, and list any packages which have been upgraded since the last release. Check the version and displayVersion in build.cake . They should have been updated at the last release. Package the release, .\\build.ps1 or .\\build.cmd Check the distribution directory for NUnit.{VERSION}.msi and NUnit.{VERSION}.zip Test the Release Test the Installer Install NUnit.{VERSION}.msi Ensure it installs correctly Check that the extensions included in build.cake are installed Run unit tests using the install Ensure the extensions work by running NUnit 2 tests and by creating NUnit 2 test results Check the version in the nunit3-console.exe output headers when running tests. Test the ZIP File Unzip NUnit.{VERSION}.zip Check that the extensions included in build.cake are installed Run unit tests using the install Ensure the extensions work by running NUnit 2 tests and by creating NUnit 2 test results Check the version in the nunit3-console.exe output headers when running tests. Archiving the Release Packages are archived on nunit.org in the downloads directory. Add the MSI and ZIP to the existing downloads/nunit/v3 for the Console/Engine release. Publishing the Release Log onto Github and go to the main nunit-console repository at https://github.com/nunit/nunit-console . Go to the releases tab and edit the existing Console release Add the MSI and ZIP files to the release Update the website if required Tag the Release Still on master , tag the release with the version, git tag v3.5 Push the tags to GitHub, git push --tags Increment the Version Create a release branch git checkout -b release-3.5 Increment the version and displayVersion in build.cake . Check-in your changes and push to GitHub Create a Pull Request, have it reviewed, merged and delete the branch Close the milestone if one exists Note The release branch in this project is not like the release branches in other projects, we don't save it. If we need to go back and do hotfixes, we will branch off the tag that was created for the release. We do this because there are usually no changes required to this repository for a release except incrementing the version post release. Any larger changes to this repository should be done and tested prior to a release using the normal Pull Request workflow"
  },
  "articles/developer-info/Packaging-the-V2-Adapter.html": {
    "href": "articles/developer-info/Packaging-the-V2-Adapter.html",
    "title": "Packaging the V2 Adapter | NUnit Docs",
    "keywords": "Packaging the V2 Adapter Introduction There are two purposes for building the adapter, one is for creating the packages for a release - which is what this page is about, the other is for creating whatever you need for debugging or testing purposes. The procedure described here is for those people who need to release a new version of the adapter. Preparing the source code Versioning The version numbers follow the basic principles of semantic versioning . (The fourth number is used for debug versions under development, and will always be 0 for release versions.) The version numbers have to be edited in the following files, and should match: File Change AssemblyInfo.cs , found in the NUnitTestAdapter project change both file and assembly version number source.extensions.vsixmanifest , found under the NUnitTestAdapterInstall project change Version tag nunit-vs-adapter.build , found under the Solution Items folder. change the version number, but only use the two first digits. license.rtf , found under the NUNitTestAdapterInstall project. If the major/minor number has changed, update that here, 2nd line. If year is changed, update copyright years accordingly. Build Build a release version, AnyCPU. Packaging Use NAnt and use the package target NAnt package Run this from the solution root folder The resulting files can be found in the \"package\" folder: NUnitVisualStudioTestAdapter-[VERSION].vsix This is the extension for Visual Studio, which is uploaded to the Visual Studio Gallery . NUnitVisualStudioTestAdapter-[VERSION].zip This is a zipped package for use with TFS Server Builds when you don't use the NuGet package in your solution. See [this blog] for more information. NUnitVisualStudioTestAdapter-[VERSION].nupkg This is the NuGet package, which is uploaded to NuGet for the adapter NUnitVisualStudioTestAdapterAndFramework-[VERSION].nupkg This is a NuGet package which includes the NUnit 2.6.3 framework, uploaded to NuGet for the adapter with framework Publishing the Release Create a release on GitHub. Few people use this directly, but it is the benchmark release and provides an archive of all past releases, so we do this first. Github will automatically create zip and tar files containing the source. In addition, upload all four packages created above as a part of the release. Upload the vsix package to the Visual Studio Gallery using the NUnitDeveloper account. If you don't have access to that account, ask one of the committers with access to do the upload for you. Upload the two NuGet packages to nuget.org. You use your own account for this but you must have been pre-authorized in order for it to work. If you are not authorized, ask a committer with access to do it for you. Update the documentation pages in this web site as needed. In order to do this quickly after publishing the packages, you may want to clone the nunit/docs repository and prepare a pull request in advance. Update the website as needed. The website is maintained in the nunit.org repository to which all committers have access. You should create a branch like 'release-n.n' and make the necessary changes there. There are three vsAdapterXxxxx files that will probably require updating. Add an announcement to the home page and remove any announcement for an older version of the adapter.Create a pull request to merge your changes into the master branch. For rapid publication, you should create the PR and have it reviewed in advance, performing the merge after the packages are published. Publicize the release, first announcing it on the nunit-developer and nunit-discuss lists and then more widely as appropriate. [We should develop a list of places.] Notes Publishing the release requires access to various online accounts, which are mentioned above. For obvious reasons, the passwords are not provided. Contact Charlie or Terje if you need this access. The website and docs site contain duplicate information at this time. In future, the duplication will be eliminated. When a change is merged into the nunit.org master branch, one of the project leaders uploads it manually to the web site. This will be automated in the future. Prerequisites Visual Studio 2013 You need Visual Studio 2013. We use the ultimate edition, but it should be enough with the premium edition. (I will probably work with both the Pro or the Express editions too, but we haven't tried them). The latest 1.1 version is built using Update 2 RC. Visual Studio 2013 SDK You need this to work with the vsix. Download from http://www.microsoft.com/en-us/download/details.aspx?id=40758 NAnt Download from http://nant.sourceforge.net/ . We use the 0.92 version. NuGet You need the nuget.exe in your path. Download the exe from http://nuget.codeplex.com/downloads/get/784779 . We use the 2.8 version VS2012 TestPlatform object model You need to have this around, the adapter and the test project refer to this. The easiest way to get it, is to have VS2012 installed and get it from there. It is located at a location similar to \"C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\Common7\\IDE\\CommonExtensions\\Microsoft\\TestWindow\" and is named Microsoft.VisualStudio.TestPlatform.ObjectModel.dll You might need to fix up these references if the locations doesn't match what has been used. Github Close the Milestone Draft and publish a Release, named like \"Version 2.0\". Add all the binaries to the same release. Tag the release like V2.0 Documentation The adapter release notes should be updated. The file is named vsTestAdapterReleaseNotes.html , and is found under Docs/2.6.4 in the nunit.org repository, branch \"vs-adapter-2.0\" Also check that the files vsTestAdapterLicense.html and vsTestAdapterReleaseNotes.html is up to date."
  },
  "articles/developer-info/Packaging-the-V3-Adapter.html": {
    "href": "articles/developer-info/Packaging-the-V3-Adapter.html",
    "title": "Packaging the V3 Adapter | NUnit Docs",
    "keywords": "Packaging the V3 Adapter Introduction There are two purposes for building the adapter, one is for creating the packages for a release - which is what this page is about, the other is for creating whatever you need for debugging or testing purposes. For the latter, see [How to build and debug the adapter] The procedure described here is for those people who need to release a new version of the adapter. Preparing the source code Update to the latest version of NUnit This may not be necessary for all releases. However, if the NUnit version used by the adapter is being updated, it is important to do it correctly. The NUnit3TestAdapter, NUnit3TestAdapterInstall and NUnit3TestAdapterTests projects should all reference the same versions of the NUnit Engine package, normally the most recent. The NUnit3TestAdapterTests and NUnitTestDemo projects should reference the same version of the NUnit framework package, also normally the most recent. Note that this is currently the same version as the engine package, but this may not continue to be the case if the frequency of release of the two packages differs. Assembly References At this time, after upgrading the NUnit engine package, you have to manually adjust the references, removing several that are added automatically by the package and adding an Alias. We will try to eliminate this manual step in the future. For each of the NUnit3TestAdapter , NUnit3TestAdapterTests and NUnit3TestAdapterInstall projects, remove references to nunit-agent and nunit-agent-x86, leaving only the four Mono.Cecil references, nunit.engine and nunit.engine.api. For the NUnit3TestAdapter project, modify the properties for nunit-engine by entering \"ENG\" for Aliases. Versioning The version numbers follow the basic principles of semantic versioning . (The fourth number is used for debug versions under development, and will always be 0 for release versions.) The version numbers have to be edited in the following files, and should match: File Change AssemblyInfo.cs , found in the NUnitTestAdapter project change both file and assembly version number source.extensions.vsixmanifest , found under the NUnitTestAdapterInstall project change Version tag appveyor.yml , found under the Solution Items folder. change the version number, but only use the three first digits. build.cake , found under the Solution Items folder. change the version number, but only use the three first digits. license.rtf , found under the NUnit3TestAdapterInstall project. If the copyright year has changed, update accordingly. Build Use the build command to build and test a release version. build -t Test Packaging Use the build command to create packages build -t Package Run this from the solution root folder The resulting files can be found in the \"package\" folder: NUnit3TestAdapter-[VERSION].vsix This is the extension for Visual Studio, which is uploaded to the Visual Studio Gallery . NUnit3TestAdapter-[VERSION].zip This is a zipped package for use with TFS Server Builds when you don't use the NuGet package in your solution. See [this blog] for more information. NUnit3TestAdapter.[VERSION].nupkg This is the NuGet package, which is uploaded to NuGet for the adapter Testing the Packages Test both the vsix and NuGet packages using each version of Visual Studio you have available, from 2012 through 2015. Publishing the Release Create a release on GitHub. Few people use this directly, but it is the benchmark release and provides an archive of all past releases, so we do this first. Github will automatically create zip and tar files containing the source. In addition, upload all three packages created above as a part of the release. Upload the vsix package to the Visual Studio Gallery using the NUnitDeveloper account. If you don't have access to that account, ask one of the committers with access to do the upload for you. Upload the NuGet package to nuget.org. You use your own account for this but you must have been pre-authorized in order for it to work. If you are not authorized, ask a committer with access to do it for you. Update the documentation pages in the site as needed. Be sure to update the Release Notes page. In order to perform the update quickly after publishing the packages, you may want to clone the nunit/docs repository and prepare the pull request in advance. Publicize the release, first announcing it on the nunit-developer and nunit-discuss lists and then more widely as appropriate. [We should develop a list of places.] Note Publishing the release requires access to various online accounts, which are mentioned above. For obvious reasons, the passwords are not provided. Contact Charlie or Terje if you need this access. Prerequisites Visual Studio Visual Studio 2017 is required in order to build the vsix. Visual Studio 2013 or 2015 may be used for other development. Visual Studio SDK You need this to work with the vsix."
  },
  "articles/developer-info/Team-Practices.html": {
    "href": "articles/developer-info/Team-Practices.html",
    "title": "Team Practices | NUnit Docs",
    "keywords": "Team Practices How We Work As a Team Issue Tracking How we track bugs, enhancements and features on GitHub. Contributions Explains how to review and merge code submitted by other developers. Technical Practices Building and testing See BUILDING.md in each repository. Coding Standards Describes coding standards used in NUnit. Best practices for XML documentation Guidelines to consider when dealing with public APIs. Packaging the Framework How to create the packages for a new NUnit Framework release. Packaging the Console and Engine How to create the packages for a new NUnit Console and Engine release. Packaging Extensions How to create the packages and release NUnit Extensions. Packaging the Installer How to create and release the NUnit MSI Installer. Packaging the V2 Adapter How to create the packages for a new NUnit 2 VS Adapter release. Packaging the V3 Adapter How to create the packages for a new NUnit 3 VS Adapter release."
  },
  "articles/nunit/extending-nunit/Action-Attributes.html": {
    "href": "articles/nunit/extending-nunit/Action-Attributes.html",
    "title": "Action Attributes | NUnit Docs",
    "keywords": "Action Attributes Note Action Attributes are a feature of NUnit V2, designed to better enable composability of test logic. They are carried over to NUnit 3, but are not the recommended approach for most new work. Instead, for most problems of extensibility, NUnit 3 Custom Attributes are a better approach and are more likely to be supported in future releases. However, at this time, Action Attributes provide the only approach that allows placing an attribute on a higher-level element and having it affect the behavior of lower-level elements. The rest of this page describes Action Attribute usage in NUnit 3. Often when writing unit tests we have logic that we want to run upon certain events in the test cycle (e.g. SetUp, TearDown, FixtureSetUp, FixtureTearDown, etc.). NUnit has had the ability to execute code upon these events by decorating fixture classes and methods with the appropriate NUnit- provided attributes. Action Attributes allow the user to create custom attributes to encapsulate specific actions for use before or after any test is run. The Problem of Composability Suppose we have some tests in multiple fixtures that need the same in-memory test database to be created and destroyed on each test run. We could create a base fixture class and derive each fixture that depends on the test from that class. Alternatively, we could create a SetUpFixture class at the level of a common namespace shared by each fixture. This works fine, until we need some other reusable functionality, say the ability to configure or reset a ServiceLocator. We could put that functionality in the base fixture class or setup fixture, but now we're mixing two different responsibilities into the base class. In the case of a setup fixture, this only works if all classes requiring both features are located in a common namespace. In some cases we may not want the test database, but we do want ServiceLocator configuration; and sometimes we want the opposite. Still other times we'll want both - so we'd have to make the base class configurable. If we now discover a third piece of functionality we need to reuse, like configuring the Thread's CurrentPrincipal in arbitrary ways, the complexity of the solution very quickly. We've violated the Single Responsibility Principle and are suffering for it. What we really want is the ability to separate the different pieces of reusable test logic and compose them together as our tests need them. Resolving the Problem Action Attributes get us out of our bind. Consider this example: [TestFixture, ResetServiceLocator] public class MyTests { [Test, CreateTestDatabase] public void Test1() { /* ... */ } [Test, CreateTestDatabase, AsAdministratorPrincipal] public void Test2() { /* ... */ } [Test, CreateTestDatabase, AsNamedPrincipal(\"charlie.poole\")] public void Test3() { /* ... */ } [Test, AsGuestPrincipal] public void Test4() { /* ... */ } } Here we have used user-defined attributes to identify five different actions that we want to compose together in different ways for different tests: ResetServiceLocator CreateTestDatabase AsAdministratorPrincipal AsNamedPrincipal AsGuestPrincipal We can reuse these actions in other test fixtures, simply by decorating them with the appropriate attributes.without having to inherit from a base class. We can even develop and distribute a library of common test actions. Implementing an Action Attribute Action attributes are defined by the programmer. They implement the ITestAction interface, which is defined as follows: public interface ITestAction { void BeforeTest(ITest test); void AfterTest(ITest test); ActionTargets Targets { get; } } For convenience, you may derive your own action attribute from NUnit's TestActionAttribute , an abstract class with virtual implementations of each member of the interface. Alternatively, you may derive from System.Attribute and implement the interface directly. Action Targets The value returned from the Targets property determines when the BeforeTest and AfterTest methods will be called. The ActionTargets enum is defined as follows: [Flags] public enum ActionTargets { Default = 0, Test = 1, Suite = 2 } When an attribute that returns ActionTargets.Suite is applied to either a class or a parameterized method, NUnit will execute the attribute's BeforeTest method prior to executing the test suite and then execute the AfterTest method after the test suite has finished executing. This is similar to how the OneTimeSetUp and OneTimeTearDown attributes work. On the other hand, when an attribute that returns ActionTargets.Test is used in the same situations, NUnit will execute the attribute's BeforeTest method prior to each contained test case and the AfterTest method after each test case. This is similar to how the SetUp and TearDown attributes work. Action attributes that return ActionTargets.Default target the particular code item to which they are attached. When attached to a method, they behave as if ActionTargets.Test had been specified. When attached to a class or assembly, they behave as if ActionTargets.Suite was returned. ITest Interface The BeforeTest and AfterTest methods are provided with information about the test that is about to run (before) or has just run (after). The ITest interface is an internal NUnit interface to the representation of a test, which may be either a test case or a suite. The before and after methods may use the interface to decide what actions to take or retrieve information about the test. public interface ITest : IXmlNodeBuilder { // Gets the id of the test int Id { get; } // Gets the name of the test string Name { get; } // Gets the fully qualified name of the test string FullName { get; } // Gets the Type of the test fixture, if applicable, or // null if no fixture type is associated with this test. Type FixtureType { get; } // Gets a MethodInfo for the method implementing this test. // Returns null if the test is not implemented as a method. MethodInfo Method { get; } // Gets the RunState of the test, indicating whether it can be run. RunState RunState { get; } // Count of the test cases (1 if this is a test case) int TestCaseCount { get; } // Gets the properties of the test IPropertyBag Properties { get; } // Gets the parent test, if any. ITest Parent { get; } // Returns true if this is a test suite bool IsSuite { get; } // Gets a bool indicating whether the current test // has any descendant tests. bool HasChildren { get; } // Gets this test's child tests System.Collections.Generic.IList<ITest> Tests { get; } } Examples The examples that follow all use the following sample Action Attribute: [AttributeUsage(AttributeTargets.Method | AttributeTargets.Class | AttributeTargets.Interface | AttributeTargets.Assembly, AllowMultiple = true)] public class ConsoleActionAttribute : Attribute, ITestAction { private string _Message; public ConsoleActionAttribute(string message) { _Message = message; } public void BeforeTest(ITest test) { WriteToConsole(\"Before\", test); } public void AfterTest(ITest test) { WriteToConsole(\"After\", test); } public ActionTargets Targets { get { return ActionTargets.Test | ActionTargets.Suite; } } private void WriteToConsole(string eventMessage, ITest details) { Console.WriteLine(\"{0} {1}: {2}, from {3}.{4}.\", eventMessage, details.IsSuite ? \"Suite\" : \"Case\", _Message, details.FixtureType != null ? details.FixtureType.Name : \"{no fixture}\", details.Method != null ? details.Method.Name : \"{no method}\"); } } Note that the above Action Attribute returns the union of ActionTargets.Test and ActionTargets.Suite. This is permitted, but will probably not be the normal case. It is done here so we can reuse the attribute in multiple examples. The attribute takes a single constructor argument, a message, that will be used to write output to the console. All of the Before and After methods write output via the WriteToConsole method. Method Attached Actions Example 1 (applied to simple test method) [TestFixture] public class ActionAttributeSampleTests { [Test][ConsoleAction(\"Hello\")] public void SimpleTest() { Console.WriteLine(\"Test ran.\"); } } Console Output Before Case: Hello, from ActionAttributeSampleTests.SimpleTest. Test ran. After Case: Hello, from ActionAttributeSampleTests.SimpleTest. Example 2 (applied action twice to test method) [TestFixture] public class ActionAttributeSampleTests { [Test] [ConsoleAction(\"Hello\")] [ConsoleAction(\"Greetings\")] public void SimpleTest() { Console.WriteLine(\"Test run.\"); } } Console Output Before Case: Greetings, from ActionAttributeSampleTests.SimpleTest. Before Case: Hello, from ActionAttributeSampleTests.SimpleTest. Test run. After Case: Hello, from ActionAttributeSampleTests.SimpleTest. After Case: Greetings, from ActionAttributeSampleTests.SimpleTest. Remarks You are permitted to apply the same attribute multiple times. Note that the order in which attributes are applied is indeterminate, although it will generally be stable for a single release of .NET. Example 3 (applied to a test method with test cases) [TestFixture] public class ActionAttributeSampleTests { [Test] [ConsoleAction(\"Hello\")] [TestCase(\"02\")] [TestCase(\"01\")] public void SimpleTest(string number) { Console.WriteLine(\"Test run {0}.\", number); } } Console Output Before Suite: Hello, from ActionAttributeSampleTests.SimpleTest. Before Case: Hello, from ActionAttributeSampleTests.SimpleTest. Test run 01. After Case: Hello, from ActionAttributeSampleTests.SimpleTest. Before Case: Hello, from ActionAttributeSampleTests.SimpleTest. Test run 02. After Case: Hello, from ActionAttributeSampleTests.SimpleTest. After Suite: Hello, from ActionAttributeSampleTests.SimpleTest. Remarks When one or more [TestCase] attributes are applied to a method, NUnit treats the method as a test suite. You'll notice that BeforeTest was run once before the suite and AfterTest was run once after it. In addition, BeforeTest and AfterTest are run again for each individual test case. Note that the order in which test cases are executed is indeterminate. Type Attached Actions Example 1 [TestFixture] [ConsoleAction(\"Hello\")] public class ActionAttributeSampleTests { [Test] public void SimpleTestOne() { Console.WriteLine(\"Test One.\"); } [Test] public void SimpleTestTwo() { Console.WriteLine(\"Test Two.\"); } } Console Output Before Suite: Hello, from ActionAttributeSampleTests.{no method}. Before Case: Hello, from ActionAttributeSampleTests.SimpleTestOne. Test ran. After Case: Hello, from ActionAttributeSampleTests.SimpleTestOne. Before Case: Hello, from ActionAttributeSampleTests.SimpleTestTwo. Test ran. After Case: Hello, from ActionAttributeSampleTests.SimpleTestTwo. After Suite: Hello, from ActionAttributeSampleTests.{no method}. Remarks In this case, the class is the test suite. BeforeTest and AfterTest are run once each for this class and then again for each test. Example 2 (attached to interface) [ConsoleAction(\"Hello\")] public interface IHaveAnAction { } [TestFixture] public class ActionAttributeSampleTests : IHaveAnAction { [Test] public void SimpleTest() { Console.WriteLine(\"Test run.\"); } } Console Output Before Suite: Hello, from ActionAttributeSampleTests.{no method}. Before Case: Hello, from ActionAttributeSampleTests.SimpleTest. Test run. After Case: Hello, from ActionAttributeSampleTests.SimpleTest. After Suite: Hello, from ActionAttributeSampleTests.{no method}. Remarks Action attributes can be applied to an interface. If a class marked with [TestFixture] implements an interface that has an action attribute applied to the interface, the class inherits the action attribute from the interface. It behaves as if you applied the action attribute to the class itself. Example 3 (action attribute is applied to interface and attribute uses interface to provide data to tests) [AttributeUsage(AttributeTargets.Interface)] public class InterfaceAwareActionAttribute : TestActionAttribute { private readonly string _Message; public InterfaceAwareActionAttribute(string message) { _Message = message; } public override void BeforeTest(ITest details) { IHaveAnAction obj = details.Fixture as IHaveAnAction; if(obj != null) obj.Message = _Message; } public override ActionTargets Targets { get { return ActionTargets.Test; } } } [InterfaceAwareAction(\"Hello\")] public interface IHaveAnAction { string Message { get; set; } } [TestFixture] public class ActionAttributeSampleTests : IHaveAnAction { [Test] public void SimpleTest() { Console.WriteLine(\"{0}, World!\", Message); } public string Message { get; set; } } Console Output Hello, World! Remarks Here we see a new action attribute, InterfaceAwareAction . This attribute uses the Fixture property of the TestDetails passed into BeforeTest and casts it to an interface, IHaveAnAction. If the fixture implements the IHaveAnAction interface, the attribute sets the Message property to the string passed into the constructor of the attribute. Since the attribute is applied to the interface, any class that implements this interface gets its Message property set to the string provided to the constructor of the attribute. This is useful when the action attribute provides some data or service to the tests. Note that this attribute inherits from TestActionAttribute . It uses the default (do-nothing) implementation of AfterTest and overrides both BeforeTest and Target . Assembly Attached Action Example 1 [assembly: ConsoleAction(\"Hello\")] [TestFixture] public class ActionAttributeSampleTests { [Test] public void SimpleTest() { Console.WriteLine(\"Test run.\"); } } Console Output Before Suite: Hello, from {no fixture}.{no method}. Before Case: Hello, from ActionAttributeSampleTests.SimpleTest. Test run. After Case: Hello, from ActionAttributeSampleTests.SimpleTest. After Suite: Hello, from {no fixture}.{no method}. Remarks The ConsoleAction attribute in this example is applied to the entire assembly. NUnit treats an assembly as a test suite (in fact, a suite of suites). Since the ConsoleAction attribute implements both ITestSuiteAction and ITestCaseAction, NUnit will run BeforeTest once before any tests are run in the assembly, and AfterTest after all tests are run in the assembly. Additionally, BeforeTest and AfterTest will be run for every test case in the assembly. It is unlikely that action attributes are applied to assemblies often. However, it is useful to build action attributes that ensure state gets cleaned up before and after each tests to prevent individual tests from affecting the outcome of other test. For example, if you have any static or cached data or services, an action attribute can be used to clean them up for each test."
  },
  "articles/nunit/extending-nunit/Custom-Asserts.html": {
    "href": "articles/nunit/extending-nunit/Custom-Asserts.html",
    "title": "Custom Asserts | NUnit Docs",
    "keywords": "Custom Asserts Warning This is a draft. The contents may be out of date. Experienced developers using NUnit generally end up with a library of custom setup, teardown, test and support methods. Custom Asserts provide one way to re-package such methods, allowing the normal NUnit syntax to be used to invoke them and providing error messages that match the style and layout of standard NUnit messages. The standard NUnit Asserts create an object known as an asserter and pass it to the DoAssert method, which includes code similar to this... if (!asserter.Test()) throw new AssertionException(asserter.Message); Asserters encapsulate the comparison to be performed as well as the objects being compared. They implement the IAsserter interface, defined as follows: public interface IAsserter { // Test the condition for the assertion. bool Test(); // Return the message giving the failure reason. string Message { get; } } When implementing an asserter , you will have to decide on an approach for creating the message. For complex tests, it may be necessary to create and cache the message - or info used to create it - while the test is being performed. For example, when NUnit compares arrays, it notes the point of failure for use in the message. Otherwise, it would have to pass the entire array a second time. Generally, the constructor for the asserter will include any required parameters, the actual value and an optional user message. You may invoke the asserter directly, using Assert.DoAssert , but it is generally more convenient and readable to create an class similar to NUnit's Assert class, which contains static methods that wrap the object creation. For an example of how to do this, see the StringAssert class in the NUnit source."
  },
  "articles/nunit/extending-nunit/Custom-Attributes.html": {
    "href": "articles/nunit/extending-nunit/Custom-Attributes.html",
    "title": "Custom Attributes | NUnit Docs",
    "keywords": "Custom Attributes NUnit 3 implements a great deal of its functionality in its attributes. This functionality is accessed through a number of standard interfaces, which are implemented by the attributes. Users may create their own attributes by implementing these interfaces. For ease of understanding, the interfaces are grouped according to the stage in the life-cycle of a test at which they are used. The two primary stages in the life of a test are Load-Time and Execution-Time. Load-Time Interfaces Loading tests means loading the assembly into memory and examining its content to discover the classes and fixtures that represent tests. The internal structures that represent tests are built at this time. If requested by the application, information about the tests may be returned for display, as is done in the NUnit GUI runner. The following interfaces are called at load time. Interface Used By IFixtureBuilder Attributes that know how to build a fixture from a test class ITestBuilder Attributes that know how to build one or more parameterized test cases for a method ISimpleTestBuilder Attributes that know how to build a single non-parameterized test case for a method IParameterDataSource Attributes that supply values for a single parameter for use in generating test cases IImplyFixture Attributes used on a method to signal that the defining class should be treated as a fixture IApplyToTest Attributes that make modifications to a test immediately after it is constructed Execution-Time Interfaces At execution-time, some or all of the tests that were previously loaded are actually run. Their results are returned and made available to the application. The following interfaces are called at execution time. Interface Used By IApplyToContext Attributes that set up the context prior to execution ICommandWrapper Attributes that can wrap a TestCommand with another command"
  },
  "articles/nunit/extending-nunit/Custom-Constraints.html": {
    "href": "articles/nunit/extending-nunit/Custom-Constraints.html",
    "title": "Custom Constraints | NUnit Docs",
    "keywords": "Custom Constraints Note Page Under Development You can implement your own custom constraints by creating a class that inherits from the Constraint abstract class, which supports performing a test on an actual value and generating appropriate messages. Constraint Abstract Class Implementations must override the one abstract method ApplyTo<TActual> which evaluates the previously stored expected value (if any) against the method's parameter, the actual value. There are also several virtual methods that may be overridden to change some default behaviors. The relevant portions of the Constraint class are represented below. namespace NUnit.Framework.Constraints { public abstract class Constraint { protected Constraint(params object[] args) {} public abstract ConstraintResult ApplyTo<TActual>(TActual actual); /* ... */ public virtual ConstraintResult ApplyTo<TActual>(ActualValueDelegate<TActual> del) {} public virtual ConstraintResult ApplyTo<TActual>(ref TActual actual) {} protected virtual object GetTestObject<TActual>(ActualValueDelegate<TActual> del) {} public virtual string Description { get; protected set; } protected virtual string GetStringRepresentation() {} } } Constraint Constructor The Constraint constructor accepts zero or more arguments and saves them to be used in the printed description later. Constraints like NullConstraint or UniqueItemsConstraint take no arguments and simply state some condition about the actual value supplied. Constraints with a single argument usually treat it as the expected value resulting from some operation. Multiple arguments can be provided where the semantics of the constraint call for it. ApplyTo Implementation The ApplyTo<TActual>(TActual actual) method must be overridden and provides for the core implementation of the custom constraint. Whatever logic defines pass or fail of the constraint and actual/expected values goes into the ApplyTo<TActual>(TActual actual) method. For example, a very naive implementation of a reference equality constraint might look like this: public override ConstraintResult ApplyTo<TActual>(TActual actual) { return new ConstraintResult(this, actual, ReferenceEquals(actual, Arguments[0])); } The key here is there needs to be some evaluation of the constraint logic, and the return value must be a ConstraintResult or subclass thereof. Custom subclasses of ConstraintResult may be used to further customize the message provided upon failure, as described below. ApplyTo Overloads Constraints may be called with a delegate to return the actual value instead of the actual value itself. This serves to delay evaluation of the value. The default implementation of ApplyTo<TActual>(ActualValueDelegate<TActual> del) waits for the delegate to complete if it's an async operation, other immediately calls the delegate if synchronous, and then calls the abstract ApplyTo<TActual>(TActual actual) method with the value. Another overload also exists, ApplyTo<TActual>(ref TActual actual) . The default implementation dereferences the value and then calls the abstract ApplyTo<TActual>(TActual actual) method with the value. This public virtual method is available by use from calling code but currently is not used from any framework calls within NUnit itself. GetTestObject Optional Override The default implementation of ApplyTo<TActual>(ActualValueDelegate<TActual> del) does not simply execute the delegate but actually calls out to another virtual method, GetTestObject<TActual>(ActualValueDelegate<TActual> del) . This method can be overridden to keep the default behavior of ApplyTo<TActual>(ActualValueDelegate<TActual> del) while still customizing how the actual value delegate is invoked. Description Property This virtual property is used to provide a description of the constraint for messages. Simple constant values can be set in the custom constraint's constructor. If more complex logic is needed, override the property and provide a custom implementation of get . Here are a few simple examples from built-in constraints. public class FalseConstraint : Constraint { public FalseConstraint() { this.Description = \"False\"; } } public class NullConstraint : Constraint { public NullConstraint() { this.Description = \"null\"; } } Here are a few complex examples from built-in constraints. public class AndConstraint : BinaryConstraint { public override string Description { get { return Left.Description + \" and \" + Right.Description; } } } public abstract class PrefixConstraint : Constraint { public override string Description { get { return string.Format( baseConstraint is EqualConstraint ? \"{0} equal to {1}\" : \"{0} {1}\", descriptionPrefix, baseConstraint.Description); } } } GetStringRepresentation Method NUnit calls the GetStringRepresentation method to return a string representation of the constraint, including the expected value(s). The default implementation returns the lowercase display name of the constraint followed by all expected values, separated by a space. For example, a custom constraint ReferenceEqualsConstraint with an instance of a custom MyObject class as expected value would result in a default string representation of <referenceequals MyObject> . You can override the initial display name only by setting DisplayName in your constructor. This public property cannot be overridden, but the Constraint base class sets it in the base constructor to be the name of the class, minus the \"Constraint\" suffix and minus any generic suffixes. Custom Constraint Usage Syntax Having written a custom constraint class, you can use it directly through its constructor: Assert.That(myObject, new CustomConstraint()); You may also use it in expressions through NUnit's Matches syntax element: Assert.That(myObject, Is.Not.Null.And.Matches(new CustomConstraint()); The direct construction approach is not very convenient or easy to read. For its built-in constraints, NUnit includes classes that implement a special constraint syntax, allowing you to write things like... Assert.That(actual, Is.All.InRange(1, 100)); Custom constraints can support this syntax by providing a static helper class and extension method on ConstraintExpression , such as this. public static class CustomConstraintExtensions { public static ContentsEqualConstraint ContentsEqual(this ConstraintExpression expression, object expected) { var constraint = new ContentsEqualConstraint(expected); expression.Append(constraint); return constraint; } } To fully utilize your custom constraint the same way built-in constraints are used, you'll need to implement two additional classes (which can cover all your constraints, not for each custom constraint). Provide a static class patterned after NUnit's Is class, with properties or methods that construct your custom constructor. If you like, you can even call it Is and extend NUnit's Is , provided you place it in your own namespace and avoid any conflicts. This allows you to write things like: Assert.That(actual, Is.Custom(x, y)); with this sample implementation: public class Is : NUnit.Framework.Is { public static CustomConstraint Custom(object expected) { return new CustomConstraint(expected); } } Provide an extension method for NUnit's ConstraintExpression , allowing you to write things like: Assert.That(actual, Is.Not.Custom(x, y)); with this sample implementation: public static class CustomConstraintExtensions { public static CustomConstraint Custom(this ConstraintExpression expression, object expected) { var constraint = new CustomConstraint(expected); expression.Append(constraint); return constraint; } }"
  },
  "articles/nunit/extending-nunit/Engine-Extensibility.html": {
    "href": "articles/nunit/extending-nunit/Engine-Extensibility.html",
    "title": "Engine Extensibility | NUnit Docs",
    "keywords": "Engine Extensibility The NUnit Test Engine uses a plugin architecture to allow new functionality to be added by third parties. We originally planned to use Mono.Addins for this purpose and did so in the first betas. Because Mono.Addins no longer supports .NET 2.0, we were using a modified version that we created ourselves and which we would have to maintain in the future. Since Mono.Addins has many more features than we expect to use we decided to return to a custom plugin architecture. The NUnit 3.0 Engine Extensibility model is essentially based on the NUnit V2 addin design with a number of improvements, primarily inspired by Mono.Addins . On this page, we describe that model as a guide for folks working on NUnit or otherwise needing to understand it. See Writing Engine Extensions for user-focused information about how to create an extension. Extension Points NUnit 3.0 Extensibility centers around ExtensionPoints . An ExtensionPoint is a place in the application where add-ins can register themselves in order to provide added functionality. Each extension point is identified by a string, called the Path , is associated with a particular Type to be used by extensions and may also have an optional Description . How an extension is used depends on the particular extension point. For example, some extension points may only allow one extension to be registered while others may support multiple extensions. Where multiple extensions are supported, they may be used as alternatives or they may all operate, depending on the precise purpose of the extension point. In other words, read the docs and understand the exact semantics of an extension point before trying to create an extension for it. In our initial implementation, all extension points are contained in the engine. In a future release, we will allow addins to define extension points and host extensions as well. ExtensionPoints are identified by use of either the TypeExtensionPointAttribute or the ExtensionPointAttribute . TypeExtensionPointAttribute This is the most common way we identify ExtensionPoints in NUnit. The TypeExtensionPointAttribute is applied to an interface or class, exposed to the user in the nunit.engine.api assembly. This indicates that extensions must implement the specified interface or derive from the class. For example, here is the code used to define the extension point for driver factories - classes that know how to create an appropriate driver for a test assembly. /// <summary> /// Interface implemented by a Type that knows how to create a driver for a test assembly. /// </summary> [TypeExtensionPoint( Description = \"Supplies a driver to run tests that use a specific test framework.\")] public interface IDriverFactory { /// <summary> /// Gets a flag indicating whether a given assembly name and version /// represent a test framework supported by this factory. /// </summary> bool IsSupportedTestFramework(string assemblyName, Version version); /// <summary> /// Gets a driver for a given test assembly and a framework /// which the assembly is already known to reference. /// </summary> /// <param name=\"domain\">The domain in which the assembly will be loaded</param> /// <param name=\"assemblyName\">The Name of the test framework reference</param> /// <param name=\"version\">The version of the test framework reference</param> /// <returns></returns> IFrameworkDriver GetDriver(AppDomain domain, string assemblyName, Version version); } In this case, we used the default constructor. An alternate constructor allows specifying the Path but is usually not needed. In this case, NUnit will assign a default Path of \"/NUnit/Engine/TypeExtensions/IDriverFactory\". Extensions that implement IDriverFactory will be automatically associated with this extension point. Description is the only named property for this attribute. ExtensionPointAttribute Extensions may also defined by use of the ExtensionPointAttribute at the assembly level. The Path and the Type must be specified in the attribute constructor. Each attribute identifies one extension point supported by that assembly, specifying an identifying string (the Path) and the required Type of any extension objects to be registered with it. The following example shows an alternative way we might have identified the same driver factory extension point shown above. This is not actual NUnit code, but only a hypothetical example. [assembly: ExtensionPoint( \"/NUnit/Engine/TypeExtensions/IDriverFactory\", typeof(IDriverFactory), Description=\"Supplies a driver to run tests that use a specific test framework.\")] This example defines exactly the same extension point as in the TypeExtensionPointAttribute example, albeit in a more roundabout way. Again, Description is the only named property for this attribute. Supported Extension Points The following extension types are supported by the engine: Project Loaders Result Writers Framework Drivers Event Listeners (NUnit Engine 3.4 and later only) Extensions An Extension is a single object of the required Type , which is registered with an ExtensionPoint . Extensions are identified by the ExtensionAttribute and additional information may be provided by use of the ExtensionPropertyAttribute , both of which are applied to the class that implements the extension. All Extensions must have a default constructor, which is used by NUnit to create the object when it is needed. ExtensionAttribute The ExtensionAttribute has only a default constructor, as well as two named properties, Path and Description . If the path is not provided, NUnit will try to find the appropriate extension point based on what Types are inherited or implemented by the class on which the attribute is placed. Assuming the extension point definition used above, any of the following would identify the classes as driver factories. [Extension(Path = \"/NUnit/Engine/TypeExtensions/IDriverFactory\")] public class DriverFactory1 : IDriverFactory { /* ... */ } [Extension] public class DriverFactory2 : IDriverFactory { /* ... */ } Generally, the Path will be omitted and the default value used. It may be needed in some cases, where classes implement multiple interfaces or inherit other classes that do so. Usually, this is not necessary if you follow the Single Responsibility principle. ExtensionPropertyAttribute Using only the ExtensionAttribute , NUnit would have to create instances of every extension in order to query it (for example) about its capabilities. Since extensions are generally in separate assemblies, this means that many potentially unneeded assemblies would be loaded. The ExtensionPropertyAttribute avoids this problem by allowing the extension to specify information about what it is able to do. NUnit scans the attributes using Mono.Cecil without actually loading the assembly, so that resources are not taken up by unused assemblies. To illustrate this, we will use the example of the engine's project loader ExtensionPoint . You can read about this extension point in detail at Project-Loaders but the essential thing for this example is that the extension point is passed a file path and must determine whether that file is in a format that it can interpret and load. We do that by loading the extension and calling its CanLoadFrom(string path) method. If we only knew what file extensions were used by the particular format, we could avoid loading the extension unnecessarily. That's where ExtensionPropertyAttribute comes in. The following is an example taken from NUnit's own extension for loading NUnit projects. [Extension] [ExtensionProperty(\"FileExtension\", \".nunit\")] public class NUnitProjectLoader : IProjectLoader { /* ... */ } By use of the ExtensionPropertyAttribute the assembly containing this extension will never be loaded unless the user asks NUnit to run tests in a file of type .nunit . If this attribute were not present, then the engine would have to load the assembly, construct the object and call its CanLoadFrom method. Of course, this means that the extension author must know a great deal about how each extension point works. That's why we provide a page for each supported extension points with details of how to use it. Locating Addins Assemblies containing Addins and Extensions are stored in one or more locations indicated in files of type .addins . Each line of the file contains the path of an addin assembly or a directory containing assemblies. Wildcards may be used for assembly entries and relative paths are interpreted based on the location of the .addins file. The default nunit.engine.addins is located in the engine directory and lists addins we build with NUnit, which are contained in the addins directory. The following is an example of a possible .addins file, with comments indicating what each line does: # This line is a comment and is ignored. The next (blank) line is ignored as well. *.dll # include all dlls in the same directory addins/*.dll # include all dlls in the addins directory too special/myassembly.dll # include a specific dll in a special directory /some/other/directory/ # process another directory, which may contain its own addins file # note that an absolute path is allowed, but is probably not a good idea # in most cases Any assemblies specified in a .addins file will be scanned fully, looking for addins and extensions. Any directories specified will be browsed, first looking for any .addins files. If one or more files are found, the content of the files will direct all further browsing. If no such file is found, then all .dll files in the directory will be scanned, just as if a .addins file contained \"*.dll.\" Assemblies are examined using Cecil, without actually loading them. Info is saved for actual instantiation of extensions on a just-in-time basis."
  },
  "articles/nunit/extending-nunit/Event-Listeners.html": {
    "href": "articles/nunit/extending-nunit/Event-Listeners.html",
    "title": "Event Listeners | NUnit Docs",
    "keywords": "Event Listeners Event Listeners are extensions that respond to specific events occurring during the running of a test. They implement the ITestEventListener interface. NUnit itself makes extensive use of this interface when running tests. By creating an extension, user code may also respond to test events. The definition of an Event Listener extension will look something like this: [Extension(EngineVersion=\"3.4\")] public class MyEventListener : ITestEventListener { /* ... */ } Note The EngineVersion property is used to document the fact that the event listener extension point was only added to the engine with version 3.4. It's function here is purely documentary because the EngineVersion property itself was also added in version 3.4. Event listeners should not be installed with earlier versions. The ITestEventListener interface is defined as follows: /// <summary> /// The ITestListener interface is used to receive notices of significant /// events while a test is running. It's single method accepts an Xml string, /// which may represent any event generated by the test framework, the driver /// or any of the runners internal to the engine. Use of Xml means that /// any driver and framework may add additional events and the engine will /// simply pass them on through this interface. /// </summary> [TypeExtensionPoint( Description = \"Allows an extension to process progress reports and other events from the test.\")] public interface ITestEventListener { /// <summary> /// Handle a progress report or other event. /// </summary> /// <param name=\"report\">An XML progress report.</param> void OnTestEvent(string report); } The argument to OnTestEvent is an XML-formatted string, with a different top-level element for each potential event. Start of run - <start-run...> End of run - <test-run...> Start of a test suite - <start-suite...> End of a test suite - <test-suite...> Start of a test case - <start-test...> End of a test case - <test-case...> The XML report signalling the end of a test case contains all available information, including the result. The start events only provide basic identifying information. See XML Formats for a full description of each report"
  },
  "articles/nunit/extending-nunit/Framework-Drivers.html": {
    "href": "articles/nunit/extending-nunit/Framework-Drivers.html",
    "title": "Framework Drivers | NUnit Docs",
    "keywords": "Framework Drivers Framework Drivers are extensions that know how to create a driver for a particular framework. The NUnit engine provides drivers for both the NUnit 3.x and NUnit 2.x frameworks. Third parties may provide drivers for other frameworks by creating extensions. The ExtensionPoint for framework drivers uses the Path \"NUnit.Engine.DriverService\" and accepts an extension of Type NUnit.Engine.Extensibility.IDriverFactory . The definition of a driver factory might look like this: [Extension] public class MyOwnFrameworkDriverFactory : IDriverFactory { /* ... */ } The IDriverFactory interface is defined as follows: public interface IDriverFactory { // Gets a flag indicating whether the provided assembly name and version // represent a test framework supported by this factory bool IsSupportedTestFramework(string assemblyName, Version version); // Gets a driver for use with the specified framework assembly name and version IFrameworkDriver GetDriver(AppDomain domain, string assemblyName, Version version); } The IFrameworkDriver interface is defined as follows: public interface IFrameworkDriver { // Gets and sets the unique identifer for this driver string ID { get; set; } // Loads the tests in an assembly string Load(string testAssemblyPath, IDictionary<string, object> settings); // Counts the test cases that would be executed int CountTestCases(string filter); // Executes the tests in an assembly string Run(ITestEventListener listener, string filter); // Returns information about the tests in an assembly string Explore(string filter); // Cancels an ongoing test run. void StopRun(bool force); The strings returned by Run and Explore are XML representations and the filter is also in XML format. See the source code for NUnit3FrameworkDriver and NUnit2FrameworkDriver for details"
  },
  "articles/nunit/extending-nunit/Framework-Extensibility.html": {
    "href": "articles/nunit/extending-nunit/Framework-Extensibility.html",
    "title": "Framework Extensibility | NUnit Docs",
    "keywords": "Framework Extensibility The NUnit Framework is the part of NUnit that is referenced by user tests. It contains the definition of all of NUnit's Attributes, Constraints and Asserts as well as the code that discovers and executes tests. Most extensions to exactly how tests are recognized and how they execute are Framework extensions. In this documentation, we refer to four different types of Framework extension: Custom Attributes allow creation of new types of tests and suites, new sources of data and modification of the environment in which a test runs as well as its final result. Action Attributes are an NUnit V2 feature, still supported in NUnit 3. They were designed to better enable composability of test logic by creating attributes that encapsulate specific actions to be taken before or after a test is run. For most work, Custom Attributes are the way to go, but Action Attributes continue to be the only way to apply an attribute at a higher level and have it apply to many tests. Custom Constraints allow the user to define new constraints for use in tests along with the associated fluent syntax that allows them to be used with Assert.That . Custom Asserts are, for the most part, no longer needed as a result the constraint-based assertion model. However, it is still possible to create them and custom asserts created for NUnit V2 are still usable. Links to Blog Posts On Custom constraints How to extend the NUnit constraints"
  },
  "articles/nunit/extending-nunit/IApplyToContext-Interface.html": {
    "href": "articles/nunit/extending-nunit/IApplyToContext-Interface.html",
    "title": "IApplyToContext Interface | NUnit Docs",
    "keywords": "IApplyToContext Interface NUnit tests run within a context, known as the TestExecutionContext . The context for a test case is nested within the context for its containing suite and so on, up to the assembly level. Attributes that implement IApplyToContext are called immediately after the context is created and before the test is run in order to make changes to the context. Once the test execution has completed, the context is discarded so that - effectively - any changes are reverted to their original values. The IApplyToContext interface is defined as follows: public interface IApplyToContext { void ApplyToContext(TestExecutionContext context); } An example of the use of the context may be helpful. One item in the TestExecutionContext is the default timeout value for test cases. When any test is marked with [Timeout(nnn)] the context value is replaced by the supplied argument. The new timeout applies for any test case it appears on and any test case that is contained in a suite that it appears on. When the test or suite completes, the new value is discarded and the value contained in the original context is once against used. Custom attributes that implement IApplyToContext should modify the TestExecutionContext in accordance with the arguments supplied to them. They are not called after the test is run and have no cleanup to perform. The NUnit attributes that implement IApplyToContext are as follows: DefaultFloatingPointToleranceAttribute ParallelizableAttribute SetCultureAttribute SetUICultureAttribute SingleThreadedAttribute TimeoutAttribute"
  },
  "articles/nunit/extending-nunit/IApplyToTest-Interface.html": {
    "href": "articles/nunit/extending-nunit/IApplyToTest-Interface.html",
    "title": "IApplyToTest Interface | NUnit Docs",
    "keywords": "IApplyToTest Interface The IApplyToTest interface is used to make modifications to a test immediately after it is constructed. It is defined as follows: public interface IApplyToTest { void ApplyToTest(Test test); } The Test Type is quite general and the argument may represent a suite or an individual test case. If the distinction is important, then you must code the attribute to examine the argument and react accordingly. The interface may appear on the same attribute that is used to construct the test or on a separate attribute. In either case, it will only be called after the test is built. The order in which ApplyToTest is called on multiple attributes is indeterminate. If two attributes make completely independent changes to a test, then the order is not relevant. But if they both change the same property, or related properties, then it may necessary to make tests in the attribute code to ensure that the correct value 'wins'. The most common example of this is for attributes that change the RunState of a test. If one attribute is trying to set it to RunState.Ignore , while the other wants it to be RunState.NotRunnable , we would normally expect the 'worst' value to win and for the test to be non-runnable. We can achieve that by code like the following: // In the attribute setting NotRunnable test.RunState = RunState.NotRunnable; /* ... */ // In the attribute setting Ignore if (test.RunState != RunState.NotRunnable) test.RunState = RunState.Ignore; The following NUnit attributes implement IApplyToTest : CategoryAttribute CombiningStrategyAttribute CultureAttribute ExplicitAttribute IgnoreAttribute OrderAttribute PlatformAttribute PropertyAttribute (and, through it, a large number of derived attributes) RequiresThreadAttribute TestAttribute TestFixtureAttribute"
  },
  "articles/nunit/extending-nunit/ICommandWrapper-Interface.html": {
    "href": "articles/nunit/extending-nunit/ICommandWrapper-Interface.html",
    "title": "ICommandWrapper Interface | NUnit Docs",
    "keywords": "ICommandWrapper Interface In NUnit 3, test execution is done using command objects, which are constructed for each test case. Execution of a single test case will generally require multiple nested commands. Some attributes placed on a test method are able to contribute to the chain of commands. For example, MaxTimeAttribute adds a command, which examines the elapsed time to complete a test and fails it if a specified maximum was exceeded. Attributes add to the command chain by implementing one of the two interfaces that derive from the ICommandWrapper interface. The interfaces are defined as follows: public interface ICommandWrapper { TestCommand Wrap(TestCommand command); } public interface IWrapTestMethod : ICommandWrapper { } public interface IWrapSetUpTearDown : ICommandWrapper { } Attributes should not implement the ICommandWrapper interface directly but should select one of the derived interfaces. NUnit applies the IWrapSetUpTearDown interface before SetUp and after TearDown. It applies the IWrapTestMethod interface after SetUp and before the test is run. Attributes implementing one of these interfaces must be placed on a test method. Otherwise, they have no effect. The Wrap method should return an appropriate command in which the original command has been nested. For an example, see the implementation of MaxTimeAttribute . The following NUnit attributes implement the IWrapSetUpTearDown interface: MaxTimeAttribute RepeatAttribute RetryAttribute The IWrapTestMethod interface is not currently used by any NUnit attributes."
  },
  "articles/nunit/extending-nunit/IFixtureBuilder-Interface.html": {
    "href": "articles/nunit/extending-nunit/IFixtureBuilder-Interface.html",
    "title": "IFixtureBuilder Interface | NUnit Docs",
    "keywords": "IFixtureBuilder Interface This interface is used by attributes that know how to build a fixture from a user class. IFixtureBuilder is defined as follows: public interface IFixtureBuilder { TestSuite BuildFrom(ITypeInfo type); } Custom fixture builders should examine the provided ITypeInfo and return an appropriate type of fixture based on it. If the fixture is intended to be an NUnit TestFixture , then the helper class NUnitTestFixtureBuilder may be used to create it. The following NUnit attributes currently implement this interface: TestFixtureAttribute TestFixtureSourceAttribute SetUpFixtureAttribute Notes: ITypeInfo is an internal interface used by NUnit to wrap a Type. See source code for details. It would make more sense for this interface method to return TestFixture rather than TestSuite . We use TestSuite because it is the common base for both TestFixture and SetupFixture . In a future version, we will try to adjust the hierarchy so that all suites based on a class are derived from TestFixture ."
  },
  "articles/nunit/extending-nunit/IImplyFixture-Interface.html": {
    "href": "articles/nunit/extending-nunit/IImplyFixture-Interface.html",
    "title": "IImplyFixture Interface | NUnit Docs",
    "keywords": "IImplyFixture Interface The IImplyFixture interface is an empty interface, used solely as a marker: public interface IImplyFixture { } If a class contains any method with an attribute that implements this interface, that class is treated as an NUnit TestFixture without any TestFixture attribute being specified. The following NUnit attributes currently implement this interface: TestAttribute TestCaseAttribute TestCaseSourceAttribute TheoryAttribute"
  },
  "articles/nunit/extending-nunit/Index.html": {
    "href": "articles/nunit/extending-nunit/Index.html",
    "title": "Extending NUnit | NUnit Docs",
    "keywords": "Extending NUnit NUnit is intended to be extensible. We can't do everything for everybody but we want to make it reasonably easy to extend NUnit. In many cases, users will be able to implement a special feature outside of our scope by simply creating a new attribute that embeds the required logic. In other cases, particularly in extending the engine, we rely on a plugin-architecture. Types of Extensibility Framework Extensibility Engine Extensibility"
  },
  "articles/nunit/extending-nunit/IParameterDataSource-Interface.html": {
    "href": "articles/nunit/extending-nunit/IParameterDataSource-Interface.html",
    "title": "IParameterDataSource Interface | NUnit Docs",
    "keywords": "IParameterDataSource Interface The IParameterDataSource interface is implemented by attributes that provide data for use as an argument to a single parameter. Other attributes and test builders combine the values in various ways to produce test cases. The interface is defined as follows: public interface IParameterDataSource { IEnumerable GetData(IParameterInfo parameter); } IParameterInfo is an NUnit internal class used to wrap a ParameterInfo . See the source code for more info. A custom attribute implementing this interface should examine the IParameterInfo and return data values that are compatible with the parameter. The attribute has no control over how this data is combined with other arguments - that's up to other attributes and ultimately NUnit itself. The following NUnit attributes currently implement IParameterDataSource : RandomAttribute ValuesAttribute , with the derived class RangeAttribute ValueSourceAttribute"
  },
  "articles/nunit/extending-nunit/ISimpleTestBuilder-Interface.html": {
    "href": "articles/nunit/extending-nunit/ISimpleTestBuilder-Interface.html",
    "title": "ISimpleTestBuilder | NUnit Docs",
    "keywords": "ISimpleTestBuilder This interface is used by attributes that know how to build a single, non-parameterized test from a MethodInfo . ISimpleTestBuilder is defined as follows: public interface ISimpleTestBuilder { TestMethod BuildFrom(IMethodInfo method, Test suite); } IMethodInfo is an NUnit internal class used to wrap a MethodInfo . See the source code for more info. The suite argument is the test suite that contains the method in question. Custom attributes implementing ISimpleTestFixture should examine the IMethodInfo provided and return a single TestMethod instance, as appropriate to that method. The BuildFrom method should never return null, even if the specified method is not valid for a test. In that case, it should return a TestMethod with a RunState of NonRunnable, in order to provide feedback to the user who placed the attribute on the method. NUnit treats attributes implementing this interface specially. They are ignored if any other attributes are present that implement ITestBuilder . This allows, for example, use of [Test] on a method that also has [Combinatorial] specified, without any error arising. Such usage has existed in NUnit for some time and this special handling of the interface allows us to preserve it. In the current build, only TestAttribute implements this interface."
  },
  "articles/nunit/extending-nunit/ITestBuilder-Interface.html": {
    "href": "articles/nunit/extending-nunit/ITestBuilder-Interface.html",
    "title": "ITestBuilder Interface | NUnit Docs",
    "keywords": "ITestBuilder Interface This interface is used by attributes that know how to build one or more parameterized TestMethod instances from a MethodInfo . ITestMethodBuilder is defined as follows: public interface ITestBuilder { IEnumerable<TestMethod> BuildFrom(IMethodInfo method, Test suite); } IMethodInfo is an NUnit internal class used to wrap a MethodInfo. See the source code for more info. The suite argument is the test suite that contains the method in question. A custom attribute implementing this interface should examine the IMethodInfo and return as many TestMethod instances as it is able to construct, using the parameters available to it. Some attributes will only return a single test, just as TestCaseAttribute does. Others, working like TheoryAttribute may return multiple tests. If no data is available to create tests, an empty collection should be returned. If the returned tests are standard NUnit TestMethods, the helper class NUnitTestCaseBuilder may be used to create them. The following NUnit attributes currently implement ITestBuilder : CombiningStrategyAttribute , with the following derived classes: CombinatorialAttribute PairwiseAttribute SequentialAttribute TestCaseAttribute TestCaseSourceAttribute TheoryAttribute"
  },
  "articles/nunit/extending-nunit/Project-Loaders.html": {
    "href": "articles/nunit/extending-nunit/Project-Loaders.html",
    "title": "Project Loaders | NUnit Docs",
    "keywords": "Project Loaders Project Loaders are extensions that know how to load a project in a particular format and create a package suitable for running tests under NUnit. NUnit itself provides two of them: NUnitProjectLoader VisualStudioProjectLoader The extension point for project loaders accepts extensions that implement the NUnit.Engine.Extensibility.IProjectLoader interface. The definition of a project loader extension might look something like the following... [Extension] [ExtensionProperty(\"FileExtension\", \".xxx\")] [ExtensionProperty(\"FileExtension\", \".yyy\")] public class SomeProjectLoader : IProjectLoader { /* ... */ } The engine will only load the extension if it encounters a potential project file using the indicated file extensions. The IProjectLoader interface is defined as follows: /// <summary> /// The IProjectLoader interface is implemented by any class /// that knows how to load projects in a specific format. /// </summary> [TypeExtensionPoint( Description = \"Recognizes and loads assemblies from various types of project formats.\")] public interface IProjectLoader { /// <summary> /// Returns true if the file indicated is one that this /// loader knows how to load. /// </summary> /// <param name=\"path\">The path of the project file</param> /// <returns>True if the loader knows how to load this file, otherwise false</returns> bool CanLoadFrom(string path); /// <summary> /// Loads a project of a known format. /// </summary> /// <param name=\"path\">The path of the project file</param> /// <returns>An IProject interface to the loaded project or null if the project cannot be loaded</returns> IProject LoadFrom(string path); } An IProject , which is returned by LoadFrom is defined as: /// <summary> /// Interface for the various project types that the engine can load. /// </summary> public interface IProject { /// <summary> /// Gets the path to the file storing this project, if any. /// If the project has not been saved, this is null. /// </summary> string ProjectPath { get; } /// <summary> /// Gets the active configuration, as defined /// by the particular project. /// </summary> string ActiveConfigName { get; } /// <summary> /// Gets a list of the configs for this project /// </summary> IList<string> ConfigNames { get; } /// <summary> /// Gets a test package for the primary or active /// configuration within the project. The package /// includes all the assemblies and any settings /// specified in the project format. /// </summary> /// <returns>A TestPackage</returns> TestPackage GetTestPackage(); /// <summary> /// Gets a TestPackage for a specific configuration /// within the project. The package includes all the /// assemblies and any settings specified in the /// project format. /// </summary> /// <param name=\"configName\">The name of the config to use</param> /// <returns>A TestPackage for the named configuration.</returns> TestPackage GetTestPackage(string configName); } TestPackage is defined in the nunit.engine.api assembly and includes a list of assemblies together with a dictionary of settings used by the package."
  },
  "articles/nunit/extending-nunit/Result-Writers.html": {
    "href": "articles/nunit/extending-nunit/Result-Writers.html",
    "title": "Result Writers | NUnit Docs",
    "keywords": "Result Writers Result Writers take the result of a test run, in NUnit 3.0 XML format, and use it to create a result file in some other format. NUnit itself provides a two result writers, one to create output in NUnit V2 format and another to write test cases to the console. The definition of a result writer extension might look something like this: [Extension] [ExtensionProperty(\"Format\", \"custom\")] public class CustomResultWriterFactory : IResultWriter { /* ... */ } You must provide an ExtensionPropertyAttribute giving the name of the format you support. Users would access your format from the nunit-console command-line by using that name in a result specification, like nunit-console test.dll --result=CustomResult.xml;format=custom The IResultWriter interface, which you must implement, is defined as follows: /// <summary> /// Common interface for objects that process and write out test results /// </summary> [TypeExtensionPoint( Description = \"Supplies a writer to write the result of a test to a file using a specific format.\")] public interface IResultWriter { /// <summary> /// Checks if the output path is writable. If the output is not /// writable, this method should throw an exception. /// </summary> /// <param name=\"outputPath\"></param> void CheckWritability(string outputPath); /// <summary> /// Writes result to the specified output path. /// </summary> /// <param name=\"resultNode\">XmlNode for the result</param> /// <param name=\"outputPath\">Path to which it should be written</param> void WriteResultFile(XmlNode resultNode, string outputPath); /// <summary> /// Writes result to a TextWriter. /// </summary> /// <param name=\"resultNode\">XmlNode for the result</param> /// <param name=\"writer\">TextWriter to which it should be written</param> void WriteResultFile(XmlNode resultNode, TextWriter writer); } The engine calls the CheckWritability method at the start of the run, before executing any tests. The WriteResultFile method is called after the run is complete. The writer may check writability in any way desired, including writing an abbreviated output file, which it will later overwrite."
  },
  "articles/nunit/extending-nunit/Writing-Engine-Extensions.html": {
    "href": "articles/nunit/extending-nunit/Writing-Engine-Extensions.html",
    "title": "Writing Engine Extensions | NUnit Docs",
    "keywords": "Writing Engine Extensions The NUnit Test Engine uses a plugin architecture that allows users and third parties to add new functionality to the engine. The extensibility model defines a number of Extension Points to which Extensions may be added. This page gives general information that applies to all types of extensions you may want to write. The individual pages for each type of extension give specific details. For a detailed description of the engine extensibility architecture, see Engine Extensibility . Extension Attribute Every extension is implemented by a class with specific characteristics: Has a default constructor so that NUnit can create an instance. Implements some interface that varies according to the particular extension. Is marked with the ExtensionAttribute so that NUnit can recognize it as an extension. The code for a typical extension might look like this. [Extension] public class MyExtension : ISomeInterface // Depending on the extension point { // Your code here } The attribute has four named properties, all optional: Path This is a string that uniquely identifies the extension point to which the extension applies. It is only rarely needed, since NUnit can usually deduce the type of extension based on what interface is implemented by the extension class. Description An optional description of what the extension does. Enabled A boolean flag indicating whether the extension is enabled. This defaults to true. The setting is used by advanced extensions with functionality that is turned on and off depending on user input. EngineVersion The minimum engine version supported by the extension. Although optional, you should use this property if your extension will not work with all versions of the engine. If you don't use it and your extension requires engine services that are not present, then it might throw an exception or cause other errors. Note Only engine versions 3.4 or later check this property. The only way to avoid errors in the case of lower engine versions is to not install such extensions. ExtensionPropertyAttribute Using only the ExtensionAttribute , NUnit would have to create instances of every extension in order to ask questions like \"What file extensions do you support.\" This would mean loading many potentially unneeded assemblies. The ExtensionPropertyAttribute avoids the problem. NUnit's own extension for loading NUnit projects is a good example: [Extension] [ExtensionProperty(\"FileExtension\", \".nunit\")] public class NUnitProjectLoader : IProjectLoader { /* ... */ } By use of the ExtensionPropertyAttribute NUnit is able to postpone loading the extension until the user actually uses a file of type .nunit . If the extension is never needed, then it won't be loaded at all. For information about what properties are used by each extension point, see the individual pages for each type of extension. Note Extensions are usually created each in their own assembly for efficiency. It's possible to have several related extensions in the same assembly, but they will all be loaded into memory as soon as one is used. Kinds of Extensions As of version 3.4, the NUnit Engine supports four types of extensions. The individual pages for each type give specific details on implementing each of them. Project Loaders Result Writers Framework Drivers Event Listeners Installing Extensions Once an extension is written and compiled, it has to be placed somewhere such that NUnit will find it. Note This section is under construction. For now see the Engine Extensibility page"
  },
  "articles/nunit/getting-started/dotnet-core-and-dotnet-standard.html": {
    "href": "articles/nunit/getting-started/dotnet-core-and-dotnet-standard.html",
    "title": ".NET Core and .NET Standards | NUnit Docs",
    "keywords": ".NET Core and .NET Standards More information and getting started tutorials are available for NUnit and .NET Core targeting C# , F# and Visual Basic in the .NET Core documentation's Unit Testing in .NET Core and .NET Standard page. Testing .NET Core and .NET Standard projects requires each test project to reference version 3.9.0 or later of the NUnit 3 Visual Studio Test Adapter. It is recommended to install the adapter from NuGet if you are testing .NET Core or .NET Standard projects. The VSIX adapter does not, and will not, support .NET Core because VSIX packages cannot target multiple platforms. Adding this adapter and Microsoft.NET.Test.Sdk version 15.5.0 to your NUnit test projects will also enable the dotnet test command for .NET Core projects. Any tests using the new style CSPROJ format, either .NET Core or .NET 4.x, need to add a PackageReference to the NuGet package Microsoft.NET.Test.Sdk . Your test assemblies must also be .NET Core or .NET 4.x, not .NET Standard. <ItemGroup> <PackageReference Include=\"Microsoft.NET.Test.Sdk\" Version=\"15.5.0\" /> <PackageReference Include=\"NUnit\" Version=\"3.9.0\" /> <PackageReference Include=\"NUnit3TestAdapter\" Version=\"3.9.0\" /> </ItemGroup> .NET Core test can be run on the command line with dotnet test , for example, > dotnet test .\\test\\NetCore10Tests\\NetCore10Tests.csproj Also, note that Code Coverage and Live Unit Testing does not work with .NET Core yet. They will be supported in a future version of Visual Studio, likely post 15.3. For a more complete walk-through, please see Testing .NET Core with NUnit in Visual Studio 2017 Install the NUnit project template The NUnit test project templates need to be installed before creating a test project. This only needs to be done once. Run dotnet new -i NUnit3.DotNetNew.Template to install the NUnit templates. Once you do this, you can then run dotnet new nunit to create an NUnit test project. FAQ Why can't my tests target .NET Standard Visual Studio and VSTest require that the tests target a specific platform. .NET Standard is like a Portable library in that it does not target any specific platform, but can run on any supported platform. Microsoft decided that your tests should be compiled to target a platform so they know which platform to run your tests under and you get the behavior you expect for the platform you are targeting. You can however target multiple platforms in your tests and compile and run each from the command line. It still only runs one platform from Visual Studio, but I would hope that is being worked on. I haven't tested 15.3 yet. It is similar to a console application, it cannot be .NET Standard, it must target a platform, .NET Core or .NET Framework. This limitation is the same for all test adapters including xUnit and MSTest2. My tests aren't showing up in Visual Studio 2017 Are you using the NuGet package? Are you using version 3.8.0 or newer of the NuGet package? Do your tests target .NET Core or the full .NET Framework? (see above) Have you added a Package Reference to Microsoft.NET.Test.Sdk ? Have you restarted Visual Studio? It is still a bit temperamental. My tests multi-target .NET Core and .NET Framework, why can't I run both in Visual Studio This is a limitation of Visual Studio, hopefully it will be fixed in a future release. Meanwhile, you can run specific tests using the --framework command line option of dotnet test How to I produce a test results file dotnet test does not currently support passing command line options on to the test adapter, so NUnit cannot produce TestResults.xml yet. We are looking at ways of working around this, but for now, people have had success producing a VSTest results file. See the issue Add support for producing XML test results for more info."
  },
  "articles/nunit/getting-started/installation.html": {
    "href": "articles/nunit/getting-started/installation.html",
    "title": "Installation | NUnit Docs",
    "keywords": "Installation To get a copy of the NUnit 3, you can use various installation approaches. Full NUnit install via NuGet. NUnitLite install via NuGet. Zip and/or MSI file download. Combined Approach Using NuGet Packages In Visual Studio, from the Tools menu, select NuGet Package Manager | Manage NuGet packages for solution... Open the Browser tab, and Scroll or use search to locate the NUnit and NUnit.Console packages. NUnit and NUnit.Console Install both packages. The NUnit package should be referenced by each of your test assemblies, but not by any others. Locate nunit3-console in the packages\\NUnit.ConsoleRunner.3.X.X\\tools (or your configured package directory of choice) directory under your solution. This is the location from which you must run nunit3-console when if you would like to run NUnit3 from console. We recommend you only use this approach when running under the control of a script on your build server. NUnit3TestAdapter If you want to run NUnit tests automated on a clean machine without any installations (e.g. TFS build agent) - and you're using Visual Studio 2012 or later, use this package. It's based on the Visual Studio Test Adapter and provides a compiled NUnit3 Visual Studio Test Adapter. Using NuGet NUnitLite Package The NUnitLite approach provides a way to run NUnit tests without a full install of the NUnit runner and test engine assemblies. Only the framework and a small runner program are installed. Note that this is currently the only way to run tests under SilverLight 5.0 or the compact framework. In Visual Studio, from the Tools menu, select NuGet Package Manager | Manage NuGet packages for solution... Scroll or use search to locate the NUnitLite Version 3 and install it. The package should be referenced by each of your test assemblies, but not by any others. As a result of your installation, a file named \"Program.cs\" will have been copied into each of your test projects. NUnitLite test projects are console applications and this file contains the Main() program for your tests. If you already have a Main() in some other class, you may delete the file. This file also contains comments describing how the main should call the NUnitLite runner. To run your tests, simply run your executable test assembly. No other runner is needed. Downloading the Zip File Download the latest binary zip of the NUnit Framework from our Download page . Unzip the file into any convenient directory. You can also download the latest binary zip or an MSI installer of the NUnit Console from GitHub . Unzip the file or install the MSI and then if you would like be able to run nunit3-console from the command line, put the bin directory, containing nunit3-console.exe on your path. In your test assemblies, add a reference to nunit.framework.dll, using the copy in the subdirectory for the appropriate runtime version. For example, if you are targeting .NET 4.0, you should reference the framework assembly in the net-4.0 subdirectory. Run nunit3-console from the command line, giving it the path to your test assembly. To run NUnit's own framework tests from within the NUnit bin directory, enter: nunit3-console net-2.0/nunit.framework.tests.dll Combined Approach This approach is useful if you would like to use a single copy of nunit3-console with individual copies of the framework in each project. Simply follow the zip file procedure to get a central copy of NUnit on your system. Then install the NUnit Version 3 NuGet package in each of your test assemblies. For desktop use by developers, this approach may give you the best of both worlds."
  },
  "articles/nunit/getting-started/samples.html": {
    "href": "articles/nunit/getting-started/samples.html",
    "title": "Samples | NUnit Docs",
    "keywords": "Samples Samples of NUnit usage are available in each of the languages listed below. C# Samples VB.NET Samples F# Samples C++ Samples"
  },
  "articles/nunit/getting-started/upgrading.html": {
    "href": "articles/nunit/getting-started/upgrading.html",
    "title": "Upgrading | NUnit Docs",
    "keywords": "Upgrading This document assumes you are upgrading to NUnit 3.0 from NUnit 2.6 or later. While it's possible to upgrade from an earlier version, you will need to take into account many additional changes in NUnit, which are not described here. If this is your situation, be sure to check the release notes for earlier versions of NUnit as well. Review Breaking Changes The Breaking Changes page lists missing and changed functionality in NUnit 3.0. You should review this page to see which items are likely to affect your own tests. Update Your Code In many cases, the items being removed have been deprecated for some time and an alternate approach may already be available in your current release of NUnit. If that is the case, it will probably save you time and effort if you modify the code in your current environment before switching to NUnit 3.0. For example, NUnit 3.0 no longer supports ExpectedExceptionAttribute . However, preferred alternatives Assert.Throws and the ThrowsConstraint have been available for several years. If you remove the attribute from your tests and use one of the alternatives instead, you can verify that they work in your present environment and they will continue to work after conversion.** Switch to NUnit 3.0 Remove references to your old version of NUnit and replace them with references to NUnit 3.0. In the case of NUnitLite executable tests, you will need to reference both the nunit.framework and NUnitLite assemblies. Compile your code. It's possible that you will find compiler errors due to breaking changes in NUnit 3.0, which you missed in the prior step. Make the necessary changes until it all works. Make the Tests Pass Hopefully, you aren't converting tests that were not passing when you started! If all goes well, they will continue to pass under NUnit 3.0. If not, investigate each case and make necessary changes. If something isn't working as advertised, please let us know."
  },
  "articles/nunit/intro.html": {
    "href": "articles/nunit/intro.html",
    "title": "NUnit Documentation | NUnit Docs",
    "keywords": "NUnit Documentation This documentation covers NUnit 3.0 and higher. Where applicable, we have marked sections with the version in which a feature first appeared. If you are new to NUnit, we suggest you begin by reading the Getting Started section of this site. Those who have used earlier releases may want to begin with the Upgrading section. See the Release Notes for more information on each release."
  },
  "articles/nunit/license.html": {
    "href": "articles/nunit/license.html",
    "title": "NUnit License | NUnit Docs",
    "keywords": "NUnit License Copyright (c) 2004-2015 Charlie Poole Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE."
  },
  "articles/nunit/release-notes/breaking-changes.html": {
    "href": "articles/nunit/release-notes/breaking-changes.html",
    "title": "Breaking Changes | NUnit Docs",
    "keywords": "Breaking Changes NUnit 3.10 NUnit.Framework.Constraints.NUnitEqualityComparer.Default was deprecated in favor of new NUnitEqualityComparer() . NUnit 3.8 Removed some deprecated attributes: TestFixtureSetUpAttribute (use OneTimeSetUpAttribute) TestFixtureTearDownAttribute (use OneTimeTearDownAttribute) RequiresSTAAttribute (use ApartmentAttribute) RequiresMTAAttribute (use ApartmentAttribute) Removed deprecated Is.StringXxxx syntax elements: Is.StringStarting (use Does.StartWith) Is.StringEnding (use Does.EndWith) Is.StringContaining (use Does.Contain) Is.StringMatching (use Does.Match) NUnit 3.7 The AssertionHelper class has now been deprecated. Users can use the NUnit.StaticExpect library as a near drop-in replacement. NUnit 3.4 Breaking changes introduced in NUnit 3.4 The --teamcity console command-line option now requires the TeamCityEventListener extension to be installed. This only affects users who install the extensions individually or copy them to another directory. If you install using the Windows installer or the NUnit.Console NuGet package the TeamCity extension is included. String arguments in the names of test cases are no longer truncated to 40 characters. The .NET 2.0 build of the nunit framework uses a private implementation of System.Linq. NUnit installs the NUnit.System.Linq assembly alongside the nunit.framework assembly. If you copy the framework to another location, you must ensure that both are copied. The extra assembly is not used in other builds because System.Linq is already supported in those environments. NUnit 3.0 A relatively large number of features present in NUnit 2.6, were either removed in NUnit 3.0 or had their behavior modified in a way that will break existing code. A key change is that the NUnit Test Engine will not recognize a test assembly that does not reference the NUnit framework directly. Normally, test assemblies use NUnit Asserts, attributes and other Types and methods. However, certain third-party frameworks are designed to completely isolate the user from the details of NUnit. They mediate between the test assembly and the NUnit framework in order to run tests. In such a case, NUnit will indicate that the assembly either contains no tests or the proper driver could not be found. To resolve this situation, simply add one NUnit attribute or other reference. An assembly-level ParallelizableAttribute is useful for this purpose. Other breaking changes are grouped in the following tables. Attributes Name Notes ExpectedExceptionAttribute No longer supported. Use Assert.Throws or Assert.That . IgnoreAttribute The reason is now mandatory RequiredAddinAttribute No longer supported. RequiresMTAAttribute Deprecated. Use ApartmentAttribute RequiresSTAAttribute Deprecated. Use ApartmentAttribute SuiteAttribute No longer supported. System.MTAThreadAttribute No longer treated as RequiresMTAAttribute System.STAThreadAttribute No longer treated as RequiresSTAAttribute TearDown and OneTimeTearDown There is a change to the logic by which teardown methods are called. See Setup and Teardown Changes for details. TestCaseAttribute Named parameter Result= is no longer supported. Use ExpectedResult= . Named parameter Ignore= now takes a string, giving the reason for ignoring the test. TestCaseSourceAttribute The attribute forms using a string argument to refer to the data source must now use only static fields, properties or methods. TestFixtureAttribute Named parameter Ignore= now takes a string, giving the reason for ignoring the test. TestFixtureSetUpAttribute Deprecated. Use OneTimeSetUpAttribute . TestFixtureTearDownAttribute Deprecated. Use OneTimeTearDownAttribute . ValueSourceAttribute The source name of the data source must now use only static fields, properties or methods. Assertions and Constraints Feature Notes Assert.IsNullOrEmpty No longer supported. Use Assert.That(..., Is.Null.Or.Empty) Assert.IsNotNullOrEmpty No longer supported. Use Assert.That(..., Is.Not.Null.And.Not.Empty) Is.InstanceOfType No longer supported. Use Is.InstanceOf Is.StringStarting Deprecated. Use Does.StartWith Is.StringContaining Deprecated. Use Does.Contain Is.StringEnding Deprecated. Use Does.EndWith Is.StringMatching Deprecated. Use Does.Match NullOrEmptyStringConstraint No longer supported. See Assert.IsNullOrEmpty above Text.All No longer supported. Use Has.All or Is.All Text.Contains No longer supported. Use Does.Contain or Contains.Substring Text.DoesNotContain No longer supported. Use Does.Not.Contain Text.StartsWith No longer supported. Use Does.StartWith Text.DoesNotStartWith No longer supported. Use Does.Not.StartWith Text.EndsWith No longer supported. Use Does.EndWith Text.DoesNotEndWith No longer supported. Use Does.Not.EndWith Text.Matches No longer supported. Use Does.Match Text.DoesNotMatch No longer supported. Use Does.Not.Match Other Framework Features Feature Notes Addins No longer supported. See Addin Replacement in the Framework . CurrentDirectory No longer set to the directory containing the test assembly. Use TestContext.CurrentContext.TestDirectory to locate that directory. NUnitLite NUnitLite executable tests must now reference nunit.framework in addition to NUnitLite. SetUpFixture Now uses OneTimeSetUpAttribute and OneTimeTearDownAttribute to designate higher-level setup and teardown methods. SetUpAttribute and TearDownAttribute are no longer allowed. TestCaseData The Throws Named Property is no longer available. Use Assert.Throws or Assert.That in your test case. TestContext The fields available in the TestContext have changed, although the same information remains available as for NUnit V2. Async void tests No longer supported. Use async Task as the method signature instead. Console Features The console runner is now called nunit3-console . The following breaking changes apply to the options that the new runner supports. Option Function Notes --fixture=STR Test fixture or namespace to be loaded No longer supported. Use --test instead. --run=STR List of tests to run No longer supported. Replaced by --test. --runlist=PATH File containing list of tests to run No longer supported. Replaced by --testlist. --include=LIST List of categories to include No longer supported. Use --where instead. --exclude=LIST List of categories to exclude No longer supported. Use --where instead. --process=PROCESS ProcessModel for test assemblies Default value is now Separate for a single assembly, Multiple for more than one. Multiple assemblies run in parallel by default. --domain=DOMAIN DomainUsage for test assemblies Default value is now Separate for a single assembly, Multiple for more than one. --apartment=APT Apartment in which to run tests No longer supported. Use ApartmentAttribute. --xml=PATH Output result xml to path No longer supported. Use --result=SPEC instead. --noxml Disable xml result output No longer supported. Use --noresult instead. --xmlconsole Display XML to the console No longer supported. --basepath Set ApplicationBase for execution No longer supported. --privatebinpath Specify probing path for execution No longer supported. --cleanup Remove left-over cache files No longer supported. --noshadow Disable shadow copy No longer supported. The console runner now disables shadow copy by default. use --shadowcopy on the command-line to turn it on. --nothread Disable use of a separate thread for tests No longer supported. --nodots Do not display dots as a progress indicator No longer supported."
  },
  "articles/nunit/release-notes/console-and-engine.html": {
    "href": "articles/nunit/release-notes/console-and-engine.html",
    "title": "Console and Engine | NUnit Docs",
    "keywords": "Console and Engine NUnit Console & Engine 3.11.1 - February 15, 2020 This hotfix fixes a problem with NUnit Project file settings being ignored. 730 NUnit project file settings are ignored 732 Upgrade Cake Build to fix Linux CI NUnit Console 3.11 - January 26, 2020 This release fixes a range of minor bugs, and includes a significant amount of internal restructuring work. In future, this will enable improved .NET Standard support in the engine, and a .NET Core build of the console. 22 Engine modifies TestPackage 53 Add project element to top-level sub-project before merging 181 XSLT Transform not honoring --encoding value 336 Should legacyCorruptedStateExceptionsPolicy enabled=true in nunit3-console.exe.config? 386 nUnit project loader does not work when --inprocess is set 453 build-mono-docker.ps1 fails to run out the box 514 Add higher-level unit tests for structure of TestRunners 586 Create Separate Addin File for the Engine NuGet Package 588 licenseUrl in NuGet packages are deprecated 591 Release 3.10 merge 592 Add status badge from Azure pipelines 594 Fixed typos in release notes 595 Clean extension dir before running FetchExtensions task 603 Engine returns assembly-level test-suite event twice 605 Trailing \\ in --work argument causes agent to crash 607 Unload + Load changes TestPackage IDs 611 Set DisableImplicitNuGetFallbackFolder and bump Ubuntu on Travis 612 Fix logging when including exception 617 Consider expanding projects before building ITestRunner structure 625 [Feature] Extend start-run data for ITestEventListener 628 [Question] Possible to set both labels=After and labels=Before 634 Remove unnecessary stream creation in XML Transform writer 635 Remove all #regions from codebase 636 Labels option: Rename On as OnOutputOnly, and deprecate On and All 637 Refactor RunnerSelectionTests 639 Engine initializes DriverService too early 667 Console Runner loads wrong .NET framework version when executing tests from multiple assemblies at once 669 nunit.console-runner-with-extensions.nuspec: Remove outdated release notes 671 Manually updated .NET Core SDK on Linux build 681 Display path and version of extension assemblies 683 Safely encapsulating the atomic agent database operations 684 Split engine into upper and lower parts 691 Sign NuGet Packages and msi 693 Update Engine tests to run on LTS .NET Core version 696 Minimal compilation/test of .NET Core Console 698 Update NUnit v2 driver extension in combined packages 703 Update Console options for .NET Core Console build 704 Agent in nupkg should not be referenced and causes warnings in consuming projects 706 build.cake maintenance 707 Set agent to reference core and not full engine 713 Engine will not recognize .NET Framework versions beyond 4.5 NUnit Console 3.10 - March 24, 2019 This release merges the .NET Standard version of the engine back into the nunit.engine NuGet package and adds a .NET Standard 2.0 version of the engine that re-enables most services and extensions. This deprecates the nunit.engine.netstandard NuGet package. Any test runners using the old .NET Standard version of the engine should switch to this release. The --params command line option which took multiple test parameters separated by a semicolon is now deprecated in favor of the new --testparam command line option. One of the most common uses for test parameters was to pass connection strings into tests but this required workarounds to handle the semicolons. Now you must pass in each test parameter separately using a --testparam or --tp option for each. Issues Resolved 8 TempResourceFile.Dispose causes run to hang 23 In nunit3-console you cannot pass parameters containing ';' because they always get split 178 Add date and time to console output 282 \"Execution terminated after first error\" does not fail the console runner 388 Merge .NET Standard Engine back into the main solution 389 Update Mono.Cecil to latest 433 All messages from EventListenerTextWriter goes to console output independent on stream name 454 Misc improvements to ExtensionServiceTests 455 Remove CF, Silverlight and PORTABLE functionality 464 NUnit Console Reports Successful Exit Code When there is an Exception on Dispose 473 ArgumentException: DTD is prohibited in this XML document 476 .NET Standard engine to load extensions 479 Merge .NET Standard Engine code back into the main solution 483 Error in SetUpFixture does not result in non-zero exit code 485 Invalid integer arguments do not display properly in error message 493 Correct order of params to Guard.ArgumentValid() 498 Reset console colors after Ctrl-C 501 Create result directory if it does not exist 502 Remove unused method from build.cake 506 Dogfood NUnit.Analyzers via the nunit-console tests 508 Re-Enable OSX CI tests 515 Appveyor CI failing on master 518 Correct Refactoring Error 519 Break up multiple console error messages with colour 523 Reloading multiple files causes exception 524 .NET Standard 2.0 engine crashes when .NET Framework extensions are in Global NuGet Cache 525 Separate NuGet Restore for Appveyor build 531 Building a forked master branch results in publishing artifacts 533 Duplicate ids when loading a project 544 Deprecate nunit.netstandard.engine NuGet package 546 Cannot run a project file using --process:Separate 547 --labels=Before ignores --nocolor 556 Appveyor CI failing due to nuget restore 557 Disable CliFallbackFolder as a nuget source 562 Fix typo in comment 563 ProjectService is incorrectly initialized in agents 565 Eliminate -dbg suffix from version 566 SettingsService is not needed in agents 567 Unnecessary call to IProjectService 571 Space characters in the work directory path are not properly handled 583 NUnit Console NuGet Package Doesn't Load Extensions 587 Disable new MSBuild GenerateSupportedRuntime functionality, which breaks framework targeting NUnit Console 3.9 - September 5, 2018 This release should stop the dreaded SocketException problem on shutdown. The console also no longer returns -5 when AppDomains fail to unload at the end of a test run. These fixes should make CI runs much more stable and predictable. For developers working on the NUnit Console and Engine project, Visual Studio 2017 update 5 or newer is now required to compile on the command line. This does not effect developers using NUnit or the NUnit Console, both of which support building and running your tests in any IDE and on any .NET Framework back to .NET 2.0. Issues Resolved 103 The switch statement does not cover all values of the 'RuntimeType' enum: NetCF. 218 Move Distribution back into the nunit-console project. 253 Master Chocolatey issue 255 SocketException thrown during console run 312 CI failure: SocketException 360 CommandLineOption --err does not write error input to ErrorFile 367 nunit3-console loads nunit.framework with partial name 370 Nunit.Console 3.8 - Socket Exception 371 Remove -5 exit code on app domain unload failures 394 Multi-targeted Engine Extensions 399 Fix minor document issues 411 Make output received when providing user friendly messages unloading the domain more user friendly 412 Extensions not detected for version 3.9.0-dev-03997 436 NUnitEngineException : Unable to acquire remote process agent 446 Output CI version info to console 448 Update vs-project-loader extension to 3.8.0 450 Update NUnit.Extension.VSProjectLoader to 3.8.0 456 NuGet Package : Add repository metadata. 461 Use MSBuild /restore NUnit Console 3.8 - January 27, 2018 This release includes several fixes when unloading AppDomains and better error reporting. The aggregate NuGet packages also include updated versions of several extensions. Issues Resolved 6 TypeLoadException in nunit3-console 3.0.1 93 Update Readme with information about the NuGet packages 111 Provide better info when AppDomain won't unload 116 NUnit 3.5.0 defaults to single agent process when using an nunit project file 191 Exception encountered unloading AppDomain 228 System.Reflection.TargetInvocationException with nunit3-console --debug on Mono 246 No way to specify app.config with console runner 256 Rewrite ConsoleRunnerTests.ThrowsNUnitEngineExceptionWhenTestResultsAreNotWriteable() 259 NUnit3 agent hangs after encountering an \"CannotUnloadAppDomainException\" 262 Transform file existence check should check current directory instead of WorkDirectory 267 Fix possible NRE 273 Insufficient error handling message in ProcessRunner -> RunTests method 275 Integrate chocolatey packages with build script 284 NUnit3: An exception occured in the driver while loading tests... bei NUnit.Engine.Runners.ProcessRunner.RunTests(ITestEventListener listener, TestFilter filter) 285 ColorConsoleWriter.WriteLabel causes NullReferenceException 289 Warnings not displayed 298 Invalid --framework option throws exception 300 Agents do not respect the Console WORK parameter when writing log file 304 Catch agent debugger launch exceptions, and improve agent crash handling 309 No driver found if framework assembly reference has uppercase characters 314 Update NUnit.Extension.VSProjectLoader to 3.7.0 318 Update NUnit.Extension.TeamCityEventListener to 1.0.3 320 Return error code -5 when AppDomain fails to unload 323 Assertion should not be ordered in AgentDatabaseTests 343 Superfluous unload error shown in console 349 Get all TestEngine tests running under NUnitAdapter apart from those . 350 Invalid assemblies no longer give an error message 355 NuGet package links to outdated license NUnit Console 3.7 - July 13, 2017 Engine Creates a .NET Standard version of the engine for use in the Visual Studio Adapter Fixes several issues that caused the runner to exit with a SocketException Issues Resolved 10 Create a .NET Standard version of the Engine 11 insufficient info on driver reflection exception 12 Upgrade Cake build to latest version 24 Update --labels switch with option to show real-time pass/fail results in console runner 31 Nunit 3.4.1 NUnit.Engine.Runners 72 TestContext.Progress.Write writes new line 82 Remove unused repository paths from repositories.config 99 Remove unused --verbose and --full command line options 126 Resolve differences between NUnit Console and NUnitLite implementations of @filename 162 Add namespace keyword to Test Selection Language 171 Socket Exception when stopping Remote Agent 172 Limit Language level to C#6 193 Settings are stored with invariant culture but retrieved with CurrentCulture 194 Better logging or error handling in SettingsStore.SaveSettings 196 Allow comments in @FILE files 200 Remove obsolete warnings from build script 206 Remove reference to removed noxml option 207 Create Chocolatey package(s) for the console 208 Explore flags test update 213 Master build failing after merging .NET Standard Engine 216 Compiling mock-assembly in Visual Studio 2017 fails 217 NUnit .NET Standard NuGet package missing some values 219 Runtime.Remoting.RemotingException in NUnit.Engine.Runners.ProcessRunner.Dispose 221 Added missing nuget package info 222 Improve missing agent error message 225 SocketException thrown by nunit3-console.exe --explore option 248 Agent TestEngine contains duplicate services 252 Console crashes when specifying both format and transform for result 254 Correct misprint \".con\" -> \".com\" NUnit Console 3.6.1 - March 6, 2017 Engine This hotfix release addresses a race condition in the Engine that caused tests to intermittently fail. Issues Resolved 168 Intermittent errors while running tests after updating to 3.6 NUnit Console 3.6 - January 14, 2017 Console Runner Added command line option --skipnontestassemblies to skip assemblies that do not contain tests without raising an error and to skip assemblies that contain the NUnit.Framework.NonTestAssemblyAttribute. Messages from the new Multiple Assert blocks will be displayed individually Warnings from the new Warn.If, Warn.Unless and Assert.Warn are now displayed Engine NUnit agents now monitor the running engine process and will terminate themselves if the parent runner process is killed or dies Issues Resolved 16 NUnit Engine Tests fail if not run from test directory 18 Invalid file type is shown in XML as type=\"Assembly\" 23 In nunit3-console you cannot pass parameters containing ';' because they always get split 37 NUnit 3 console should produce xml events for ITestEventListener which contain unique id in the scope of all test agents for NUnit 2 tests 58 System.Configuration.ConfigurationErrorsException thrown in multiple domain mode. 62 NUnit3 Fails on DLL with no Tests, Unlike NUnit2 100 Class NUnit.Engine.Services.ResultWriters.Tests.SchemaValidator is never used 101 Method NUnit.Options.OptionSet.Unprocessed always returns \"false\" 104 Type of variable enumerated in 'foreach' is not guaranteed to be cast-able 110 Writability check could give a friendlier message. 113 Add task descriptions to Build.cake 127 Modify console runner to display multiple assert information 128 Terminate agent if main process has terminated 133 NUnit downloadable packages zip file naming is confusing and non-intuitive 136 Handle early termination of multiple assert block 138 Report Warnings in console runner 145 MasterTestRunner.RunAsync no longer provides start-run and test-run events 151 Unexpected behavior from --framework flag 153 Remove some settings used by the engine 156 Use high-quality icon for nuspecs 157 Fix Detection of invalid framework when --inprocess 159 Update extension versions in the NuSpec Files Earlier Releases Release Notes for NUnit 2.9.1 through 3.5 . Release Notes for NUnit 2.6 through 2.6.4 Release Notes for NUnit 2.5 through 2.5.10 Release Notes for NUnit 2.4 through 2.4.8 Release Notes for NUnit 2.0 through 2.2.10"
  },
  "articles/nunit/release-notes/framework.html": {
    "href": "articles/nunit/release-notes/framework.html",
    "title": "Framework Release | NUnit Docs",
    "keywords": "Framework Release NUnit 3.12 - May 14, 2019 This release of NUnit finally drops support for .NET 2.0. If your application still targets .NET 2.0, your tests will need to target at least .NET 3.5. Microsoft ended support for .NET 2.0 on July 12, 2011. Microsoft recommends that everyone migrate to at least .NET Framework 3.5 SP1 for security and performance fixes. This release dramatically improves NUnit support for async tests including returning ValueTask and custom tasks from tests, improved handling of SynchronizationContexts and better exception handling. The .NET Standard 2.0 version of NUnit continues to gain more functionality that is found in the .NET 4.5 version of the framework like setting the ApartmentState and enabling Timeout on tests. Issues Resolved 474 TypeHelperTests.cs is orphaned 999 Support multiple TestOf attributes per test 1638 TimeoutAttribute not available when targeting netcoreapp framework 2168 ThrowsAsync reports OperationCanceledException as TaskCanceledException 2194 How to use Contains.Substring with And 2286 Add support for custom Task (i.e. ValueTask) 2579 AppVeyor Test Failures under .NET 3.5 2614 TestExecutionContext.CurrentContext is saved in Remoting CallContext between test runs 2696 Getting WorkerId fails in debug 2772 Random failing of parallel test run: Unhandled Exception: System.InvalidOperationException: Stack empty. 2975 ComparisonConstraints are allocating string on construction 3014 Timeout failures on MacOS 3023 NUnit runner fails when test method returns ValueTask<> 3035 Apartment state can't be used for .NET Standard 2.0 tests 3036 Apartment state can't be used for .NET Standard 2.0 tests 3038 TestName in TestCase attribute not validated to be not empty 3042 RequiresThreadAttribute allows ApartmentState.Unknown, unlike ApartmentAttribute 3048 Add .idea folder to .gitignore 3053 Conversion from TestCase string parameter to DateTimeOffset 3059 Constraint Throws.Exception does not work with async return value 3068 First Chance Exception in RuntimeFramework 3070 End support for .NET Framework 2.0 (released in 2005) 3073 CollectionAssert.AreEquivalent fails for ValueTuple Wrapped Dictionary 3079 Regression from 3.10 to 3.11: Range in bytes 3082 Is.Ordered.By 3085 XML Test-Suite Assembly does not contain DLL path anymore 3089 Remove outdated comment 3093 Tests having TaskLike objects as their return type throws Exception 3094 Bad error message if collections have different types 3104 Removed NET20 compile output 3105 Add tests for use of ApartmentState.Unknown in RequiresThreadAttribute 3107 Declare class in Program.cs provided with NUnitLite Nuget package static 3109 Azure DevOps build fails in Save package artifacts 3124 Switch copyright notice 3128 Correct documentation on ParallelScope 3137 Fix doc-comments in NUnitTestAssemblyRunner 3138 Assert.Ignore breaks when a Task is returned w/o using async/await 3139 Add Azure pipelines badge to front page 3144 Retry attribute should not derive from PropertyAttribute 3145 Capture additional exception details in the test output 3156 UnexpectedExceptionTests should tolerate Mono on Azure DevOps Ubuntu 3159 Make tests more tolerant 3161 https url repo 3166 Allow static SetUpFixture classes 3171 Incorrect type for Test Fixtures when using running explore with a filter 3175 Improve user-facing messages 3181 Template Based Test Naming - Incorrect truncation for individual arguments 3186 Fix licenseUrl element in nuspec, will be deprecated 3193 Cake Build Fails with Visual Studio 2019 3195 Drop or at least make Travis not required? 3231 Breaking change in filter functionality between framework 2.7 and 3.11 3209 Test fail when posting to SynchronizationContext.Current 3211 Fix logging 3218 Remove to-dos from the code base 3222 Our build script tests hang when run with Mono on Windows 3233 AndConstraint should write additional information from failed constraint NUnit 3.11 - October 6, 2018 More informative assertion messages PlatformAttribute is available on and now detects .NET Core ValuesAttribute now works with nullable types Async tests detecting and running Windows Forms or WPF message pumps rather than deadlocking Support for UWP 10.0 is back via .NET Standard 1.4 Issues Resolved 352 Test with infinite loop in TearDown cannot be aborted 452 Deprecate the existing Chocolatey framework package 660 Order dependence of And and Or constraints should be documented 1200 async test + Apartment(ApartmentState.STA) => await not returning on STA thread 2123 Task.Run inside a test will result in deadlock if a control was created previously 2146 Assert.That with a Throws constraint does not provide as much info as Assert.Throws 2427 PropertyConstraint throws away the more helpful message in the base constraint result 2432 Ability to exclude/include the platform .NET Core 2450 NullReferenceException in ExceptionHelper.BuildMessage on Mono 2536 SetArgDisplayNames for TestCaseData and TestFixtureData 2611 Enable .NET Standard 1.6 tests on non-Windows 2693 Ensure that ReSharper settings are consistent with the editorconfig configuration 2757 Broken char comparison in v3.7 and higher 2759 Test fails with \"No arguments were provided\" error when no values returned from IParameterDataSource 2761 Infinite loop in nunit 3.9 2781 Fixed pre-compiler typo 2786 Timeout value not resetting on Retry of failed test 2790 Removing ITypeInfo abstraction 2798 [Request] Show actual count value when test fail on Has.Exactly(x).Items 2814 Remove public marker types 2819 Only run AppVeyor PR build against open PRs 2821 Save and restore the SynchronizationContext before and after each test case 2823 SetUp failed for test fixture - Array was not a one-dimensional array. Issue seems related to byte[,] method parameters 2829 Obsoletion warning for DataAttribute 2831 Regular \"BusyExecIdle after 200 milliseconds delay\" CI failures 2833 Use longer BusyExecIdle to avoid CI failures 2836 NUnit.Framework.Does cannot be extended 2837 DictionaryContainsKeyConstraint behavior is inconstant with Dictionary.ContainsKey when the dictionary uses a custom Comparer 2842 Supporting inheritance of Assert and related classes 2854 Has.All.../Has.None... - show non-matching items in error message 2863 Make tests robust without depending on the order of attributes 2867 Skip executing TestCaseSources for tests which are not included in the filter 2876 Implement Discovery-time filtering for NUnitLite 2883 Our public ConcurrentQueue causes type conflicts 2885 Copy/paste error in Assert.That documentation 2887 NETStandard 1.3 support dropped in NUnit 3.10 2896 Some tests are silently skipped on netstandard1.x since #2796 2898 AssemblyPath contains invalid characters 2901 Values attribute support for nullable bool and enum types 2923 Update outdated CategoryAttribute xml doc 2928 Improve error message on EmptyConstraint 2929 Added NUnit XML schemas 2940 Increase StackTracesAreFiltered amount to 5 2955 Potential threading issue in IsolatedContext 2965 NuGet Package : Add repository metadata. 2970 InvalidCastException @ NUnit.Framework.TestFixtureSourceAttribute.BuildFrom 2979 Warn.If in Assert.Multiple 2994 Error in .NET Standard 1.4 DictionaryContainsKeyConstraint MetadataToken compatibility methods 2996 Remove unused enum 3009 Fix failing CI Builds by upgrading to NUnit Console 3.9.0 3020 Upgrade nunit-vs-adapter to 3.10 for nUnit 3.11 3024 Unable to add .IgnoreCase modifier to an AnyOf constraint in collection constraints 3032 APIs to restore before 3.11 NUnit 3.10.1 - March 12, 2018 Added a namespace to the props file included in the NuGet package to make it compatible with versions of Visual Studio prior to VS 2017. NUnit 3.10 - March 12, 2018 This release adds a .NET Standard 2.0 version of the framework which re-enables most of the features that have been missing in our earlier .NET Standard builds like parallelism, timeouts, directory and path based asserts, etc. It also contains numerous bug fixes and smaller enhancements. We've improved our XML docs, fixed performance issues and added more detail to Multiple Asserts. This release also contains source-indexed PDB files allowing developers to debug into the NUnit Framework. This allows you to track down errors or see how the framework works. In order to support the .NET Standard 2.0 version, the NUnit project switched to the new CSPROJ format and now requires Visual Studio 2017 to compile. This only effects people contributing to the project. NUnit still supports building and compiling your tests in older .NET IDEs and NUnit still supports older versions of the .NET Framework back to 2.0. For contributors, NUnit can now compile all supported targets on Windows, Linux and Mac using the Cake command line build. Issues Resolved 1212 Separate AssertionHelper project or assembly 1373 Setting with a null value 1382 Use array argument contents in name of parameterized tests rather than just array type. 1578 TestContext.CurrentTest exposes too much internal info 1678 Result Message: OneTimeSetUp: Category name must not contain ',', '!', '+' or '-' 1944 Removing Compact Framework workarounds 1958 System.Reflection.TargetInvocationException after run finished 2033 Nameof refactor 2202 Best practices for XML doc comments 2325 Retry attribute doesn't retry the test. 2331 Repo does not build in VS without running build -t build first 2405 Improve PropertyConstraint error output 2421 Publishing symbols with releases 2494 CollectionAssert.AllItemsAreUnique() very slow 2515 Re-target Solution to use the New CSPROJ Format 2518 Bug in CollectionAssert.AreEqual for ValueTuples. 2530 Running tests on main thread. Revisiting #2483 2542 NUnit does not support parallelism on .NET Core 2.0 2555 CI timeout: NUnit.Framework.Assertions.CollectionAssertTest.PerformanceTests 2564 Add minClientVersion to .nuspec files 2566 Refactor SimpleEnumerableWithIEquatable test object 2577 Warning in TearDown is inconsistent with Assertion failure 2580 Remove unused defines 2591 NUnitEqualityComparer.Default should be replaced with new NUnitEqualityComparer() 2592 Add .props with ProjectCapability to suppress test project service GUID item 2608 Culture differences on .NET Core on non-Windows causes test failures 2622 Fix flakey test 2624 Prevent emails for successful builds on Travis 2626 SetUp/TearDown methods are invoked multiple times before/after test in .NET Standard targeted projects 2627 Breaking change in CollectionAssert.AllItemsAreUnique with NUnit 3.9 2628 Error during installing tools when running build script 2630 Framework throws NullReferenceException if test parameter is marked with [Values(null)] 2632 Parallel tests are loading 100% CPU when nested SetUpFixture exists 2639 ValuesAttribute causes ExpectedResult to have no effect 2647 Add Current Attempt indicator in TestContext for use with RetryAttribute 2654 Address feedback from @oznetmaster 2656 NuGet package links to outdated license 2659 Naming Errors 2662 NullReferenceException after parallel tests have finished executing 2663 Building NUnit .NET 4.5 in VS2017 fails 2669 Removed vestigial build script helper method 2670 Invalid assemblies no longer give an error message 2671 Ensure that FailureSite.Child is used where appropriate. 2685 Remove Rebracer file 2688 Assert.Throws swallows console output 2695 MultipleAssertException doesn't provide proper details on failures 2698 Syntax suggestions errors as warnings 2704 Add Constraint to test whether actual item is contained in expected collection 2711 NUnitLite: Add support for --nocolor option 2714 AnyOfConstraint enumerates multiple times 2725 Enable 'strict' compilation flag 2726 Replace the ConcurrentQueue and SpinWait compatibility classes 2727 Avoid treating warnings as errors inside the IDE 2734 TestCaseAttribute: ExpectedResult should support same value conversion as normal method arguments 2742 FailureSite not correctly set on containing suites when tests are ignored. 2749 Update Travis SDK versions NUnit 3.9 - November 10, 2017 This release addresses numerous parallelization issues that were introduced in 3.8 when method level parallelization was added. Most of the parallelization issues resolved were tests never completing when using some combinations of parallel tests and ApartmentState not being properly applied to tests in all cases. Issues Resolved 893 Inconsistent Tuple behavior. 1239 NUnit3 sometimes hangs if SetUpFixtures are run in parallel 1346 NullReferenceException when [TestFixtureSource] refers to data in a generic class. 1473 Allow Is.Ordered to Compare Null Values 1899 Constraint Throws.Exception does not catch exception with async lambdas 1905 SetupFixture without namespace will make assembly-level Parallelizable attribute useless 2091 When a native exception of corrupted state is thrown, nunit test thread crashes and the nunit-console process hangs 2102 NUnitLite incorrectly reports Win 10 OS name 2271 When CollectionAssert.AreEqual do compare each element, it will ignore the IEquatable of the element too 2289 ResolveTypeNameDifference does not handle generic types well 2311 Resolve test projects' namespace situation 2319 Add .editorconfig to set file encodings so that people don't have to think about it 2364 Parallelizable attribute not invalidating invalid parallel scope combinations 2372 Create testing for compounded ConstraintFilters 2388 Parallelization causes test cases to stop respecting fixture's apartment state 2395 NUnit 3.8+ does not finish running tests 2398 NUnit CI spurious failures, NUnit.Framework.Internal.ThreadUtilityTests.Kill 2402 --labels=All doesn't show anything in console output executing NUnitLite Console Runner 2406 Summary descriptions replaced by more detailed ones 2411 And constraint on Has.Member throws 2412 Using fluent syntax unintentionally removed in 3.8 2418 Support equality comparison delegate 2422 Has.Property causes AmbiguousMatchException for shadowing properties 2425 XML doc typo fix 2426 Regression in 3.8.1: ApartmentAttribute no longer works when applied to an assembly 2428 Fix NullReferenceExceptions caused by WorkItemQueue not being thread-safe 2429 Stack trace shown for Assert.Warn 2438 [Parallelizable] hangs after a few tests 2441 Allows to override load-time/execution-time interfaces in built-in tests attributes 2446 CI failure in mono Warning tests 2448 Inherited Test SetUp, TearDown, etc. are not executed in .NET Core if they are not public 2451 Compile RegEx to improve performance 2454 SetUpFixture not respecting NonParallelizable tag on TestFixtures. 2459 [Parallelizable(ParallelScope.Children)] Unable to finish tests 2465 Possible wrong properties are returned by reflection in ReflectionExtensions.cs 2467 Test execution hangs when using [SetUpFixture] with NUnit 3.8.x 2469 Allow RangeAttribute to be specified multiple times for the same argument 2471 Parametrized test cases not running in parallel 2475 Framework incorrectly identifies Win 10 in xml results 2478 Attributes on SetUpFixture are not applied 2486 Message when asserting null with Is.EquivalentTo could be more helpful 2497 Use ConstraintUtils.RequireActual through out the codebase 2504 Support changing test display name on TestFixtureData 2508 Correct divergence from shadowed Is / Has members. 2516 When test writes something to the stdErr there is no guaranteed way to link a test-output event to a target test using ITestEventListener 2525 Remove unwanted space from comment 2526 SerializationException in low trust floating point equality test 2533 Matches <T>(Predicate<T>) throws ArgumentException or Fails when actual is null 2534 SetUpFixture causes NUnit to lock with Apartment( STA ) 2551 CollectionItemsEqualConstraint is missing Using(Func<T, T, bool>) 2554 Made TestFixtureData.SetName internal for 3.9 NUnit 3.8.1 - August 28, 2017 This release fixes two critical regressions in the 3.8 release. The first caused the console runner to crash if you are using test parameters. The second issue caused collection constraints checking for multiple items in a collection to fail. Issues Resolved 2386 Contains.Item() fails for collections in NUnit 3.8 2390 Missing value attribute in test parameters setting causes NullReferenceException in console NUnit 3.8 - August 27, 2017 This release removes several methods and attributes that were marked obsolete in the original 3.0 release. Support for iOS and Android has been improved. An issue that caused unit tests to run slower was addressed as was a bug that prevented the use of Assert.Multiple in async code. The Order attribute can now also be applied to the class level to set the order that test fixtures will be run. Issues Resolved 345 Order of Fixture Execution 1151 Include differences in output for Is.EquivalentTo 1324 Remove CollectionContainsConstraint 1670 Attaching files to the test result 1674 InRange-Constraint must work with object 1851 TestCaseSource unable to pass one element byte array 1996 Timeout does not work if native code is running at the time 2004 Has.One as synonym for Has.Exactly(1).Items 2062 TestCaseSource attribute causes test to pass when source is not defined 2144 Allow option on RandomAttribute to produce distinct values 2179 Some NUnit project's tests fail on systems with CultureInfo other than en 2195 Contains.Substring with custom StringComparison 2196 Expose ParallelizableAttribute (and other attribute) constructor arguments as properties 2201 Invalid platform name passed to PlatformAttribute should mark test NotRunnable 2208 StackFilter trims leading spaces from each line 2213 SetCultureAttribute: CultureInfo ctor should use default culture settings 2217 Console runner performance varies wildly depending on environmental characteristics 2219 Remove Obsolete Attributes 2225 OneTimeTearDown and Dispose Ordering 2237 System.Runtime.Loader not available for iOS/Android 2242 Running tests directly should never surface a NullReferenceException 2244 Add KeyValuePair<TKey, TValue> to the default formatters 2251 Randomizer.NextGuid() 2253 Parallelizable(ParallelScope.Fixtures) doesn't work on a TestFixture 2254 EqualTo on ValueTuple with Nullable unexpected 2261 When an assembly is marked with ParallelScope.None and there are Parallelizable tests NUnit hangs 2269 Parallelizable and NonParallelizable attributes on setup and teardown silently ignored 2276 Intermittent test failures in Travis CI: TestContextTests 2281 Add type constraint for Throws and any method requiring Exception 2288 Killing thread cancels test run 2292 Is.Ordered.By() with a field throws NullReferenceException 2298 Write TestParametersDictionary to xml result file in readable format 2299 NUnitLite NuGet package no longer installs NUnit NuGet package 2304 Revert accidental doc removal 2305 Correct misprint \".con\" -> \".com\" 2312 Prevent crash on invalid --result parsing in NUnitLite 2313 Incorrect xml doc on RetryAttribute 2332 Update build script to use NUnitConsoleRunner v3.7.0 2335 Execute OneTimeTearDown as early as possible when running fixtures in parallel 2342 Remove deprecated Is.String* Constraints 2348 Can't use Assert.Multiple with async code 2353 Provide additional Result information through TestContext 2358 Get framework to build under Mono 5.0 2360 Obsolete CollectionContainsConstraint Constructors 2361 NUnit Parallelizable and OneTimeSetUp with no namespace results in single-threaded test execution 2370 TestCaseAttribute can't convert int to nullable long NUnit 3.7.1 - June 6, 2017 This is a hotfix release that addresses occasional hangs when using test parallelization and fixes crashes in NCrunch prior to version 3.9. Issues Resolved 2205 NCrunch: System.Xml.XmlException: Root element is missing, when adding NUnit 3.7.0 2209 NUnit occasionally hangs when parallelizable TestFixture has OneTimeSetUp and OneTimeTearDown NUnit 3.7 - May 29, 2017 This release of NUnit expands on parallel test execution to allow test methods to be run in parallel. Please see the Parallelizable Attribute for more information. NUnit 3.7 also drops the Portable build of the framework and replaces it with a .NET Standard 1.3 version to compliment the .NET Standard 1.6 version. This change enables several constraints and other features in the .NET Standard builds that weren't available in portable like Path and Directory based asserts. The AssertionHelper class has been deprecated because it is seldom used and has not received any of the updates that Asserts and Constraints receive. If your code is using the AssertionHelper class, we recommend that you migrate your asserts. Issues Resolved 164 Run test methods within a fixture in parallel 391 Multiple Assertions 652 Add ability to execute test actions before SetUp or OneTimeSetUp 1000 Support multiple Author attributes per test 1096 Treat OneTimeSetup and OneTimeTearDown as separate work items 1143 NUnitLite - Explore flag does not apply where filter to output 1238 Feature request: Print LoaderExceptions when fixture loading fails 1363 Make Timeouts work without running test on its own thread 1474 Several SetUpFixtures at the same level may be active at the same time 1819 TestContext.Progress.Write writes new line 1830 Add --labels switch changes to NUnitLite and NUnitLite tests 1859 ConcurrentQueue is duplicate with System.Threading.dll package 1877 Resolve differences between NUnit Console and NUnitLite implementations of @filename 1885 Test parameter containing a semicolon 1896 Test has passed however Reason with an empty message is printed in the xml 1918 Changing DefaultFloatingPointTolerance breaks tests running in parallel 1932 NUnit Warn class should be removed from stack trace by filter 1934 NullReferenceException when null arguments are used in TestFixtureAttribute 1952 TestContext.Out null when used in task with .NET Core 1963 Investigate removing SpecialValue 1965 TestContext does not flow in async method 1971 Switch CHANGES.txt to Markdown 1973 Implemented TestExecutionContext to use AsyncLocal<> for NETSTANDARD1_6 1975 TestFixtureSource doesn't work with a class that has no namespace 1983 Add missing ConstraintExpression.Contain overload 1990 Add namespace filter 1997 Remove unused --verbose and --full command line options 1999 Author Tests assume ICustomAttributeProvider.GetCustomAttributes return order is defined 2003 Better user info about ParallelizableAttribute and ParallelScope 2005 Exclude empty failure messages from results xml 2007 3.6 Multiple assertion backwards compatibility 2010 Add DelayedConstraint in NetStandard 1.6 build 2020 Better message when timeout fails 2023 Ability to abort threads running a message pump 2025 NullReferenceException using Is.EqualTo on two unequal strings 2030 Add method to mark tests as invalid with a reason 2031 Limit Language level to C#6 2034 Remove SilverLight project - no longer used 2035 NullReferenceException inside failing Assert.That call 2040 Cannot catch AssertionException 2045 NUnitLite-runner crashes if no file is provided 2050 Creation of TestExecutionContext should be explicit 2052 NullReferenceException with TestCaseSource if a property has no setter 2061 TestContext.WorkDirectory not initialized during build process 2079 Make TestMethod.Arguments public or otherwise accessible (e.g. TestContext) 2080 Allow comments in @FILE files 2087 Enhance error message: Test is not runnable in single-threaded context. Timeout 2092 Convert Portable library to .NET Standard 1.3 2095 Extend use of tolerance to ComparisonConstraints 2099 Include type in start-suite/start-test report elements 2110 NullReferenceException when getting TestDirectory from TestContext 2115 Mark AssertionHelper as Obsolete 2121 Chained PropertyConstraint constraints report incorrect ActualValue 2131 Remove \"Version 3\" suffix from NUnitLite NuGet Package 2132 TestFixtureTests.CapturesArgumentsForConstructorWithMultipleArgsSupplied assumes order of custom attributes 2143 Non-parallel fixture with parallel children runs in parallel with other fixtures 2147 Test Assembly using NUnitLite & NUnit 3.6.1 hangs under .NET Core when --timeout is supplied on command line 2150 Add portable-slow-tests to Cake file 2152 Allow attaching files to TestResults 2154 Fix execution of non-parallel test fixtures 2157 Getting WorkerId inside Assert.Throws / DoesNotThrow returns null instead of previous non-null value 2158 Update SetupFixtureAttribute XML Docs 2159 Prevent crash in .NET standard with log file path 2165 Trying to install NUnit 3.6.1 on .NET Framework asks for download of 20 more packages 2169 Incorrect xml docs for SetUpAttribute 2170 Cake build fails if only Visual Studio 2017 installed 2173 Remove PreTestAttribute and PostTestAttribute 2186 Replace special characters as part of converting branch names to package versions 2191 System.Reflection.TargetInvocationException with nunit3-console --debug on Mono NUnit 3.6.1 - February 26, 2017 This is a hotfix release of the framework that addresses critical issues found in the 3.6 release. Issues Resolved 1962 A Theory with no data passes 1986 NUnitLite ignores --workers option 1994 NUnitLite runner crashing when --trace is specified 2017 Two NUnit project's tests fail on systems with comma decimal mark settings 2043 Regression in 3.6.0 when catching AssertionException NUnit 3.6 - January 9, 2017 This release of the framework no longer includes builds for Compact Framework or for SilverLight, but adds a .NET Standard 1.6 build. If anyone still using Compact Framework or SilverLight and would like to continue development on those versions of the framework, please contact the NUnit team. Framework .NET Standard 1.6 is now supported Adds support for Multiple Assert blocks Added the --params option to NUnitLite Theories now support Nullable enums Improved assert error messages to help differentiate differences in values Added warnings with Warn.If(), Warn.Unless() and Assert.Warn() Enabled Path, File and Directory Asserts/Constraints for .NET Core testing Added NonTestAssemblyAttribute for use by third-party developers to indicate that their assemblies reference the NUnit framework, but do not contain tests Issues Resolved 406 Warning-level Assertions 890 Allow file references anywhere in the command line. 1380 AppVeyor Failures when branch name is too long 1589 Split the nunit repository into multiple repositories 1599 Move Compact Framework to separate project 1601 Move SilverLight to a separate project 1609 Upgrade Cake build to latest version 1661 Create .NET Standard Framework Build 1668 Need implementation-independent way to test number of items in a collection 1743 Provide multiple results for a test case in the XML output 1758 No direct inverse for Contains.Key 1765 TestCaseSourceAttribute constructor for method with parameters 1802 Design Multiple Assert syntax as seen by users 1808 Disambiguate error messages from EqualConstraint 1811 Build.ps1 fails if spaces in path 1823 Remove engine nuspecs and old global.json 1827 Remove unused repository paths from repositories.config 1828 Add Retry for failed tests only 1829 NUnitLite accepts --params option but does not make any use of it. 1836 Support nullable enums in Theories 1837 [Request] AfterConstraint to support more readable usage 1840 Remove SL and CF #Defined source 1866 [Request] More readable way to set polling interval in After constraint 1870 EqualConstraint result failure message for DateTime doesn't show sufficient resolution 1872 Parameterized method being called with no parameter 1876 What should we do about Env.cs 1880 AttributeUsage for various Attributes 1889 Modify NUnitLite to display multiple assert information 1891 TestContext.Progress and TestContext.Error silently drop text that is not properly XML encoded 1901 Make NUnitLite-runner Prefer32Bit option consistent across Debug/Release 1904 Add .NET Standard 1.6 Dependencies to the Nuspec Files 1907 Handle early termination of multiple assert block 1911 Changing misleading comment that implies that every ICollection<T> is a list 1912 Add new warning status and result state 1913 Report Warnings in NUnitLite 1914 Extra AssertionResult entries in TestResults 1915 Enable Path, File and Directory Assert/Constraints in the .NET Standard Build 1917 Use of IsolatedContext breaks tests in user-created AppDomain 1924 Run tests using the NUnit Console Runner 1929 Rename zip and remove source zip 1933 Tests should pass if test case source provides 0 test cases 1941 Use dictionary-based property for test run parameters 1945 Use high-quality icon for nuspecs 1947 Add NonTestAssemblyAttribute 1954 Change Error Message for Assert.Equals 1960 Typo fixes 1966 Xamarin Runner cannot reference NUnit NuGet Package Earlier Releases Release Notes for NUnit 2.9.1 through 3.5 Release Notes for NUnit 2.6 through 2.6.4 Release Notes for NUnit 2.5 through 2.5.10 Release Notes for NUnit 2.4 through 2.4.8 Release Notes for NUnit 2.0 through 2.2.10"
  },
  "articles/nunit/release-notes/Pre-3.5-Release-Notes.html": {
    "href": "articles/nunit/release-notes/Pre-3.5-Release-Notes.html",
    "title": "Pre 3.5 Release Notes | NUnit Docs",
    "keywords": "Pre 3.5 Release Notes Note Combined Release Notes for the NUnit framework, console and engine, up to version 3.5. For later releases, see: Framework Release Notes Console Release Notes NUnit 3.5 - October 3, 2016 This is the last version of NUnit where the framework, console runner, engine and extensions are being released together. From this point forward, the NUnit Framework will be released on its own schedule that is not bound to that of any other NUnit project and version numbers may diverge over time. This is also the first release where the NUnit Framework will not be included in the installer. Only the console runner, engine and extensions will be available as an MSI installer. We recommend that you use the NUnit NuGet packages for the framework, but a ZIP file with the binaries will also be available. Framework Added Assert.Zero and Assert.NotZero methods You can now pass a Func<string> to Asserts to lazily evaluate exception messages Added the ability to Assert on the order of multiple properties in a collection Tests with a Timeout will no longer timeout while you are debugging Issues Resolved 144 Pass a Func<string> to lazily evaluate an exception message 995 Enable Warning as Error 1106 Move various Assembly Info files under Properties for CF 1334 Add Assert.Zero and Assert.NotZero 1479 Don't enforce [Timeout] when debugger is attached 1540 Remove old .NET Core Projects 1553 Allow ordering tests to be done in multiple properties 1575 Escaping control chars in custom message 1596 Eliminate code sharing across projects to be split 1598 Split framework and console/engine into separate projects 1610 Refactor dependencies in build.cake 1615 AppVeyor error in TestCF 1621 Remove console and command-line option files from common 1640 When submitting only part of optional parameters, all are overridden by defaults 1641 Create OSX CI Build on Travis 1663 Find way to hide NUnit.Compatibility.Path from intellisense 1681 NUnitLite under .net core doesn't support TeamCity output 1683 Existence of SerializableAttribute in .NET Core 1693 2 unit tests fail due to localization 1716 Move installer to new repository 1717 Change suffix for master builds 1723 Remove Cake target TestAll 1739 Create separate copies of MockAssembly for framework, engine and extensions 1751 Serializable attribute exists in both System.Runtime.Serialization.Formatters and nunit.framework 1775 Support NUnit assertions in partial trust code. 1800 Remove Console/Engine projects from nunit.linux.sln 1805 Error message \"arguments provided for method not taking any\" seems incomplete / doesn't make much sense 1815 Prevent NullReferenceException in SubPathConstraint NUnit 3.4.1 - June 30, 2016 Console Runner A new option, --list-extensions, will display all the engine extensions that have been installed by the engine. Issues Resolved 1623 NUnit 3.4 is not integrated with TeamCity 1626 NUnit.ConsoleRunner is not picking up NUnit.Extension.NUnitV2ResultWriter 1628 Agent's process stays in memory when it was failed to unload AppDomain 1635 Console option to list loaded extensions NUnit 3.4 - June 25, 2016 Framework Improvements in comparing equality using IEquatable<T> Test case names will only be truncated if the runner requests it or it is overridden on the command line with the --test-name-format option The .NET 2.0 version of the framework now includes LINQ. If your tests target .NET 2.0, you can now use LINQ queries in your tests Engine The TeamCity event listener has been separated out into an engine extension Fixed numerous issues around thread safety of parallel test runs Additional fixes to reduce memory usage Fixes for Mono 4.4 Console Runner There is a new --params command line option that allows you to pass parameters to your tests which can be retrieved using TestContext.Parameters Another new command line option --loaduserprofile causes the User Profile to be loaded into the NUnit Agent process. Issues Resolved 329 (CLI) Runner does not report AppDomain unloading timeout 720 Need a way to get test-specific command-line arguments at runtime 1010 Need to control engine use of extensions 1139 NUnit3 console doesn't show test output continuously 1225 The --teamcity option should really be an extension 1241 Make TestDirectory accessible when TestCaseSource attributes are evaluated 1366 Classname for inherited test is not correct 1371 Support dotnet test in .NET CLI and .NET Core 1379 Console returns 0 for invalid fixtures 1422 Include TestListWithEmptyLine.tst in ZIP Package 1423 SingleThreaded attribute should raise an error if a thread is required 1425 Lazy initialization of OutWriter in TestResult is not thread safe 1427 Engine extensions load old packages 1430 TestObjects are retained for lifetime of test run, causing high memory usage 1432 NUnit hangs when reporting to TeamCity 1434 TestResult class needs to be thread-safe 1435 Parallel queue creation needs to be thread-safe 1436 CurrentFramework and Current Platform need to be more thread-safe 1439 EqualConstraint does Not use Equals Override on the Expected Object 1441 Add Linq for use internally in .NET 2.0 code 1446 TestOrderAttributeTests is not public 1450 SilverLight detection doesn't work when building on 32-bit OS 1457 Set the 2.0 build to ignore missing xml documentation 1463 Should TestResult.AssertCount have a public setter? 1464 TNode.EscapeInvalidXmlCharacters recreates Regex continually 1470 Make EventQueue and associated classes lock-less and thread safe 1476 Examine need for \"synchronous\" events in event queue 1481 TestCase with generic return type causes NullReferenceException 1483 Remoting exceptions during test execution 1484 Comparing Equality using IEquatable<T> Should Use Most Specific Method 1493 NUnit 2 test results report ParameterizedMethod but should be ParameterizedTest 1507 NullReferenceException when null arguments are used in TestFixtureAttribute 1513 Add new TeamCity extension to packages 1518 NUnit does not send the \"testStarted\" TeamCity service message when exception was thrown from SetUp/OneTimeSetUp 1520 Detect Portable, SilverLight and Compact and give error message 1528 Use of Sleep(0) in NUnit 1543 Blank name attribute in nunit2-formatted XML result file test-run element 1547 Create separate assembly for System.Linq compatibility classes 1548 Invalid Exception when engine is in a 32-bit process 1549 Changing default behavior for generating test case names 1551 Path in default .addins file for ConsoleRunner package may not exist 1555 EndsWith calls in Constraint constructor can cause major perf issues 1560 Engine writes setting file unnecessarily 1573 Move NUnit.Portable.Agent to new Repo 1579 NUnit v3 dangerously overrides COMPLUS_Version environment variable 1582 Mono 4.4.0 Causes Test Failures 1593 NUnit Console Runner 3.2.1 and Mono 4.4 throws RemotingException 1597 Move Portable agent to its own repository 1605 TeamCity package has no pre-release suffix 1607 nunit.nuget.addins discovery pattern is wrong then restored through project.json 1617 Load user profile on test runners NUnit 3.2.1 - April 19, 2016 Framework The output and error files are now thread safe when running tests in parallel Added a .NET 3.5 build of the framework preventing conflicts with the compatibility classes in the 2.0 framework Added a SingleThreadedAttribute to be added to a TestFixture to indicate all child tests should run on the same thread Engine Unless required, run all tests within a fixture on the same thread Added an EventListener extension point Reduced memory usage Console Runner No longer probes for newer versions of the engine, instead uses the engine that is included with the console Issues Resolved 1413 Switch console to use a local engine 1410 Make OutFile and ErrFile stream writers synchronized 1406 TextCapture is not thread-safe but is used to intercept calls that are expected to be thread-safe 1405 ITestRunner.StopRun throws exception of type 'System.MissingMethodException' 1399 Fixed NullReference issue introduced by the fix for #681 1390 --testlist with file with blank first line causes IndexOutOfRangeException 1386 Bug when using Assert.Equals() with types that explicitly implement IEquatable<T> 1383 Skip SilverLight build if SDK not installed 1359 Compilation error in NUnitPortableDriverTests.cs 1352 Tests losing data setup on thread 1349 Collision on System.Func from nunit.framework with System.Core in .Net 3.5 (CS0433) 1338 BUILDING.txt is outdated 1333 Single Thread per Worker 1329 Unable to build without Compact Framework 1327 TestCaseSource in NUnit 3 converts an argument declared as String[] to String 1318 NUnit console runner fails with error code -100 1317 Getting CF framework unit tests running on CI build 1302 Create EventListener ExtensionPoint for the Engine 1266 SetCultureAttribute does not work if set on assembly level 1247 Potential memory issue 1231 Build may silently fail some tests 1208 Apartment on assembly level broken 1161 NUnit3-Console should disallow the combination of --inprocess and --x86, giving an error message 1141 Explicit Tests get run when using --where with some filters 773 Upgrade Travis CI from Legacy Infrastructure 640 Keep CF Build (and other future builds) in Sync 332 Add CF to the AppVeyor CI build NUnit 3.2 - March 5, 2016 Framework Added an Order attribute that defines the order in which tests are run Added Assert.ThrowsAsync for testing if async methods throw an exception You can now compare unlike collections using Is.EquivalentTo().Using(...) Added the ability to add custom message formatters to MsgUtils TestCaseSourceAttribute now optionally takes an array of parameters that can be passed to the source method Added Is.Zero and Is.Not.Zero to the fluent syntax as a shorter option for Is.EqualTo(0) and Is.Not.EqualTo(0) Engine Engine extensions can be installed via NuGet packages Issues Resolved 170 Test Order Attribute 300 Create an NUnit Visual Studio Template 464 Async delegate assertions 532 Batch runner for SilverLight tests 533 Separate NUnitLite runner and auto-runner 681 NUnit agent cannot resolve test dependency assemblies when mixed mode initialization runs in the default AppDomain 793 Replace CoreEngine by use of Extensions 907 Console report tests are too fragile 922 Wrap Console in NUnitLite 930 Switch from MSBuild based build system to Cake 981 Define NUnit Versioning for post-3.0 Development 1004 Poor formatting of results for Assert.AreEqual(DateTimeOffset, DateTimeOffset) 1018 ArgumentException when 2.x version of NUnit Framework is in the bin directory 1022 Support Comparing Unlike Collections using Is.EquivalentTo().Using(...) 1044 Re-order Test Summary Errors/Failures 1066 ApartmentAttribute and TestCaseAttribute(s) do not work together 1103 Can't use TestCaseData from base class 1109 NullReferenceException when using inherited property for ValueSource 1113 Console runner and xml output consistency 1117 Fix misbehavior of Throws.Exception with non-void returning functions 1120 NUnitProject should parse .nunit project files containing Xml Declarations 1121 Usage of field set to null as value source leads to somewhat cryptic error 1122 Region may be disposed before test delegate is executed 1133 Provide a way to install extensions as nuget packages 1136 Don't allow V2 framework to update in V2 driver tests 1171 A bug when using Assert.That() with Is.Not.Empty 1185 Engine finds .NET 4.0 Client Profile twice 1187 ITestAssemblyRunner.StopRun as implemented by NUnitTestAssemblyRunner 1195 name attribute in test-suite and test-results element of output xml is different to nunit 2.6.4 using nunit2-format 1196 Custom value formatter for v3 via MsgUtils 1210 Available runtimes issues 1230 Add ability for testcasedatasource to have parameters passed to methods 1233 Add TestAssemblyRunner tests to both portable and SilverLight builds 1234 Have default NUnitLite Runner Program.cs return exit code 1236 Make AppVeyor NuGet feed more useable 1246 Introduce Is.Zero syntax to test for zero 1252 Exception thrown when any assembly is not found 1261 TypeHelper.GetDisplayName generates the wrong name for generic types with nested classes 1278 Fix optional parameters in TestCaseAttribute 1282 TestCase using Params Behaves Oddly 1283 Engine should expose available frameworks. 1286 value of the time attribute in nunit2 outputs depends on the machine culture 1297 NUnit.Engine nuget package improvements 1301 Assert.AreNotSame evaluates ToString unnecessarily NUnit 3.0.1 (3.0.5813) - December 1, 2015 Console Runner The NUnit.Runners NuGet package was updated to become a meta-package that pulls in the NUnit.Console package Reinstated the --pause command line option that will display a message box allowing you to attach a debugger if the --debug option does not work Issues Resolved 994 Add max number of Agents to the NUnit project file 1014 Ensure NUnit API assembly updates with MSI installs 1024 Added --pause flag to console runner 1030 Update NUnit.Runners package to 3.0 1033 \"No arguments were provided\" with Theory and Values combination 1035 Check null arguments 1037 Async tests not working on Windows 10 Universal 1041 NUnit2XmlResult Writer is reporting Success when test fails 1042 NUnit2 reports on 3.0 is different than 2.6.4 1046 FloatingPointNumerics.AreAlmostEqualUlps throws OverflowException 1049 Cannot select Generic tests from command line 1050 Do not expose System.Runtime.CompilerServices.ExtensionAttribute to public 1054 Create nuget feeds for CI builds on AppVeyor 1055 nunit3 console runner --where option does not return error on invalid selection string 1060 Remove \"Version 3\" from NUnit Nuget Package 1061 Nunit30Settings.xml becomes corrupted 1062 Console.WriteLine statements in \"OneTimeSetUp\" and \"OneTimeTearDown\" annotated methods are not directed to the console when using nunit3-console.exe runner 1063 Error in Random Test NUnit 3.0.0 Final Release (3.0.5797) - November 15, 2015 Issues Resolved 635 Mono 4.0 Support NUnit 3.0.0 Release Candidate 3 (3.0.5795) - November 13, 2015 Engine The engine now only sets the config file for project.nunit to project.config if project.config exists. Otherwise, each assembly uses its own config, provided it is run in a separate AppDomain by itself. Note It is not possible for multiple assemblies in the same AppDomain to use different configs. This is not an NUnit limitation, it's just how configs work! Issues Resolved 856 Extensions support for third party runners in NUnit 3.0 1003 Delete TeamCityEventHandler as it is not used 1015 Specifying .nunit project and --framework on command line causes crash 1017 Remove Assert.Multiple from framework NUnit 3.0.0 Release Candidate 2 (3.0.5790) - November 8, 2015 Engine The IDriverFactory extensibility interface has been modified. Issues Resolved 970 Define PARALLEL in CF build of NUnitLite 978 It should be possible to determine version of NUnit using nunit console tool 983 Inconsistent return codes depending on ProcessModel 986 Update docs for parallel execution 988 Don't run portable tests from NUnit Console 990 V2 driver is passing invalid filter elements to NUnit 991 Mono.Options should not be exposed to public directly 993 Give error message when a regex filter is used with NUnit V2 997 Add missing XML Documentation 1008 NUnitLite namespace not updated in the NuGet Packages NUnit 3.0.0 Release Candidate (3.0.5783) - November 1, 2015 Framework The portable build now supports ASP.NET 5 and the new Core CLR. Note The nunit3-console runner cannot run tests that reference the portable build. You may run such tests using NUnitLite or a platform-specific runner. TestCaseAttribute and TestCaseData now allow modifying the test name without replacing it entirely. The SilverLight packages for are now separate downloads. NUnitLite The NUnitLite runner now produces the same output display and XML results as the console runner. Engine The format of the XML result file has been finalized and documented. Console Runner The console runner program is now called nunit3-console . Console runner output has been modified so that the summary comes at the end, to reduce the need for scrolling. Issues Resolved 59 Length of generated test names should be limited 68 Customization of test case name generation 404 Split tests between SilverLight.runner and nunit.framework 575 Add support for ASP.NET 5 and the new Core CLR 783 Package separately for SilverLight 833 Intermittent failure of WorkItemQueueTests.StopQueue_WithWorkers 859 NUnit-Console output - move Test Run Summary to end 867 Remove Warnings from Ignored tests 868 Review skipped tests 887 Move environment and settings elements to the assembly suite in the result file 899 Colors for ColorConsole on grey background are too light 904 InternalPreserveStackTrace is not supported on all Portable platforms 914 Unclear error message from console runner when assembly has no tests 916 Console runner dies when test agent dies 918 Console runner --where parameter is case sensitive 920 Remove addins\\nunit.engine.api.dll from NuGet package 929 Rename nunit-console.exe 931 Remove beta warnings from NuGet packages 936 Explicit skipped tests not displayed 939 Installer complains about .NET even if already installed 940 Confirm or modify list of packages for release 947 Breaking API change in ValueSourceAttribute 949 Update copyright in NUnit Console 954 NUnitLite XML output is not consistent with the engine's 955 NUnitLite does not display the where clause 959 Restore filter options for NUnitLite portable build 960 Intermittent failure of CategoryFilterTests 967 Run Settings Report is not being displayed. NUnit 3.0.0 Beta 5 (3.0.5767) - October 16, 2015 Framework Parameterized test cases now support nullable arguments. The NUnit framework may now be built for the .NET Core framework. Note that this is only available through building the source code. A binary will be available in the next release. Engine The engine now runs multiple test assemblies in parallel by default The output XML now includes more information about the test run, including the text of the command used, any engine settings and the filter used to select tests. Extensions may now specify data in an identifying attribute, for use by the engine in deciding whether to load that extension. Console Runner The console now displays all settings used by the engine to run tests as well as the filter used to select tests. The console runner accepts a new option --maxagents . If multiple assemblies are run in separate processes, this value may be used to limit the number that are executed simultaneously in parallel. The console runner no longer accepts the --include and --exclude options. Instead, the new --where option provides a more general way to express which tests will be executed, such as --where \"cat==Fast && Priority==High\". See the docs for details of the syntax. The new --debug option causes NUnit to break in the debugger immediately before tests are run. This simplifies debugging, especially when the test is run in a separate process. Issues Resolved 41 Check for zeroes in Assert messages 254 Finalize XML format for test results 275 NUnitEqualityComparer fails to compare IEquatable<T> where second object is derived from T 304 Run test Assemblies in parallel 374 New syntax for selecting tests to be run 515 OSPlatform.IsMacOSX doesn't work 573 nunit-console hangs on Mac OS X after all tests have run 669 TeamCity service message should have assembly name as a part of test name. 689 The TeamCity service message \"testFinished\" should have an integer value in the \"duration\" attribute 713 Include command information in XML 719 We have no way to configure tests for several assemblies using NUnit project file and the common installation from msi file 735 Workers number in xml report file cannot be found 784 Build Portable Framework on Linux 790 Allow Extensions to provide data through an attribute 794 Make it easier to debug tests as well as NUnit itself 801 NUnit calls Dispose multiple times 814 Support nullable types with TestCase 818 Possible error in Merge Pull Request #797 821 Wrapped method results in loss of result information 822 Test for Debugger in NUnitTestAssemblyRunner probably should not be in CF build 824 Remove unused System.Reflection using statements 826 Randomizer uniqueness tests fail randomly! 828 Merge pull request #827 (issue 826) 830 Add ability to report test results synchronously to test runners 837 Enumerators not disposed when comparing IEnumerables 840 Add missing copyright notices 844 Pull Request #835 (Issue #814) does not build in CF 847 Add new --process:inprocess and --inprocess options 850 Test runner fails if test name contains invalid xml characters 851 Exclude' console option is not working in NUnit Lite 853 Cannot run NUnit Console from another directory 860 Use CDATA section for message, stack-trace and output elements of XML 863 Eliminate core engine 865 Intermittent failures of StopWatchTests 869 Tests that use directory separator char to determine platform misreport Linux on MaxOSX 870 NUnit Console Runtime Environment misreports on MacOSX 874 Add .NET Core Framework 878 Cannot exclude MacOSX or XBox platforms when running on CF 892 Fixed test runner returning early when executing more than one test run. 894 Give nunit.engine and nunit.engine.api assemblies strong names 896 NUnit 3.0 console runner not placing test result xml in --work directory NUnit 3.0.0 Beta 4 (3.0.5715) - August 25, 2015 Framework A new RetryAttribute allows retrying of failing tests. New SupersetConstraint and Is.SupersetOf syntax complement SubsetConstraint. Tests skipped due to ExplicitAttribute are now reported as skipped. Engine We now use Cecil to examine assemblies prior to loading them. Extensions are no longer based on Mono.Addins but use our own extension framework. Issues Resolved 125 3rd-party dependencies should be downloaded on demand 283 What should we do when a user extension does something bad? 585 RetryAttribute 642 Restructure MSBuild script 649 Change how we zip packages 654 ReflectionOnlyLoad and ReflectionOnlyLoadFrom 664 Invalid \"id\" attribute in the report for case \"test started\" 685 In the some cases when tests cannot be started NUnit returns exit code \"0\" 728 Missing Assert.That overload 741 Explicit Tests get run when using --exclude 746 Framework should send events for all tests 747 NUnit should apply attributes even if test is non-runnable 749 Review Use of Mono.Addins for Engine Extensibility 750 Include Explicit Tests in Test Results 753 Feature request: Is.SupersetOf() assertion constraint 755 TimeOut attribute doesn't work with TestCaseSource Attribute 757 Implement some way to wait for execution to complete in ITestEngineRunner 760 Packaging targets do not run on Linux 766 Added overloads for True()/False() accepting booleans 778 Build and build.cmd scripts invoke nuget.exe improperly 780 TeamCity fix 782 No sources for 2.6.4 NUnit 3.0.0 Beta 3 (3.0.5674) - July 15, 2015 Framework The RangeAttribute has been extended to support more data types including uint, long and ulong Added platform support for Windows 10 and fixed issues with Windows 8 and 8.1 support Added async support to the portable version of NUnit Framework The named members of the TestCaseSource and ValueSource attributes must now be static. RandomAttribute has been extended to add support for new data types including uint, long, ulong, short, ushort, float, byte and sbyte TestContext.Random has also been extended to add support for new data types including uint, long, ulong, short, ushort, float, byte, sbyte and decimal Removed the dependency on Microsoft.Bcl.Async from the NUnit Framework assembly targeting .NET 4.0. If you want to write async tests in .NET 4.0, you will need to reference the NuGet package yourself. Added a new TestFixtureSource attribute which is the equivalent to TestCaseSource but provides for instantiation of fixtures. Significant improvements have been made in how NUnit deduces the type arguments of generic methods based on the arguments provided. Engine If the target framework is not specified, test assemblies that are compiled to target .NET 4.5 will no longer run in .NET 4.0 compatibility mode Console If the console is run without arguments, it will now display help Issues Resolved 47 Extensions to RangeAttribute 237 System.Uri .ctor works not properly under NUnit 244 NUnit should properly distinguish between .NET 4.0 and 4.5 310 Target framework not specified on the AppDomain when running against .Net 4.5 321 Rationalize how we count tests 472 Overflow exception and DivideByZero exception from the RangeAttribute 524 int and char do not compare correctly? 539 Truncation of string arguments 544 AsyncTestMethodTests for 4.5 Framework fails frequently on Travis CI 656 Unused parameter in Console.WriteLine found 670 Failing Tests in TeamCity Build 673 Ensure proper disposal of engine objects 674 Engine does not release test assemblies 679 Windows 10 Support 682 Add Async Support to Portable Framework 683 Make FrameworkController available in portable build 687 TestAgency does not launch agent process correctly if runtime type is not specified (i.e. v4.0) 692 PlatformAttribute_OperatingSystemBitNess fails when running in 32-bit process 693 Generic Test<T> Method cannot determine type arguments for fixture when passed as IEnumerable<T> 698 Require TestCaseSource and ValueSource named members to be static 703 TeamCity non-equal flowid for 'testStarted' and 'testFinished' messages 712 Extensions to RandomAttribute 715 Provide a data source attribute at TestFixture Level 718 RangeConstraint gives error with from and two args of differing types 723 Does nunit.nuspec require dependency on Microsoft.Bcl.Async? 724 Adds support for Nullable<bool> to Assert.IsTrue and Assert.IsFalse 734 Console without parameters doesn't show help NUnit 3.0.0 Beta 2 (3.0.5610) - May 12, 2015 Framework The Compact Framework version of the framework is now packaged separately and will be distributed as a ZIP file and as a NuGet package. The NUnit 2.x RepeatAttribute was added back into the framework. Added Throws.ArgumentNullException Added GetString methods to NUnit.Framework.Internal.RandomGenerator to create repeatable random strings for testing When checking the equality of DateTimeOffset, you can now use the WithSameOffset modifier Some classes intended for internal usage that were public for testing have now been made internal. Additional classes will be made internal for the final 3.0 release. Engine Added a core engine which is a non-extensible, minimal engine for use by devices and similar situations where reduced functionality is compensated for by reduced size and simplicity of usage. Issues Resolved 22 Add OSArchitecture Attribute to Environment node in result xml 24 Assert on Dictionary Content 48 Explicit seems to conflict with Ignore 168 Create NUnit 3.0 documentation 196 Compare DateTimeOffsets including the offset in the comparison 217 New icon for the 3.0 release 316 NUnitLite TextUI Runner 320 No Tests found: Using parameterized Fixture and TestCaseSource 360 Better exception message when using non-BCL class in property 454 Rare registry configurations may cause NUnit to fail 478 RepeatAttribute 481 Testing multiple assemblies in NUnitLite 538 Potential bug using TestContext in constructors 546 Enable Parallel in NUnitLite/CF (or more) builds 551 TextRunner not passing the NumWorkers option to the ITestAssemblyRunner 556 Executed tests should always return a non-zero duration 559 Fix text of NuGet packages 560 Fix PackageVersion property on wix install projects 562 Program.cs in NUnitLite NuGet package is incorrect 564 NUnitLite Nuget package is Beta 1a, Framework is Beta 1 565 NUnitLite Nuget package adds Program.cs to a VB Project 568 Isolate packaging from building 570 ThrowsConstraint failure message should include stack trace of actual exception 576 Throws.ArgumentNullException would be nice 577 Documentation on some members of Throws falsely claims that they return TargetInvocationException constraints 579 No documentation for recommended usage of TestCaseSourceAttribute 580 TeamCity Service Message Uses Incorrect Test Name with NUnit2Driver 582 Test Ids Are Not Unique 583 TeamCity service messages to support parallel test execution 584 Non-runnable assembly has incorrect ResultState 609 Add support for integration with TeamCity 611 Remove unused --teamcity option from CF build of NUnitLite 612 MaxTime doesn't work when used for TestCase 621 Core Engine 622 nunit-console fails when use --output 628 Modify IService interface and simplify ServiceContext 631 Separate packaging for the compact framework 646 ConfigurationManager.AppSettings Params Return Null under Beta 1 NUnit 3.0.0 Beta 1 (3.0.5562) - March 25, 2015 General There is now a master windows installer for the framework, engine and console runner. Framework We no longer create a separate framework build for .NET 3.5. The 2.0 and 3.5 builds were essentially the same, so the former should now be used under both runtimes. A new Constraint, DictionaryContainsKeyConstraint , may be used to test that a specified key is present in a dictionary. LevelOfParallelizationAttribute has been renamed to LevelOfParallelismAttribute . The SilverLight runner now displays output in color and includes any text output created by the tests. The class and method names of each test are included in the output xml where applicable. String arguments used in test case names are now truncated to 40 rather than 20 characters. Engine The engine API has now been finalized. It permits specifying a minimum version of the engine that a runner is able to use. The best installed version of the engine will be loaded. Third-party runners may override the selection process by including a copy of the engine in their installation directory and specifying that it must be used. The V2 framework driver now uses the event listener and test listener passed to it by the runner. This corrects several outstanding issues caused by events not being received and allows selecting V2 tests to be run from the command-line, in the same way that V3 tests are selected. Console The console now defaults to not using shadowcopy. There is a new option --shadowcopy to turn it on if needed. Issues Resolved 224 SilverLight Support 318 TestActionAttribute: Retrieving the TestFixture 428 Add ExpectedExceptionAttribute to C# samples 440 Automatic selection of Test Engine to use 450 Create master install that includes the framework, engine and console installs 477 Assert does not work with ArraySegment 482 nunit-console has multiple errors related to -framework option 483 Adds constraint for asserting that a dictionary contains a particular key 484 Missing file in NUnit.Console nuget package 485 Can't run v2 tests with nunit-console 3.0 487 NUnitLite can't load assemblies by their file name 488 Async setup and teardown still don't work 497 Framework installer should register the portable framework 504 Option --workers:0 is ignored 508 Travis builds with failure in engine tests show as successful 509 Under linux, not all mono profiles are listed as available 512 Drop the .NET 3.5 build 517 V2 FrameworkDriver does not make use of passed in TestEventListener 523 Provide an option to disable shadowcopy in NUnit v3 528 V2 FrameworkDriver does not make use of passed in TestFilter 530 Color display for SilverLight runner 531 Display text output from tests in SilverLight runner 534 Add classname and methodname to test result xml 541 Console help doesn't indicate defaults NUnit 3.0.0 Alpha 5 (3.0.5509) - January 30, 2015 General A Windows installer is now included in the release packages. Framework TestCaseAttribute now allows arguments with default values to be omitted. Additionally, it accepts IncludePlatform and ExcludePlatform properties to specify the platforms on which the test case should be run. TestFixture and TestCase attributes now enforce the requirement that a reason needs to be provided when ignoring a test. SetUp, TearDown, OneTimeSetUp and OneTimeTearDown methods may now be async. String arguments over 20 characters in length are truncated when used as part of a test name. Engine The engine is now extensible using Mono.Addins. In this release, extension points are provided for FrameworkDrivers, ProjectLoaders and OutputWriters. The following addins are bundled as a part of NUnit: A FrameworkDriver that allows running NUnit V2 tests under NUnit 3.0. ProjectLoaders for NUnit and Visual Studio projects. An OutputWriter that creates XML output in NUnit V2 format. DomainUsage now defaults to Multiple if not specified by the runner Console New options supported: --testlist provides a list of tests to run in a file --stoponerror indicates that the run should terminate when any test fails. Issues Resolved 20 TestCaseAttribute needs Platform property. 60 NUnit should support async setup, teardown, fixture setup and fixture teardown. 257 TestCaseAttribute should not require parameters with default values to be specified. 266 Pluggable framework drivers. 368 Create addin model. 369 Project loader addins 370 OutputWriter addins 403 Move ConsoleOptions.cs and Options.cs to Common and share... 419 Create Windows Installer for NUnit. 427 [TestFixture(Ignore=true)] should not be allowed. 437 Errors in tests under Linux due to hard-coded paths. 441 NUnit-Console should support --testlist option 442 Add --stoponerror option back to nunit-console. 456 Fix memory leak in RuntimeFramework. 459 Remove the Mixed Platforms build configuration. 468 Change default domain usage to multiple. 469 Truncate string arguments in test names in order to limit the length. NUnit 3.0.0 Alpha 4 (3.0.5476) - December 30, 2014 Framework ApartmentAttribute has been added, replacing STAAttribute and MTAAttribute. Unnecessary overloads of Assert.That and Assume.That have been removed. Multiple SetUpFixtures may be specified in a single namespace. The Pairwise strategy test case generation algorithm has been improved. Engine A driver is now included, which allows running NUnit 2.x tests under NUnit 3.0. The engine can now load and run tests specified in a number of project formats: NUnit (.nunit) Visual Studio C# projects (.csproj) Visual Studio F# projects (.vjsproj) Visual Studio Visual Basic projects (.vbproj) Visual Studio solutions (.sln) Legacy C++ and Visual JScript projects (.csproj and .vjsproj) are also supported Support for the current C++ format (.csxproj) is not yet available Creation of output files like TestResult.xml in various formats is now a service of the engine, available to any runner. Console The command-line may now include any number of assemblies and/or supported projects. Issues Resolved 37 Multiple SetUpFixtures should be permitted on same namespace 210 TestContext.WriteLine in an AppDomain causes an error 227 Add support for VS projects and solutions 231 Update C# samples to use NUnit 3.0 233 Update F# samples to use NUnit 3.0 234 Update C++ samples to use NUnit 3.0 265 Reorganize console reports for nunit-console and SilverLight 299 No full path to assembly in XML file under Compact Framework 301 Command-line length 363 Make Xml result output an engine service 377 CombiningStrategyAttributes don't work correctly on generic methods 388 Improvements to NUnitLite runner output 390 Specify exactly what happens when a test times out 396 ApartmentAttribute 397 CF SilverLight runner assembly has the wrong name 407 Assert.Pass() with ]]> in message crashes console runner 414 Simplify Assert overloads 416 NUnit 2.x Framework Driver 417 Complete work on NUnit projects 420 Create Settings file in proper location NUnit 3.0.0 Alpha 3 (3.0.5446) - November 29, 2014 Breaking Changes NUnitLite tests must reference both the nunit.framework and SilverLight assemblies. Framework The NUnit and NUnitLite frameworks have now been merged. There is no longer any distinction between them in terms of features, although some features are not available on all platforms. The release includes two new framework builds: compact framework 3.5 and portable. The portable library is compatible with .NET 4.5, SilverLight 5.0, Windows 8, Windows Phone 8.1, Windows Phone SilverLight 8, Mono for Android and MonoTouch. A number of previously unsupported features are available for the Compact Framework: Generic methods as tests RegexConstraint TimeoutAttribute FileAssert, DirectoryAssert and file-related constraints Engine The logic of runtime selection has now changed so that each assembly runs by default in a separate process using the runtime for which it was built. On 64-bit systems, each test process is automatically created as 32-bit or 64-bit, depending on the platform specified for the test assembly. Console The console runner now runs tests in a separate process per assembly by default. They may still be run in process or in a single separate process by use of command-line options. The console runner now starts in the highest version of the .NET runtime available, making it simpler to debug tests by specifying that they should run in-process on the command-line. The -x86 command-line option is provided to force execution in a 32-bit process on a 64-bit system. A writability check is performed for each output result file before trying to run the tests. The -teamcity option is now supported. Issues Resolved 12 Compact framework should support generic methods 145 NUnit-console fails if test result message contains invalid xml characters 155 Create utility classes for platform-specific code 223 Common code for NUnitLite console runner and NUnit-Console 225 Compact Framework Support 238 Improvements to running 32 bit tests on a 64 bit system 261 Add portable NUnitLite build 284 NUnitLite Unification 293 CF does not have a CurrentDirectory 306 Assure NUnit can write result file 308 Early disposal of runners 309 NUnit-Console should support incremental output under TeamCity 325 Add RegexConstraint to compact framework build 326 Add TimeoutAttribute to compact framework build 327 Allow generic test methods in the compact framework 328 Use .NET Stopwatch class for compact framework builds 331 Alpha 2 CF does not build 333 Add parallel execution to desktop builds of NUnitLite 334 Include File-related constraints and syntax in NUnitLite builds 335 Re-introduce 'Classic' NUnit syntax in NUnitLite 336 Document use of separate obj directories per build in our projects 337 Update Standard Defines page for .NET 3.0 341 Move the NUnitLite runners to separate assemblies 367 Refactor XML Escaping Tests 372 CF Build TestAssemblyRunnerTests 373 Minor CF Test Fixes 378 Correct documentation for PairwiseAttribute 386 Console Output Improvements NUnit 3.0.0 Alpha 2 (3.0.5419) - November 2, 2014 Breaking Changes The console runner no longer displays test results in the debugger. The NUnitLite compact framework 2.0 build has been removed. All addin support has been removed from the framework. Documentation of NUnit 3.0 extensibility features will be published in time for the beta release. In the interim, please ask for support on the nunit-discuss list. General A separate solution has been created for Linux We now have continuous integration builds under both Travis and AppVeyor The compact framework 3.5 build is now working and will be supported in future releases. New Features The console runner now automatically detects 32- versus 64-bit test assemblies. The NUnitLite report output has been standardized to match that of nunit-console. The NUnitLite command-line has been standardized to match that of nunit-console where they share the same options. Both nunit-console and NUnitLite now display output in color. ActionAttributes now allow specification of multiple targets on the attribute as designed. This didn't work in the first alpha. OneTimeSetUp and OneTimeTearDown failures are now shown on the test report. Individual test failures after OneTimeSetUp failure are no longer shown. The console runner refuses to run tests build with older versions of NUnit. A plugin will be available to run older tests in the future. Issues Resolved 222 Color console for NUnitLite 229 Timing failures in tests 241 Remove reference to Microsoft BCL packages 243 Create solution for Linux 245 Multiple targets on action attributes not implemented 246 C++ tests do not compile in VS2013 247 Eliminate trace display when running tests in debug 255 Add new result states for more precision in where failures occur 256 ContainsConstraint break when used with AndConstraint 264 Stacktrace displays too many entries 269 Add manifest to nunit-console and nunit-agent 270 OneTimeSetUp failure results in too much output 271 Invalid tests should be treated as errors 274 Command line options should be case insensitive 276 NUnit-console should not reference nunit.framework 278 New result states (ChildFailure and SetupFailure) break NUnit2XmlOutputWriter 282 Get tests for NUnit2XmlOutputWriter working 288 Set up AppVeyor CI build 290 Stack trace still displays too many items 315 NUnit 3.0 alpha: Cannot run in console on my assembly 319 CI builds are not treating test failures as failures of the build 322 Remove Stopwatch tests where they test the real .NET Stopwatch NUnit 3.0.0 Alpha 1 (3.0.5378) - September 22, 2014 Breaking Changes Legacy suites are no longer supported Assert.NullOrEmpty is no longer supported (Use Is.Null.Or.Empty) General MsBuild is now used for the build rather than NAnt The framework test harness has been removed now that nunit-console is at a point where it can run the tests. New Features Action Attributes have been added with the same features as in NUnit 2.6.3. TestContext now has a method that allows writing to the XML output. TestContext.CurrentContext.Result now provides the error message and stack trace during teardown. Does prefix operator supplies several added constraints. Issues Resolved 6 Log4net not working with NUnit 13 Standardize command-line options for NUnitLite runner 17 No allowance is currently made for nullable arguments in TestCase parameter conversions 33 TestCaseSource cannot refer to a parameterized test fixture 54 Store message and stack trace in TestContext for use in TearDown 111 Implement Changes to File, Directory and Path Assertions 112 Implement Action Attributes 156 Accessing multiple AppDomains within unit tests result in SerializationException 163 Add --trace option to NUnitLite 167 Create interim documentation for the alpha release 169 Design and implement distribution of NUnit packages 171 Assert.That should work with any lambda returning bool 175 Test Harness should return an error if any tests fail 180 Errors in Linux CI build 181 Replace NAnt with MsBuild / XBuild 183 Standardize command-line options for test harness 188 No output from NUnitLite when selected test is not found 189 Add string operators to Does prefix 193 TestWorkerTests.BusyExecutedIdleEventsCalledInSequence fails occasionally 197 Deprecate or remove Assert.NullOrEmpty 202 Eliminate legacy suites 203 Combine framework, engine and console runner in a single solution and repository 209 Make Ignore attribute's reason mandatory 215 Running 32-bit tests on a 64-bit OS 219 Teardown failures are not reported Console Issues Resolved (Old nunit-console project, now combined with nunit) 2 Failure in TestFixtureSetUp is not reported correctly 5 CI Server for nunit-console 6 System.NullReferenceException on start nunit-console-x86 21 NUnitFrameworkDriverTests fail if not run from same directory 24 Debug' value for /trace option is deprecated in 2.6.3 38 Confusing Excluded categories output NUnit 2.9.7 - August 8, 2014 Breaking Changes NUnit no longer supports void async test methods. You should use a Task return Type instead. The ExpectedExceptionAttribute is no longer supported. Use Assert.Throws() or Assert.That(..., Throws) instead for a more precise specification of where the exception is expected to be thrown. New Features Parallel test execution is supported down to the Fixture level. Use ParallelizableAttribute to indicate types that may be run in parallel. Async tests are supported for .NET 4.0 if the user has installed support for them. A new FileExistsConstraint has been added along with FileAssert.Exists and FileAssert.DoesNotExist ExpectedResult is now supported on simple (non-TestCase) tests. The Ignore attribute now takes a named parameter Until, which allows specifying a date after which the test is no longer ignored. The following new values are now recognized by PlatformAttribute: Win7, Win8, Win8.1, Win2012Server, Win2012ServerR2, NT6.1, NT6.2, 32-bit, 64-bit TimeoutAttribute is now supported under SilverLight ValuesAttribute may be used without any values on an enum or boolean argument. All possible values are used. You may now specify a tolerance using Within when testing equality of DateTimeOffset values. The XML output now includes a start and end time for each test. Issues Resolved 8 [SetUpFixture] is not working as expected 14 CI Server for NUnit Framework 21 Is.InRange Constraint Ambiguity 27 Values attribute support for enum types 29 Specifying a tolerance with \"Within\" doesn't work for DateTimeOffset data types 31 Report start and end time of test execution 36 Make RequiresThread, RequiresSTA, RequiresMTA inheritable 45 Need of Enddate together with Ignore 55 Incorrect XML comments for CollectionAssert.IsSubsetOf 62 Matches(Constraint) does not work as expected 63 Async support should handle Task return type without state machine 64 AsyncStateMachineAttribute should only be checked by name 65 Update NUnit site to show the new location of samples 66 Parallel Test Execution within test assemblies 67 Allow Expected Result on simple tests 70 EquivalentTo isn't compatible with IgnoreCase for dictionaries 75 Async tests should be supported for projects that target .NET 4.0 82 nunit-framework tests are timing out on Linux 83 Path-related tests fail on Linux 85 Culture-dependent NUnit tests fail on non-English machine 88 TestCaseSourceAttribute documentation 90 EquivalentTo isn't compatible with IgnoreCase for char 100 Changes to Tolerance definitions 110 Add new platforms to PlatformAttribute 113 Remove ExpectedException 118 Workarounds for missing InternalPreserveStackTrace in mono 121 Test harness does not honor the --worker option when set to zero 129 Standardize Timeout in the SilverLight build 130 Add FileAssert.Exists and FileAssert.DoesNotExist 132 Drop support for void async methods 153 Surprising behavior of DelayedConstraint pollingInterval 161 Update API to support stopping an ongoing test run NUnit 2.9.6 - October 4, 2013 Main Features Separate projects for nunit-console and nunit.engine New builds for .NET 4.5 and SilverLight TestContext is now supported and includes an additional property, Random , which may be used to generate repeatable random values for use in a test. The external framework API is now stable; internal interfaces are separate from API Tests may be run in parallel on separate threads Solutions and projects now use VS2012 (except for Compact framework) Bug Fixes 463470 We should encapsulate references to pre-2.0 collections 498690 Assert.That() doesn't like properties with scoped setters 501784 Theory tests do not work correctly when using null parameters 531873 Feature: Extraction of unit tests from NUnit test assembly and calling appropriate one 611325 Allow Teardown to detect if last test failed 611938 Generic Test Instances disappear 655882 Make CategoryAttribute inherited 664081 Add Server2008 R2 and Windows 7 to PlatformAttribute 671432 Upgrade NAnt to Latest Release 676560 Assert.AreEqual does not support IEquatable<T> 691129 Add Category parameter to TestFixture 697069 Feature request: dynamic location for TestResult.xml 708173 NUnit's logic for comparing arrays - use Comparer<T[]> if it is provided 709062 \"System.ArgumentException : Cannot compare\" when the element is a list 712156 Tests cannot use AppDomain.SetPrincipalPolicy 719184 Platform dependency in src/ClientUtilities/util/Services/DomainManager.cs:40 719187 Using Path.GetTempPath() causes conflicts in shared temporary folders 735851 Add detection of 3.0, 3.5 and 4.0 frameworks to PlatformAttribute 736062 Deadlock when EventListener performs a Trace call + EventPump synchronization 756843 Failing assertion does not show non-linear tolerance mode 766749 net-2.0\\nunit-console-x86.exe.config should have a <startup /> element and also enable loadFromRemoteSources 770471 Assert.IsEmpty does not support IEnumerable 785460 Add Category parameter to TestCaseSourceAttribute 787106 EqualConstraint provides inadequate failure information for IEnumerables 792466 TestContext MethodName 794115 HashSet incorrectly reported 800089 Assert.Throws() hides details of inner AssertionException 848713 Feature request: Add switch for console to break on any test case error 878376 Add 'Exactly(n)' to the NUnit constraint syntax 882137 When no tests are run, higher level suites display as Inconclusive 882517 NUnit 2.5.10 doesn't recognize TestFixture if there are only TestCaseSource inside 885173 Tests are still executed after cancellation by user 885277 Exception when project calls for a runtime using only 2 digits 885604 Feature request: Explicit named parameter to TestCaseAttribute 890129 DelayedConstraint doesn't appear to poll properties of objects 892844 Not using Mono 4.0 profile under Windows 893919 DelayedConstraint fails polling properties on references which are initially null 896973 Console output lines are run together under Linux 897289 Is.Empty constraint has unclear failure message 898192 Feature Request: Is.Negative, Is.Positive 898256 IEnumerable<T> for Datapoints doesn't work 899178 Wrong failure message for parameterized tests that expect exceptions 904841 After exiting for timeout the teardown method is not executed 908829 TestCase attribute does not play well with variadic test functions 910218 NUnit should add a trailing separator to the ApplicationBase 920472 CollectionAssert.IsNotEmpty must dispose Enumerator 922455 Add Support for Windows 8 and Windows 2012 Server to PlatformAttribute 928246 Use assembly.Location instead of assembly.CodeBase 958766 For development work under TeamCity, we need to support nunit2 formatted output under direct-runner 1000181 Parameterized TestFixture with System.Type as constructor arguments fails 1000213 Inconclusive message Not in report output 1023084 Add Enum support to RandomAttribute 1028188 Add Support for SilverLight 1029785 Test loaded from remote folder failed to run with exception System.IODirectory 1037144 Add MonoTouch support to PlatformAttribute 1041365 Add MaxOsX and Xbox support to platform attribute 1057981 C#5 async tests are not supported 1060631 Add .NET 4.5 build 1064014 Simple async tests should not return Task<T> 1071164 Support async methods in usage scenarios of Throws constraints 1071343 Runner.Load fails on CF if the test assembly contains a generic method 1071861 Error in Path Constraints 1072379 Report test execution time at a higher resolution 1074568 Assert/Assume should support an async method for the ActualValueDelegate 1082330 Better Exception if SetCulture attribute is applied multiple times 1111834 Expose Random Object as part of the test context 1111838 Include Random Seed in Test Report 1172979 Add Category Support to NUnitLite Runner 1203361 Randomizer uniqueness tests sometimes fail 1221712 When non-existing test method is specified in -test, result is still \"Tests run: 1, Passed: 1\" 1223294 System.NullReferenceException thrown when ExpectedExceptionAttribute is used in a static class 1225542 Standardize command-line options for test harness NUnit 2.9.5 - July 30, 2010 Bug Fixes 483836 Allow non-public test fixtures consistently 487878 Tests in generic class without proper TestFixture attribute should be invalid 498656 TestCase should show array values in GUI 513989 Is.Empty should work for directories 519912 Thread.CurrentPrincipal Set In TestFixtureSetUp Not Maintained Between Tests 532488 constraints from ConstraintExpression/ConstraintBuilder are not reusable 590717 categories contains dash or trail spaces is not selectable 590970 static TestFixtureSetUp/TestFixtureTearDown methods in base classes are not run 595683 NUnit console runner fails to load assemblies 600627 Assertion message formatted poorly by PropertyConstraint 601108 Duplicate test using abstract test fixtures 601645 Parameterized test should try to convert data type from source to parameter 605432 ToString not working properly for some properties 606548 Deprecate Directory Assert in 2.5 and remove it in 3.0 608875 NUnit Equality Comparer incorrectly defines equality for Dictionary objects NUnit 2.9.4 - May 4, 2010 Bug Fixes 419411 Fixture With No Tests Shows as Non-Runnable 459219 Changes to thread principal cause failures under .NET 4.0 459224 Culture test failure under .NET 4.0 462019 Line endings needs to be better controlled in source 462418 Assume.That() fails if I specify a message 483845 TestCase expected return value cannot be null 488002 Should not report tests in abstract class as invalid 490679 Category in TestCaseData clashes with Category on ParameterizedMethodSuite 501352 VS2010 projects have not been updated for new directory structure 504018 Automatic Values For Theory Test Parameters Not Provided For bool And enum 505899 'Description' parameter in both TestAttribute and TestCaseAttribute is not allowed 523335 TestFixtureTearDown in static class not executed 556971 Datapoint(s)Attribute should work on IEnumerable<T> as well as on Arrays 561436 SetCulture broken with 2.5.4 563532 DatapointsAttribute should be allowed on properties and methods NUnit 2.9.3 - October 26, 2009 Main Features Created new API for controlling framework New builds for .Net 3.5 and 4.0, compact framework 3.5 Support for old style tests has been removed New ad-hoc runner for testing the framework Bug Fixes 432805 Some Framework Tests don't run on Linux 440109 Full Framework does not support \"Contains\" NUnit 2.9.2 - September 19, 2009 Main Features NUnitLite code is now merged with NUnit Added NUnitLite runner to the framework code Added Compact framework builds Bug Fixes 430100 Assert.Catch<T> should return T 432566 NUnitLite shows empty string as argument 432573 Mono test should be at runtime NUnit 2.9.1 - August 27, 2009 Main Features Created a separate project for the framework and framework tests Changed license to MIT / X11 Created Windows installer for the framework Bug Fixes 400502 NUnitEqualityComparer.StreamsEÂ­qual fails for same stream 400508 TestCaseSource attribute is not working when Type is given 400510 TestCaseData variable length ctor drops values 417557 Add SetUICultureAttribute from NUnit 2.5.2 417559 Add Ignore to TestFixture, TestCase and TestCaseData 417560 Merge Assert.Throws and Assert.Catch changes from NUnit 2.5.2 417564 TimeoutAttribute on Assembly Earlier Releases Release Notes for NUnit 2.6 through 2.6.4 Release Notes for NUnit 2.5 through 2.5.10 Release Notes for NUnit 2.4 through 2.4.8 Release Notes for NUnit 2.0 through 2.2.10"
  },
  "articles/nunit/running-tests/Console-Command-Line.html": {
    "href": "articles/nunit/running-tests/Console-Command-Line.html",
    "title": "Console Command Line | NUnit Docs",
    "keywords": "Console Command Line The console interface runner is invoked by a command in the form NUNIT3-CONSOLE [inputfiles] [options] where inputfiles is one or more assemblies or test projects of a type that NUnit can process and options is zero or more options. Input files and options may be mixed in any order. Input Files The console program must always have an assembly or project specified. Assemblies are specified by file name or path, which may be absolute or relative. Relative paths are interpreted based on the current directory. In addition to assemblies, you may specify any project type that is understood by NUnit. Out of the box, this includes various Visual Studio project types as well as NUnit (.nunit) test projects (see NUnit Test Projects for a description of NUnit test projects). If the NUnit V2 framework driver is installed, test assemblies may be run based on any version of the NUnit framework beginning with 2.0. Without the V2 driver, only version 3.0 and higher tests may be run. Options Option Description @FILE Specifies the name (or path) of a FILE containing additional command-line arguments to be interpolated at the point where the @FILE expression appears. Each line in the file represents a separate command-line argument. --test=FULLNAMES Comma-separated list of FULLNAMES of tests to run or explore. This option may be repeated. Note that this option is retained for backward compatibility. The --where option can now be used instead. --testlist=FILE The name (or path) of a FILE containing a list of tests to run or explore, one per line. --where=EXPRESSION An expression indicating which tests to run. It may specify test names, classes, methods, categories or properties comparing them to actual values with the operators ==, !=, =~ and !~. See Test Selection Language for a full description of the syntax. --params|p=PARAMETER A test PARAMETER specified in the form NAME=VALUE for consumption by tests. Multiple parameters may be specified, separated by semicolons or by repeating the --params option multiple times. Case-sensitive. --config=NAME NAME of a project configuration to load (e.g.: Debug). --process=PROCESS PROCESS isolation for test assemblies. Values: Single, Separate, Multiple. If not specified, defaults to Separate for a single assembly or Multiple for more than one. By default, processes are run in parallel. --inprocess This option is a synonym for --process=Single --agents=NUMBER NUMBER of agents that may be allowed to run simultaneously assuming you are not running inprocess. If not specified, all agent processes run tests at the same time, whatever the number of assemblies. This setting is used to control running your assemblies in parallel. --domain=DOMAIN DOMAIN isolation for test assemblies. Values: None, Single, Multiple. If not specified, defaults to Single for a single assembly or Multiple for more than one. --framework=FRAMEWORK FRAMEWORK type/version to use for tests. Examples: mono, net-4.5, v4.0, 2.0, mono-4.0 --x86 Run tests in a 32-bit process on 64-bit systems. --dispose-runners Dispose each test runner after it has finished running its tests --timeout=MILLISECONDS Set timeout for each test case in MILLISECONDS. --seed=SEED Set the random SEED used to generate test cases. --workers=NUMBER Specify the NUMBER of worker threads to be used in running tests. This setting is used to control running your tests in parallel and is used in conjunction with the Parallelizable Attribute . If not specified, workers defaults to the number of processors on the machine, or 2, whichever is greater. --stoponerror Stop run immediately upon any test failure or error. --skipnontestassemblies Skip any non-test assemblies specified - or assemblies containing NUnit.Framework.NonTestAssemblyAttribute, without error. --debug Causes NUnit to break into the debugger immediately before it executes your tests. This is particularly useful when the tests are running in a separate process to which you would otherwise have to attach. --debug-agent Available only in debug builds of NUnit, this option is for use by developers in debugging the nunit-agent itself. It breaks in the agent code immediately upon entry of the process. --pause Causes NUnit to immediately open a message box, allowing you to attach a debugger. For cases where --debug does not work. --wait Wait for input before closing console window. --work=PATH PATH of the directory to use for output files. --output, --out=PATH File PATH to contain text output from the tests. --result=SPEC An output SPEC for saving the test results. This option may be repeated. --explore[=SPEC] Display or save test info rather than running tests. Optionally provide an output SPEC for saving the test info. This option may be repeated. --noresult Don't save any test results. --trace=LEVEL Set internal trace LEVEL. Values: Off, Error, Warning, Info, Verbose (Debug) --labels=VALUE Specify whether to write test case names to the output. Values: Off, On, Before, After, or All. Off : No labeling is used. Both normal and immediate output appear in the order produced - i.e. immediate first. On : A label appears before each sequence of output lines from the same test. Since tests may be run in parallel, output from different tests may be intermixed. Before : A label appears at the start of every test, whether it produces output or not. Additional labels are produced as needed if interspersed output takes place, just as for --labels=On . Synonym for --labels=All . labels=After : A label appears at the end of every test, whether it produced output or not. This label includes the pass/fail status of the test in addition to its name. Additional labels are produced as needed if there is any output, just as for --labels=On . All : A label appears at the start of every test, whether it produces output or not. Additional labels are produced as needed if interspersed output takes place, just as for --labels=On . Synonym for --labels=Before . --test-name-format=VALUE Specify a non-standard naming pattern to use when generating all test names. See Template Based Test Naming . --encoding=CODEPAGE Specify the Console CODEPAGE, such as utf-8, ascii, etc. This option is not normally needed unless your output includes special characters. The page specified must be available on the system. --shadowcopy Tells .NET to copy loaded assemblies to the shadowcopy directory. --teamcity Turns on use of TeamCity service messages. --loaduserprofile Causes the user profile to be loaded in any separate test processes. --list-extensions Lists all extension points and the extensions installed on each of them. --set-principal-policy=POLICY Set the principal policy for the test domain to POLICY. Values: UnauthenticatedPrincipal, NoPrincipal, WindowsPrincipal --noheader, --noh Suppress display of program information at start of run. --nocolor, --noc Displays console output without color. --help, -h Display this message and exit. Description By default, this command runs the tests contained in the assemblies and projects specified. If the --explore option is used, no tests are executed but a description of the tests is saved in the specified or default format. Several options that specify processing of XML output take an output specification as a value. A SPEC may take one of the following forms: --OPTION:filename --OPTION:filename;format=formatname --OPTION:filename;transform=xsltfile The --result option may use any of the following formats: nunit3 - the native XML format for NUnit 3 nunit2 - legacy XML format used by earlier releases of NUnit The --explore option may use any of the following formats: nunit3 - the native XML format for NUnit 3 cases - a text file listing the full names of all test cases. If --explore is used without any specification following, a list of test cases is output to the console. If neither --result nor --explore is used, NUnit saves the results to TestResult.xml in nunit3 format. Any transforms provided must handle input in the native nunit3 format."
  },
  "articles/nunit/running-tests/Console-Runner.html": {
    "href": "articles/nunit/running-tests/Console-Runner.html",
    "title": "Console Runner | NUnit Docs",
    "keywords": "Console Runner The nunit3-console.exe program is a text-based runner for listing and running our tests from the command-line. It is able to run all NUnit 3.0 or higher tests natively and can run NUnit 2.x tests if the v2 driver is installed. This runner is useful for automation of tests and integration into other systems. It automatically saves its results in XML format, allowing you to produce reports or otherwise process the results. The following is a screenshot of the console program output. In this example, nunit3-console has just run selected tests in the mock-nunit-assembly.exe assembly that is part of the NUnit distribution. This assembly contains a number of tests, some of which are either ignored or marked explicit. The summary line shows the result of the test run."
  },
  "articles/nunit/running-tests/Index.html": {
    "href": "articles/nunit/running-tests/Index.html",
    "title": "Running Tests | NUnit Docs",
    "keywords": "Running Tests NUnit provides three different runners, which may be used to load and run your tests. The Console Runner , nunit-console.exe , is used for batch execution. The Gui Runner, nunit.exe , provides interactive loading and running of tests. NUnit Agent When running tests in a separate process, the console and gui runners make use of the NUnit Agent program, nunit-agent.exe. Although not directly run by users, nunit-agent does load and execute tests and users need to be aware of it, especially when debugging is involved. Third-Party Runners Various third-party applications are available for loading and running NUnit tests. Some of these actually use NUnit to load the tests, while others provide their own emulation and may not work in the same way that NUnit does. Because the status of such projects may change from time to time, we don't discuss them individually here. For the latest information, consult the manufacturer of any third-party software or ask other users on our discussion list . Additional Information For additional general information on how tests are loaded and run, see Runtime Selection Assembly Isolation Configuration Files Visual Studio Support"
  },
  "articles/nunit/running-tests/NUnitLite-Options.html": {
    "href": "articles/nunit/running-tests/NUnitLite-Options.html",
    "title": "NUnitLite Options | NUnit Docs",
    "keywords": "NUnitLite Options The NUnitLite runner is invoked by executing the test program. If desired, any of the following options may be specified: Option Description --test=NAMES Comma-separated list of NAMES of tests to run or explore. This option may be repeated. --testlist=PATH File PATH containing a list of tests to run, one per line. This option may be repeated. --include=CATEGORIES Test CATEGORIES to be included. May be a single category, a comma-separated list of categories or a category expression. --exclude=CATEGORIES Test CATEGORIES to be excluded. May be a single category, a comma-separated list of categories or a category expression. --timeout=MILLISECONDS Set timeout for each test case in MILLISECONDS. --seed=SEED Set the random SEED used to generate test cases. --workers=NUMBER Specify the NUMBER of worker threads to be used in running tests. --stoponerror Stop run immediately upon any test failure or error. --wait Wait for input before closing console window. --work=PATH PATH of the directory to use for output files. --output , --out=PATH File PATH to contain text output from the tests. --err=PATH File PATH to contain error output from the tests. --result=SPEC An output SPEC for saving the test results. This option may be repeated. --explore[=SPEC] Display or save test info rather than running tests. Optionally provide an output SPEC for saving the test info. This option may be repeated. --noresult Don't save any test results. --labels=VALUE Specify whether to write test case names to the output. Values: Off , On , All --trace=LEVEL Set internal trace LEVEL. Values: Off , Error , Warning , Info , Verbose (Debug) --teamcity Turns on use of TeamCity service messages. --noheader , --noh Suppress display of program information at start of run. --nocolor , --noc Displays console output without color. --verbose , -v Display additional information as the test runs. --help , -h Display this message and exit. Description By default, this command runs the tests contained in the assemblies and projects specified. If the --explore option is used, no tests are executed but a description of the tests is saved in the specified or default format. Several options that specify processing of XML output take an output specification as a value. A SPEC may take one of the following forms: --OPTION:filename --OPTION:filename;format=formatname --OPTION:filename;transform=xsltfile The --result option may use any of the following formats: nunit3 - the native XML format for NUnit 3.0 nunit2 - legacy XML format used by earlier releases of NUnit The --explore option may use any of the following formats: nunit3 - the native XML format for NUnit 3.0 cases - a text file listing the full names of all test cases. If --explore is used without any specification following, a list of test cases is output to the console. If none of the options ( --result , --explore , --noxml ) is used, NUnit saves the results to TestResult.xml in nunit3 format. Any transforms provided must handle input in the native nunit3 format."
  },
  "articles/nunit/running-tests/NUnitLite-Runner.html": {
    "href": "articles/nunit/running-tests/NUnitLite-Runner.html",
    "title": "NUnite Lite Runner | NUnit Docs",
    "keywords": "NUnite Lite Runner NUnitLite started out life as a separate version of the NUnit framework, with fewer features and a built-in test runner. It ran on devices as well as on desktop .NET and mono and allowed users to create executable tests without the overhead of a full NUnit installation. With NUnit 3.0, the NUnitLite framework has been merged with the full NUnit framework. There is now only one framework, nunit.framework.dll . The built-in runner, which was a part of the old NUnitLite, is now packaged as nunitlite.dll . Using NUnitLite To run tests under NUnitLite, proceed as follows: Create a console application to use as your test assembly. If you have already placed tests in a dll, you can change the project so that it produces a console application and reload it. Make sure your test assembly references both nunit.framework and nunitlite . The Main() for your console application should look something like this... public static int Main(string[] args) { return new AutoRun().Execute(args); } Execute your test application in order to run the tests. If you install the NUnitLite runner via the NuGet package, steps 2 is handled automatically. Both assemblies are installed and referenced for you. In addition, if you are using C#, step 3 is handled as well. A file, Program.cs, is added to your project with a Main() like that above. Note If you are not working in C#, you should delete the Program.cs file that the NuGet package added to your test project. NUnitLite Output As seen in the following screen shot, the output from an NUnitLite run is quite similar to that from the console runner."
  },
  "articles/nunit/running-tests/NUnit-Test-Projects.html": {
    "href": "articles/nunit/running-tests/NUnit-Test-Projects.html",
    "title": "NUnit Test Projects | NUnit Docs",
    "keywords": "NUnit Test Projects Although you may simply enter multiple assembly names on the console command-line, running tests from multiple assemblies is facilitated by the use of NUnit test projects. These are files with the extension .nunit containing information about the assemblies to be loaded. The following is an example of a hypothetical test project file: <NUnitProject> <Settings activeconfig=\"Debug\"/> <Config name=\"Debug\"> <assembly path=\"LibraryCore\\bin\\Debug\\Library.dll\"/> <assembly path=\"LibraryUI\\bin\\Debug\\LibraryUI.dll\"/> </Config> <Config name=\"Release\"> <assembly path=\"LibraryCore\\bin\\Release\\Library.dll\"/> <assembly path=\"LibraryUI\\bin\\Release\\LibraryUI.dll\"/> </Config> </NUnitProject> This project contains two configurations, each of which contains two assemblies. The Debug configuration is currently active. By default, the assemblies will be loaded using the directory containing this file as the ApplicationBase. The PrivateBinPath will be set automatically to LibraryCore\\bin\\Debug;LibraryUI\\bin\\Debug or to the corresponding release path. XML attributes are used to specify non-default values for the ApplicationBase, Configuration File and PrivateBinPath. The Project Editor may be used to create or modify NUnit projects. If you edit the XML manually, you should make sure to use a path relative to the directory containing the project file as the location of any assemblies. For details, see NUnit Project XML Format Command-line Overrides The following command-line options override what is specified in the NUnit project file: --config --domain --process --framework"
  },
  "articles/nunit/running-tests/Template-Based-Test-Naming.html": {
    "href": "articles/nunit/running-tests/Template-Based-Test-Naming.html",
    "title": "Template-Based Test Naming | NUnit Docs",
    "keywords": "Template-Based Test Naming NUnit uses a standard naming convention for all tests - however, this can be overridden by the user if required. TestName generation is driven by a name formatting string, which may contain any of the following format specifiers: {n} The namespace of the test or empty if there is no namespace. If empty, any immediately following '.' is ignored. {c} The class name of the test or empty if there is no class. This name includes any type arguments, enclosed in angle braces and separated by commas. {C} The full name of the class. Equivalent to {n}.{c} {m} The method name of the test or empty if there is no method. The name includes any type arguments, enclosed in angle braces and separated by commas. {M} The full name of the method. {a} The full argument representation, enclosed in parentheses and separated by commas. Each argument is represented by the standard NUnit format for certain types, otherwise by the result of ToString(). {p} Same as {a} but with a parameter name before each argument in the same style as the named arguments C# language feature . {0} , {1} ... {9} . An individual argument. This form is only useful when setting the name of an individual test case. If used in the default format string, any arguments not used will be ignored. {i} The test id, which is normally of the form mmm-nnn. Any text not included between curly braces is copied to the name as is. After the name is formatted, any leading or trailing '.' characters are removed. Otherwise, all non-format characters in the string are included as is. String arguments may be truncated to a maximum length. Either the {a} specifier or any of the individual argument specifiers may be followed by a colon and a length: {a:40} Truncate each string argument to 40 characters. All strings more than 37 characters are truncated to the first 37 followed by \"...\" {0:20} Truncate argument zero to 20 characters. Standard Name Formats Internally, NUnit uses certain standard formats unless overridden by the user. The standard format for generating a name from a test method and its arguments is: {m}{a} // Name This leads to test names like: Test1 Test2(5, 2) Test3(\"This is the argument\") Test4(\"This is quite long argument, so it is...\") Modifying the Name Format The SetName method of TestCaseData allows setting the name of an individual test case. In normal use, the provided string simply becomes the name of the test. However, if one of the template format specifiers is used in the argument to SetName , the name is regenerated using that format. For example, if the user wishes to specify only the argument portion of the name of a test method, while still retaining the method name, the name could be set to {m}(User argument) This would result in the display of the test name as SomeMethod(User Argument) Note that in this usage, it will generally only make sense to use {m} , {a} or {0} through {9} specifiers. However, NUnit will use whatever is provided."
  },
  "articles/nunit/running-tests/Test-Selection-Language.html": {
    "href": "articles/nunit/running-tests/Test-Selection-Language.html",
    "title": "Test Selection Language | NUnit Docs",
    "keywords": "Test Selection Language The console command-line allows you to specify a filter, which will select which tests are executed. This is done using the --where option, followed by an expression in NUnit's Test Selection Language (TSL), a simple domain-specific language designed for this purpose. Some of the characters used in the expression, such as space, | or &, may have a special meaning when entered on the command-line. In such a case, you should place the expression in quotation marks. nunit3-console mytest.dll --where \"cat == Urgent || Priority == High\" Note that TSL is handled by the NUnit engine but requires framework support to actually select the tests. The NUnit 3.0 framework supports it fully. See below for support limitations in NUnit V2 tests. Simple Expressions Simple Expressions are essentially comparisons, consisting of a key word or property name on the left-hand side, an operator and some constant value on the right-hand side. Here are some examples: cat == Data test =~ /TestCaseAttributeTest/ method == SomeMethodName cat != Slow Priority == High namespace == My.Name.Space The following key words are recognized on the left-hand side of the comparison: test - The fully qualified test name as assigned by NUnit, e.g. My.Name.Space.TestFixture.TestMethod(5) name - The test name assigned by NUnit, e.g. TestMethod(5) class - The fully qualified name of the class containing the test, e.g. My.Name.Space.TestFixture namespace - The fully qualified name of the namespace containing the test(s), e.g. My.Name.Space method - The name of the method, e.g. TestMethod cat - A category assigned to the test, e.g. SmokeTests If the left-hand side of the comparison does not consist of a key word, it is treated as the name of a property on the test whose value is to be checked. See below for restrictions on use of properties. The following operators are supported == to test for equality - a single equal sign ( = ) may be used as well and has the same meaning != to test for inequality =~ to match a regular expression !~ to not match a regular expression The right-hand side of the comparison may be a sequence of non-blank, non-special characters or a quoted string. Quoted strings may be surrounded by single quotes ( ' ), double quotes ( \" ) or slashes ( / ) and may contain any character except the quote character used to delimit them. If it is necessary to include the quote character in the string, it may be escaped using a backslash () as may the backslash itself should you need to include one. The following expressions all do the same thing: test =~ /TestCaseAttributeTest/ test =~ \"TestCaseAttributeTest\" test =~ 'TestCaseAttributeTest' test =~ TestCaseAttributeTest test=~TestCaseAttributeTest For matching regular expressions, NUnit uses .NET's Regex.IsMatch method. For detailed information on the syntax of regular expressions in .NET, see https://msdn.microsoft.com/en-us/library/az24scfc%28v=vs.110%29.aspx . For specifying qualified names, the same format as used for reflection should be used. For example My.Name.Space.TestFixture+NestedFixture can be used to select a nested fixture. For detailed information see: Specifying Special Characters Filtering By Namespace Using the namespace keyword with == will not match on sub-namespaces. For example by using the filter namespace == My.Name.Space , a test My.Name.Space.MyFixture will be selected but a test My.Name.Space.SubNamespace.MyFixture will not, since its namespace is not equal to the namespace provided. In order to inclusively select namespaces, a regular expression can be used. For example to match all namespaces under the root namespace My.Name.Space , the following filter can be used namespace =~ ^My\\.Name\\.Space($|\\.) Filtering Based on Properties Although the syntax will accept any property name - including names that don't actually exist - filtering will only work on existing, string-valued properties. The following properties are created by NUnit and have string values: Author Category Description SetCulture SetUICulture TestOf IgnoreUntilDate In general, these properties were not created with filtering in mind, but you can use them if it suits your needs. Using the Category property currently accomplishes the same thing as the cat keyword. You should be aware that the use of these properties by NUnit is considered an implementation detail and they may change in the future. We envision that most filtering by property will be based on user-defined properties, created for this purpose by inheriting from Property Attribute . When defining a property, you should keep the limitation to string values in mind. For example, a PriorityAttribute taking values of \"High\", \"Medium\" and \"Low\" could be used for filtering, while one that took the integers 1, 2 and 3 could not. Filtering by Test Id In addition to the left-hand-side items listed, NUnit supports filtering by the test id through the id keyword. The id may only be selected using the == operator and is intended only for use by programs that have explored the tests and cached the ids, not for general use by users. The reason for this restriction is that users have no way of predicting the id that will be assigned to a test. The id is not persistent across test runs and its format can differ between different framework drivers. Compound Expressions Simple expressions may be combined using logical and, logical or, parentheses or negation operators. Logical and is expressed as && , & or and . Logical or is expressed as || , | , or or . The negation operator is ! and may only appear before a left parenthesis. The letter variants, and and or , are provided for use on the command-line in systems that give & and | a special meaning. The following are valid compound expressions: test == \"My.Namespace\" and cat == Urgent test == \"My.Namespace\" and (cat == Urgent or Priority == High) test == \"My.Namespace\" and (cat == Urgent or Priority == High) method =~ /Source.*Test/ and class =~ \"My.Namespace.ClassName\" Usage on the Command Line Because TSL contains special characters and may contain blank spaces, you will usually want to put the expression in quotes on the command line. Consequently, any strings within the TSL expression will most likely need to use an alternate quote character. For example: nunit-console test.dll --where \"method =~ /Source.*Test/ && class =~ 'My.Namespace.Classname'\" Support in NUnit V2 The driver for NUnit V2 supports a subset of TSL. Because the V2 NUnit framework only allowed filtering on test names and categories, you may only use the cat and test keywords in comparisons. In addition, the regular expression operators =~ and !~ are not supported. If you use any of the unsupported keywords or operators with V2 tests, an error message is displayed and the tests are not run."
  },
  "articles/nunit/technical-notes/nunit-internals/Active-Attributes.html": {
    "href": "articles/nunit/technical-notes/nunit-internals/Active-Attributes.html",
    "title": "Active Attributes | NUnit Docs",
    "keywords": "Active Attributes Warning Out Of Date - Needs Rewrite NUnit identifies tests and fixtures of custom attributes. Additional attributes are used to identify test data, modify tests and control how they execute. NUnit 3.0 is changing how attributes are used and recognized internally, while maintaining the same API for the test writer. This specification describes how the new version will recognize and use attributes, the interfaces implemented by attributes and the class hierarchy of NUnit's custom attributes. Rationale In the NUnit 2.x releases, attributes are recognized by the text of their name rather than using the attribute Type. This means that there is no need or the runner to have an actual reference to the nunit.framework assembly, where attributes are defined. This approach was taken in order to support multiple versions of the framework. Each new release of NUnit was able to run tests built against older frameworks, so long as the names remained the same. However, this approach has some drawbacks: As new attributes were added to the framework, it became necessary to also add the name of each attribute to the nunit core, which contained the code to load and run tests. The growing number of attributes in the framework now presents and extremely large surface area for the core to be aware of. Inheritance from attributes does not work as users would expect with NUnit failing to automatically recognize those attributes as equivalent to their base classes. In a few cases, NUnit contains special code to scan the base classes of any attributes found but it is not easy for users to discover which attributes allow this. NUnit must examine all attributes of a given class or method, comparing their names with the names it understands. This is quite inefficient and can slow down loading of assemblies containing large numbers of classes or methods. By locating the code to load and run tests in the framework assembly, NUnit 3.0 eliminates the first problem above. Test runners now need only be aware of a much narrower API. The design section below describes how we are handling the second and third issues. Design With NUnit 3.0, attributes are now only used within the framework assembly. Since all references are within that assembly, we can now handle them as Types rather than strings. All existing code that uses attribute names will be modified to use Type references, improving efficiency and allowing use of standard object-oriented programming techniques. The following sections provide an outline of the planned design. As implementation progresses, the code itself should be examined for updated information and further details. Active Attributes NUnit has a relatively small number of test types (e.g. TestFixture, TestMethod, Theory) and a relatively larger number of attributes. The current (2.x) design uses attributes almost exclusively as passive containers for their arguments and properties. All active code around attributes is located in the code around loading and running tests. In almost all cases, it is possible to reverse this logic and have the attributes play an active part in modifying the operation of tests. For example, the NUnit 2.6 test building logic understands that a test description may be found as a property of a DescriptionAttribute, TestAttribute or TestFixtureAttribute. In NUnit 3.0, each of those attributes will simply be called upon to update the test under construction with whatever information they can supply using the IApplyToTest interface. Attribute Hierarchy With just a few exceptions, NUnit's current set of attributes inherit from System.Attribute directly. Since we are now switching to use of the standard .NET reflection mechanism via attribute Types, it is useful to categorize attributes according to how and when they are used. For example, at a certain point in the construction of tests, NUnit must scan the attributes on a method to apply all those that provide modifications to the test being built. This is currently done by looking at all attributes of the method but it will be much more convenient to only retrieve TestModificationAttributes. The top levels of the Attribute hierarchy are listed here to the extent that they have been thought out. This will change as we implement it and will not necessarily remain stable in future releases because the hierarchy is considered to be an internal implementation detail. NUnitAttribute TestIdentificationAttribute TestModificationAttribute PropertyAttribute TestActionAttribute DataAttribute TestCaseDataAttribute ParameterDataAttribute Interface Usage While class inheritance of attributes is useful for retrieving groups of them and for sharing implementation, public access to capabilities of an attribute is better provided through an interface. For example, most TestModificationAttributes will implement the IApplyToTest interface, allowing them to be called upon to modify the test under construction. public interface IApplyToTest { void ApplyToTest(ITest test); } Interfaces are defined in the NUnit.Framework.Api namespace. Properties Versus Separate Attributes In some cases, there is a design choice to be made between use of a separate attribute or a property of the primary attribute for holding a particular of information. For example, the description of a test may be given as a property of TestAttribute or using a separate DescriptionAttribute. Recent versions of NUnit have deprecated use of properties in favor of separate attributes. Separate attributes provide a more orthogonal design and have been preferred for that reason. However, the introduction of parameterized tests has necessitated adding properties to the TestCaseAttribute and other attributes, representing functionality that was provided by a separate attribute on non-parameterized tests. For example, a test is ignored using the IgnoreAttribute while a TestCase is ignored by setting the Ignore property of TestCaseAttribute to true. For NUnit 3.0, we will try to provide some consistency of use for cases like this. This may result in \"un-deprecating\" certain existing properties and creating new ones. Attribute Targets NUnit will continue to rely on the AttributeUsageAttribute being properly defined on each of its attributes. This allows us to use one attribute type for both methods and classes while still counting on a given attribute only appearing in the proper context. Unresolved Issues One problem that is created by the new approach is that NUnit will no longer \"just work\" with tests compiled against framework versions prior to 3.0. This requires the NUnit test execution engine to use the old approach when dealing with tests compiled against a pre-3.0 framework version. This specification does not cover the execution engine, so the problem is not discussed further here."
  },
  "articles/nunit/technical-notes/nunit-internals/Architectural-Overview.html": {
    "href": "articles/nunit/technical-notes/nunit-internals/Architectural-Overview.html",
    "title": "Architectural Overview | NUnit Docs",
    "keywords": "Architectural Overview Warning This is a draft. The contents may be out of date. This specification describes the overall layered architecture of the NUnit Platform. Details of individual components are covered only as they are relevant to the overall architecture. Layers The basic architecture of the NUnit Extended testing platform consists of three layers: Test Runner Layer Test Engine Layer Framework Layer The layering can be seen in the diagram below. This is the original architectural document, which is a bit out of date with regard to some details. A replacement is being created. Test Runner Layer The Test Runner or UI layer contains various runners, some provided by the NUnit team, others by independent projects leveraging the NUnit platform. Some runners are stand-alone programs, while others are tasks or plugins running under the control of an IDE or other application. This diversity of runners is part of the reason we refer to NUnit 3.0 as a Testing Platform â€“ we expect many different runners to come into existence and will facilitate their development by providing reusable controls for several key environments. Programs in this layer are able to participate in the NUnit platform plugin architecture, providing extension points that allow them to be extended. Plugins at this level will usually add some functionality to the UI. Some of them may be standalone while others may require the presence of specific test engine plugins in order to operate. The NUnit project will continue to provide both a console runner and a WinForms-based GUI with extended capabilities those in NUnit 2.6. In addition, two new GUI runners will be developed, one based on WPF, the other on GTK#. Weâ€™ll work with the NAnt project to provide updates to the NAnt task for use with NUnit 3.0, with the goal of keeping that task current as new versions of NUnit are released. We will provide an NUnit plugin for the new Gallio platform. In the area of IDE integration, we will deliver a Visual Studio addin or package for running NUnit tests. Since other folks are already providing open source plugins for SharpDevelop and MonoDevelop, weâ€™ll work with them to ensure compatibility. There is a long-standing need for a runner that executes tests in an actual or simulated web server environment. While good practice calls for extracting as much functionality as possible into separately testable assemblies, more complex applications often contain code which can only be tested in such an environment. For that reason, NUnit 3.0 will feature a web runner, which allows tests to be executed on a web server, reporting results back to the desktop. Each of the runners will have the option of participating in the NUnit plugin architecture and using functionality provided by NUnit to whatever degree desired. For the runners developed directly by the NUnit team, this capability will be used to the max, allowing others to add GUI features that function by themselves or in conjunction with other plugins operating at the level of the test engine. Test Engine Layer The Test Engine Layer is the core of the NUnit platform. It provides a public API for use by applications that want to locate, load and run tests and display test results. Many aspects of the Test Engine are already present in NUnit 2.6, while others are new. Iâ€™ll focus on the new features here. NUnit 2.6 already supports running tests in a separate process, allowing selection of the CLR version under which the test is to be run. NUnit 3.0 will extend this feature to allow test processes to run on other machines. It will also support distribution of test execution across a network of remote Test Agents. This facility is intended to be used in several distinct scenarios: Simple load sharing when test execution time is excessive Testing applications on multiple platforms Testing applications, which are themselves distributed A great deal of distributed function is already present in NUnit 2.6 through pNUnit, the distributed testing runner contributed to our project by Codice Software. With NUnit 3.0, we plan to integrate this function more completely into NUnit, allowing them to be executed by any runner that uses the NUnit Test Engine. NUnit will support performance and coverage analysis, test result reporting and maintenance of a history of test results. These features will function only as called upon by the user. That is, we will not carry on data collection activities with the potential of impacting performance when the user simply wants to run tests. Through use of plugins, NUnit will be able to support a wide variety of test types beyond low-level, isolated programmer tests. What is available in this area will be dependent on the interests of users and their willingness to contribute their efforts to creating them. Examples of the kinds of things we envision, some of which we will provide directly, are: Randomization of test execution order Deterministic test ordering for integration tests Parameterized (data-driven) tests Transactional test behavior Timed tests and parameterized timeout failures Dynamic test generation based on data input Repetitive test execution Tests written as non-managed code Test generation for legacy applications Framework Layer In NUnit 3.0, the NUnit framework itself â€“ the assembly that is referenced by user tests â€“ will be split along two dimensions. First, there will be separate framework assemblies for different version levels of the Common Language Runtime. By splitting the framework in this way, we will be able to take advantage of newer features, and allow users to take advantage of them, without compromising basic support for older runtimes. The second split we plan is between the core framework capabilities and the syntactic features that make it easy to access those features. A key example of this is the fluent interface introduced in NUnit 2.4 â€“ the â€œAssert.Thatâ€ syntax. One thing we learned through that experiment is that the same syntactic â€œsugarâ€ does not work well for different language environments. Many of the 2.4/2.5/2.6 constructs are unusable or very difficult to use in other languages â€“ C++ for example. By a combination of separate namespaces and separate assemblies, we will allow users to select the appropriate syntax for the work they are doing. Other people will be able to build on the syntax we provide or create entirely new syntactic overlays for their own purposes. Through use of plugins in the Test Engine layer, NUnit will be able to recognize, load and run tests written using other frameworks. Our focus will be on facilitating the creation of plugins in support of external frameworks by the projects that produce those frameworks or by interested users. For frameworks where that sort of support is not possible â€“ commercial frameworks, for example â€“ we have the option of creating the plugins ourselves. In some cases, individuals with an idea for a new framework may be able to create them more simply by writing an adapter on top of the NUnit framework itself. We will encourage and support this by giving priority to framework modifications that provide the necessary infrastructure for such projects. NUnit will also provide or re-package some framework extensions for specific types of applications, including Windows Forms development, WPF development, web page access, XML testing, performance measurement and load testing. At this point, it is not yet possible to state which of these will involve existing third-party packages and which will be developed from scratch, because discussions are ongoing. The NUnitLite framework will be supported running on devices and reporting results back to the Test Engine through a communications channel. Various popular mock frameworks will be supported. NUnit's own self-tests now use the NSubstitute framework, which is packaged with NUnit, but users may make use of whatever mocking framework they prefer. See Also You can also view the Original Architectural Overview Document created for NUnit 3.0 in 2009."
  },
  "articles/nunit/technical-notes/nunit-internals/Attribute-Hierarchy.html": {
    "href": "articles/nunit/technical-notes/nunit-internals/Attribute-Hierarchy.html",
    "title": "Attribute Hierarchy | NUnit Docs",
    "keywords": "Attribute Hierarchy Warning This is a draft. The contents may be out of date. This technical note describes the inheritance hierarchy used for attributes in NUnit. It applies to the built-in attributes and may also be used as a guide for where to place custom attributes in the hierarchy. However, use of these attributes as base classes is entirely optional for custom attributes, as all functionality is accessed through the implemented interfaces. Essentially, we use attribute inheritance to define the \"what\" of an attribute... that is, what it primarily is and what it primarily is used for. The actual functionality of an attribute is defined by the use of interfaces. Abstract Attribute Classes The base of the hierarchy is formed by a number of abstract classes. They generally incorporate no code. NUnitAttribute All NUnit attributes inherit directly or indirectly from NUnitAttribute . Its only purpose is to allow easy selection of all NUnit attributes on a member. If a custom attribute does not fit under any of the other attribute classes, you may derive it directly from NUnitAttribute . TestFixtureBuilderAttribute TestFixtureBuilderAttribute is the base class for any attribute that knows how to build a test fixture of some kind from a provided class. In this context, a test fixture means any test that is based on a user class. NUnit includes the following attributes derived from TestFixtureBuilderAttribute : TestFixtureAttribute SetUpFixtureAttribute . Derived classes that build fixtures should implement the IFixtureBuilder interface. TestFixtureBuilderAttribute does not implement this interface itself since future versions of NUnit may introduce additional interfaces that build fixtures. Therefore, the choice of interface is left to the derived class. TestCaseBuilderAttribute TestCaseBuilderAttribute is the base class for any attribute that knows how to build a test case from a given method. Test cases may be simple (without arguments) or parameterized (taking arguments) and are always based on a MethodInfo . NUnit includes the following attributes derived from TestCaseBuilderAttribute : CombiningStrategyAttribute CombinatorialAttribute PairwiseAttribute SequentialAttribute TestAttribute TestCaseAttribute TestCaseSourceAttribute TheoryAttribute As with TestFixtureBuilderAttribute , the choice of a specific interface to implement is left to the derived class. Custom classes that build test cases should implement one of the interfaces designed for the purpose: ISimpleTestCaseBuilder or ITestCaseBuilder . Further interfaces may be defined in the future. In addition, any builder that is intended to cause a non-attributed class to be used as an NUnit TestFixture should implement IImplyFixture . IncludeExcludeAttribute IncludeExcludeAttribute is the base class for any attributes used to decide whether to include a test in the current run or exclude it based on the string properties Include , Exclude and Reason . The abstract base simply makes these properties available to the derived class, which is responsible for taking action on them. NUnit currently defines two attributes that derive from IncludeExcludeAttribute : CultureAttribute PlatformAttribute These two attributes implement IApplyToTest and set the RunState of the test based on interpreting the arguments and the current environment. Custom classes derived from IncludeExcludeAttribute should do the same thing."
  },
  "articles/nunit/technical-notes/nunit-internals/Engine-Driver-Api.html": {
    "href": "articles/nunit/technical-notes/nunit-internals/Engine-Driver-Api.html",
    "title": "Engine Driver API | NUnit Docs",
    "keywords": "Engine Driver API The TestEngine uses drivers to interface with frameworks. This isolates framework-specific code from the more general code used to load and run tests. Each test framework that is used with the engine needs a driver to support it. While a driver could theoretically support multiple frameworks, we expect the normal case to be a one-to-one mapping of drivers to frameworks. Because they are quite different internally, NUnit itself treats its own 2.x and 3.x framework versions as separate frameworks, with each using a different driver. The NUnit 3 driver is the only one built into the engine. All other drivers must be written and installed as extensions. Designing an API for drivers involved compromise. The API had to be simple enough to be easily implemented by those wanting to use NUnit with a particular framework. On the other hand, if it was too simple, some advanced capabilities of a given framework might not be easily accessible. Implementation Details The driver API is encapsulated in the IDriverFactory and IFrameworkDriver interfaces, which must be implemented by all framework driver extensions to the engine. IDriverFactory The IDriverFactory interface is called by the engine to determine if a particular extension is able to create a driver for a particular framework assembly. The engine passes the AssemblyName of each assembly referenced by the test assembly to the factory to see if it is a supported framework. If it finds one, then it uses that driver. If not, it goes on to check the next driver extension. namespace NUnit.Engine.Extensibility { /// <summary> /// Interface implemented by a Type that knows how to create a driver for a test assembly. /// </summary> [TypeExtensionPoint(Description = \"Supplies a driver to run tests that use a specific test framework.\")] public interface IDriverFactory { /// <summary> /// Gets a flag indicating whether a given AssemblyName /// represents a test framework supported by this factory. /// </summary> /// <param name=\"reference\">An AssemblyName referring to the possible test framework.</param> bool IsSupportedTestFramework(AssemblyName reference); /// <summary> /// Gets a driver for a given test assembly and a framework /// which the assembly is already known to reference. /// </summary> /// <param name=\"domain\">The domain in which the assembly will be loaded</param> /// <param name=\"reference\">An AssemblyName referring to the test framework.</param> /// <returns></returns> IFrameworkDriver GetDriver(AppDomain domain, AssemblyName reference); } } IFrameworkDriver The IFrameworkDriver interface is returned from IDriverFactory and is the key interface for actually loading, exploring and running the tests in the test assembly. In theory, a single driver factory could return different drivers in different situations, but we expect a one-to-one mapping of factories to drivers to be most commonly used. namespace NUnit.Engine.Extensibility { /// <summary> /// The IFrameworkDriver interface is implemented by a class that /// is able to use an external framework to explore or run tests /// under the engine. /// </summary> public interface IFrameworkDriver { /// <summary> /// Gets and sets the unique identifier for this driver, /// used to ensure that test ids are unique across drivers. /// </summary> string ID { get; set; } /// <summary> /// Loads the tests in an assembly. /// </summary> /// <returns>An Xml string representing the loaded test</returns> string Load(string testAssemblyPath, IDictionary<string, object> settings); /// <summary> /// Count the test cases that would be executed. /// </summary> /// <param name=\"filter\">An XML string representing the TestFilter to use in counting the tests</param> /// <returns>The number of test cases counted</returns> int CountTestCases(string filter); /// <summary> /// Executes the tests in an assembly. /// </summary> /// <param name=\"listener\">An ITestEventHandler that receives progress notices</param> /// <param name=\"filter\">A XML string representing the filter that controls which tests are executed</param> /// <returns>An Xml string representing the result</returns> string Run(ITestEventListener listener, string filter); /// <summary> /// Returns information about the tests in an assembly. /// </summary> /// <param name=\"filter\">An XML string representing the filter that controls which tests are included</param> /// <returns>An Xml string representing the tests</returns> string Explore(string filter); /// <summary> /// Cancel the ongoing test run. If no test is running, the call is ignored. /// </summary> /// <param name=\"force\">If true, cancel any ongoing test threads, otherwise wait for them to complete.</param> void StopRun(bool force); } } As designed, the IFrameworkDriver interface maps most directly to the requirements of the NUnit 3 framework. Drivers for other frameworks need to function as an adapter to run tests and return understandable results to the engine. The filter argument passed to several of the interface methods is an XML string representing the filter. See Test Filters for a description of the format, which is directly understood by the NUnit 3 framework, but which must be converted by the driver to something that is understood by other frameworks. ITestEventListener The ITestEventListener interface is implemented by the Engine and used by each driver to report significant events during the execution of tests. namespace NUnit.Engine { /// <summary> /// The ITestEventListener interface is used to receive notices of significant /// events while a test is running. Its single method accepts an Xml string, /// which may represent any event generated by the test framework, the driver /// or any of the runners internal to the engine. Use of Xml means that /// any driver and framework may add additional events and the engine will /// simply pass them on through this interface. /// </summary> [TypeExtensionPoint(Description = \"Allows an extension to process progress reports and other events from the test.\")] public interface ITestEventListener { /// <summary> /// Handle a progress report or other event. /// </summary> /// <param name=\"report\">An XML progress report.</param> void OnTestEvent(string report); } }"
  },
  "articles/nunit/technical-notes/nunit-internals/Framework-Api.html": {
    "href": "articles/nunit/technical-notes/nunit-internals/Framework-Api.html",
    "title": "Framework API | NUnit Docs",
    "keywords": "Framework API The NUnit 3 Framework API consists of a number of related classes with well-known names contained in the framework. The NUnit 3 Framework Driver, which is part of the engine, performs actions by creating these classes. All required actions are performed in the constructor. The driver only needs to know the names of the classes and the arguments each one accepts. This document describes the interface between the driver and framework and the rules that must be followed to provide continued backward compatibility as new versions of the framework are created. Note that it only applies to the NUnit 3 framework. The following is a simplified example of how a calling program might use the framework to load and run tests in a particular AppDomain . This sort of code is expected to reside only in a driver. User-created runners should use the Engine API rather than dealing with the framework at this low level. See below for explanations of each call. var myHandler = new MyHandlerClass(); // implements ICallbackEventHandler // Create the controller var args = new object[] { \"my.test.assembly.dll\", new Hashtable()}; var controller = domain.CreateInstanceAndUnwrap( \"nunit.framework\", \"NUnit.Framework.Api.FrameworkController\", false, 0, null, args, null, null, null); // Load the assembly args = new object[] { controller, myHandler }; domain.CreateInstanceAndUnwrap( \"nunit.framework\", \"NUnit.Framework.Api.FrameworkController+LoadTestsAction\", false, 0, null, args, null, null, null); // myHandler.GetCallbackResult() should return an Xml string with the result // of the Load, which was passed to it by the framework. // We're not checking this here, as we normally would do. // Run the tests args = new object[] { controller, \"<filter/>\", myHandler }; domain.CreateInstanceAndUnwrap( \"nunit.framework\", \"NUnit.Framework.Api.FrameworkController+RunTestsAction\", false, 0, null, args, null, null, null); // myHandler.GetCallbackResult() should return an Xml string with the results // of running the test, which was passed to it by the framework. API Classes The following classes provide the API: FrameworkPackageSettings FrameworkController FrameworkControllerAction LoadTestsAction CountTestsAction ExploreTestsAction RunTestsAction FrameworkPackageSettings This static class defines constants for the names of all settings recognized by the framework. We use FrameworkPackageSettings rather than constants spread throughout the code in order to keep things consistent. A copy of this class is maintained in both the console runner and the framework and the settings are passed through to the framework by the engine. As new versions of the framework are released, settings in this file are not changed, although new settings may be added. See the code itself for a list of the settings in use. FrameworkController The driver creates a FrameworkController instance using reflection for each test assembly that must be loaded for browsing or execution. The constructor is defined as follows: public FrameworkController(string assemblyPath, string idPrefix, IDictionary settings) where assemblyPath is the full path to the test assembly. idPrefix is a prefix used for all test ids created under this controller. This is how the engine is able to provide unique ids for each test identified, even though multiple assemblies, frameworks and controllers may be involved. settings is an IDictionary containing the settings to be used in loading and running this assembly. A non-generic dictionary is used to allow for implementation of the framework on platforms that don't support Generics. This constructor always succeeds, provided that the arguments are of the correct types. Any operational errors will occur when specific actions like Load or Run are taken. FrameworkControllerAction As the driver needs to perform some action, it creates a temporary instance of a class derived from FrameworkControllerAction . The constructors for all actions have the following points in common: They take an instance of FrameworkController as their first argument. This must be the instance originally created by the driver for the particular assembly. This instance provides a common point of communication among various actions taken against the assembly. Another argument, the last one, is an object that implements System.Web.UI.ICallbackEventHandler . The handler receives the result of each action and - in the case of executing tests - progress notifications. Due to the nature of the ICallbackEventHandler interface, the results returned are always strings. The specific content of each result depends on the particular action. Exceptions are only thrown in the case of completely unanticipated errors, generally meaning an error in the calling program or a bug in the framework. We don't consider things like missing or bad files or exceptions thrown in user code as unanticipated. Some actions take the string representation of a test filter as an argument. The NUnit Engine and Framework have shared knowledge of the format of a filter. For an empty filter (no filtering) use \"<filter/>\" . A null or empty string is also accepted for an empty filter as of NUnit 3.7.1, but \"<filter/>\" should be used for backwards compatibility. Note The ICallbackEventHandler is actually passed as an object and cast to the interface by the framework. This is intended to allow future use of other interfaces for progress. LoadTestsAction LoadTestsAction must be used before any other action can be called. Its constructor is as follows: public LoadTestsAction(FrameworkController controller, object handler); where controller is the FrameworkController instance that was created for managing the test assembly. handler is an object implementing ICallbackEventHandler , to receive the result of the load. The result returned from handler.GetCallbackResult() is the XML representation of the loaded test assembly. No child tests are included in the XML, since this method will be called by programs with no need for such a level of detail. Programs requiring the full tree of tests, such as Gui runners, should follow up by using the ExploreTestsAction . If the assembly can not be found or loaded, the same result is returned, but with a RunState of NotRunnable . ExploreTestsAction ExploreTestsAction is used to get the full tree of tests, as for display in a Gui. Its constructor is as follows: public ExploreTestsAction(FrameworkController controller, string filter, object handler); where controller is the FrameworkController instance that was created for managing the test assembly. filter is the string representation of a filter in XML format to be used when exploring tests. handler is an object implementing ICallbackEventHandler, to receive the result of the call. The result returned from handler.GetCallbackResult() is the XML representation of the test assembly, containing all tests that passed the filter, arranged as a tree with child tests contained within their parents. If the assembly was not found or unable to be loaded, a non-runnable assembly with no child tests is returned. If this action is invoked without first invoking LoadTestsAction , an InvalidOperationException is thrown. CountTestsAction CountTestsAction is used to get the number of test cases that will be executed under a specified filter, for use in a progress display. Its constructor is as follows. public CountTestsAction(FrameworkController controller, string filter, object handler); where controller is the FrameworkController instance that was created for managing the test assembly. filter is the string representation of a filter in XML format to be used when counting tests. handler is an object implementing ICallbackEventHandler , to receive the result of the call. The result returned from handler.GetCallbackResult() is the string representation of the integer number of test cases that match the filter. If the assembly was not found or unable to be loaded, \"0\" is returned. If this action is invoked without first invoking LoadTestsAction , an InvalidOperationException is thrown. RunTestsAction RunTestsAction is used to execute the loaded tests. Its constructor is as follows: public RunTestsAction(FrameworkController controller, string filter, object handler); where controller is the FrameworkController instance that was created for managing the test assembly. filter is the string representation of a filter in XML format to be used when counting tests. handler is an object implementing ICallbackEventHandler , to receive the result of the call. The result returned from handler.GetCallbackResult is the XML representation of the test result, including all child results. If the assembly was not found or could not be loaded, a non-runnable result with no child tests is returned. If this action is invoked without first invoking LoadTestsAction , an InvalidOperationException is thrown. RunAsyncAction RunAsyncAction is used to initiate an asynchronous test run, returning immediately. Its constructor is as follows: public RunAsyncAction(FrameworkController controller, string filter, object handler); where controller is the FrameworkController instance that was created for managing the test assembly. filter is the string representation of a filter in XML format to be used when counting tests. handler is an object implementing ICallbackEventHandler , to receive the result of the call. No actual result is returned immediately from the call. The handler progress notices must be tracked in order to know what is going on with the tests and eventually the final result may be retrieved. If the assembly was not found or could not be loaded, a non-runnable result with no child tests is returned. If this action is invoked without first invoking LoadTestsAction , an InvalidOperationException is thrown. StopRunAction StopRunAction is used to stop an ongoing test run. Its constructor is as follows: public StopRunAction(FrameworkController controller, bool force, object handler); where controller is the FrameworkController instance that was created for managing the test assembly. force indicates whether or not the stop should be forced, as opposed to a cooperative stop. handler is an object implementing ICallbackEventHandler , to receive the result of the call. No result is returned from the call. If no run is in progress, the call is ignored."
  },
  "articles/nunit/technical-notes/nunit-internals/Framework-Design.html": {
    "href": "articles/nunit/technical-notes/nunit-internals/Framework-Design.html",
    "title": "Framework Design | NUnit Docs",
    "keywords": "Framework Design Warning This is a draft. The contents may be out of date. NUnit 3.0 is intentionally changing certain design decisions made in earlier versions. We document those changes here so that developers may find them all in one place. For details, see the individual specifications referenced under each design change subheading. Key Design Changes Multiple Framework Distributions NUnit 3.0 introduces separate framework builds for each supported runtime version, including .NET 2.0, 3.5, 4.0 and 4.5. We will continue to use the same framework assemblies for both the Microsoft and Mono implementations. Merge NUnitLite NUnitLite is a light-weight version of NUnit, requiring minimal resources and running on platforms not supported by full NUnit. NUnitLite is approximately equivalent to the framework portion of NUnit, with the addition of a rudimentary test runner. For the NUnit 3.0 release, the NUnitLite project code has been merged with the code of NUnit itself, using conditional compilation to support a reduced feature set. Framework Boundary Historically, most xUnit frameworks incorporate the logic for loading and running tests in the same module that includes assertions, attributes and other types referenced by the tests. NUnit started that way but the loading and test execution logic was extracted into a separate assembly in later versions. This approach had some benefit - most notably NUnit's ability to run tests built against older versions of the framework - but has proven less useful as more features were added. Essentially, the surface area that NUnit presents to a client program wanting to run tests grows each time a new feature is added. This has made it very difficult for third parties to keep up with NUnit's feature growth. For NUnit 3.0, the boundary has been moved. Each version of the framework incorporates a test runner that knows how to load and execute the tests supported by that version. Framework Api The internal (core) interfaces used by earlier versions of NUnit are not suitable for external use because they tend to change as features are added. The 3.0 release incorporates a new interface, supporting the same functionality as the existing interfaces, but with fewer dependencies on custom types. It is usable by both NUnit and third-party runners and will provide functions of test discovery, loading and execution. See Framework Api Active Attributes In the NUnit 2.x series, Attributes are fundamentally passive objects. They are used as markers for certain kinds of functionality, but that functionality is implemented in the nunit.core assembly. Reflection is used to identify attributes, in order to avoid a reference from the core to a specific version of the framework. In NUnit 3.0, since the test loader is part of the framework assembly, we'll be able to identify attributes without use of reflection, which should improve load performance. Attributes will actually contain the code that carries out the necessary functionality. See DRAFT:Active Attributes Test Loading Earlier releases of NUnit load tests in a hierarchy based on the namespace and may optionally load them as a flat list of fixtures. The test hierarchy is built as the tests are loaded and reflected in the gui display. With NUnit 3.0, the test loader will only load fixtures and will not create a hierarchy. It will be the responsibility of the Gui to construct whatever display hierarchy the user chooses as a view of the tests. This will simplify the loading of tests and is compatible with NUnitLite, which already loads tests this way. Test Execution Currently, the sequencing of tests is the responsibility of the tests themselves. That is, each test suite executes its own child tests and each test reports its own results. The absence of a distinct test execution object makes it difficult to support certain features, such as high-level setup and teardown, parallel test execution and cancellation of running tests with restart. In NUnit 3.0, the objects representing tests will no longer have the responsibility of running any subordinate tests and a separate test runner will sequence through the tests to execute them in the desired order."
  },
  "articles/nunit/technical-notes/nunit-internals/NUnit-3.0-Architecture-(2009).html": {
    "href": "articles/nunit/technical-notes/nunit-internals/NUnit-3.0-Architecture-(2009).html",
    "title": "NUnit 3.0 Architecture (2009) | NUnit Docs",
    "keywords": "NUnit 3.0 Architecture (2009) This is the original - now out of date - document created to describe the planned architecture for NUnit 3.0. We are keeping it for whatever historical interest it may have. The diagram was created first and was shown for the first time by Charlie Poole at a Mono gathering in Madrid in 2008. The complete document was published the following year. Summary This specification describes the overall layered architecture of the NUnit Platform. Details of individual components are covered only as they are relevant to the overall architecture. Launchpad Blueprint http://blueprints.launchpad.net/nunit-3.0/+spec/nunit-3.0-architecture User Stories An NUnit User upgrades selected components of the NUnit platform without changing others. runs tests using alternate runners and frameworks under the NUnit platform. installs and uses addins and other extensions to the NUnit platform. An NUnit Developer understands how each component fits into the overall architecture of NUnit. chooses the proper component and project for making a fix or adding a feature. is able to focus attention on the component being modified, without worrying about the details of other components. An NUnit Extension Developer can develop an extension to a specific NUnit component, without dealing with other parts. can develop extensions to multiple NUnit components, which work together to achieve their result. Layers The basic architecture of the NUnit Extended testing platform consists of three layers: Test Runner Layer Test Engine Layer Framework Layer Test Runner Layer The Test Runner or UI layer contains various runners, some provided by the NUnit team, others by independent projects leveraging the NUnit platform. Some runners are stand-alone programs, while others are tasks or plugins running under the control of an IDE or other application. This diversity of runners is part of the reason we refer to NUnit 3.0 as a Testing Platform â€“ we expect many different runners to come into existence and will facilitate their development by providing reusable controls for several key environments. Programs in this layer are able to participate in the NUnit platform plugin architecture, providing extension points that allow them to be extended. Plugins at this level will usually add some functionality to the UI. Some of them may be standalone while others may require the presence of specific test engine plugins in order to operate. The NUnit project will continue to provide both a console runner and a WinForms-based GUI with extended capabilities those in NUnit 2.5. In addition, two new GUI runners will be developed, one based on WPF, the other on GTK#. Weâ€™ll work with the NAnt project to provide updates to the NAnt task for use with NUnit 3.0, with the goal of keeping that task current as new versions of NUnit are released. We will provide an NUnit plugin for the new Gallio platform. In the area of IDE integration, we will deliver a Visual Studio addin or package for running NUnit tests. Since other folks are already providing open source plugins for SharpDevelop and MonoDevelop, weâ€™ll work with them to ensure compatibility. There is a long-standing need for a runner that executes tests in an actual or simulated web server environment. While good practice calls for extracting as much functionality as possible into separately testable assemblies, more complex applications often contain code which can only be tested in such an environment. For that reason, NUnit 3.0 will feature a web runner, which allows tests to be executed on a web server, reporting results back to the desktop. Each of the runners will have the option of participating in the NUnit plugin architecture and using functionality provided by NUnit to whatever degree desired. For the runners developed directly by the NUnit team, this capability will be used to the max, allowing others to add GUI features that function by themselves or in conjunction with other plugins operating at the level of the test engine. Test Engine Layer The Test Engine Layer is the core of the NUnit platform. It provides a public API for use by applications that want to locate, load and run tests and display test results. Many aspects of the Test Engine are already present in NUnit 2.4, while others are new. Iâ€™ll focus on the new features here. NUnit 2.5 already supports running tests in a separate process, allowing selection of the CLR version under which the test is to be run. NUnit 3.0 will extend this feature to allow test processes to run on other machines. It will also support distribution of test execution across a network of remote Test Agents. This facility is intended to be used in several distinct scenarios: Simple load sharing when test execution time is excessive Testing applications on multiple platforms Testing applications, which are themselves distributed A great deal of distributed function is already present in NUnit 2.5 through pNUnit, the distributed testing runner contributed to our project by Codice Software. With NUnit 3.0, we plan to integrate this function more completely into NUnit, allowing them to be executed by any runner that uses the NUnit Test Engine. NUnit will support performance and coverage analysis, test result reporting and maintenance of a history of test results. These features will function only as called upon by the user. That is, we will not carry on data collection activities with the potential of impacting performance when the user simply wants to run tests. Through use of plugins, NUnit will be able to support a wide variety of test types beyond low-level, isolated programmer tests. What is available in this area will be dependent on the interests of users and their willingness to contribute their efforts to creating them. Examples of the kinds of things we envision, some of which we will provide directly, are: Randomization of test execution order Deterministic test ordering for integration tests Parameterized (data-driven) tests Transactional test behavior Timed tests and parameterized timeout failures Dynamic test generation based on data input Repetitive test execution Tests written as non-managed code Test generation for legacy applications Framework Layer In NUnit 3.0, the NUnit framework itself â€“ the assembly that is referenced by user tests â€“ will be split along two dimensions. First, there will be separate framework assemblies for different version levels of the Common Language Runtime. By splitting the framework in this way, we will be able to take advantage of newer features, and allow users to take advantage of them, without compromising basic support for older runtimes. The second split we plan is between the core framework capabilities and the syntactic features that make it easy to access those features. A key example of this is the fluent interface introduced in NUnit 2.4 â€“ the â€œAssert.Thatâ€ syntax. One thing we learned through that experiment is that the same syntactic â€œsugarâ€ does not work well for different language environments. Many of the 2.4/2.5 constructs are unusable or very difficult to use in other languages â€“ C++ for example. By a combination of separate namespaces and separate assemblies, we will allow users to select the appropriate syntax for the work they are doing. Other people will be able to build on the syntax we provide or create entirely new syntactic overlays for their own purposes. Through use of plugins in the Test Engine layer, NUnit will be able to recognize, load and run tests written using other frameworks. Our focus will be on facilitating the creation of plugins in support of external frameworks by the projects that produce those frameworks or by interested users. For frameworks where that sort of support is not possible â€“ commercial frameworks, for example â€“ we have the option of creating the plugins ourselves. In some cases, individuals with an idea for a new framework may be able to create them more simply by writing an adapter on top of the NUnit framework itself. We will encourage and support this by giving priority to framework modifications that provide the necessary infrastructure for such projects. NUnit will also provide or re-package some framework extensions for specific types of applications, including Windows Forms development, WPF development, web page access, XML testing, performance measurement and load testing. At this point, it is not yet possible to state which of these will involve existing third-party packages and which will be developed from scratch, because discussions are ongoing. The NUnitLite framework will be supported running on devices and reporting results back to the Test Engine through a communications channel. Various popular mock frameworks will be supported. One framework will be selected for use by NUnitâ€™s own self-tests and will be packaged with NUnit. Further Details More detailed specifications are being developed for each of the layers. Consult the Specifications index for their current status."
  },
  "articles/nunit/technical-notes/nunit-internals/NUnit-Agent.html": {
    "href": "articles/nunit/technical-notes/nunit-internals/NUnit-Agent.html",
    "title": "NUnit Agent | NUnit Docs",
    "keywords": "NUnit Agent The nunit-agent.exe program is used by other runners when the tests are being run in a separate process. It is not intended for direct execution by users. NUnit runs tests in a separate process by default. When running under the Gui, NUnit will continue to use the same process to reload tests so that it is not normally necessary to re-attach to a new process. However, if the settings are changed in a way that requires a different process - for example, by changing the version of the runtime that is being used - the old process will be terminated and a new one created. In that case, it's necessary to re-attach to the new process. Debugging When debugging tests that are run in a separate process, it is not possible to do so by simply running the console or gui runner under the debugger. Rather, it is necessary to attach the debugger to the nunit-agent process after the tests have been loaded."
  },
  "articles/nunit/technical-notes/nunit-internals/NUnit-APIs.html": {
    "href": "articles/nunit/technical-notes/nunit-internals/NUnit-APIs.html",
    "title": "NUnit APIs | NUnit Docs",
    "keywords": "NUnit APIs NUnit provides three levels of public APIs for discovering and running tests. From highest to lowest level they are: Test Engine API - for general use by any program that needs to discover and execute tests. Engine Driver API - implemented by framework drivers to allow the engine to communicate with a particular framework. Framework API - used by the NUnit 3 framework driver to communicate with the framework. Test Engine API The NUnit TestEngine is a separate component, introduced in NUnit 3.0, which knows how to discover and execute tests. It provides an API for both simple batch execution and more complex interaction as needed by Gui test runners. It also provides additional Engine services beyond what the framework provides. This is what we recommend for use by anyone needing to run NUnit tests programmatically. See Test Engine API for more info. Engine Driver API The NUnit TestEngine uses drivers to communicate with test frameworks. It is possible to create a driver for running any sort of test framework, supporting any language at all. The driver API is what makes this possible. The TestEngine has support for the NUnit 3 framework built in. An extension driver for running NUnit 2 tests is also available. The driver API is only intended to be implemented by drivers and is only used by the NUnit engine. See Engine Driver API for more info. NUnit Framework API This is a primitive API implemented by the NUnit 3 Framework. The NUnitFrameworkDriver in the engine uses this API. The API is a bit complicated to use. Since it needs to support multiple versions of the framework, it uses well-known framework class names, which are constructed via reflection. All results are returned as raw XML. This API is not intended for any use except by NUnit itself. See Framework API for more info."
  },
  "articles/nunit/technical-notes/nunit-internals/NUnit-Internals.html": {
    "href": "articles/nunit/technical-notes/nunit-internals/NUnit-Internals.html",
    "title": "NUnit Internals | NUnit Docs",
    "keywords": "NUnit Internals Architectural Overview NUnit APIs Test Engine API Engine Driver API Framework API Framework Design Active Attributes NUnit Agent Attribute Hierarchy Test Discovery And Execution Engine Extensibility"
  },
  "articles/nunit/technical-notes/nunit-internals/specs/Dynamic-Test-Cases-Spec.html": {
    "href": "articles/nunit/technical-notes/nunit-internals/specs/Dynamic-Test-Cases-Spec.html",
    "title": "Dynamic Test Cases Spec | NUnit Docs",
    "keywords": "Dynamic Test Cases Spec Warning This is a draft. The contents may be out of date. This specification describes changes in how test cases will be generated in NUNit 3.0 Rationale NUnit currently supports parameterized tests using the TestCase, TestCaseSource, Values, ValueSource, Random and Range attributes. All these data sources provide data that is used to generate test cases as the tests are loaded. We refer to these as \"pre-generated\" test cases. There is also a need for what we are calling \"dynamically generated\" test cases, which are not created until the test is about to run and which may be re-created each time the test is run. For example, it may be desirable to perform some initialization of the data in a OneTimeFixtureSetUp method. This is not possible using the pre-generated model, because the tests are generated before any execution. As another example, the data may consist of the names of files in a certain directory. If the directory content is changing dynamically, we may want our tests to reflect those changes, which is only possible using the dynamic model. For all these reasons - and because users have requested it - we are introducing the notion of \"dynamically generated\" test cases in NUnit 3.0. Some existing attributes will be re-purposed and new attributes created to support it. Note Dynamic test case generation is also required for the proper implementation of Theories , which will be described in a separate specification. Design Key Tradeoffs The two types of test cases have important differences in how they may be used by NUnit and each has certain advantages and limitations as well. Pre-Generated Dynamically Generated Data must be known at the time of loading in order to construct the test. Data is not needed until the point of running the test. Data may not change between test runs unless the tests are reloaded. Data may change between test runs. Test cases are available to show in the Gui as soon as the test is loaded. Test cases can only be displayed after the test has been run. Certain types of errors may be displayed as soon as the test is loaded. Errors can only be displayed after the test has been run. Data may not be initialized in OneTimeSetUp because the individual test cases have already been created by that time. Data may be initialized in OneTimeSetUp if desired. External changes to a data source have no effect on subsequent test runs. Each test run reflects the current state of the data. Static methods, properties and fields must be used to hold test data for two forms of the TestCaseSource attribute. Instance methods, properties and fields may be used in all cases. Test runs are automatically repeatable within a session at least until the test is reloaded. Repeatability within a session will require special support within NUnit. Data-generating code is only executed once - as the test is loaded. Data-generating code is executed for each run. General Approach Introduce dynamic test case generation, as described above. For ease of use, each data attribute should use either the pre-generated or dynamically generated model exclusively. Parameterized test methods may mix both types of attribute, allowing both pre-generated and dynamically generated test cases. Provided that external data sources such as files and databases are not changed, we will support repeatable test runs across different program sessions and within the same session. The Gui will display new test cases as they are generated and will provide a visual cue to distinguish the two types of test cases. Syntax As in NUnit 2.5, Attributes applied to test methods will provide or point to the data to be used as test arguments. Except as noted below, attributes will not change syntactically and will continue to operate as before even though many of them will now generate test cases dynamically. The following paragraphs describe the impact of the change on each attribute. TestCaseAttribute will continue to work as it now does, producing pre-generated test cases. TestCaseSourceAttribute and ValueSourceAttribute will continue to create pre-generated test cases, but will be more limited in their usage than before. The following data sources will be supported: Static fields, properties or methods of the test fixture. Static or instance fields properties or methods of an external or nested class. It's likely that there will be ways to 'trick' NUnit into accepting an instance member for one of these attributes, leading to instantiation of the test class at load time. If that occurs, the results are undefined. Obviously, such trickery is not recommended and we'll try hard to detect and reject such attempts. A new DynamicDataSourceAttribute (the name is a placeholder) will supplant both TestCaseSourceAttribute and ValueSourceAttribute for dynamic generation of test cases and parameter values respectively. Suggestions are welcome for the final name of this attribute. ValuesAttribute , RangeAttribute , RandomAttribute , CombinatorialAttribute , PairwiseAttribute and SequentialAttribute (that is, all other data attributes) will be used to produce test cases dynamically. DatapointAttribute and DatapointsAttribute are only used for Theories, but for the sake of completeness it may be noted that they will also operate dynamically. Where necessary, additional properties may be added to some attributes in order to provide for repeatability of tests. At the moment, the only known requirement is for specification of a random seed for RandomAttribute but others may arise in implementation. Gui Design Notes Since we don't have an NUnit 3.0 Gui yet, these notes are for the future... When tests are run in batch mode using the console runner, the distinction between fixed and dynamic data is moot. In that environment, tests are loaded and executed in rapid sequence, after which the process is terminated. But when using the Gui, the affect of using dynamic data is quite visible. Dynamic tests are initially loaded without showing any subordinate test cases. After each run, test cases are repopulated and may even be different. This has several important consequences for the Gui... It must be able to deal with test cases added during test execution. It must be able to trigger regeneration of test cases for a rerun. It must also provide some way to re-run the same tests in a repeatable fashion. It must give the user control over whether to run the tests repeatably or not. Implementation Notes Interface changes will be required to identify the presence of either pre-generated or dynamic data for a method. NUnitTestCaseBuilder will accept a test method with arguments so long as either type is present but will only create pre-generated test cases. Dynamic test case generation will take place in the Run method of ParameterizedMethodSuite class using registered extensions that support dynamic data. The result will be a new addition to the standard sequence of test execution, as follows: Create test fixture instance Run TestFixtureSetUp Generate dynamic test cases For each test case Run SetUp method Run Test method Run TearDown method Run TestFixtureTearDown Dispose and destroy the test fixture instance Unresolved Issues None known, implementation issues aside."
  },
  "articles/nunit/technical-notes/nunit-internals/specs/Engine-Addins-Spec.html": {
    "href": "articles/nunit/technical-notes/nunit-internals/specs/Engine-Addins-Spec.html",
    "title": "Engine Addins Spec | NUnit Docs",
    "keywords": "Engine Addins Spec Note This page is a specification that was used as a starting point for creating the feature in NUnit. It needs to be reviewed and revised in order to accurately reflect what was actually built. If you take it with a grain of salt, it may still be helpful to you as documentation. This notice will be removed when the page is brought up to date. This spec covers a proposed new approach to Engine addins, replacing the use of Mono.Addins. Background We originally planned to use Mono.Addins for the engine and have done so in the first betas. However, Mono.Addins no longer supports .NET 2.0. We are using a modified version that we created and which we will have to maintain in the future. Mono.Addins has many more features than we expect to use and has a rather large memory and disk footprint. In sum, Mono.Addins is not really carrying its weight for our usage. We will try to replace it with a simple plugin architecture of our own design, using some pieces of our old NUnit 2.x addin feature as well as other features inspired by Mono.Addins. At a minimum, we need to support existing addins that are supported by Mono.Addins. Once we have that support, we can replace Mono.Addins. Further features could be added later. Three addin types are currently supported: Project Loaders - used to load NUnit and VS projects Result Writers - used to write out results in NUnit 2 format Driver Factories - used to create the driver for running NUnit 2 tests under NUnit 3 Design Extension Points In both Mono and NUnit (2.x) addins, extensibility centers around ExtensionPoints . An ExtensionPoint is a place in the application where add-ins can register themselves in order to provide added functionality. extension nodes to provide extra functionality. NUnit 3.0 will continue to use this concept. In our initial implementation, all extension points must be known in advance and are contained in the engine. At a future point, we will probably want to add a way to dynamically create new extension points so that addins can themselves host extensions. ExtensionPoints in the engine will be identified by use of ExtensionPointAttribute at the assembly level. Each attribute identifies one extension point, specifying an identifying string (the Path) and the required Type of any extension objects to be registered with it. Example [assembly: ExtensionPoint(Path=\"/NUnit/Engine/DriverService\" Type=\"NUnit.Engine.Extensibility.IDriverFactory\")] In this example, the Path identifying the extension point is \"/NUnit/Engine/DriverService.\" Any type to be plugged into this extension point must implement IDriverFactory . Note that even though each extension point is typically implemented by some class in the system, the identity of that class is an implementation detail, which is not revealed in the ExtensionPoint . Extensions An Extension is a single object of the required type, which is registered with an ExtensionPoint . Extensions are identified by the ExtensionAttribute which is applied to the class. Extensions identified in this way must have a default constructor. See the Addins section below for dealing with more complex situations. Example [Extension(Path = \"/NUnit/Engine/DriverService\")] public class NUnit2DriverFactory : IDriverFactory { /* ... */ } The example above shows an extension Type being used with the ExtensionPoint defined in the previous example. An instance of NUnit2DriverFactory will be supplied to the DriverService when needed. The Path property must match the Path for the intended ExtensionPoint . The Path is actually optional so long as NUnit is able to deduce the correct ExtensionPoint based on the Type. In fact, that's the case in this example, which can be rewritten more simply as... [Extension] public class NUnit2DriverFactory : IDriverFactory { /* ... */ } The Path may be omitted provided that no other extension point is able to accept an object of the same class as the extension. Locating Addins Assemblies containing Addins and Extensions are stored in one or more locations indicated in files of type .addins . Each line of the file contains the path of an addin assembly or a directory containing assemblies. Wildcards may be used for assembly entries and relative paths are interpreted based on the location of the .addins file. The default nunit.engine.addins is located in the engine directory and lists addins we build with NUnit, which are contained in the addins directory. Any assemblies specified in a .addins file will be scanned fully, looking for addins and extensions. Any directories specified will be browsed, first looking for any .addins files. If one or more files are found, the content of the files will direct all further browsing. If no such file is found, then all .dll files in the directory will be scanned, just as if a .addins file contained \"*.dll.\" Assemblies are be examined using Cecil. Any assembly that cannot be opened is be ignored, with a log message generated. This be a normal occurrence in cases where the assembly targets a higher level runtime than that which is in use. Info is saved for actual instantiation of extensions on a just-in-time basis. We hope that the combination of specifically indicating which assemblies to scan and the use of Cecil to do the scanning will make this process quite efficient. If that turns out not to be the case, we can use an assembly-level attribute to identify assemblies containing extensions. Future Enhancements Addins An Addin is a Type that provides Extensions . As indicated in the previous section, simple extensions providing a single instance of the object through a default constructor do not require an Addin. For more complex situations, an Addin object could be allowed to create and register one or more extensions. This is the approach that we took in NUnit 2.x. Addins would be identified by the AddinAttribute and implement the IAddin interface. They actively participate in the installation of extensions and may be used to create objects that require parameters, to install multiple extensions or to select among different extensions. Example [Addin] public class MyAddin : IAddin { public bool Install(IExtensionHost host) { var ep = host.GetExtensionPoint(\"/NUnit/Engine/DriverFactory\"); ep.Install(new NUnit2DriverFactory()); } } public class NUnit2DriverFactory : IDriverFactory { /* ... */ } The above example does the same thing as the previous example in a more complicated way. Obviously, you would use this approach only in more complex situations. Note that the factory class does not have an ExtensionAttribute as this would lead to its being installed twice. Notes This design feature is not required initially and will be omitted from the implementation until we actually require it. The interfaces used in this section are notionally based on NUnit 2.6.4. Addins on Addins Initially, we only need one level of addins to allow for everything we now do. It may be convenient at some point to support addins on top of other addins. For example, a given framework driver might be enhanced with some special feature through an addin. An ExtensionPoint in an extension assembly could be identified in the same way as an engine extension point is known, using the ExtensionPointAttribute at assembly level. However, this is not a feature we need for the 3.0 release, only one to keep in mind for the future."
  },
  "articles/nunit/technical-notes/nunit-internals/specs/Extended-Constraint-Syntax-Spec.html": {
    "href": "articles/nunit/technical-notes/nunit-internals/specs/Extended-Constraint-Syntax-Spec.html",
    "title": "Extended Constraint Syntax Spec | NUnit Docs",
    "keywords": "Extended Constraint Syntax Spec Warning This is a draft. The contents may be out of date. This specification is about a new syntax for expressing NUnit assertions using the features of .NET framework 3.5 including language improvements. There are two key features this enables: Extension methods permit a modular, extensible fluent constraint syntax, and LINQ expression trees permit using plain C# (or VB) as a expression-based constraint language. User Stories Fluent Constraint Syntax A user expresses assertions in a fluent fashion A user extends NUnit's constraints without modifying NUnit An extension developer packages new constraints and their syntax in a single extension This improves NUnit by making extensibility easier. Expression-based Constraints A user expresses assertions in C# or VB without needing to learn NUnit-specific constraints Any boolean expression convertible to an expression tree can form a constraint Failed assertions include detailed error messages such as sub-expression values - i.e. unlike Debug.Assert. This improves NUnit by making it easier to learn and less necessary to extend. Existing Implementations There are already a couple of implementations implementing a fluent syntax or expression-based syntax or both: Extension Methods for NUnit: this is substantially an aliasing mechanism which, without touching the constraints themselves, provides a fluent way to express them SharpTestsEx : this is an improvement of NUnitEx and provides an extension-method based constraint syntax in addition to a starting point for an expression-based mechanism of assertions. ExpressionToCode : this is an expression-based assertion library. It is a reimplementation of Power Assert .NET , which is itself a port of Groovy's Power Assert . Extensible Fluent Constraint Proposal Ideally we would like to be able to use a constraint syntax similar to the current fluent syntax that is extensible. This requires using extension methods instead of static classes, as the following example demonstrates: Assert.That(1, Is.GreaterThan(0)) This example is not extensible since it uses the static ''Is'' class. If I wanted to write something like ''Is.MuchGreaterThan(int x)'' and thus a constraint ''MuchGreaterThan'' which NUnit doesn't provide, I would have to alter and recompile NUnit's code. Patching NUnit like this and maintaining such a patch is a high barrier to entry. The same assertion could be written as: Assert.That(1).Is.GreaterThan(0) This allows for extensions since any user can define a new extension method for the class of the ''Is'' property. Say ''Is'' were to return a value of type ''IIsConstraint'', then I could just write public static void MuchGreaterThan(this IIsConstraint iis) { /* ... */ } Taking syntax shown on the SharpTestsEx homepage as an example, some assertions with the new NUnit syntax could be written as following: SharpTestsEx NUnit 3.0 proposal true.Should().Be.True(); Assert.That(true).Is.True \"something\".Should().Contain(\"some\"); Assert.That(\"something\").Contains(\"some\") \"something\".Should().StartWith(\"so\").And.EndWith(\"ing\") Assert.That(\"something\").StartsWith(\"so\").And.EndsWith(\"ing\") new[] { 1, 2, 3 }.Should().Have.SameSequenceAs(new[] { 1, 2, 3 }); Assert.That(new[] { 1, 2, 3 }).Is.EquivalentTo(new[] { 1, 2, 3 }) %%ActionAssert.Throws<ArgumentException>(() => new SillyClass(null))%% %%Assert.That(() => new SillyClass(null)).Throws<ArgumentException>()%% Unresolved Issues How would the following actually work? Assert.That(â€œsomethingâ€).StartsWith(â€œsoâ€).Or.EndsWith(â€œingâ€); How would ''StartsWith'' know that it's not supposed to do anything if it fails, since there is a chance ''EndsWith'' might succeed? Remember, the above code is semantically identical to this: var temp = Assert.That(â€œsomethingâ€).StartsWith(â€œsoâ€); temp.Or.EndsWith(â€œingâ€); Extension methods can lead to namespace pollution; in particular if defined on ''object'' (which we therefore should try to avoid). Expression Based Constraint Proposal NUnit provides a wealth of constraints. This means that knowing how to expression non-trivial constraints isn't always easy (particularly for new or casual users). Finding the appropriate constraint (or combination of constraints) requires knowledge NUnit's many constraints, and the semantics of a particular constraint may not be clear without reading the documentation. For example, consider the assertion (valid for many uppercase strings, for most cultures): Assert.That(() => x == x.ToLower().ToUpper()); This expression can be expressed as a standard equality constraint, but doing so means not showing the intermediate steps in the computation. Using expression trees, a failure could be rendered as: Assert.That failed for: x == x.ToLower().ToUpper() | | | | | | | | | \"ABC I\" | | | \"abc i\" | | \"ABC Ä°\" | false \"ABC Ä°\" This variant requires very little knowledge of NUnit, yet is still usable even for complex constraints by leveraging a language the user already knows (namely VB or C#). Possible extensions to this concept could be \"Helpers\" that recognize specific patterns and improve readability. For instance, if an expression consists of a sequence of ''&&'' operators, a helper might suppress showing the details of non-failing clauses. Or, if an expression contains multiple DateTime, the helper could ensure the accuracy of the DateTime.ToString is high enough to represent any differences. If an ''=='' operator fails but ''.Equals'' would have succeeded, this could be mentioned."
  },
  "articles/nunit/technical-notes/nunit-internals/specs/Generation-of-Test-Names-Spec.html": {
    "href": "articles/nunit/technical-notes/nunit-internals/specs/Generation-of-Test-Names-Spec.html",
    "title": "Generation Of Test Names Spec | NUnit Docs",
    "keywords": "Generation Of Test Names Spec Test Names are generated in the framework and used in the other layers. There are four key issues around naming of tests. NUnit test names often \"look like\" method names but in principal they are arbitrary strings. Since we allow the user to change the name in many cases - using the TestCase attribute for example - they can be arbitrary in practice as well. This issue is essentially the underlying cause of the remaining three issues. Some clients display the names in a way that causes an error if they are too long. Such clients need a way to direct NUnit to restrict the length of names. NUnit does not require the names of tests to be unique. Some clients, however, make that assumption, which leads to errors. Such clients need a way to add a unique value to each test name. Test names may be used in the command line for the purpose of selecting tests. That means the user must be able to predict the name of the test. In NUnit 3.0, this problem is mitigated by the presence of command-line options that allow for selecting tests in other ways. Nevertheless, it is desirable that the user have some control over how names are generated. Note that the term \"tests\" in this section refers to test cases, test methods, test fixtures and other kinds of test suites. NUnit treats all of these as \"tests\" for most purposes. Name Formatting Strings TestName generation is driven driven by a name formatting string, which may be specified or modified by the user. The format string may contain any of the following format specifiers, for which NUnit will make the appropriate substitution: {n} The namespace of the test or empty if there is no namespace. If empty, any immediately following '.' is ignored. {c} The class name of the test or empty if there is no class. This name includes any type arguments, enclosed in angle braces and separated by commas. {C} The full name of the class. Equivalent to {n}.{c} {m} The method name of the test or empty if there is no method. The name includes any type arguments, enclosed in angle braces and separated by commas. {M} The full name of the method. Equivalent to {n}.{c}.{m} or {C}.{m} {a} The full argument representation, enclosed in parentheses and separated by commas. Each argument is represented by the standard NUnit format for certain types, otherwise by the result of ToString(). {0}, {1} ... {9}. An individual argument. This form is only useful when setting the name of an individual test case. If used in the default format string, any arguments not used will be ignored. {i} The test id, which is normally of the form mmm-nnn. Any text not included between curly braces is copied to the name as is. After the name is formatted, any leading or trailing '.' characters are removed. Otherwise, all non-format characters in the string are included as is. String arguments may be truncated to a maximum length. Either the {a} specifier or any of the individual argument specifiers may be followed by a colon and a length: {a:40} Truncate each string argument to 40 characters. All strings lest than 37 characters are truncated to the first 37 followed by \"...\" {0:20} Truncate argument 0 to 20 characters. Standard Name Formats Internally, NUnit uses certain standard formats unless overridden by the user. The standard format for generating a name from a test method and its arguments is {m}{a:40} // Name {M}{a:40} // FullName This leads to test names like Test1 Test2(5, 2) Test3(\"This is the argument\") Test4(\"This is quite long argument, so it is...\") Modifying the Name Format The SetName property of TestCaseData allow setting the format string for the individual test case. So long as no format specifiers are used in the name, there will be no change in how this works. Any format specifier will trigger regeneration of the test name according to what is provided. For example, if the user wishes to specify only the argument portion of the name of a test method, while retaining the method name, the name could be set to {m}(User argument) This would result in the display of the test name as SomeMethod(User Argument) Note that in this usage, it will generally only make sense to use {m} , {a} or {0} through {9} specifiers. However, NUnit will use whatever is provided."
  },
  "articles/nunit/technical-notes/nunit-internals/specs/Include and Exclude Attributes (Alternatives).html": {
    "href": "articles/nunit/technical-notes/nunit-internals/specs/Include and Exclude Attributes (Alternatives).html",
    "title": "Include And Exclude Attributes Alternatives | NUnit Docs",
    "keywords": "Include And Exclude Attributes Alternatives This spec describes proposed new attributes to replace and extend the existing CultureAttribute and PlatformAttribute. These attributes derive from the abstract IncludeExcludeAttribute, which provides Include and Exclude named properties. The following examples show how these attributes are currently used: [Culture(\"fr-FR\")] [Culture(Include=\"fr-FR\")] [Culture(Exclude=\"fr-FR\")] [Platform(\"Net-4.5\")] [Platform(Include=\"Net-4.5\")] [Platform(Exclude=\"Net-4.5\")] Alternative Approaches Note Three alternative approaches were identified in March, 2014. This is the final update of the document prior to choosing an alternative. Approach #3 seems to be the front-runner at this time. 1. Keep the current approach How it Works Exclude has priority. If any attribute excludes a test, it remains excluded, even if another attribute matches it for inclusion. The default constructor argument represents inclusion, so you should not use it along with the Include parameter. Comma-separated alternatives form a union, so that if any item is matched, the test is included (or excluded). Pros Having a separate attribute for each domain from which we are making a selection is easy for users to understand. With the new attribute-based framework extensibility model in NUnit 3.0, this is probably the easiest approach of all to extend. Cons The current Platform attribute actually works across three different domains: the OS, the runtime and the bit-ness of the process. It's very difficult to define criteria like Windows 7 or 8 running .NET 4.5 using a single attribute. [Platform(\"Windows7,Windows8,Net-4.5)] will include Win 7 or 8 with any runtime and .NET 4.5 with any OS. The best we can do is [Platform(\"Windows7,Windows8\",Exclude=\"Net-2.0,Net-3.0,Net-3.5\")] . Boolean expressions involving the accepted values would permit the above more cleanly. For example, we might write Platform(\"(Windows7 | Windows8) & !Net-4.5)\") . Such logic would have to be implemented for each attribute, most likely in the base class. However, any such logic would only apply within the single attribute: it would not be possible to include both OS and Culture (for example) in the same expression. Extensibility Create a new attribute that inherits from IncludeExcludeAttribute and implement the necessary selection logic to decide whether a given string tag is supported. 2. Keep Current Approach, but Split PlatformAttribute How It Would Work As mentioned above, PlatformAttribute actually tests over three different domains. We would create a separate attribute for each domain, for example: PlatformAttribute, RuntimeAttribute and ProcessAttribute. Pros All the same as for approach #1, plus... The first 'con' in approach #1 would be eliminated. The example given would work as [Platform(\"Windows7,Windows8\"), Runtime(\"Net-4.5\")] . Having separate attributes might make it easier to understand for some users. (see cons) Cons Boolean expressions would become even more limited, as compared to #1 Having separate attributes might make it harder to understand for some users. (see pros) We would be proliferating attributes, although that may not be a serious issue. Extensibility Create a new attribute that inherits from IncludeExcludeAttribute and implement the necessary selection logic to decide whether a given string tag is supported. 3. Create Replacement Attributes How It Would Work Invert the implied hierarchy by providing an IncludeAttribute and an ExcludeAttribute, which specify what is to be tested in one of several ways. For example: [Include(Culture=\"fr-FR\")] [Exclude(\"Runtime:Net-4.5\")] Note that the above example includes two mutually exclusive ways of implementing the syntax. See below. Pros This seems to be at least as easy to understand as the current approach. In some cases it may be better, since use of Include as the attribute name makes it quite clear what is happening, whereas Culture may be misunderstood as changing the culture. May be extended by the user, depending on which syntactic sub-option we select below. Cons Allows future development of an expression syntax that would combine all selection elements, but again, depending on the syntax option chosen. Some of the syntactic sub-options are not so easy to extend. See below. Syntax Options For this alternative we will want to use a separate namespace for each domain. There would be one set of unique names for the Operating System, one for Runtimes, one for Culture, etc. There are two options we might use to implement this, which are designated as alternatives 3A and 3B. 3A. Create Replacement Attributes Using Named Properties Map each domain to a separate named property. For example: [Include(Culture=\"fr-FR\")] [Exclude(Runtime=\"Net-2.0\")] Pros Easiest to implement Familiar syntax for users Cons Need to decide how to combine tests across multiple domains. Does [Include(Culture=\"fr-FR\", Runtime=\"Net-2.0\")] mean both or either? Not possible to have logical expressions that combine domains (but maybe they are not needed). Extensibility We would need to provide a registration mechanism, whereby a program provided the name of the domain, the value and a function for evaluating whether the feature is supported or not. It would not be possible to add new domains. 3B. Create Replacement Attributes Using Prefixes Prefix each value with the domain name, thereby creating a unified namespace. [Include(\"Culture:fr-FR\")] [Exclude(\"Runtime:Net-2.0\")] Pros Similar to syntax used by VS for selecting tests We could create an expression syntax for combining tags. Could support other relations than simple equality, e.g.: [\"Runtime>=4.0\"]. Cons Slightly more work initially. Lots more work if we implement expressions. New syntax for many users Extensibility We would need to provide a registration mechanism, whereby a program provided the name of the domain, the value and a function for evaluating whether the feature is supported or not. New domains could be added in addition to new values. Next Steps We need to pick the general approach and then work can begin on the feature."
  },
  "articles/nunit/technical-notes/nunit-internals/specs/Include-and-Exclude-Attributes-Spec.html": {
    "href": "articles/nunit/technical-notes/nunit-internals/specs/Include-and-Exclude-Attributes-Spec.html",
    "title": "Include And Exclude Attributes Spec | NUnit Docs",
    "keywords": "Include And Exclude Attributes Spec Warning This is a draft. The contents may be out of date. This spec describes proposed new attributes to replace and extend the existing CultureAttribute and PlatformAttribute. We considered several alternative approaches to doing this and selected the approach described here. See Include and Exclude Attributes (Alternatives) for the original discussion of choices. Attributes We would define two new attributes, IncludeAttribute and ExcludeAttribute : [Include(Culture=\"fr-FR\")] [Include(Platform=\"Win7,Win8\")] [Exclude(\"Runtime:Net-4.5\")] [Exclude(\"Linux\")] [Include(\"Runtime >= 4.0 and Platform == \"Linux\"\")] Syntax Options There are a number of possible alternatives for specifying when a test is to be included or excluded. Each of them is illustrated in the examples above, from which we need to select a subset. 1. Named Properties As illustrated in the first two examples, this approach allows us to clearly separate the namespaces for each selection domain. Comma-separated values are intended to be alternatives, so the second example would include the test under either Win7 or Win8. Separate properties (domains) would be \"and-ed\" together. 2. Prefixes By prefixing each value with the domain name, we can create a unified namespace. The third example above uses this approach, making it clear that Net-4.5 represents a runtime and nothing else. As in #1, comma-separated values are alternatives. There is no other way to create logical combinations. 3. Implied Domain To the extent that the accepted values are exclusive, it's possible to deduce the domain from the value. The fourth example above takes advantage of this. Note that this approach can be combined with #2 as a kind of shorthand. 4. Logical Expression We can define a DSL that allows us to specify arbitrary expressions for including or excluding tests. The last example above does this. If the expression language included not , then we could do away with the ExcludeAttribute. Comparison of Options Note The following are Charlie's ratings. Feel free to disagree! Ease of implementation (easy to hard) 1 > 2 > 3 > 4 Expressiveness (least to greatest) 3 > 2 > 1 > 4 Learning Curve (shallow to steep) 1 > 3 > 2 > 4 Extensibility to new domains (easy to hard) 1 > (2, 3, 4) Extensibility with new values (easy to hard) 3 > (2, 4) > 1"
  },
  "articles/nunit/technical-notes/nunit-internals/specs/Internal-Trace-Spec.html": {
    "href": "articles/nunit/technical-notes/nunit-internals/specs/Internal-Trace-Spec.html",
    "title": "Internal Trace Spec | NUnit Docs",
    "keywords": "Internal Trace Spec Warning This is a draft. The contents may be out of date. NUnit traps text output directed to the Console, Trace or a logging subsystem. This makes it difficult to use text output when debugging the framework itself, particularly when working on the classes that redirect output. For that reason, NUnit incorporates a simple internal tracing mechanism for use by developers and for debugging problems in the field. User Stories An NUnit User enables NUnit's internal trace in order to collect information about an apparent bug or unexplained error. An NUnit Developer makes use of the internal trace as a part of the development cycle. Design NUnit provides a simple internal trace facility using the InternalTrace class. The following public methods are provided for creating output: public static void Error(string message, params object[] args) public static void Warning(string message, params object[] args) public static void Info(string message, params object[] args) public static void Debug(string message, params object[] args) By default, all output through InternalTrace is sent to the console, which means it is mixed with other console output. Note that the trace mechanism bypasses NUnit's redirection of output and displays on the actual Console. Of course, if NUnit is being run without a console - from the Gui, for example - the output will be lost. Redirecting Output The InternalTrace.Open() method allows the programmer to specify a file to which the output will be written. Any absolute or relative path may be used as an argument. Relative paths are interpreted as relative to the location of the assembly being tested. A programmer working on NUnit may call this method at any point in the code. InternalTrace.Close() is also provided. Note Since the path is saved as a static property, it must be specified separately within each AppDomain. Writing to the same file from two different AppDomains is not supported. Specifying Verbosity Verbosity is specified using the nested enum InternalTrace.TraceLevel. Although the values currently match those of System.Diagnostics.TraceLevel, they have no actual relation to that class. Additional values may be added in the future. public class InternalTrace { public enum TraceLevel { Off, Error, Warning, Info, Debug } /* ... */ } A programmer working on NUnit may set the TraceLevel at any point in the code by setting the InternalTrace.Level property. Unresolved Issues How should the destination and verbosity level of internal trace be specified by a user?"
  },
  "articles/nunit/technical-notes/nunit-internals/specs/Parameterized-Test-Fixtures-Spec.html": {
    "href": "articles/nunit/technical-notes/nunit-internals/specs/Parameterized-Test-Fixtures-Spec.html",
    "title": "Parameterized Test Fixtures Spec | NUnit Docs",
    "keywords": "Parameterized Test Fixtures Spec Note This page is a specification that was used as a starting point for creating the feature in NUnit. It needs to be reviewed and revised in order to accurately reflect what was actually built. If you take it with a grain of salt, it may still be helpful to you as documentation. This notice will be removed when the page is brought up to date. NUnit 2.6.4 supports parameterized test fixtures using constructor arguments specified on the TestFixtureAttribute . This is similar to the way that TestCaseAttribute handles parameterized methods. However, methods in 2.6.4 benefit from a very rich set of attributes in addition, allowing the data to be kept separately from the test and permitting use of data types that cannot appear as arguments to an Attribute constructor in .NET. For NUnit 3.0, we would like to create a similarly rich set of attributes for specifying how TestFixture instances should be created. This spec will outline the features we plan to support. Type names are placeholders and may be changed as the work proceeds. TestFixtureSourceAttribute This will work similarly to TestCaseSourceAttribute and will supply the constructor arguments for the fixture. The two types will probably be unified under a common base. TestFixtureData This will work similarly to TestCaseData with the addition of a number of features that are needed for fixtures. In particular, the Type will need to support a TypeArgs property and possibly a separate set of arguments for use with the OneTimeSetUp method. ValuesAttribute ValueSourceAttribute RangeAttribute RandomAttribute These attributes may be used on a TestFixture constructor with arguments. Their effect will be similar to use on method arguments, causing the fixture to be constructed a number of times. CombinatorialAttribute PairwiseAttribute SequentialAttribute These attributes will need to be modified to work on test fixtures as well as methods. They specify how individual argument values are to be combined to for a set of arguments for constructing the fixture."
  },
  "articles/nunit/technical-notes/nunit-internals/specs/Specifications.html": {
    "href": "articles/nunit/technical-notes/nunit-internals/specs/Specifications.html",
    "title": "Specifications | NUnit Docs",
    "keywords": "Specifications Note Some of these items are actually implemented in the latest release. We are in the process of reviewing all the specs in this section to determine what needs to be converted into actual documentation pages. Specifications are descriptions of work we are doing or plan to do. They may vary in degree of specificity and the actual code may sometimes deviate from the spec as work progresses, without necessarily going back to change the spec. When the work is done, the spec is removed from the site or incorporated into a tech note as needed. Component Title Implemented? General Internal Trace Spec Partial? Framework Include and Exclude Attributes Spec No Extended Constraint Syntax Spec No Dynamic Test Cases Spec No Text Output from Tests Spec Yes Generation of Test Names Spec Yes Parameterized Test Fixtures Spec Partial Test Dependency Attribute Spec No Test Engine Engine Addins Spec Partial"
  },
  "articles/nunit/technical-notes/nunit-internals/specs/Test-Dependency-Attribute-Spec.html": {
    "href": "articles/nunit/technical-notes/nunit-internals/specs/Test-Dependency-Attribute-Spec.html",
    "title": "Test Dependency Attribute Spec | NUnit Docs",
    "keywords": "Test Dependency Attribute Spec Warning This is a draft. The contents may be out of date. This spec describes a proposed new attribute to be used to specify dependencies between tests within a test fixture, and between different test fixtures. Attribute We would define a new attributes, Dependencies: [Dependencies (<dependency-specification> [, <dependency-specification> [, ...]])] where <dependency-specification> is: Before=\"TestA, TestB\" After=\"TestC, TestD\" AfterAnySuccess=\"TestE, TestF\" AfterAnyFailure=\"TestG, TestH\" AfterAllSuccess=\"TestE, TestF\" AfterAllFailure=\"TestG, TestH\" BeforeAll AfterAll AfterAllSuccess This attribute would apply to Test's within a single TestFixture, or to TextFixture's within a single test assembly. Each dependency-specification is described in more detail below (in all cases, <test-list> should be replaced with a <testfixture-list> if the attribute is being applied to a TestFixture): <test-list> is a string containing a comma separated list of Test's to include in the dependency. <testfixture-list> is a string containing a comma separated list of TestFixture's to include in the dependency. Before=<test-list> The designated Test or TestFixture will be run to completion (successfully or not) before any of the tests specified in the list are run. After=<test-list> The designated Test or TestFixture will be run after the completion (successfully or not) of all of the tests specified in the list. AfterAllSuccess=<test-list> The Test or TestFixture will be run after the successful completion of all of the tests specified in the list. If any of the tests specified in the list fail, the designated Test or TestFixture will not be run. AfterAllFailure=<test-list> The Test or TestFixture will be run after the failure of all of the tests specified in the list. If any of the tests specified in the list succeed, the designated Test or TestFixture will not be run. AfterAnySuccess=<test-list> The Test or TestFixture will be run after the successful completion of any of the tests specified in the list. If all of the tests specified in the list fail, the designated Test or TestFixture will not be run. AfterAnyFailure=<test-list> The Test or TestFixture will be run after the failure of any of the tests specified in the list. If all of the tests specified in the list succeed, the designated Test or TestFixture will not be run. BeforeAll The Test or TestFixture will be run before all other tests or test fixtures are run. This dependency can be overridden by a specific Before dependency referencing this Test or TestFixture. AfterAll The Test or TestFixture will be run after all other tests or test fixtures have been run (whether they have completed successfully or not). This dependency can be overridden by a specific Afterxxx dependency referencing this Test or TestFixture. AfterAllSuccess The Test or TestFixture will be run after all other tests or test fixtures have been run and completed successfully. If any Test or TestFixture fails, this Test or TestFixture will not be run. This dependency can be overridden by a specific Afterxxx dependency referencing this Test or TestFixture. Note that a single Test or TestFixture may have multiple <dependency-specification> elements as long as they do not conflict with each other. Any loops or contradictory references in the dependencies will be discovered, and will result in the specified dependencies being ignored, and a warning being given. For example, if TestA has Before=\"TestB\" and TestB has Before=\"TestA\", both will be ignored, and a warning given. (An alternative would be to use whichever was specified first or last). If multiple tests or test fixtures are in the same relative position in the dependency tree, the order in which they will be run will be the default order. For example, if multiple tests have a BeforeAll dependency, they will run in the default order, but before all other tests not having that dependency specified. Items to consider: Is the name in a <test-list> the name in the code, or the generated name for the test? I would prefer to use the static name that is in the code, but there may be a case for using the generated name. Should there be a simple dependency language to be used to specify the dependency rather then the static properties? e.g. before(\"TestA\") && afterFails (\"TestB\") || afterSuccess (\"TestC\")"
  },
  "articles/nunit/technical-notes/nunit-internals/specs/Text-Output-from-Tests-Spec.html": {
    "href": "articles/nunit/technical-notes/nunit-internals/specs/Text-Output-from-Tests-Spec.html",
    "title": "Text Output From Tests Spec | NUnit Docs",
    "keywords": "Text Output From Tests Spec Note This page is a specification that was used as a starting point for creating the feature in NUnit. It needs to be reviewed and revised in order to accurately reflect what was actually built. If you take it with a grain of salt, it may still be helpful to you as documentation. This notice will be removed when the page is brought up to date. Background In the past, NUnit was able to capture text output (Console, Trace and Log) and associate it with the correct test. This was possible because only one test could run at a time, therefore any output received between the start and end of a particular test could be identified with that test. In an environment where multiple tests may be running at the same time, this is no longer possible. Let's say that NUnit has received the following messages, in order: Start Test A Start Test B Some text output End Test A End Test B In this situation, the text output might be from Test A or from Test B. NUnit cannot associate the output with a particular test, although it is possible that the user might be able to interpret the result based on the actual content of the text output. Approach Since it does run tests in parallel, NUnit 3.0 needs a new approach to handling text output: The TestResult class will have a new string property, Output , holding text output associated with the individual test. Console standard output will be captured and added to the test result. A separate facility will be added to the NUnit TestContext to allow tests to write directly to the test result. TestContext.Out gets a TextWriter that may be used to write output to the TestResult. TestContext.Write(...) is a static method that writes output to the TestResult. Multiple overloads will be provided. TestContext.WriteLine(...) is a static method that writes output to the TestResult. Multiple overloads will be provided. Trace and Log output will no longer be handled by NUnit at all. Console error output will not be captured, but will display directly to the Console when using any of the console runners. Impact of Changes Standard output sent to the console will not display until the test completes. It will be clearly associated with the test if test labels are in use. If error output is redirected to a file either through the operating system or by using a command-line option then it will be written to the file. When running in the Gui, it will be available for display when the test is selected. Error output sent to the console will display immediately, provided a console is available. When running under the Gui or in another environment without a console attached, it will simply not appear. If error output is redirected to a file either through the operating system or by using a command-line option then it will be written to the file. Trace output will be processed in the normal way by .NET, depending on the configuration. NUnit will handle this output in any way or even be aware of it. This is how Trace is normally intended to work with a program. All log output will be processed by log4net (or any other logging facility) based on the configuration. NUnit will not handle it at all. NUnit-Console will display this output as each test completes. Since the completion of a test is a single event, all output will be associated with the correct test. However, since the output is not available until the test completes, it will not be useful for indicating progress of long-running tests."
  },
  "articles/nunit/technical-notes/nunit-internals/Test-Discovery-And-Execution.html": {
    "href": "articles/nunit/technical-notes/nunit-internals/Test-Discovery-And-Execution.html",
    "title": "Test Discovery And Execution | NUnit Docs",
    "keywords": "Test Discovery And Execution Warning This is a draft. The contents may be out of date. This spec summarizes the three levels of APIs provided by NUnit for discovering and running tests. Note that only one of them - the highest level - is supported for general usage. The others have very specific purposes and should only be used for those purposes. The three APIs, from highest to lowest level, are: Test Engine API - for use by any program that needs to discover and execute tests. Engine Driver API - for use by framework drivers, intended to be loaded by the engine to enable communication with a particular framework. Framework API - only used by NUnit's own framework driver to communicate with the framework. Test Engine API The NUnit TestEngine is a separate component, new to NUnit 3.0, which knows how to discover and execute tests. It provides an API for both simple batch execution and more complex interaction as needed by typical Gui test runners. It also provides additional Engine services beyond what the framework provides. This API is currently under development. See Test Engine API for more info. Engine Driver API The NUnit TestEngine uses drivers to communicate with test frameworks. Initially, the engine will come with a driver for NUnit 3.0, followed by an NUnit 2.x driver. It is possible to create a driver for running any sort of test framework, supporting any language at all. The driver API is what makes this possible. The driver API is only intended to be implemented by drivers and is only used by the NUnit engine. This API is currently under development. See Engine Driver API for more info. NUnit Framework API This is a primitive API implemented by the nunit.framework and NUnitLite assemblies. The NUnitFrameworkDriver in the engine uses this API. The API is a bit complicated to use. Since it needs to support multiple versions of the framework, it uses well-known framework class names, which are constructed via reflection. All results are returned as raw XML. This API is not intended for any use except by NUnit itself. See Framework API for more info."
  },
  "articles/nunit/technical-notes/nunit-internals/Test-Engine-API.html": {
    "href": "articles/nunit/technical-notes/nunit-internals/Test-Engine-API.html",
    "title": "Test Engine API | NUnit Docs",
    "keywords": "Test Engine API The NUnit Test Engine API is our published API for discovering, exploring and executing tests programmatically. Third-party test runners should use the Engine API as the supported method to execute NUnit tests. Overview The Engine API is included in the nunit.engine.api assembly, which must be referenced by any runners wanting to use it. This assembly is being released as version 3.0, to coincide with the versioning of other NUnit components. The actual engine is contained in the nunit.engine assembly. This assembly is not referenced by the runners. Instead, the API is used to locate and load an appropriate version of the engine, returning an instance of the ITestEngine interface to the runner. Getting an Instance of the Engine The static class TestEngineActivator is used to get an interface to the engine. Its CreateInstance member has two overloads, depending on whether a particular minimum version of the engine is required. public static ITestEngine CreateInstance(bool unused = false); public static ITestEngine CreateInstance(Version minVersion, bool unused = false); (The unused bool parameter previously allowed users to indicate if wished to restrict usage of global NUnit Engine installations. The latter functionality is no longer available.) We search for the engine in a standard set of locations, starting with the current ApplicationBase. The Application base and probing privatepath . A copy installed as a NuGet package - intended for use only when developing runners that make use of the engine. Key Interfaces The runner deals with the engine through a set of interfaces. These are quite general because we hope to avoid many changes to this API. ITestEngine This is the primary interface to the engine. namespace NUnit.Engine { /// <summary> /// ITestEngine represents an instance of the test engine. /// Clients wanting to discover, explore or run tests start /// require an instance of the engine, which is generally /// acquired from the TestEngineActivator class. /// </summary> public interface ITestEngine : IDisposable { /// <summary> /// Gets the IServiceLocator interface, which gives access to /// certain services provided by the engine. /// </summary> IServiceLocator Services { get; } /// <summary> /// Gets and sets the directory path used by the engine for saving files. /// Some services may ignore changes to this path made after initialization. /// The default value is the current directory. /// </summary> string WorkDirectory { get; set; } /// <summary> /// Gets and sets the InternalTraceLevel used by the engine. Changing this /// setting after initialization will have no effect. The default value /// is the value saved in the NUnit settings. /// </summary> InternalTraceLevel InternalTraceLevel { get; set; } /// <summary> /// Initialize the engine. This includes initializing mono addins, /// setting the trace level and creating the standard set of services /// used in the Engine. /// /// This interface is not normally called by user code. Programs linking /// only to the nunit.engine.api assembly are given a /// pre-initialized instance of TestEngine. Programs /// that link directly to nunit.engine usually do so /// in order to perform custom initialization. /// </summary> void Initialize(); /// <summary> /// Returns a test runner instance for use by clients in discovering, /// exploring and executing tests. /// </summary> /// <param name=\"package\">The TestPackage for which the runner is intended.</param> /// <returns>An ITestRunner.</returns> ITestRunner GetRunner(TestPackage package); } } The normal sequence of calls for initially acquiring this interface is: ITestEngine engine = TestEngineActivator.CreateInstance(...); engine.WorkDirectory = ...; // Defaults to the current directory engine.InternalTraceLevel = ...; // Defaults to Off The engine provides a number of services, some internal and some public. Public services are those for which the interface is publicly defined in the nunit.engine.api assembly. Internal services are... well, internal to the engine. See below for a list of public services available to runners. The final and probably most frequently used method on the interface is GetRunner . It takes a TestPackage and returns an ITestRunner that is appropriate for the options specified. ITestRunner This interface allows loading test assemblies, exploring the tests contained in them and running the tests. namespace NUnit.Engine { /// <summary> /// Interface implemented by all test runners. /// </summary> public interface ITestRunner : IDisposable { /// <summary> /// Get a flag indicating whether a test is running /// </summary> bool IsTestRunning { get; } /// <summary> /// Load a TestPackage for possible execution /// </summary> /// <returns>An XmlNode representing the loaded package.</returns> /// <remarks> /// This method is normally optional, since Explore and Run call /// it automatically when necessary. The method is kept in order /// to make it easier to convert older programs that use it. /// </remarks> XmlNode Load(); /// <summary> /// Unload any loaded TestPackage. If none is loaded, /// the call is ignored. /// </summary> void Unload(); /// <summary> /// Reload the current TestPackage /// </summary> /// <returns>An XmlNode representing the loaded package.</returns> XmlNode Reload(); /// <summary> /// Count the test cases that would be run under /// the specified filter. /// </summary> /// <param name=\"filter\">A TestFilter</param> /// <returns>The count of test cases</returns> int CountTestCases(TestFilter filter); /// <summary> /// Run the tests in the loaded TestPackage and return a test result. The tests /// are run synchronously and the listener interface is notified as it progresses. /// </summary> /// <param name=\"listener\">The listener that is notified as the run progresses</param> /// <param name=\"filter\">A TestFilter used to select tests</param> /// <returns>An XmlNode giving the result of the test execution</returns> XmlNode Run(ITestEventListener listener, TestFilter filter); /// <summary> /// Start a run of the tests in the loaded TestPackage. The tests are run /// asynchronously and the listener interface is notified as it progresses. /// </summary> /// <param name=\"listener\">The listener that is notified as the run progresses</param> /// <param name=\"filter\">A TestFilter used to select tests</param> /// <returns></returns> ITestRun RunAsync(ITestEventListener listener, TestFilter filter); /// <summary> /// Cancel the ongoing test run. If no test is running, the call is ignored. /// </summary> /// <param name=\"force\">If true, cancel any ongoing test threads, otherwise wait for them to complete.</param> void StopRun(bool force); /// <summary> /// Explore a loaded TestPackage and return information about the tests found. /// </summary> /// <param name=\"filter\">The TestFilter to be used in selecting tests to explore.</param> /// <returns>An XmlNode representing the tests found.</returns> XmlNode Explore(TestFilter filter); } } For the most common use cases, it isn't necessary to call Load , Unload or Reload . Calling either Explore , Run or RunAsync will cause the tests to be loaded automatically. The Explore methods returns an XmlNode containing the description of all tests found. The Run method returns an XmlNode containing the results of every test. The XML format for results is the same as that for the exploration of tests, with additional nodes added to indicate the outcome of the test. RunAsync returns an ITestRun interface, which allows retrieving the XML result when it is complete. The progress of a run is reported to the ITestEventListener passed to one of the run methods. Notifications received on this interface are strings in XML format, rather than XmlNodes, so that they may be passed directly across a Remoting interface. The following example shows how to get a copy of the engine, create a runner and run tests using the interfaces. // Get an interface to the engine ITestEngine engine = TestEngineActivator.CreateInstance(); // Create a simple test package - one assembly, no special settings TestPackage package = new TestPackage(\"my.test.assembly.dll\"); // Get a runner for the test package ITestRunner runner = engine.GetRunner(package); // Run all the tests in the assembly XmlNode testResult = runner.Run(this, TestFilter.Empty); The call to Run assumes that the calling class implements ITestEventListener. The returned result is an XmlNode representing the result of the test run. Engine Services The engine Services property exposes the IServiceLocator interface, which allows the runner to use public services of the engine. namespace NUnit.Engine { /// <summary> /// IServiceLocator allows clients to locate any NUnit services /// for which the interface is referenced. In normal use, this /// limits it to those services using interfaces defined in the /// nunit.engine.api assembly. /// </summary> public interface IServiceLocator { /// <summary> /// Return a specified type of service /// </summary> T GetService<T>() where T : class; /// <summary> /// Return a specified type of service /// </summary> object GetService(Type serviceType); } } The following services are available publicly. Service Interface Function ExtensionService IExtensionService Manages engine extensions RecentFilesService IRecentFiles Provides information about recently opened files ResultService IResultService Produces test result output in various formats SettingsService ISettings Provides access to user settings TestFilterService ITestFilterService Creates properly formed test filters for use by runners LoggingService ILogging Provides centralized internal trace logging for both the engine and runners (Not Yet Implemented) The following services are used internally by the engine but are not currently exposed publicly. They potentially could be in the future: Service Function TestRunnerFactory Creates test runners based on the TestPackage content DomainManager Creates and manages AppDomains used to run tests DriverService Provides the runner with a framework driver suitable for a given assembly ProjectService Is able to load assemblies referenced in various project formats RuntimeFrameworkSelector Determines the runtime framework to be used in running a test TestAgency Creates and manages Processes used to run tests Extensibility Interfaces The following interfaces are used by engine extensions: Interface Extension Function IProjectLoader Load projects in a particular format IProject Project returned by IProjectLoader IDriverFactory Provide a driver to interface with a test framework IFrameworkDriver Driver returned by IDriverFactory IResultWriter Result writer returned by IResultWriterFactory Objectives of the API The API was developed with a number of objectives in mind: To provide a public, published API for discovering and executing NUnit tests, suitable for use by the NUnit console and Gui runners as well as by third parties. To allow discovery and execution of NUnit tests independent of the particular build or version of the framework used and without the need to reference the framework itself. To allow future development of drivers for other frameworks and for those tests to be discovered and executed in the same way as NUnit tests. To provide specific features beyond the frameworks, including: Determining how and where each test assembly is loaded and executed. Parsing project files of various types and using them to determine the location of test assemblies and the options to be used in executing them. Providing access to NUnit settings for a machine."
  },
  "articles/nunit/technical-notes/usage/Addin-Replacement-in-the-Framework.html": {
    "href": "articles/nunit/technical-notes/usage/Addin-Replacement-in-the-Framework.html",
    "title": "Addin Replacement In The Framework | NUnit Docs",
    "keywords": "Addin Replacement In The Framework NUnit 2.6 supports six types of addins, all of which are being removed from NUnit 3.0: SuiteBuilders TestCaseBuilders TestDecorators TestCaseProviders DataPointProviders EventListeners General Approach The addin design for NUnit 2.6 was intended to extend to the console and gui runners in addition to the framework. However, this was never implemented and all six of the existing addin types apply to the framework only. In NUnit 3.0, the functions provided by these addins are being taken over by the use of custom attributes. NUnit 3.0 attributes are generally active. That is, they contain code to perform the function they call for rather than simply serving as markers to be interpreted by the runner. Advantages In general, all the same capabilities will be present in NUnit 3.0 and will be much more easily accessible to those who create extensions. Currently, creating an extension is complex and error prone. Use of active attributes generally involves one of two approaches: Derive the new attribute class from an existing NUnit base that provides the needed facilities. For example, a new data-providing attribute might derive from DataAttribute . Derive directly from NUnitAttribute , the base of the NUnit attribute hierarchy, and implement one or more interfaces that perform the desired function. Limitations All existing addins will need to be re-implemented as custom attributes. They will not work in NUnit 3.0. Addins not based on custom attributes are no longer possible. In NUnit 2.6, for example, it was possible to write an addin that defined tests based on the name of a method, e.g.: methods beginning with \"Test\". This sort of extension will no longer be possible in the NUnit 3.0 framework. However, this does not seem to be a big problem, since virtually all addins that we know about have been based on attributes. Implementation Because parts of NUnit are implemented as internal addins , it's not possible to simply remove all addin support at once. Many things would stop working if we did this. Therefore, we will refactor code for each of the internal types to conform to the new design, only removing the overall addin framework when this is complete. The remaining sections of this spec deal with how each of the addin types is being replaced. The order of the sections reflects the order in which we are implementing the changes. The implementation status of each of the types is shown in parentheses. This spec refers to a number of interfaces that form part of the NUnit framework. Until a technical note covering these interfaces is published, please rely on the source code for documentation. Some of the sections that follow have not had all their design work completed, so the degree of detail varies among them. More information will be added as work progresses. TestDecorators Status: REMOVED TestDecorators in NUnit 2.6 could do one of three things: Modify the properties of the test or the execution context Drop the test by returning null. Replace the test, possibly wrapping the old test within the new one. In NUnit 3.0, each of these is implemented differently. To modify the properties of the test, create an attribute that implements IApplyToTest . To modify the execution context, implement IApplyToContext . This is a new capability. It is no longer possible - but not necessary either - to replace the test. In NUnit 3.0, the test object does not execute itself. Instead, a series of commands is created, which carry out the necessary operations to run the test. An attribute that implements ICommandDecorator is able to contribute to add additional commands to be executed when running the test. It is no longer possible to simply eliminate the test. Once created, a test will always appear in the UI, for example. However, by use of a command decorator, it is possible to prevent the test from executing. DataPointProviders Status: Removed NUnit 2.6 has two built-in providers of data for individual parameters of test methods: ParameterDataProvider gets data from attributes that appear directly on the parameter. DatapointProvider gets data from DataPoint and DataPointSource attributes, which appear on the data source rather than on the parameter. In the current 3.0 code, ParameterDataProvider actually delegates its work to the attributes, which must implement IParameterDataSource . In NUnit 3.0, users will be able to create additional attributes implementing this interface and they will be used as data sources. On the other hand, DataPointProvider contains the code for accessing the data specified by the DataPoint and DataPointSource attributes, which are simply used as markers. This is because the attributes do not have a reference to the member on which they are placed. It would be necessary to introduce a method to provide them with this reference in order to do the processing within the attribute and this would appear to introduce otherwise unneeded code with no particular benefit. Consequently, for the initial implementation of NUnit 3.0, it will not be possible to create custom attributes that work in similar fashion to DataPoint or DataPointSource . If the need arises, some interface may be introduced. Since DataPointProvider s are only called from within TestCaseProvider s, implementation of these changes may need to be interleaved with changes related to TestCaseProvider s. See the next section for details. TestCaseProviders Status: REMOVED NUnit 2.6 currently has two built-in TestCaseProviders: DataAttributeTestCaseProvider gets test case data from any DataAttribute, such as TestCaseAttribute . CombinatorialTestCaseProvider creates test cases by combining parameter data from a DataPointProvider . Currently, DataAttributeTestCaseProvider delegates all the work to the DataAttribute . This is the desired approach. Users implementing a new custom data attribute may inherit from DataAttribute or implement an interface. CombinatorialTestCaseProvider works differently. It instantiates one of three available CombiningStrategy types, based on attributes appearing on the method. The CombiningStrategy is used to generate test cases from the available parameter data. For NUnit 3.0, the work of combining parameter data into cases will be moved into the CombiningStrategy attributes. An interface will be defined and users will be able to create new combining strategies by defining a custom attribute that implements the interface. EventListeners Status: REMOVED EventListeners implement the ITestListener interface and are notified when important events in the life of a test occur. Almost all the functions of an EventListener can already be emulated in NUnit 2.6 by use of an ActionAttribute . ActionAttribute s are not yet implemented in NUnit 3.0. Consequently, the first step in removing EventListeners is to implement ActionAttribute s. Some changes may be made in the process and a separate spec will be written to describe them. The only function of EventListeners that cannot be duplicated by ActionAttributes at this time is the capture of text output from the test. A new approach will be designed for this purpose. TestCaseBuilders Status: REMOVED NUnit 2.6 has one built-in TestCaseBuilder, NUnitTestCaseBuilder , which implements ITestCaseBuilder2 . All TestCaseBuilders must implement either ITestCaseBuilder or ITestCaseBuilder2 . In NUnit 3.0, the interface and its implementation will be moved into the attributes that designate a test. For example, TestAttribute will actually build a test case. This may be done using ITestCaseBuilder2 or a new interface may be designed. Users wishing to create a new kind of test case will need to define a new attribute, which implements the interface. A few issues need to be resolved: Some attributes, such as TestCaseAttribute or TestCaseSourceAttribute serve dual functions: they both mark a test case and provide data for the test case. Some combination of the code for generating test cases with that for creating tests is likely to be required. For backward compatibility, an extra TestAttribute accompanying one or more TestCaseAttribute s should not generate an additional TestCase . SuiteBuilders Status: REMOVED NUnit 2.6 has one built-in SuiteBuilder, which implements the required ISuiteBuilder interface. Similarly to what is being done for test cases, the building of a test fixture will be moved into the TestFixture attribute. The supporting interface may need to be redefined. Users may create new types of test fixtures by defining a new attribute, which implements the interface. Similar issues as with TestCaseBuilder must be resolved, in addition to a few others: TestFixtureAttribute both marks a test case and provides arguments used to construct the fixture. Extra TestFixtureAttribute s in the hierarchy must be ignored. We want to add similar data-generation capabilities to TestFixture as exist for methods using TestCaseSource . We want to allow \"TheoryFixtures\", which combine multiple related Theories into a single fixture. We want to support an AbstractTestFixtureAttribute , which marks a class as the base of a fixture hierarchy but not a fixture itself."
  },
  "articles/nunit/technical-notes/usage/Assembly-Isolation.html": {
    "href": "articles/nunit/technical-notes/usage/Assembly-Isolation.html",
    "title": "Assembly Isolation | NUnit Docs",
    "keywords": "Assembly Isolation NUnit isolates test assemblies from its own code and from one another by use of separate Processes and AppDomains. By default, NUnit loads each test assembly into a separate Process under the control of the NUnit Agent program. This allows NUnit to ensure that each assembly is loaded in the environment for which it was built. Within the agent process, NUnit's own code runs in the primary AppDomain while the tests run in a separate AppDomain . If desired, multiple test assemblies may be loaded into the same process and even the same domain by use of the -process and -domain command-line options. See Console Command Line ."
  },
  "articles/nunit/technical-notes/usage/Configuration-Files.html": {
    "href": "articles/nunit/technical-notes/usage/Configuration-Files.html",
    "title": "Configuration Files | NUnit Docs",
    "keywords": "Configuration Files Normally, a configuration file used to provide settings or to control the environment in which tests are run, should be given the name as the assembly file with the suffix \".config\" added. For example, the configuration file used to run nunit.tests.dll must be named nunit.tests.dll.config and located in the same directory as the dll. Notes: When multiple assemblies are specified in an NUnit project (file extension .nunit ), it is possible to specify a common config file for the included test assemblies. When multiple assemblies are specified on the command-line using the --domain:Single option, no config file is currently used."
  },
  "articles/nunit/technical-notes/usage/Counting-Tests.html": {
    "href": "articles/nunit/technical-notes/usage/Counting-Tests.html",
    "title": "Counting Tests | NUnit Docs",
    "keywords": "Counting Tests Counting tests sounds simple but there are a few issues. This page documents how the framework counts tests in various categories. In general, when counting tests, we are talking about test cases. In the case of non-parameterized test methods, that's the same as the number of methods. Where there are parameters, we count the number of individual cases. When all the tests in an assembly are run, the total number of tests is the number of tests present in the assembly. When selection is made - either via the command line or through a Gui - we count only tests that are actually selected. Non-selected tests don't appear at all in the XML result file and are not taken into account by the counts. Tests are categorized in one of four statuses: Passed, Failed, Inconclusive and Skipped. Passed tests currently only have one ResultState, Success. Failed tests are caused by any of the following: Failure of an assertion (ResultState.Failure) An unexpected exception (ResultState.Error) An invalid test (ResultState.NotRunnable) User cancellation (ResultState.Cancelled) Inconclusive tests currently only have one ResultState, Inconclusive Skipped tests are caused by Ignoring the test (ResultState.Ignored) The test was marked explicit (ResultState.Skipped) Note: this may change to ResultState.Explicit in the future A Platform, Culture or UICulture attribute test failed (ResultState.Skipped) Users may define new ResultStates in any of the four statuses. Failures, errors, skipping or ignoring in the SetUp for a test counts the same as if the action happened in the test method itself. When fixtures are ignored or otherwise skipped using an attribute on the class, all tests within the fixture are given the corresponding result. Failures, errors, skipping or ignoring in the OneTimeSetUp for a fixture causes all the test cases in the fixture to get the corresponding result. An invalid fixture causes all of its test cases to count as invalid."
  },
  "articles/nunit/technical-notes/usage/Engine-Parallel-Test-Execution.html": {
    "href": "articles/nunit/technical-notes/usage/Engine-Parallel-Test-Execution.html",
    "title": "Engine Parallel Test Execution | NUnit Docs",
    "keywords": "Engine Parallel Test Execution The NUnit test engine is able to offer a certain degree of parallelization by running the tests in each test assembly in a different Process . This is a separate facility from Framework Parallel Test Execution although the two may be used concurrently. If tests are already split across multiple assemblies, this is the simplest way to improve performance through parallel execution. By running in separate processes, the tests in each assembly are independent of one another so long as they do not use any common external resources such as files or databases. Parallel execution is the default behavior when running multiple assemblies together using the nunit3-console runner. Normally, all the test processes run simultaneously. If you need to reduce the number of processes allowed to run at one time, you may specify a value for the --agents option on the nunit3-console command-line. For example, if you are running tests in 10 different processes, a setting of --agents=3 will allow no more than three of them to execute simultaneously. Note This facility does not depend on the test framework used in any way. Test assemblies that use older versions of NUnit may be run in parallel processes just as easily as those using NUnit 3. If extensions are created to support additional frameworks, the NUnit engine will run those assemblies in parallel as well. Process Model NUnit 3 uses the ProcessModel enumeration to specify how assemblies are split across processes. The ProcessModel for a run may specified either on the console command-line or in the NUnit project file. As in NUnit V2, three values are defined: ProcessModel.Single causes all tests to be run within the NUnit process itself. ProcessModel.Separate loads and runs all the tests in a single separate process. ProcessModel.Multiple loads and runs each test assembly in a separate process. In NUnit 3, if ProcessModel.Multiple is used, the processes are executed in parallel. This is also the default if the ProcessModel is not specified."
  },
  "articles/nunit/technical-notes/usage/Framework-Parallel-Test-Execution.html": {
    "href": "articles/nunit/technical-notes/usage/Framework-Parallel-Test-Execution.html",
    "title": "Framework Parallel Test Execution | NUnit Docs",
    "keywords": "Framework Parallel Test Execution The NUnit 3.0 framework can run tests in parallel within an assembly. This is a completely separate facility from Engine Parallel Test Execution , although it is possible to use both in the same test run. By default, no parallel execution takes place. Attributes are used to indicate which tests may run in parallel and how they relate to other tests. Platform Support Parallel execution is supported by the NUnit framework on desktop .NET runtimes and .NET Standard 2.0. It is not supported in the .NET Standard 1.6 build, although the attributes are recognized without error in order to allow use in projects that build against multiple targets. ParallelizableAttribute This attribute is used to indicate whether the test and/or its descendants may be run in parallel with other tests. The constructor takes an optional ParallelScope enumeration argument (see below), which defaults to ParallelScope.Self . The attribute may be used at the assembly, class or method level and the word \"test\" in the rest of this description refers to the suite or test case that corresponds to the item on which the attribute appears. One Named Property is supported: Scope = ParallelScope for setting ParallelScope using property syntax NonParallelizableAttribute This Attribute is used to indicate that the test as well as its descendants may not be run in parallel with other tests. Although [NonParallelizable] is completely equivalent to [Parallelizable(ParallelScope.None)] , we recommend that you use the former for clarity. ParallelScope Enumeration This is a [Flags] type enumeration used to specify which tests may run in parallel. It applies to the test upon which it appears and any subordinate tests. The following values are available for use: ParallelScope.Self indicates that the test itself may be run in parallel with other tests. This is the default for the ParallelizableAttribute and is the only value permitted on a test method. ParallelScope.Children indicates that the descendants of the test may be run in parallel with respect to one another. ParallelScope.Fixtures indicates that test fixtures that are the descendants of the test may be run in parallel with one another.` Note Additional values of the enumerator are used internally. They do not show up in the Intellisense and are not documented here. The value ParallelScope.None , which was used before the creation of the NonParallelizableAttribute is still accepted for the purpose of backward compatibility. Specifying Parallelism at Multiple Test Levels [Parallelizable] or [NonParallelizable] may be specified on multiple levels of the tests, with lower-level specifications overriding higher ones to a certain degree. Thus, if the assembly has [NonParallelizable] either by use of the attribute or by default, classes with [Parallelizable] may be run in parallel as may their children if an appropriate scope is used. It is important to note that a parallel or non-parallel specification only applies at that level where it appears and below. It cannot override the settings on higher-level tests. In this way, parallelism is not absolute but is relative to other tests at the same level in the tree. The following are a few examples of how this works: Non-parallel class with parallel methods: The methods only run in parallel with one another, not with the test methods of any other classes. Parallel class with non-parallel methods: The methods run sequentially, usually on the same thread that ran the class one-time setup, but may actually be running in parallel with other, unrelated methods from other classes. Non-parallel SetUpFixture with parallel test fixtures: The entire group of fixtures runs separately from any fixtures outside the group. Within the group, multiple fixtures run in parallel. Parallel SetUpFixture with non-parallel test fixtures: The group runs in parallel with other fixtures and groups. Within the group, only one fixture at a time may execute. Parallel SetUpFixture with non-parallel test fixtures containing parallel test cases: This is just one example of a more complex setup. The fixtures themselves run as described in (4) but the cases within each fixture run in parallel with one another. Once you understand the principles, you can construct complex hierarchies of parallel and non-parallel tests. LevelOfParallelismAttribute This is an assembly-level attribute, which may be used to specify the level of parallelism, that is, the maximum number of worker threads executing tests in this assembly. It may be overridden using a command-line option in the console runner. If it is not specified, NUnit uses a default value based on the number of processors available or a specified minimum, whichever is greater. Parallel Execution Internals We use multiple queues organized into \"shifts\". A WorkShift consists of one or more queues of work items, which may be active at the same time. As the name suggests, no two shifts are active simultaneously. NUnit runs one WorkShift until all available work is complete and then switches to the next shift. When there is no work for any shift, the run is complete. There are three shifts, listed here with their associated queues... Shift Queues Workers Usage Parallel Shift Parallel Queue LoP* Parallelizable tests run in the MTA Parallel STA Queue 1 Parallelizable tests run in the STA Non-Parallel Shift Non-Parallel Queue 1 Non-parallelizable tests run in the MTA Non-Parallel STA Shift Non-Parallel STA Queue 1 Non-parallelizable tests run in the STA (* Depends on Level of Parallelism) For efficiency, each queue is created when the first test is added to it. At the time of creation, all workers for that queue are also created and initialized. Whenever a non-parallel fixture begins execution, an entirely new set of queues is created so that the child tests of that fixture may be run without any conflict from other tests that are already in the main set of queues. If the command line specifies zero workers, all use of the dispatcher and its queues is bypassed and tests are run sequentially on a single thread."
  },
  "articles/nunit/technical-notes/usage/NUnit-Project-XML-Format.html": {
    "href": "articles/nunit/technical-notes/usage/NUnit-Project-XML-Format.html",
    "title": "NUnit Project XML Format | NUnit Docs",
    "keywords": "NUnit Project XML Format <NUnitProject> The required root element for any NUnit project file. Containing Element: None Contained Elements: <Settings> , <Config> Attributes: None <Settings> Contains global settings that apply to all configurations in the project. May be empty or absent. Containing Element: <NUnitProject> Contained Elements: None Attributes: activeconfig The name of the config to use if none is specified by the user. Using nunit-console , you may override this through the --config command-line option. appbase The application base to use in loading and running tests. Defaults to the location of the .nunit project file. If the path is relative, as it normally is, it is taken as relative to the location of the project file. processModel Specifies how NUnit should create processes for executing test assemblies. Possible values are: Default, Single (no separate processes are created), Separate (tests are run in a single, separate process) and Multiple (each assembly is run in its own separate process). The default value is Multiple, provided there are multiple assemblies, otherwise Separate. domainUsage Specifies how NUnit should create AppDomains within each process for running tests. Possible values are: Default, None (no domain is created), Single (a single domain is created) and Multiple (a separate domain is created for each assembly). The default is Multiple if multiple assemblies are run in the same process, Single if only one assembly is run in a process. <Config> Describes a specific configuration of the project. This may map to traditional compiler configs like Debug or Release or may be used to specify any arbitrary collection of assemblies to be tested together. At least one configuration should be specified or the project will not be usable. Containing Element: <NUnitProject> Contained Elements: <assembly> Attributes: name The name of this configuration. (Required) appbase The application base to use in loading and running tests under this config. Defaults to the appbase specified in the <Settings> element. The path should normally be relative to that global application base or to the location of project file if there is no global appbase. binpath The probing path used to search for assemblies, consisting of a number of directory paths separated by semicolons. The directory paths should be relative to the application base and must be under it. Specifying this attribute automatically sets the binpathtype to 'manual'. binpathtype Indicates how the probing path is determined. Possible values are: Auto (the probing path is determined from the location of the test assemblies), Manual (the path is specified by the binpath attribute) and None (no probing path is used). It is an error to specify a value other than Manual if the binpath attribute is also used. configfile Specifies the path to a config file to be used when running tests under this configuration. The path is relative to the application base. processModel Specifies how NUnit should create processes for executing test assemblies under this configuration. Possible values are: Default, Single (no separate processes are created), Separate (tests are run in a single, separate process) and Multiple (each assembly is run in its own separate process). The default is the value specified globally or Multiple if nothing has been specified. domainUsage Specifies how NUnit should create AppDomains within each process for running tests under this configuration. Possible values are: Default, None (no domain is created), Single (a single domain is created) and Multiple (a separate domain is created for each assembly). The default is the value specified globally, if provided, otherwise Multiple if multiple assemblies are run in the same process, Single if only one assembly is run in a process. runtimeFramework Specifies a runtime framework to be used in running tests. Abbreviations are the same as those accepted by the nunit-console command-line. If none is specified, tests are run under the target runtime specified when the assembly was compiled. <assembly> Specifies a single assembly containing tests. Containing Element: <Config> Contained Elements: None Attributes: path The path to the test assembly, relative to the application base for its configuration."
  },
  "articles/nunit/technical-notes/usage/Parameterized-Tests.html": {
    "href": "articles/nunit/technical-notes/usage/Parameterized-Tests.html",
    "title": "Parameterized Tests | NUnit Docs",
    "keywords": "Parameterized Tests NUnit supports parameterized tests. Test methods may have parameters and various attributes are available to indicate what arguments should be supplied by NUnit. Multiple sets of arguments cause the creation of multiple tests. All arguments are created at the point of loading the tests, so the individual test cases are available for display and selection in the Gui, if desired. Some attributes allow you to specify arguments inline - directly on the attribute - while others use a separate method, property or field to hold the arguments. In addition, some attributes identify complete test cases, including all the necessary arguments, while others only provide data for a single argument. This gives rise to four groups of attributes, as shown in the following table. Complete Test Cases Data for One Argument Inline TestCase Attribute Random Attribute , Range Attribute , Values Attribute Separate TestCaseSource Attribute ValueSource Attribute In addition, when data is specified for individual arguments, special attributes may be added to the test method itself in order to tell NUnit how to go about combining the arguments. Currently, the following attributes are provided: Combinatorial Attribute (default) Pairwise Attribute Sequential Attribute Order of Execution The individual test cases are executed in the order in which NUnit discovers them. This order does not necessarily follow the lexical order of the attributes and will often vary between different compilers or different versions of the CLR. The following specific rules for ordering apply: If all arguments are specified in a single TestCaseSource attribute, the ordering of the cases provided will be maintained. If each parameter has a single Values , ValueSource or Range attribute and the Sequential combining strategy is used - or there is only one argument - the ordering will be maintained. In all other cases, including using multiple TestCase attributes or a combination of different types of attributes, the ordering of the test cases is undefined."
  },
  "articles/nunit/technical-notes/usage/Platform-Selection.html": {
    "href": "articles/nunit/technical-notes/usage/Platform-Selection.html",
    "title": "Platform Selection | NUnit Docs",
    "keywords": "Platform Selection If your tests are compiled x86 or x64, NUnit will run each assembly by default in a process targeted at the appropriate platform as well as the targeted runtime. If you run multiple assemblies in the same process, you may not mix x86 and x64 assemblies. On an x64 machine, if your test assembly is compiled x86, you must not use /process=Single on the command line. This is because NUnit is already running in a 64-bit process and will fail when it tries to load your assembly into the same process. If your test assembly references any x86 or x64 assemblies, it should be built for the same platform. Consequently, you may not mix x86 and x64 references."
  },
  "articles/nunit/technical-notes/usage/Runtime-Selection.html": {
    "href": "articles/nunit/technical-notes/usage/Runtime-Selection.html",
    "title": "Runtime Selection | NUnit Docs",
    "keywords": "Runtime Selection By default, NUnit runs tests under the runtime version for which the test assembly was built, provided it is available on the test machine. If it is not available, NUnit runs the assembly under the best available runtime that will allow it to run. If no suitable runtime can be found, an error is reported. Overriding the Defaults The default runtime framework may be overridden using command line options. In all cases, NUnit will attempt to honor the options given, issuing an error message if the assembly cannot be loaded. See Console Command Line for more information. The /framework option of console runner allows you to specify the framework type and version to be used for a test run. When this option is used, NUnit will attempt to run the tests under the framework specified even if the assembly targets a different runtime. The /process:Single command-line option indicates that tests should be run in the NUnit process itself. This forces usage of the runtime under which NUnit is already running. The process:Separate causes a single separate process to be used for all assemblies. In this case, NUnit will use the highest level runtime targeted by any of the assemblies, if it is available."
  },
  "articles/nunit/technical-notes/usage/SetUp-and-TearDown.html": {
    "href": "articles/nunit/technical-notes/usage/SetUp-and-TearDown.html",
    "title": "SetUp And TearDown | NUnit Docs",
    "keywords": "SetUp And TearDown Attribute Usage SetUpAttribute is now used exclusively for per-test setup. TearDownAttribute is now used exclusively for per-test teardown. OneTimeSetUpAttribute is used for one-time setup per test-run. If you run n tests, this event will only occur once. OneTimeTearDownAttribute is used for one-time teardown per test-run. If you run n tests, this event will only occur once SetUpFixtureAttribute continues to be used as at before, but with changed method attributes. Attribute Usage by Fixture Type TestFixture SetUpFixture OneTimeSetUp Supported Supported OneTimeTearDown Supported Supported TestFixtureSetUp Deprecated Not Allowed TestFixtureTearDown Deprecated Not Allowed SetUp Supported Not Allowed TearDown Supported Not Allowed How Setup and TearDown Methods Are Called Multiple SetUp, OneTimeSetUp, TearDown and OneTimeTearDown methods may exist within a class. Setup methods (both types) are called on base classes first, then on derived classes. If any setup method throws an exception, no further setups are called. Teardown methods (again, both types) are called on derived classes first, then on the base class. The teardown methods at any level in the inheritance hierarchy will be called only if a setup method at the same level was called. The following example is illustrates the difference. public class BaseClass { [SetUp] public void BaseSetUp() { /* ... */ } // Exception thrown! [TearDown] public void BaseTearDown() { /* ... */ } } [TestFixture] public class DerivedClass : BaseClass { [SetUp] public void DerivedSetUp() { /* ... */ } [TearDown] public void DerivedTearDown() { /* ... */ } [Test] public void TestMethod() { /* ... */ } } Execution will proceed as follows: BaseSetUp BaseTearDown rather than BaseSetUp DerivedTearDown BaseTearDown See also: SetUp and TearDown Changes"
  },
  "articles/nunit/technical-notes/usage/Test-Filters.html": {
    "href": "articles/nunit/technical-notes/usage/Test-Filters.html",
    "title": "Test Filters | NUnit Docs",
    "keywords": "Test Filters Test Filters represent a selection of tests to be displayed, run or loaded. When a filter needs to be passed to the framework, it is passed as a string containing an XML fragment. This page describes the elements present in the XML for a filter. <filter> This is the required top-level element for any filter. If it contains no other elements, it represents an empty filter. If it contains just one element, that element is used as the filter for all tests. If it contains multiple elements, it works like an <and> element. Child elements allowed: <and> , <or> , <not> , <id> , <test> , <cat> , <class> , <method> , <namespace> , <prop> , <name> . <and> Represents an AndFilter. All contained filter elements must pass in order for this filter to pass. Child elements allowed: <and> , <or> , <not> , <id> , <test> , <cat> , <class> , <method> , <namespace> , <prop> , <name> . <or> Represents an OrFilter. At least one contained filter element must pass in order for this filter to pass. Child elements allowed: <and> , <or> , <not> , <id> , <test> , <cat> , <class> , <method> , <namespace> , <prop> , <name> . <not> Represents a NotFilter. The single contained filter element must fail in order for this filter to pass. Child elements allowed: <and> , <or> , <not> , <id> , <test> , <cat> , <class> , <method> , <namespace> , <prop> , <name> . <id> Represents an IdFilter. The text of the element contains a single test id or multiple ids separated by commas. Since test ids are an internal construct, this filter is not useful externally. However, it is used by the NUnit Gui to efficiently select tests from the list of those loaded. Child elements allowed: None. <test> Represents a selection by test name. The full name of the test is used as its inner text. If the filter should use a regular expression for matching then the element should contain an attribute named re with the value \"1\" . Child elements allowed: None. <cat> Represents a CategoryFilter. The text of the element contains a single category. If the filter should use a regular expression for matching then the element should contain an attribute named re with the value \"1\" . Child elements allowed: None. <class> Represents a selection by class name. The fully qualified name of the class is used as its inner text. If the filter should use a regular expression for matching then the element should contain an attribute named re with the value \"1\" . Child elements allowed: None. <method> Represents a selection by method name. The name of the method is used as its inner text. If the filter should use a regular expression for matching then the element should contain an attribute named re with the value \"1\" . Child elements allowed: None. <namespace> Represents a selection by namespace. The fully qualified name of the namespace is used as its inner text. If the filter should use a regular expression for matching then the element should contain an attribute named re with the value \"1\" . Child elements allowed: None. <prop> Represents a PropertyFilter. The element has an attribute name which specifies the name of the property. The text of the element contains the value of the property. If the filter should use a regular expression for matching then the element should contain an attribute named re with the value \"1\" . Child elements allowed: None. <name> Represents a selection by test name. The test name assigned by NUnit is used as its inner text. If the filter should use a regular expression for matching then the element should contain an attribute named re with the value \"1\" . Child elements allowed: None."
  },
  "articles/nunit/technical-notes/usage/Test-Result-XML-Format.html": {
    "href": "articles/nunit/technical-notes/usage/Test-Result-XML-Format.html",
    "title": "Test Result XML Format | NUnit Docs",
    "keywords": "Test Result XML Format <test-run> The required root element for any NUnit 3.0 test result file. Containing Elements: None Contained Elements: <command-line> , <filter> , <test-suite> Attributes: id The unique ID of this test. testcasecount The number of test cases contained in this test run. result The basic result of the test. May be Passed, Failed, Inconclusive or Skipped. total The total number of test cases executed in the run. This may be less than the testcasecount due to filtering of tests. passed The number of test cases that passed. failed The number of test cases that failed. inconclusive The number of test cases that were inconclusive. skipped The number of test cases that were skipped. asserts The number of asserts executed in the test run. engine-version The version of the NUnit test engine in use. clr-version The runtime version under which the engine is running, taken from Environment.Version. start-time The UTC time that the test run started. end-time The UTC time that the test run ended. duration The duration of the test run in seconds, expressed as a real number. <command-line> Holds a CDATA section containing the text of the command used to run the tests. Containing Elements: <test-run> Contained Elements: None Attributes: None <filter> The XML representation of the filter used to execute tests. This element is also used as a fragment in passing the filter to a runner and by the NUnit 3.0 framework and driver. Containing Elements: <test-run> Contained Elements: <or> , <and> , <not> , <id> , <test> , <class> , <method> , <cat> Attributes: None <or> Represents a composite filter that contains other filters. At least one of the contained filters must pass in order for this filter to pass. Containing Elements: <filter> , <or> , <and> , <not> Contained Elements: <or> , <and> , <not> , <id> , <test> , <class> , <method> , <cat> , <prop> Attributes: None <and> Represents a composite filter that contains other filters. All of the contained filters must pass in order for this filter to pass. Containing Elements: <filter> , <or> , <and> , <not> Contained Elements: <or> , <and> , <not> , <id> , <test> , <class> , <method> , <cat> , <prop> Attributes: None <not> Represents a composite filter that contains wraps a single base filters. The base filter must fail in order for this filter to pass. Containing Elements: <filter> , <or> , <and> , <not> Contained Elements: <or> , <and> , <not> , <id> , <test> , <class> , <method> , <cat> , <prop> Attributes: None <id> Represents a filter that examines the test id, which is generated by NUnit. Containing Elements: <filter> , <or> , <and> , <not> Contained Elements: None Attributes: None <test> Containing Elements: <filter> , <or> , <and> , <not> Contained Elements: None Attributes: re Set to '1' to indicate that a regular expression comparison is to be used. <class> Containing Elements: <filter> , <or> , <and> , <not> Contained Elements: None Attributes: re Set to '1' to indicate that a regular expression comparison is to be used. <method> Containing Elements: <filter> , <or> , <and> , <not> Contained Elements: None Attributes: re Set to '1' to indicate that a regular expression comparison is to be used. <prop> Containing Elements: <filter> , <or> , <and> , <not> Contained Elements: None Attributes: name The name of the property to filter on. re Set to '1' to indicate that a regular expression comparison is to be used. <cat> Containing Elements: <filter> , <or> , <and> , <not> Contained Elements: None Attributes: None <test-suite> Containing Elements: <test-run> , <test-suite> Contained Elements: <environment> , <settings> , <properties> , <reason> , <failure> , <output> , <attachments> , <test-suite> , [ <test-case> ](#test-case* Attributes type The type of suite represented by this element. Currently supported types are Assembly, TestSuite, TestFixture, id The unique id of this test. Coded as \"mmm-nnn\" where the part before the hyphen represents the assembly and the part after it represents a test in that assembly. Currently, mmm and nnn are ints, but that is merely an accident of the implementation and should not be relied on. name The display name of the test as generated by NUnit. fullname The full name of the test as generated by NUnit. classname The full name of the class (fixture) representing this test. Only present if type is equal to \"TestFixture\". testcasecount The number of test cases contained, directly or indirectly, in this suite. runstate An indicator of whether the suite is runnable. Value may be NotRunnable, Runnable, Explicit, Skipped or Ignored. NotRunnable means there is an error in how the test is expressed in code, for example, the signature may be wrong. Explicit, Skipped and Ignored are set by attributes on the test. result The basic result of the test. May be Passed, Failed, Inconclusive or Skipped. label Additional labeling information about the result. In principle, this may be any string value and is combined with the result to give a more precise reason for failure. Currently, NUnit may use the following labels in combination with the Failure result: Error, Cancelled or Invalid. It may use the following labels in combination with a Skipped result: Ignored or Explicit. Additional values may be added in future releases or supplied by extensions, so code that processes a result file should be prepared to deal with any label or none at all. site Optional element indicating where a failure occurred. Values are Test, SetUp, TearDown, Parent or Child. Default is Test and the attribute does not normally appear in that case. start-time The UTC time that the suite started. end-time The UTC time that the suite ended. duration The duration of the suite in seconds, expressed as a real number. total The total number of test cases executed under this suite. passed The number of test cases that passed. failed The number of test cases that failed. inconclusive The number of test cases that were inconclusive. skipped The number of test cases that were skipped. asserts The number of asserts executed by the suite, including any nested suites or test cases. Since asserts may be executed in OneTimeSetUp and in ActionAttributes, this number can be greater than the total of the asserts for the test cases. <environment> Describes the environment in which the tests in a particular assembly are being run. Containing Elements: <test-suite> (Assembly level only) Contained Elements: None Attributes: framework-version The version of the nunit framework in use. clr-version The runtime version under which the tests are running, taken from Environment.Version. os-version A text string describing the operating system running the tests, taken from Environment.OsVersion. platform The platform id, taken from Environment.OsVersion.Platform. cwd The current working directory path, taken from Environment.CurrentDirectory. machine-name The machine name, taken from Environment.MachineName. user The user id, taken from Environment.UserName. user-domain The user domain, taken from Environment.UserDomainName. culture The current culture, taken from CultureInfo.CurrentCulture. uiculture The current UI culture, taken from CultureInfo.CurrentUICulture. os-architecture The architecture, taken from GetProcessorArchitecture(). <settings> Settings used by the engine for executing an assembly. These are taken from the supplied settings in the TestPackage supplemented by default settings created by the engine itself. Containing Elements: <test-suite> (Assembly level only) Contained Elements: <setting> Attributes: None <setting> A single setting Containing Elements: <settings> Contained Elements: None Attributes: name The name of the setting. value The value assigned to the setting. <test-case> Containing Elements: <test-suite> Contained Elements: <properties> , <reason> , <failure> , <output> , <attachments> Attributes id The unique id of this test. Coded as \"mmm-nnn\" where the part before the hyphen represents the assembly and the part after it represents a test in that assembly. Currently, mmm and nnn are ints, but that is merely an accident of the implementation and should not be relied on. name The display name of the test as generated by NUnit or, in the case of some parameterized tests, specified by the user. fullname The full name of the test as generated by NUnit. methodname The name of the method representing the test case. classname The full name of the class in which this test case appears. runstate An indicator of whether the suite is runnable. Value may be NotRunnable, Runnable, Explicit, Skipped or Ignored. NotRunnable means there is an error in how the test is expressed in code, for example, the signature may be wrong. Explicit, Skipped and Ignored are set by attributes on the test. seed The seed used to generate random arguments and other values for this test. result The basic result of the test. May be Passed, Failed, Inconclusive or Skipped. label Additional labeling information about the result. In principle, this may be any string value and is combined with the result to give a more precise reason for failure. Currently, NUnit may use the following labels in combination with the Failure result: Error, Cancelled or Invalid. It may use the following labels in combination with a Skipped result: Ignored or Explicit. Additional values may be added in future releases or supplied by extensions, so code that processes a result file should be prepared to deal with any label or none at all. site Optional element indicating where a failure occurred. Values are Test, SetUp, TearDown, Parent or Child. Default is Test and the attribute does not normally appear in that case. start-time The UTC time that the test started. end-time The UTC time that the test ended. duration The duration of the test in seconds, expressed as a real number. asserts The number of asserts executed by the test. <properties> Optional element containing any properties assigned to the test case or suite. Containing Elements: <test-suite> , <test-case> Contained Elements: <property> Attributes None <property> A single property Containing Elements: <properties> Contained Elements: None Attributes name The name of the property value The value of the property <reason> Optional element that may appear on tests or suites that were not executed. Contains a message giving the reason for skipping the test. Containing Elements: <test-suite> , <test-case> Contained Elements: <message> Attributes None <failure> Optional element that appears on all tests or suites with a result of 'Failed'. Optionally contains the error message and/or a stack trace. Containing Elements: <test-suite> , <test-case> Contained Elements: <message> , <stack-trace> Attributes None <assertions> Containing Elements: <test-suite> , <test-case> Contained Elements: <assertion> Attributes None <assertion> Containing Elements: <assertions> Contained Elements: <message> , <stack-trace> Attributes result The result of the assertion. May be Inconclusive, Passed, Warning, Failed or Error. <message> Optional element with a CDATA section containing a message relating to the test's result. Containing Elements: <failure> , <reason> , <assertion> Contained Elements: None Attributes None <stack-trace> Optional element with a CDATA section containing a stack-trace of the location where a test failed. Containing Elements: <failure> , <assertion> Contained Elements: None Attributes None <output> Optional element that appears on tests or suites that produce text output. The output may be intercepted from writes to the console or captured directly when the test writes to the TestContext. It is contained in a CDATA section. Containing Elements: <test-suite> , <test-case> Contained Elements: None Attributes None <attachments> Optional element that appears when files are attached to a test. Contains a list of <attachment> elements. Containing Elements: <test-suite> , <test-case> Contained Elements: <attachment> Attributes None <attachment> Groups together the file path and description of a test attachment. Containing Elements: <attachments> Contained Elements: <filePath> , <description> Attributes None <filePath> Contains the file path for the attachment. Paths will be fully rooted. Containing Elements: <attachment> Contained Elements: None Attributes None <description> Optional element that contains the user's description of the attachment. It is contained in a CDATA section. Containing Elements: <attachment> Contained Elements: None Attributes None"
  },
  "articles/nunit/technical-notes/usage/Usage-Notes.html": {
    "href": "articles/nunit/technical-notes/usage/Usage-Notes.html",
    "title": "Usage Notes | NUnit Docs",
    "keywords": "Usage Notes Runtime Selection Platform Selection Assembly Isolation Configuration Files XML Formats Visual Studio Support SetUp and TearDown Parameterized Tests Addin Replacement in the Framework Counting Tests Framework Parallel Test Execution Engine Parallel Test Execution"
  },
  "articles/nunit/technical-notes/usage/Visual-Studio-Support.html": {
    "href": "articles/nunit/technical-notes/usage/Visual-Studio-Support.html",
    "title": "Visual Studio Support | NUnit Docs",
    "keywords": "Visual Studio Support Warning This is a draft. The contents may be out of date. NUnit supports the Visual Studio project and solution format, which are also used by a number of other IDEs. Running From Within Visual Studio The most convenient way to do this is to set up a custom tool entry specifying the path to NUnit as the command. For a VS2003 C# project, you can use $(TargetPath) for the arguments and $(TargetDir) for the initial directory. With Visual Studio VS2005 this becomes a bit harder, because that release changed the meaning of the 'Target' macros so they now point to the intermediate 'obj' directories rather than the final output in one of the 'bin' directories. Here are some alternatives that work in both versions: $(ProjectDir)$(ProjectFileName) to open the VS Project rather than the assembly. If you use this approach, be sure to rename your config file accordingly and put it in the same directory as the VS project file. $(ProjectDir)bin/Debug/$(TargetName)$(TargetExt) to run the assembly directly. Note that this requires hard-coding part of the path, including the configuration. If you would like to debug your tests, use the Visual Studio Debug | Processesâ€¦ menu item to attach to NUnit after starting it and set breakpoints in your test code as desired before running the tests. Opening Visual Studio Projects When Visual Studio support is enabled, the File Open dialog displays the following supported Visual Studio project types: C#, VB.Net, J# and C++. The project file is read and the configurations and output assembly locations are identified. Since the project files do not contain information about the most recently opened configuration, the output assembly for the first configuration found (usually Debug) is loaded in the GUI. The tree shows the project as the top-level node with the assembly shown as its descendant. When tests are run for a Visual studio project, they run just as if the output assembly had been loaded with one exception. The default location for the config file is the directory containing the project file and its default name is the same as the project file with an extension of .config. For example, the following command would load the tests in the nunit.tests assembly using the configuration file nunit.tests.dll.config located in the same directory as the dll. nunit.exe nunit.tests.dll On the other hand, the following command would load the tests using the configuration file nunit.tests.config located in the same directory as the csproj file. nunit.exe nunit.tests.csproj The same consideration applies to running tests using the console runner. Opening Visual Studio Solutions When Visual Studio support is enabled, solution files may be opened as well. All the output assemblies from contained projects of the types supported will be loaded in the tree. In the case where all contained projects are located in the subdirectories beneath the solution, it will be possible to load and run tests using this method directly. When a solution contains projects located elsewhere in the file system, it may not be possible to run the tests - although the solution will generally load without problem. In this case, the Project Editor should be use to modify and save the NUnit test project so that there is all referenced assemblies are located in or beneath the application base directory."
  },
  "articles/nunit/technical-notes/usage/XML-Formats.html": {
    "href": "articles/nunit/technical-notes/usage/XML-Formats.html",
    "title": "XML Formats | NUnit Docs",
    "keywords": "XML Formats Warning This is a draft. The contents may be out of date. Use of XML in NUnit 2.x is somewhat limited and is only used in external files. NUnit 3.0 uses XML in several of its interfaces for communicating between its three architectural layers. The samples given here represent the current state of the application and are subject to change. Watch this page for new information as development continues. NUnit Projects An NUnit project is stored as a file with the extension .nunit and describes one or more test assemblies to be executed, together with certain parameters used in running them. No schema is used for this file. Sample NUnit Project Currently, the format is the same as for NUnit 2.x but it is likely to change as the project proceeds. Note that NUnitLite does not use or recognize NUnit projects, but only assemblies. For details of the file contents, see NUnit Project XML Format NUnit Settings The NUnitSettings30.xml file holds default settings for NUnit 3.0. No schema is used for this file. The format is the same as for 2.x but new settings may be added and the names of certain keys are likely to change. Sample NUnit Settings File Test Results The results of an test run are saved in a file with the default name of TestResult.xml. The schema of this file is being modified substantially for NUnit 3.0. Sample Schema not yet available For details of the file layout see Test Result XML Format . V2 Test Results Optionally, NUnit 3.0 is able to save results in the NUnit 2.x format for use with CI servers that do not yet understand the new format. Sample Schema Test Representation When using the -explore option, a list of tests without results is returned. The format used is simply a subset of the test result format, without the result information. See Test Result XML Format for details. Test Filters Information about which tests to run is provided to the framework using a test filter, represented as an XML fragment. See Test Filters for details. Test Packages Progress Reports As a test run progresses, individual test run results are sent as xml fragments from the result file under construction. A runner can, in fact, construct a copy of the result file incrementally using these fragments if desired. VisualState The Gui runner uses a file with the suffix .VisualState.xml to save the current visual state of a project so that it may be restored upon re-opening. This file is private to the Gui but is included here for completeness. The current format is identical to that used in NUnit 2.x. Sample Visual State File"
  },
  "articles/nunit/writing-tests/AssertionHelper.html": {
    "href": "articles/nunit/writing-tests/AssertionHelper.html",
    "title": "Assertion Helper | NUnit Docs",
    "keywords": "Assertion Helper AssertionHelper has been deprecated as of NUnit Framework 3.7. The syntax is now maintained and being enhanced as an independent library, NUnit.StaticExpect . Some users prefer a shorter form of assertion than is given by Assert.That. If you derive your test fixture class from AssertionHelper , the Expect() method may be used instead... Expect(bool condition); Expect(bool condition, string message, params object[] params); Expect(ActualValueDelegate del, IResolveConstraint constraint) Expect(ActualValueDelegate del, IResolveConstraint constraint, string message, params object[] params) Expect<TActual>(TActual actual, IResolveConstraint constraint) Expect<TActual>(TActual actual, IResolveConstraint constraint, string message, params object[] params) Expect(TestDelegate del, IResolveConstraint constraint); In addition, AssertionHelper allows the derived class to make direct use of many of the syntactic elements that would normally require you to specify the Is , Has or Does class in order to use them. For example, you can write... Expect(actual, EqualTo(\"Hello\")); Use Intellisense to determine which syntactic elements are available in the current release."
  },
  "articles/nunit/writing-tests/assertions/assertion-models/classic.html": {
    "href": "articles/nunit/writing-tests/assertions/assertion-models/classic.html",
    "title": "Classic Model | NUnit Docs",
    "keywords": "Classic Model The classic Assert model uses a separate method to express each individual assertion of which it is capable. Here's a simple assert using the classic model: StringAssert.AreEqualIgnoringCase(\"Hello\", myString); The Assert class provides the most common assertions in NUnit: Assert.True Assert.False Assert.Null Assert.NotNull Assert.Zero Assert.NotZero Assert.IsNaN Assert.IsEmpty Assert.IsNotEmpty Assert.AreEqual Assert.AreNotEqual Assert.AreSame Assert.AreNotSame Assert.Contains Assert.Greater Assert.GreaterOrEqual Assert.Less Assert.LessOrEqual Assert.Positive Assert.Negative Assert.IsInstanceOf Assert.IsNotInstanceOf Assert.IsAssignableFrom Assert.IsNotAssignableFrom Assert.Throws Assert.ThrowsAsync Assert.DoesNotThrow Assert.DoesNotThrowAsync Assert.Catch Assert.CatchAsync Assert.Pass Assert.Fail Assert.Ignore Assert.Inconclusive Additional assertions are provided by the following classes: String Assert Collection Assert File Assert Directory Assert See Also Constraint Model"
  },
  "articles/nunit/writing-tests/assertions/assertion-models/constraint.html": {
    "href": "articles/nunit/writing-tests/assertions/assertion-models/constraint.html",
    "title": "Constraint Model | NUnit Docs",
    "keywords": "Constraint Model The constraint-based Assert model uses a single method of the Assert class for all assertions. The logic necessary to carry out each assertion is embedded in the constraint object passed as the second parameter to that method. Here's a very simple assert using the constraint model: Assert.That(myString, Is.EqualTo(\"Hello\")); The second argument in this assertion uses one of NUnit's syntax helpers to create an EqualConstraint . The same assertion could also be made in this form: Assert.That(myString, new EqualConstraint(\"Hello\")); Using this model, all assertions are made using one of the forms of the Assert.That() method, which has a number of overloads... Assert.That(bool condition); Assert.That(bool condition, string message, params object[] params); Assert.That(bool condition, Func<string> getExceptionMessage); Assert.That(Func<bool> condition); Assert.That(Func<bool> condition, string message, params object[] params); Assert.That(Func<bool> condition, Func<string> getExceptionMessage); Assert.That<TActual>(ActualValueDelegate<TActual> del, IResolveConstraint constraint) Assert.That<TActual>(ActualValueDelegate<TActual> del, IResolveConstraint constraint, string message, object[] params) Assert.That<TActual>(ActualValueDelegate<TActual> del, IResolveConstraint expr, Func<string> getExceptionMessage) Assert.That<TActual>(TActual actual, IResolveConstraint constraint) Assert.That<TActual>(TActual actual, IResolveConstraint constraint, string message, params object[] params) Assert.That<TActual>(TActual actual, IResolveConstraint expression, Func<string> getExceptionMessage) Assert.That(TestDelegate del, IResolveConstraint constraint) Assert.That(TestDelegate code, IResolveConstraint constraint, string message, params object[] args) Assert.That(TestDelegate code, IResolveConstraint constraint, Func<string> getExceptionMessage) The overloads that take a bool work exactly like Assert.IsTrue , except that Assert.IsTrue does not accept a Func<string> for the exception message. For overloads taking a constraint, the argument must be a object implementing the IResolveConstraint interface, which supports performing a test on an actual value and generating appropriate messages. This interface is described in more detail under Custom Constraints . NUnit provides a number of constraint classes similar to the EqualConstraint used in the example above. Generally, these classes may be used directly or through a syntax helper. The valid forms are described on the pages related to each constraint. See also Classic Model"
  },
  "articles/nunit/writing-tests/assertions/assertions.html": {
    "href": "articles/nunit/writing-tests/assertions/assertions.html",
    "title": "Assertions | NUnit Docs",
    "keywords": "Assertions Assertions are central to unit testing in any of the xUnit frameworks, and NUnit is no exception. NUnit provides a rich set of assertions as static methods of the Assert class. If an assertion fails, the method call does not return and an error is reported. If a test contains multiple assertions, any that follow the one that failed will not be executed. For this reason, it's usually best to try for one assertion per test. Each method may be called without a message, with a simple text message or with a message and arguments. In the last case the message is formatted using the provided text and arguments. Two Models In NUnit 3.0, assertions are written primarily using the Assert.That method, which takes constraint objects as an argument. We call this the Constraint Model of assertions. In earlier versions of NUnit, a separate method of the Assert class was used for each different assertion. This Classic Model is still supported but since no new features have been added to it for some time, the constraint-based model must be used in order to have full access to NUnit's capabilities. For example, the following code must use the constraint model. There is no real classic equivalent. int[] array = new int[] { 1, 2, 3 }; Assert.That(array, Has.Exactly(1).EqualTo(3)); Assert.That(array, Has.Exactly(2).GreaterThan(1)); Assert.That(array, Has.Exactly(3).LessThan(100)); Where equivalents do exist, the two approaches will always give the same result, because the methods of the classic approach have all been implemented internally using constraints. For example... Assert.AreEqual(4, 2+2); Assert.That(2+2, Is.EqualTo(4));"
  },
  "articles/nunit/writing-tests/assertions/classic-assertions/Assert.AreEqual.html": {
    "href": "articles/nunit/writing-tests/assertions/classic-assertions/Assert.AreEqual.html",
    "title": "Assert.AreEqual | NUnit Docs",
    "keywords": "Assert.AreEqual Assert.AreEqual tests whether the two arguments are equal. Assert.AreEqual(double expected, double actual, double tolerance); Assert.AreEqual(double expected, double actual, double tolerance, string message, params object[] params); Assert.AreEqual(object expected, object actual); Assert.AreEqual(object expected, object actual, string message, params object[] params); Comparing Numerics of Different Types The method overloads that compare two objects make special provision so that numeric values of different types compare as expected. This assert succeeds: Assert.AreEqual(5, 5.0); Comparing Floating Point Values Values of type float and double are compared using an additional argument that indicates a tolerance within which they will be considered as equal. Special values are handled so that the following Asserts succeed: Assert.AreEqual(double.PositiveInfinity, double.PositiveInfinity); Assert.AreEqual(double.NegativeInfinity, double.NegativeInfinity); Assert.AreEqual(double.NaN, double.NaN); Comparing Arrays and Collections NUnit is able to compare single-dimensioned arrays, multi-dimensioned arrays, nested arrays (arrays of arrays) and collections. Two arrays or collections are considered equal if they have the same dimensions and if each pair of corresponding elements is equal. NUnit 3.0 adds the ability to compare generic collections and dictionaries. See Also Equal Constraint DefaultFloatingPointTolerance Attribute"
  },
  "articles/nunit/writing-tests/assertions/classic-assertions/Assert.AreNotEqual.html": {
    "href": "articles/nunit/writing-tests/assertions/classic-assertions/Assert.AreNotEqual.html",
    "title": "Assert.AreNotEqual | NUnit Docs",
    "keywords": "Assert.AreNotEqual Assert.AreNotEqual tests whether the two arguments are unequal. Assert.AreNotEqual(object expected, object actual); Assert.AreNotEqual(object expected, object actual, string message, params object[] params); See Assert.AreEqual for details of how NUnit performs equality comparisons. See Also Assert.AreEqual Equal Constraint"
  },
  "articles/nunit/writing-tests/assertions/classic-assertions/Assert.AreNotSame.html": {
    "href": "articles/nunit/writing-tests/assertions/classic-assertions/Assert.AreNotSame.html",
    "title": "Assert.AreNotSame | NUnit Docs",
    "keywords": "Assert.AreNotSame Assert.AreNotSame tests that the two arguments do not reference the same object. Assert.AreNotSame(object expected, object actual); Assert.AreNotSame(object expected, object actual, string message, params object[] params); See Also SameAs Constraint"
  },
  "articles/nunit/writing-tests/assertions/classic-assertions/Assert.AreSame.html": {
    "href": "articles/nunit/writing-tests/assertions/classic-assertions/Assert.AreSame.html",
    "title": "Assert.AreSame | NUnit Docs",
    "keywords": "Assert.AreSame Assert.AreSame tests that the two arguments reference the same object. Assert.AreSame(object expected, object actual); Assert.AreSame(object expected, object actual, string message, params object[] params); See Also SameAs Constraint"
  },
  "articles/nunit/writing-tests/assertions/classic-assertions/Assert.Catch.html": {
    "href": "articles/nunit/writing-tests/assertions/classic-assertions/Assert.Catch.html",
    "title": "Assert.Catch | NUnit Docs",
    "keywords": "Assert.Catch Assert.Catch is similar to Assert.Throws but will pass for an exception that is derived from the one specified. Exception Assert.Catch(TestDelegate code); Exception Assert.Catch(TestDelegate code, string message, params object[] params); Exception Assert.Catch(Type expectedExceptionType, TestDelegate code); Exception Assert.Catch(Type expectedExceptionType, TestDelegate code, string message, params object[] params); T Assert.Catch<T>(TestDelegate code); T Assert.Catch<T>(TestDelegate code, string message, params object[] params); See Also Assert.CatchAsync Assert.Throws Assert.ThrowsAsync ThrowsConstraint"
  },
  "articles/nunit/writing-tests/assertions/classic-assertions/Assert.CatchAsync.html": {
    "href": "articles/nunit/writing-tests/assertions/classic-assertions/Assert.CatchAsync.html",
    "title": "Assert.CatchAsync | NUnit Docs",
    "keywords": "Assert.CatchAsync Assert.CatchAsync is similar to Assert.ThrowsAsync but will pass for an exception that is derived from the one specified. Exception Assert.CatchAsync(AsyncTestDelegate code); Exception Assert.CatchAsync(AsyncTestDelegate code, string message, params object[] params); Exception Assert.CatchAsync(Type expectedExceptionType, AsyncTestDelegate code); Exception Assert.CatchAsync(Type expectedExceptionType, AsyncTestDelegate code, string message, params object[] params); T Assert.CatchAsync<T>(AsyncTestDelegate code); T Assert.CatchAsync<T>(AsyncTestDelegate code, string message, params object[] params); See Also Assert.Catch Assert.Throws Assert.ThrowsAsync ThrowsConstraint"
  },
  "articles/nunit/writing-tests/assertions/classic-assertions/Assert.Contains.html": {
    "href": "articles/nunit/writing-tests/assertions/classic-assertions/Assert.Contains.html",
    "title": "Assert.Contains | NUnit Docs",
    "keywords": "Assert.Contains Assert.Contains is used to test whether an object is contained in a collection. Assert.Contains(object anObject, ICollection collection); Assert.Contains(object anObject, ICollection collection, string message, params object[] params); See Also CollectionContainsConstraint"
  },
  "articles/nunit/writing-tests/assertions/classic-assertions/Assert.DoesNotThrow.html": {
    "href": "articles/nunit/writing-tests/assertions/classic-assertions/Assert.DoesNotThrow.html",
    "title": "Assert.DoesNotThrow | NUnit Docs",
    "keywords": "Assert.DoesNotThrow Assert.DoesNotThrow verifies that the delegate provided as an argument does not throw an exception. See Assert.DoesNotThrowAsync for asynchronous code. void Assert.DoesNotThrow(TestDelegate code); void Assert.DoesNotThrow(TestDelegate code, string message, params object[] params); See Also Assert.Throws ThrowsConstraint"
  },
  "articles/nunit/writing-tests/assertions/classic-assertions/Assert.DoesNotThrowAsync.html": {
    "href": "articles/nunit/writing-tests/assertions/classic-assertions/Assert.DoesNotThrowAsync.html",
    "title": "Assert.DoesNotThrowAsync | NUnit Docs",
    "keywords": "Assert.DoesNotThrowAsync Assert.DoesNotThrowAsync verifies that the delegate provided as an argument does not throw an exception. See Assert.DoesNotThrow for synchronous code. void Assert.DoesNotThrowAsync(AsyncTestDelegate code); void Assert.DoesNotThrowAsync(AsyncTestDelegate code, string message, params object[] params); See Also Assert.ThrowsAsync ThrowsConstraint"
  },
  "articles/nunit/writing-tests/assertions/classic-assertions/Assert.Fail.html": {
    "href": "articles/nunit/writing-tests/assertions/classic-assertions/Assert.Fail.html",
    "title": "Assert.Fail | NUnit Docs",
    "keywords": "Assert.Fail The Assert.Fail method provides you with the ability to generate a failure based on tests that are not encapsulated by the other methods. It is also useful in developing your own project-specific assertions. Assert.Fail(); Assert.Fail(string message, params object[] params); Here's an example of its use to create a private assertion that tests whether a string contains an expected value. public void AssertStringContains(string expected, string actual) { AssertStringContains(expected, actual, string.Empty); } public void AssertStringContains(string expected, string actual, string message) { if (actual.IndexOf(expected) < 0) Assert.Fail(message); } See Also Assert.Pass Assert.Ignore Assert.Inconclusive"
  },
  "articles/nunit/writing-tests/assertions/classic-assertions/Assert.False.html": {
    "href": "articles/nunit/writing-tests/assertions/classic-assertions/Assert.False.html",
    "title": "Assert.False | NUnit Docs",
    "keywords": "Assert.False Assert.False and Assert.IsFalse test that the specified condition is false. The two forms are provided for compatibility with past versions of NUnit and NUnitLite. Assert.False(bool condition); Assert.False(bool condition, string message, params object[] params); Assert.IsFalse(bool condition); Assert.IsFalse(bool condition, string message, params object[] params); See Also Condition Constraints"
  },
  "articles/nunit/writing-tests/assertions/classic-assertions/Assert.Greater.html": {
    "href": "articles/nunit/writing-tests/assertions/classic-assertions/Assert.Greater.html",
    "title": "Assert.Greater | NUnit Docs",
    "keywords": "Assert.Greater Assert.Greater tests whether one object is greater than another. Contrary to the normal order of Asserts, these methods are designed to be read in the \"natural\" English-language or mathematical order. Thus Assert.Greater(x, y) asserts that x is greater than y (x > y). Assert.Greater(int arg1, int arg2); Assert.Greater(int arg1, int arg2, string message, params object[] params); Assert.Greater(uint arg1, uint arg2); Assert.Greater(uint arg1, uint arg2, string message, params object[] params); Assert.Greater(long arg1, long arg2); Assert.Greater(long arg1, long arg2, string message, params object[] params); Assert.Greater(ulong arg1, ulong arg2); Assert.Greater(ulong arg1, ulong arg2, string message, params object[] params); Assert.Greater(decimal arg1, decimal arg2); Assert.Greater(decimal arg1, decimal arg2, string message, params object[] params); Assert.Greater(double arg1, double arg2); Assert.Greater(double arg1, double arg2, string message, params object[] params); Assert.Greater(float arg1, float arg2); Assert.Greater(float arg1, float arg2, string message, params object[] params); Assert.Greater(IComparable arg1, IComparable arg2); Assert.Greater(IComparable arg1, IComparable arg2, string message, params object[] params); See Also Assert.GreaterOrEqual Assert.Less Assert.LessOrEqual Comparison Constraints"
  },
  "articles/nunit/writing-tests/assertions/classic-assertions/Assert.GreaterOrEqual.html": {
    "href": "articles/nunit/writing-tests/assertions/classic-assertions/Assert.GreaterOrEqual.html",
    "title": "Assert.GreaterOrEqual | NUnit Docs",
    "keywords": "Assert.GreaterOrEqual Assert.GreaterOrEqual tests whether one object is greater than or equal to another. Contrary to the normal order of Asserts, these methods are designed to be read in the \"natural\" English-language or mathematical order. Thus Assert.GreaterOrEqual(x, y) asserts that x is greater than or equal to y (x >= y). Assert.GreaterOrEqual(int arg1, int arg2); Assert.GreaterOrEqual(int arg1, int arg2, string message, params object[] params); Assert.GreaterOrEqual(uint arg1, uint arg2); Assert.GreaterOrEqual(uint arg1, uint arg2, string message, params object[] params); Assert.GreaterOrEqual(long arg1, long arg2); Assert.GreaterOrEqual(long arg1, long arg2, string message, params object[] params); Assert.GreaterOrEqual(ulong arg1, ulong arg2); Assert.GreaterOrEqual(ulong arg1, ulong arg2, string message, params object[] params); Assert.GreaterOrEqual(decimal arg1, decimal arg2); Assert.GreaterOrEqual(decimal arg1, decimal arg2, string message, params object[] params); Assert.GreaterOrEqual(double arg1, double arg2); Assert.GreaterOrEqual(double arg1, double arg2, string message, params object[] params); Assert.GreaterOrEqual(float arg1, float arg2); Assert.GreaterOrEqual(float arg1, float arg2, string message, params object[] params); Assert.GreaterOrEqual(IComparable arg1, IComparable arg2); Assert.GreaterOrEqual(IComparable arg1, IComparable arg2, string message, params object[] params); See Also Assert.Greater Assert.Less Assert.LessOrEqual Comparison Constraints"
  },
  "articles/nunit/writing-tests/assertions/classic-assertions/Assert.Ignore.html": {
    "href": "articles/nunit/writing-tests/assertions/classic-assertions/Assert.Ignore.html",
    "title": "Assert.Ignore | NUnit Docs",
    "keywords": "Assert.Ignore The Assert.Ignore method provides you with the ability to dynamically cause a test or suite to be ignored at runtime. It may be called in a test, setup or fixture setup method. We recommend that you use this only in isolated cases. The category facility is provided for more extensive inclusion or exclusion of tests or you may elect to simply divide tests run on different occasions into different assemblies. Assert.Ignore(); Assert.Ignore(string message, params object[] params); See Also Assert.Pass Assert.Fail Assert.Inconclusive"
  },
  "articles/nunit/writing-tests/assertions/classic-assertions/Assert.Inconclusive.html": {
    "href": "articles/nunit/writing-tests/assertions/classic-assertions/Assert.Inconclusive.html",
    "title": "Assert.Inconclusive | NUnit Docs",
    "keywords": "Assert.Inconclusive The Assert.Inconclusive method indicates that the test could not be completed with the data available. It should be used in situations where another run with different data might run to completion, with either a success or failure outcome. Assert.Inconclusive(); Assert.Inconclusive(string message, params object[] params); See Also Assert.Pass Assert.Fail Assert.Ignore"
  },
  "articles/nunit/writing-tests/assertions/classic-assertions/Assert.IsAssignableFrom.html": {
    "href": "articles/nunit/writing-tests/assertions/classic-assertions/Assert.IsAssignableFrom.html",
    "title": "Assert.IsAssignableFrom | NUnit Docs",
    "keywords": "Assert.IsAssignableFrom Assert.IsAssignableFrom succeeds if the object provided may be assigned a value of the expected type. Assert.IsAssignableFrom(Type expected, object actual); Assert.IsAssignableFrom(Type expected, object actual, string message, params object[] params); Assert.IsAssignableFrom<T>(object actual); Assert.IsAssignableFrom<T>(object actual, string message, params object[] params); See Also Type Constraints"
  },
  "articles/nunit/writing-tests/assertions/classic-assertions/Assert.IsEmpty.html": {
    "href": "articles/nunit/writing-tests/assertions/classic-assertions/Assert.IsEmpty.html",
    "title": "Assert.IsEmpty | NUnit Docs",
    "keywords": "Assert.IsEmpty Assert.IsEmpty may be used to test either a string or a collection or IEnumerable. When used with a string, it succeeds if the string is the empty string. When used with a collection, it succeeds if the collection is empty. Assert.IsEmpty(string aString); Assert.IsEmpty(string aString, string message, params object[] args); Assert.IsEmpty(IEnumerable collection); Assert.IsEmpty(IEnumerable collection, string message, params object[] args); Note When used with an IEnumerable that is not also an ICollection, Assert.IsEmpty attempts to enumerate the contents. It should not be used in cases where this results in an unwanted side effect. See Also Condition Constraints"
  },
  "articles/nunit/writing-tests/assertions/classic-assertions/Assert.IsInstanceOf.html": {
    "href": "articles/nunit/writing-tests/assertions/classic-assertions/Assert.IsInstanceOf.html",
    "title": "Assert.IsInstanceOf | NUnit Docs",
    "keywords": "Assert.IsInstanceOf Assert.IsInstanceOf succeeds if the object provided as an actual value is an instance of the expected type. Assert.IsInstanceOf(Type expected, object actual); Assert.IsInstanceOf(Type expected, object actual, string message, params object[] params); Assert.IsInstanceOf<T>(object actual); Assert.IsInstanceOf<T>(object actual, string message, params object[] params); See Also Type Constraints"
  },
  "articles/nunit/writing-tests/assertions/classic-assertions/Assert.IsNaN.html": {
    "href": "articles/nunit/writing-tests/assertions/classic-assertions/Assert.IsNaN.html",
    "title": "Assert.IsNaN | NUnit Docs",
    "keywords": "Assert.IsNaN Assert.IsNaN tests that the specified double value is NaN. Assert.IsNaN(double aDouble); Assert.IsNaN(double aDouble, string message, params object[] params); See Also Condition Constraints"
  },
  "articles/nunit/writing-tests/assertions/classic-assertions/Assert.IsNotAssignableFrom.html": {
    "href": "articles/nunit/writing-tests/assertions/classic-assertions/Assert.IsNotAssignableFrom.html",
    "title": "Assert.IsNotAssignableFrom | NUnit Docs",
    "keywords": "Assert.IsNotAssignableFrom Assert.IsNotAssignableFrom succeeds if the object provided may not be assigned a value of the expected type. Assert.IsNotAssignableFrom(Type expected, object actual); Assert.IsNotAssignableFrom(Type expected, object actual, string message, params object[] params); Assert.IsNotAssignableFrom<T>(object actual); Assert.IsNotAssignableFrom<T>(object actual, string message, params object[] params); See also Type Constraints"
  },
  "articles/nunit/writing-tests/assertions/classic-assertions/Assert.IsNotEmpty.html": {
    "href": "articles/nunit/writing-tests/assertions/classic-assertions/Assert.IsNotEmpty.html",
    "title": "Assert.IsNotEmpty | NUnit Docs",
    "keywords": "Assert.IsNotEmpty Assert.IsNotEmpty may be used to test either a string or a collection or IEnumerable. When used with a string, it succeeds if the string is not the empty string. When used with a collection, it succeeds if the collection is not empty. Assert.IsNotEmpty(string aString); Assert.IsNotEmpty(string aString, string message, params object[] args); Assert.IsNotEmpty(IEnumerable collection); Assert.IsNotEmpty(IEnumerable collection, string message, params object[] args); Note When used with an IEnumerable that is not also an ICollection, Assert.IsEmpty attempts to enumerate the contents. It should not be used in cases where this results in an unwanted side effect. See Also Condition Constraints"
  },
  "articles/nunit/writing-tests/assertions/classic-assertions/Assert.IsNotInstanceOf.html": {
    "href": "articles/nunit/writing-tests/assertions/classic-assertions/Assert.IsNotInstanceOf.html",
    "title": "Assert.IsNotInstanceOf | NUnit Docs",
    "keywords": "Assert.IsNotInstanceOf Assert.IsNotInstanceOf succeeds if the object provided as an actual value is not an instance of the expected type. Assert.IsNotInstanceOf(Type expected, object actual); Assert.IsNotInstanceOf(Type expected, object actual, string message, params object[] params); Assert.IsNotInstanceOf<T>(object actual); Assert.IsNotInstanceOf<T>(object actual, string message, params object[] params); See Also Type Constraints"
  },
  "articles/nunit/writing-tests/assertions/classic-assertions/Assert.Less.html": {
    "href": "articles/nunit/writing-tests/assertions/classic-assertions/Assert.Less.html",
    "title": "Assert.Less | NUnit Docs",
    "keywords": "Assert.Less Assert.Less tests whether one object is less than another. Contrary to the normal order of Asserts, these methods are designed to be read in the \"natural\" English-language or mathematical order. Thus Assert.Less(x, y) asserts that x is less than y (x < y). Assert.Less(int arg1, int arg2); Assert.Less(int arg1, int arg2, string message, params object[] params); Assert.Less(uint arg1, uint arg2); Assert.Less(uint arg1, uint arg2, string message, params object[] params); Assert.Less(long arg1, long arg2); Assert.Less(long arg1, long arg2, string message, params object[] params); Assert.Less(ulong arg1, ulong arg2); Assert.Less(ulong arg1, ulong arg2, string message, params object[] params); Assert.Less(decimal arg1, decimal arg2); Assert.Less(decimal arg1, decimal arg2, string message, params object[] params); Assert.Less(double arg1, double arg2); Assert.Less(double arg1, double arg2, string message, params object[] params); Assert.Less(float arg1, float arg2); Assert.Less(float arg1, float arg2, string message, params object[] params); Assert.Less(IComparable arg1, IComparable arg2); Assert.Less(IComparable arg1, IComparable arg2, string message, params object[] params); See Also Assert.Greater Assert.GreaterOrEqual Assert.LessOrEqual Comparison Constraints"
  },
  "articles/nunit/writing-tests/assertions/classic-assertions/Assert.LessOrEqual.html": {
    "href": "articles/nunit/writing-tests/assertions/classic-assertions/Assert.LessOrEqual.html",
    "title": "Assert.LessOrEqual | NUnit Docs",
    "keywords": "Assert.LessOrEqual Assert.LessOrEqual tests whether one object is less than or equal to another. Contrary to the normal order of Asserts, these methods are designed to be read in the \"natural\" English-language or mathematical order. Thus Assert.LessOrEqual(x, y) asserts that x is less than or equal to y (x <= y). Assert.LessOrEqual(int arg1, int arg2); Assert.LessOrEqual(int arg1, int arg2, string message, params object[] params); Assert.LessOrEqual(uint arg1, uint arg2); Assert.LessOrEqual(uint arg1, uint arg2, string message, params object[] params); Assert.LessOrEqual(long arg1, long arg2); Assert.LessOrEqual(long arg1, long arg2, string message, params object[] params); Assert.LessOrEqual(ulong arg1, ulong arg2); Assert.LessOrEqual(ulong arg1, ulong arg2, string message, params object[] params); Assert.LessOrEqual(decimal arg1, decimal arg2); Assert.LessOrEqual(decimal arg1, decimal arg2, string message, params object[] params); Assert.LessOrEqual(double arg1, double arg2); Assert.LessOrEqual(double arg1, double arg2, string message, params object[] params); Assert.LessOrEqual(float arg1, float arg2); Assert.LessOrEqual(float arg1, float arg2, string message, params object[] params); Assert.LessOrEqual(IComparable arg1, IComparable arg2); Assert.LessOrEqual(IComparable arg1, IComparable arg2, string message, params object[] params); See Also Assert.Greater Assert.GreaterOrEqual Assert.Less Comparison Constraints"
  },
  "articles/nunit/writing-tests/assertions/classic-assertions/Assert.Negative.html": {
    "href": "articles/nunit/writing-tests/assertions/classic-assertions/Assert.Negative.html",
    "title": "Assert.Negative | NUnit Docs",
    "keywords": "Assert.Negative Asserts that a number is negative. //true Assert.Negative(-1); //false Assert.Negative(1); All the overloads of the method are Assert.Negative(int actual); Assert.Negative(int actual, string message, params object[] args); Assert.Negative(uint actual); Assert.Negative(uint actual, string message, params object[] args); Assert.Negative(long actual); Assert.Negative(long actual, string message, params object[] args); Assert.Negative(ulong actual); Assert.Negative(ulong actual, string message, params object[] args); Assert.Negative(decimal actual); Assert.Negative(decimal actual, string message, params object[] args); Assert.Negative(double actual); Assert.Negative(double actual, string message, params object[] args); Assert.Negative(float actual); Assert.Negative(float actual, string message, params object[] args); You may also use Assert.That with a Is.Negative constraint to achieve the same result. See Also Assert.Positive Assert.Zero Assert.NotZero Assert.IsNaN"
  },
  "articles/nunit/writing-tests/assertions/classic-assertions/Assert.NotNull.html": {
    "href": "articles/nunit/writing-tests/assertions/classic-assertions/Assert.NotNull.html",
    "title": "Assert.NotNull | NUnit Docs",
    "keywords": "Assert.NotNull Assert.NotNull and Assert.IsNotNull test that the specified object is non-null. The two forms are provided for compatibility with past versions of NUnit and NUnitLite. Assert.NotNull(object anObject); Assert.NotNull(object anObject, string message, params object[] params); Assert.IsNotNull(object anObject); Assert.IsNotNull(object anObject, string message, params object[] params); See Also Condition Constraints"
  },
  "articles/nunit/writing-tests/assertions/classic-assertions/Assert.NotZero.html": {
    "href": "articles/nunit/writing-tests/assertions/classic-assertions/Assert.NotZero.html",
    "title": "Assert.NotZero | NUnit Docs",
    "keywords": "Assert.NotZero Assert.NotZero tests that a value is not zero. Assert.NotZero(int actual); Assert.NotZero(int actual, string message, params object[] args); Assert.NotZero(uint actual); Assert.NotZero(uint actual, string message, params object[] args); Assert.NotZero(long actual); Assert.NotZero(long actual, string message, params object[] args); Assert.NotZero(ulong actual); Assert.NotZero(ulong actual, string message, params object[] args); Assert.NotZero(decimal actual); Assert.NotZero(decimal actual, string message, params object[] args); Assert.NotZero(double actual); Assert.NotZero(double actual, string message, params object[] args); Assert.NotZero(float actual); Assert.NotZero(float actual, string message, params object[] args); You may also use Assert.That with a Is.Not.Zero constraint to achieve the same result."
  },
  "articles/nunit/writing-tests/assertions/classic-assertions/Assert.Null.html": {
    "href": "articles/nunit/writing-tests/assertions/classic-assertions/Assert.Null.html",
    "title": "Assert.Null | NUnit Docs",
    "keywords": "Assert.Null Assert.Null and Assert.IsNull test that the specified object is null. The two forms are provided for compatibility with past versions of NUnit and NUnitLite. Assert.Null(object anObject); Assert.Null(object anObject, string message, params object[] params); Assert.IsNull(object anObject); Assert.IsNull(object anObject, string message, params object[] params); See Also Condition Constraints"
  },
  "articles/nunit/writing-tests/assertions/classic-assertions/Assert.Pass.html": {
    "href": "articles/nunit/writing-tests/assertions/classic-assertions/Assert.Pass.html",
    "title": "Assert.Pass | NUnit Docs",
    "keywords": "Assert.Pass The Assert.Pass method allows you to immediately end the test, recording it as successful. Since it causes an exception to be thrown, it is more efficient to simply allow the test to return. However, Assert.Pass allows you to record a message in the test result and may also make the test easier to read in some situations. Additionally, like the other methods on this page, it can be invoked from a nested method call with the result of immediately terminating test execution. Assert.Pass(); Assert.Pass(string message, params object[] params); See Also Assert.Fail Assert.Ignore Assert.Inconclusive"
  },
  "articles/nunit/writing-tests/assertions/classic-assertions/Assert.Positive.html": {
    "href": "articles/nunit/writing-tests/assertions/classic-assertions/Assert.Positive.html",
    "title": "Assert.Positive | NUnit Docs",
    "keywords": "Assert.Positive Asserts that a number is positive. //false Assert.Positive(-1); //true Assert.Positive(1); All the overloads of the method are Assert.Positive(int actual); Assert.Positive(int actual, string message, params object[] args); Assert.Positive(uint actual); Assert.Positive(uint actual, string message, params object[] args); Assert.Positive(long actual); Assert.Positive(long actual, string message, params object[] args); Assert.Positive(ulong actual); Assert.Positive(ulong actual, string message, params object[] args); Assert.Positive(decimal actual); Assert.Positive(decimal actual, string message, params object[] args); Assert.Positive(double actual); Assert.Positive(double actual, string message, params object[] args); Assert.Positive(float actual); Assert.Positive(float actual, string message, params object[] args); You may also use Assert.That with a Is.Positive constraint to achieve the same result. See Also Assert.Negative Assert.Zero Assert.NotZero Assert.IsNaN"
  },
  "articles/nunit/writing-tests/assertions/classic-assertions/Assert.Throws.html": {
    "href": "articles/nunit/writing-tests/assertions/classic-assertions/Assert.Throws.html",
    "title": "Assert.Throws | NUnit Docs",
    "keywords": "Assert.Throws The Assert.Throws method is pretty much in a class by itself. Rather than comparing values, it attempts to invoke a code snippet, represented as a delegate, in order to verify that it throws a particular exception. It's also in a class by itself in that it returns an Exception, rather than void, if the Assert is successful. See the example below for a few ways to use this. Assert.Throws may be used with a constraint argument, which is applied to the actual exception thrown, or with the Type of exception expected. The Type format is available in both a non-generic and generic form. If the code under test is async, you must use Assert.ThrowsAsync . Exception Assert.Throws(Type expectedExceptionType, TestDelegate code); Exception Assert.Throws(Type expectedExceptionType, TestDelegate code, string message, params object[] params); Exception Assert.Throws(IResolveConstraint constraint, TestDelegate code); Exception Assert.Throws(IResolveConstraint constraint, TestDelegate code, string message, params object[] params); Assert.Throws<T>(TestDelegate code); Assert.Throws<T>(TestDelegate code, string message, params object[] params); In the above code TestDelegate is a delegate of the form void TestDelegate() , which is used to execute the code in question. This may be an anonymous delegate or, when compiling under C# 3.0 or greater, a lambda expression. The following example shows different ways of writing the same test. [TestFixture] public class AssertThrowsTests { [Test] public void Tests() { // Using a method as a delegate Assert.Throws<ArgumentException>(MethodThatThrows); // Using an anonymous delegate Assert.Throws<ArgumentException>( delegate { throw new ArgumentException(); }); // Using a Lambda expression Assert.Throws<ArgumentException>( () => { throw new ArgumentException(); }); } void MethodThatThrows() { throw new ArgumentException(); } } This example shows use of the return value to perform additional verification of the exception. [TestFixture] public class UsingReturnValue { [Test] public void TestException() { MyException ex = Assert.Throws<MyException>( delegate { throw new MyException(\"message\", 42); }); Assert.That(ex.Message, Is.EqualTo(\"message\")); Assert.That(ex.MyParam, Is.EqualTo(42)); } } This example does the same thing using the overload that includes a constraint. [TestFixture] public class UsingConstraint { [Test] public void TestException() { Assert.Throws(Is.TypeOf<MyException>() .And.Message.EqualTo(\"message\") .And.Property(\"MyParam\").EqualTo(42), delegate { throw new MyException(\"message\", 42); }); } } Use the form that matches your style of coding. Exact Versus Derived Types When used with a Type argument, Assert.Throws requires that exact type to be thrown. If you want to test for any derived Type, use one of the forms that allows specifying a constraint. Alternatively, you may use Assert.Catch , which differs from Assert.Throws in allowing derived types. See the following code for examples: // Require an ApplicationException - derived types fail! Assert.Throws(typeof(ApplicationException), code); Assert.Throws<ApplicationException>()(code); // Allow both ApplicationException and any derived type Assert.Throws(Is.InstanceOf(typeof(ApplicationException), code); Assert.Throws(Is.InstanceOf<ApplicationException>;(), code); // Allow both ApplicationException and any derived type Assert.Catch<ApplicationException>(code); // Allow any kind of exception Assert.Catch(code); See Also Assert.Catch Assert.CatchAsync Assert.ThrowsAsync ThrowsConstraint"
  },
  "articles/nunit/writing-tests/assertions/classic-assertions/Assert.ThrowsAsync.html": {
    "href": "articles/nunit/writing-tests/assertions/classic-assertions/Assert.ThrowsAsync.html",
    "title": "Assert.ThrowsAsync | NUnit Docs",
    "keywords": "Assert.ThrowsAsync The Assert.ThrowsAsync is the async equivalent to Assert.Throws for asynchronous code. See Assert.Throws for more information. Exception Assert.ThrowsAsync(Type expectedExceptionType, AsyncTestDelegate code); Exception Assert.ThrowsAsync(Type expectedExceptionType, AsyncTestDelegate code, string message, params object[] params); Exception Assert.ThrowsAsync(IResolveConstraint constraint, AsyncTestDelegate code); Exception Assert.ThrowsAsync(IResolveConstraint constraint, AsyncTestDelegate code, string message, params object[] params); TActual Assert.ThrowsAsync<TActual>(AsyncTestDelegate code); TActual Assert.ThrowsAsync<TActual>(AsyncTestDelegate code, string message, params object[] params); In the above code AsyncTestDelegate is a delegate of the form Task AsyncTestDelegate() , which is used to execute the code in question. This will likely be a lambda expression. The following example shows the most common way of writing tests. [TestFixture] public class AssertThrowsTests { [Test] public void Tests() { // Using a method as a delegate Assert.ThrowsAsync<ArgumentException>(async () => await MethodThatThrows()); } async Task MethodThatThrows() { await Task.Delay(100); throw new ArgumentException(); } } This example shows use of the return value to perform additional verification of the exception. Note that you do not need to await the result. [TestFixture] public class UsingReturnValue { [Test] public async Task TestException() { MyException ex = Assert.ThrowsAsync<MyException>(async () => await MethodThatThrows()); Assert.That(ex.Message, Is.EqualTo(\"message\")); Assert.That(ex.MyParam, Is.EqualTo(42)); } } See Also Assert.Catch Assert.CatchAsync Assert.Throws ThrowsConstraint"
  },
  "articles/nunit/writing-tests/assertions/classic-assertions/Assert.True.html": {
    "href": "articles/nunit/writing-tests/assertions/classic-assertions/Assert.True.html",
    "title": "Assert.True | NUnit Docs",
    "keywords": "Assert.True Assert.True and Assert.IsTrue test that the specified condition is true. The two forms are provided for compatibility with past versions of NUnit and NUnitLite. Assert.True(bool condition); Assert.True(bool condition, string message, params object[] params); Assert.IsTrue(bool condition); Assert.IsTrue(bool condition, string message, params object[] params); You may also use Assert.That with a boolean argument to achieve the same result. See Also Condition Constraints"
  },
  "articles/nunit/writing-tests/assertions/classic-assertions/Assert.Zero.html": {
    "href": "articles/nunit/writing-tests/assertions/classic-assertions/Assert.Zero.html",
    "title": "Assert.Zero | NUnit Docs",
    "keywords": "Assert.Zero Assert.Zero tests that a value is zero. Assert.Zero(int actual); Assert.Zero(int actual, string message, params object[] args); Assert.Zero(uint actual); Assert.Zero(uint actual, string message, params object[] args); Assert.Zero(long actual); Assert.Zero(long actual, string message, params object[] args); Assert.Zero(ulong actual); Assert.Zero(ulong actual, string message, params object[] args); Assert.Zero(decimal actual); Assert.Zero(decimal actual, string message, params object[] args); Assert.Zero(double actual); Assert.Zero(double actual, string message, params object[] args); Assert.Zero(float actual); Assert.Zero(float actual, string message, params object[] args); You may also use Assert.That with a Is.Zero constraint to achieve the same result."
  },
  "articles/nunit/writing-tests/assertions/classic-assertions/Collection-Assert.html": {
    "href": "articles/nunit/writing-tests/assertions/classic-assertions/Collection-Assert.html",
    "title": "CollectionAssert | NUnit Docs",
    "keywords": "CollectionAssert The CollectionAssert class provides a number of methods that are useful when examining collections and their contents or for comparing two collections. These methods may be used with any object implementing IEnumerable . The AreEqual overloads succeed if the corresponding elements of the two collections are equal. AreEquivalent tests whether the collection contents are equal, but without regard to order. In both cases, elements are compared using NUnit's default equality comparison. CollectionAssert.AllItemsAreInstancesOfType(IEnumerable collection, Type expectedType); CollectionAssert.AllItemsAreInstancesOfType( IEnumerable collection, Type expectedType, string message, params object[] args); CollectionAssert.AllItemsAreNotNull(IEnumerable collection); CollectionAssert.AllItemsAreNotNull( IEnumerable collection, string message, params object[] args); CollectionAssert.AllItemsAreUnique(IEnumerable collection); CollectionAssert.AllItemsAreUnique( IEnumerable collection, string message, params object[] args); CollectionAssert.AreEqual(IEnumerable expected, IEnumerable actual); CollectionAssert.AreEqual( IEnumerable expected, IEnumerable actual, string message, params object[] args); CollectionAssert.AreEquivalent(IEnumerable expected, IEnumerable actual); CollectionAssert.AreEquivalent( IEnumerable expected, IEnumerable actual, string message, params object[] args); CollectionAssert.AreNotEqual(IEnumerable expected, IEnumerable actual); CollectionAssert.AreNotEqual( IEnumerable expected, IEnumerable actual, string message, params object[] args); CollectionAssert.AreNotEquivalent(IEnumerable expected, IEnumerable actual); CollectionAssert.AreNotEquivalent( IEnumerable expected, IEnumerable actual, string message, params object[] args); CollectionAssert.Contains(IEnumerable expected, object actual); CollectionAssert.Contains( IEnumerable expected, object actual, string message, params object[] args); CollectionAssert.DoesNotContain(IEnumerable expected, object actual); CollectionAssert.DoesNotContain( IEnumerable expected, object actual, string message, params object[] args); CollectionAssert.IsSubsetOf(IEnumerable subset, IEnumerable superset); CollectionAssert.IsSubsetOf( IEnumerable subset, IEnumerable superset, string message, params object[] args); CollectionAssert.IsNotSubsetOf(IEnumerable subset, IEnumerable superset); CollectionAssert.IsNotSubsetOf( IEnumerable subset, IEnumerable superset, string message, params object[] args); CollectionAssert.IsEmpty(IEnumerable collection); CollectionAssert.IsEmpty( IEnumerable collection, string message, params object[] args); CollectionAssert.IsNotEmpty(IEnumerable collection); CollectionAssert.IsNotEmpty( IEnumerable collection, string message, params object[] args); CollectionAssert.IsOrdered(IEnumerable collection); CollectionAssert.IsOrdered( IEnumerable collection, string message, params object[] args); CollectionAssert.IsOrdered(IEnumerable collection, IComparer comparer); CollectionAssert.IsOrdered(IEnumerable collection, IComparer comparer, string message, params object[] args); See Also Collection Constraints"
  },
  "articles/nunit/writing-tests/assertions/classic-assertions/Directory-Assert.html": {
    "href": "articles/nunit/writing-tests/assertions/classic-assertions/Directory-Assert.html",
    "title": "DirectoryAssert | NUnit Docs",
    "keywords": "DirectoryAssert The DirectoryAssert class provides methods for comparing two directories or verifying the existence of a directory. Directories may be provided as DirectoryInfos or as strings giving the path to each directory. DirectoryAssert.AreEqual(DirectoryInfo expected, DirectoryInfo actual); DirectoryAssert.AreEqual(DirectoryInfo expected, DirectoryInfo actual, string message, params object[] args); DirectoryAssert.AreNotEqual(DirectoryInfo expected, DirectoryInfo actual); DirectoryAssert.AreNotEqual(DirectoryInfo expected, DirectoryInfo actual, string message, params object[] args); DirectoryAssert.Exists(DirectoryInfo actual); DirectoryAssert.Exists(DirectoryInfo actual, string message, params object[] args); DirectoryAssert.Exists(string actual); DirectoryAssert.Exists(string actual, string message, params object[] args); DirectoryAssert.DoesNotExist(DirectoryInfo actual); DirectoryAssert.DoesNotExist(DirectoryInfo actual, string message, params object[] args); DirectoryAssert.DoesNotExist(string actual); DirectoryAssert.DoesNotExist(string actual, string message, params object[] args); See Also File and Directory Constraints"
  },
  "articles/nunit/writing-tests/assertions/classic-assertions/File-Assert.html": {
    "href": "articles/nunit/writing-tests/assertions/classic-assertions/File-Assert.html",
    "title": "FileAssert | NUnit Docs",
    "keywords": "FileAssert The FileAssert class provides methods for comparing or verifying the existence of files, which may be provided as Streams, as FileInfos or as strings giving the path to each file. FileAssert.AreEqual(Stream expected, Stream actual); FileAssert.AreEqual( Stream expected, Stream actual, string message, params object[] args); FileAssert.AreEqual(FileInfo expected, FileInfo actual); FileAssert.AreEqual( FileInfo expected, FileInfo actual, string message, params object[] args); FileAssert.AreEqual(string expected, string actual); FileAssert.AreEqual( string expected, string actual, string message, params object[] args); FileAssert.AreNotEqual(Stream expected, Stream actual); FileAssert.AreNotEqual( Stream expected, Stream actual, string message, params object[] args); FileAssert.AreNotEqual(FileInfo expected, FileInfo actual); FileAssert.AreNotEqual( FileInfo expected, FileInfo actual, string message, params object[] args); FileAssert.AreNotEqual(string expected, string actual); FileAssert.AreNotEqual( string expected, string actual, string message, params object[] args); FileAssert.Exists(FileInfo actual); FileAssert.Exists( FileInfo actual, string message, params object[] args); FileAssert.Exists(string actual); FileAssert.Exists( string actual, string message, params object[] args); FileAssert.DoesNotExist(FileInfo actual); FileAssert.DoesNotExist( FileInfo actual, string message, params object[] args); FileAssert.DoesNotExist(string actual); FileAssert.DoesNotExist( string actual, string message, params object[] args); See Also File and Directory Constraints"
  },
  "articles/nunit/writing-tests/assertions/classic-assertions/String-Assert.html": {
    "href": "articles/nunit/writing-tests/assertions/classic-assertions/String-Assert.html",
    "title": "StringAssert | NUnit Docs",
    "keywords": "StringAssert The StringAssert class provides a number of methods that are useful when examining string values. StringAssert.Contains(string expected, string actual); StringAssert.Contains(string expected, string actual, string message, params object[] args); StringAssert.DoesNotContain(string expected, string actual); StringAssert.DoesNotContain(string expected, string actual, string message, params object[] args); StringAssert.StartsWith(string expected, string actual); StringAssert.StartsWith(string expected, string actual, string message, params object[] args); StringAssert.DoesNotStartsWith(string expected, string actual); StringAssert.DoesNotStartsWith(string expected, string actual, string message, params object[] args); StringAssert.EndsWith(string expected, string actual); StringAssert.EndsWith(string expected, string actual, string message, params object[] args); StringAssert.DoesNotEndWith(string expected, string actual); StringAssert.DoesNotEndWith(string expected, string actual, string message, params object[] args); StringAssert.AreEqualIgnoringCase(string expected, string actual); StringAssert.AreEqualIgnoringCase(string expected, string actual, string message params object[] args); StringAssert.AreNotEqualIgnoringCase(string expected, string actual); StringAssert.AreNotEqualIgnoringCase(string expected, string actual, string message params object[] args); StringAssert.IsMatch(string regexPattern, string actual); StringAssert.IsMatch(string regexPattern, string actual, string message, params object[] args); StringAssert.DoesNotMatch(string regexPattern, string actual); StringAssert.DoesNotMatch(string regexPattern, string actual, string message, params object[] args); See Also String Constraints"
  },
  "articles/nunit/writing-tests/assertions/multiple-asserts.html": {
    "href": "articles/nunit/writing-tests/assertions/multiple-asserts.html",
    "title": "Multiple Asserts | NUnit Docs",
    "keywords": "Multiple Asserts Usually, once an assertion fails, we want the test to terminate. But sometimes, it's desirable to continue and accumulate any additional failures so they may all be fixed at once. This is particularly useful for testing things like object initialization and UI appearance as well as certain kinds of integration testing. Syntax Multiple asserts are implemented using the Assert.Multiple method. Here is an example of its use: [Test] public void ComplexNumberTest() { ComplexNumber result = SomeCalculation(); Assert.Multiple(() => { Assert.AreEqual(5.2, result.RealPart, \"Real part\"); Assert.AreEqual(3.9, result.ImaginaryPart, \"Imaginary part\"); }); } Functionally, this results in NUnit storing any failures encountered in the block and reporting all of them together upon exit from the block. If both asserts failed, then both would be reported. The test itself would terminate at the end of the block if any failures were encountered, but would continue otherwise. Notes The multiple assert block may contain any arbitrary code, not just asserts. Multiple assert blocks may be nested. Failure is not reported until the outermost block exits. If the code in the block calls a method, that method may also contain multiple assert blocks. The test will be terminated immediately if any exception is thrown that is not handled. An unexpected exception is often an indication that the test itself is in error, so it must be terminated. If the exception occurs after one or more assertion failures have been recorded, those failures will be reported along with the terminating exception itself. Assert.Fail is handled just as any other assert failure. The message and stack trace are recorded but the test continues to execute until the end of the block. An error is reported if any of the following are used inside a multiple assert block: Assert.Pass Assert.Ignore Assert.Inconclusive Assume.That Use of Warnings (Assert.Warn, Warn.If, Warn.Unless) is permitted inside a multiple assert block. Warnings are reported normally along with any failures that occur inside the block. Runner Support Multiple assertion failures per test are stored in the representation of the test result using new XML elements, which are not recognized by older runners. The following runners are known to support display of the new elements: NUnit Console Runner 3.6 NUnit 3 Visual Studio Adapter 3.7 NUnit Gui Runner (under development) Compatibility Older runners generally display a single failure message and stack trace for each test. For compatibility purposes, the framework creates a single message that lists all the failures. The stack trace in such a case will indicate the end of the assert multiple block."
  },
  "articles/nunit/writing-tests/Assumptions.html": {
    "href": "articles/nunit/writing-tests/Assumptions.html",
    "title": "Assumptions | NUnit Docs",
    "keywords": "Assumptions Assumptions are intended to express the state a test must be in to provide a meaningful result. They are functionally similar to assertions, however a unmet assumption will produce an Inconclusive test result, as opposed to a Failure. Assumptions make use of the Assume static class. Syntax Assume.That(myString, Is.EqualTo(\"Hello\")); Assume.That() has the same set of overloads as Assert.That() . For further details there, see the Constraint Model documentation. Note Failing assumptions indicate that running tests is invalid, while Multiple Asserts allow testing to continue after a failure. For that reason, the two features are incompatible and assumptions may not be used within a multiple assert block."
  },
  "articles/nunit/writing-tests/attributes.html": {
    "href": "articles/nunit/writing-tests/attributes.html",
    "title": "Attributes | NUnit Docs",
    "keywords": "Attributes NUnit uses custom attributes to identify tests. All NUnit attributes are contained in the NUnit.Framework namespace. Each source file that contains tests must include a using statement for that namespace and the project must reference the framework assembly, nunit.framework.dll . This table lists all the attributes supported by NUnit. Attribute Usage Apartment Attribute Indicates that the test should run in a particular apartment. Author Attribute Provides the name of the test author. Category Attribute Specifies one or more categories for the test. Combinatorial Attribute Generates test cases for all possible combinations of the values provided. Culture Attribute Specifies cultures for which a test or fixture should be run. Datapoint Attribute Provides data for Theories . DatapointSource Attribute Provides data for Theories . DefaultFloatingPointTolerance Attribute Indicates that the test should use the specified tolerance as default for float and double comparisons. Description Attribute Applies descriptive text to a Test, TestFixture or Assembly. Explicit Attribute Indicates that a test should be skipped unless explicitly run. Ignore Attribute Indicates that a test shouldn't be run for some reason. LevelOfParallelism Attribute Specifies the level of parallelism at assembly level. MaxTime Attribute Specifies the maximum time in milliseconds for a test case to succeed. NonParallelizable Attribute Specifies that the test and its descendants may not be run in parallel. NonTestAssembly Attribute Specifies that the assembly references the NUnit framework, but that it does not contain tests. OneTimeSetUp Attribute Identifies methods to be called once prior to any child tests. OneTimeTearDown Attribute Identifies methods to be called once after all child tests. Order Attribute Specifies the order in which decorated test should be run within the containing fixture or suite. Pairwise Attribute Generate test cases for all possible pairs of the values provided. Parallelizable Attribute Indicates whether test and/or its descendants can be run in parallel. Platform Attribute Specifies platforms for which a test or fixture should be run. Property Attribute Allows setting named properties on any test case or fixture. Random Attribute Specifies generation of random values as arguments to a parameterized test. Range Attribute Specifies a range of values as arguments to a parameterized test. Repeat Attribute Specifies that the decorated method should be executed multiple times. RequiresThread Attribute Indicates that a test method, class or assembly should be run on a separate thread. Retry Attribute Causes a test to be rerun if it fails, up to a maximum number of times. Sequential Attribute Generates test cases using values in the order provided, without additional combinations. SetCulture Attribute Sets the current Culture for the duration of a test. SetUICulture Attribute Sets the current UI Culture for the duration of a test. SetUp Attribute Indicates a method of a TestFixture called just before each test method. SetUpFixture Attribute Marks a class with one-time setup or teardown methods for all the test fixtures in a namespace. SingleThreaded Attribute Marks a fixture that requires all its tests to run on the same thread. TearDown Attribute Indicates a method of a TestFixture called just after each test method. Test Attribute Marks a method of a TestFixture that represents a test. TestCase Attribute Marks a method with parameters as a test and provides inline arguments. TestCaseSource Attribute Marks a method with parameters as a test and provides a source of arguments. TestFixture Attribute Marks a class as a test fixture and may provide inline constructor arguments. TestFixtureSetup Attribute Deprecated synonym for OneTimeSetUp Attribute . TestFixtureSource Attribute Marks a class as a test fixture and provides a source for constructor arguments. TestFixtureTeardown Attribute Deprecated synonym for OneTimeTearDown Attribute . TestOf Attribute Indicates the name or Type of the class being tested. Theory Attribute Marks a test method as a Theory, a special kind of test in NUnit. Timeout Attribute Provides a timeout value in milliseconds for test cases. Values Attribute Provides a set of inline values for a parameter of a test method. ValueSource Attribute Provides a source of values for a parameter of a test method."
  },
  "articles/nunit/writing-tests/attributes/apartment.html": {
    "href": "articles/nunit/writing-tests/attributes/apartment.html",
    "title": "Apartment | NUnit Docs",
    "keywords": "Apartment The ApartmentAttribute is used on a test method, class or assembly to specify that the tests should be run in a particular apartment , either the STA or the MTA. When running tests in parallel, the test is simply scheduled to execute from a queue that uses the apartment specified. When the parallel feature is not in use, it causes creation of a new thread if the parent test is not already running in the correct apartment. When this attribute is not specified, tests run in the MTA. This attribute replaces the RequiresMTA and RequiresSTA attributes, which are now considered obsolete. Assembly Level Examples // All the tests in this assembly will use the MTA by default. Since // this is the general default, the attribute is not actually needed. [assembly:Apartment(ApartmentState.MTA)] ... // All the tests in this assembly will use the STA by default [assembly:Apartment(ApartmentState.STA)] Test Fixture Examples // TestFixture requiring use of the MTA. The attribute is not // needed unless the STA was specified at a higher level. [TestFixture, Apartment(ApartmentState.MTA)] public class FixtureRequiringMTA { // All tests in the fixture will run in the MTA. } // TestFixture requiring use of the STA. [TestFixture, Apartment(ApartmentState.STA)] public class FixtureRequiringSTA { // All tests in the fixture will run in the STA. } Test Method Examples [TestFixture] public class AnotherFixture { [Test, Apartment(ApartmentState.MTA)] public void TestRequiringMTA() { // This test will run in the MTA. } [Test, Apartment(ApartmentState.STA)] public void TestRequiringSTA() { // This test will run in the STA. } } See Also RequiresThread Attribute"
  },
  "articles/nunit/writing-tests/attributes/author.html": {
    "href": "articles/nunit/writing-tests/attributes/author.html",
    "title": "Author | NUnit Docs",
    "keywords": "Author The Author Attribute adds information about the author of the tests. It can be applied to test fixtures and to tests. The constructor takes the name of the test author and optionally the author's email address. Author can also be specified on a TestFixture or Test attribute. [TestFixture] [Author(\"Jane Doe\", \"jane.doe@example.com\")] [Author(\"Another Developer\", \"email@example.com\")] public class MyTests { [Test] public void Test1() { /* ... */ } [Test] [Author(\"Joe Developer\")] [Author(\"Yet Another Developer\", \"not.my.email@example.com\")] public void Test2() { /* ... */ } } [TestFixture(Author = \"Jane Doe\")] public class MyOtherTests { [Test] public void Test1() { /* ... */ } [Test(Author = \"Joe Developer\")] public void Test2() { /* ... */ } } Note From NUnit version 3.7 you can have multiple Author attributes per fixture or test. Before version 3.7 you could only have one Author attribute per fixture or test."
  },
  "articles/nunit/writing-tests/attributes/category.html": {
    "href": "articles/nunit/writing-tests/attributes/category.html",
    "title": "Category | NUnit Docs",
    "keywords": "Category The Category attribute provides an alternative to suites for dealing with groups of tests. Either individual test cases or fixtures may be identified as belonging to a particular category. Both the gui and console test runners allow specifying a list of categories to be included in or excluded from the run. When categories are used, only the tests in the selected categories will be run. Those tests in categories that are not selected are not reported at all. This feature is accessible by use of the /include and /exclude arguments to the console runner and through a separate \"Categories\" tab in the gui. The gui provides a visual indication of which categories are selected at any time. Warning While the C# syntax allows you to place a Category attribute on a SetUpFixture class, the attribute is ignored by NUnit and has no effect in current releases. Test Fixture Syntax namespace NUnit.Tests { using System; using NUnit.Framework; [TestFixture] [Category(\"LongRunning\")] public class LongRunningTests { // ... } } Test Syntax namespace NUnit.Tests { using System; using NUnit.Framework; [TestFixture] public class SuccessTests { [Test] [Category(\"Long\")] public void VeryLongTest() { /* ... */ } } Custom Category Attributes Custom attributes that derive from CategoryAttribute will be recognized by NUnit. The default protected constructor of CategoryAttribute sets the category name to the name of your class. Here's an example that creates a category of Critical tests. It works just like any other category, but has a simpler syntax. A test reporting system might make use of the attribute to provide special reports. [AttributeUsage(AttributeTargets.Method, AllowMultiple=false)] public class CriticalAttribute : CategoryAttribute { } [Test, Critical] public void MyTest() { /*...*/ }"
  },
  "articles/nunit/writing-tests/attributes/combinatorial.html": {
    "href": "articles/nunit/writing-tests/attributes/combinatorial.html",
    "title": "Combinatorial | NUnit Docs",
    "keywords": "Combinatorial The CombinatorialAttribute is used on a test to specify that NUnit should generate test cases for all possible combinations of the individual data items provided for the parameters of a test. Since this is the default, use of this attribute is optional. Example The following test will be executed six times: [Test, Combinatorial] public void MyTest( [Values(1, 2, 3)] int x, [Values(\"A\", \"B\")] string s) { ... } MyTest is called six times, as follows: MyTest(1, \"A\") MyTest(1, \"B\") MyTest(2, \"A\") MyTest(2, \"B\") MyTest(3, \"A\") MyTest(3, \"B\") Limitations When used on a generic method the programmer must ensure that all possible combinations of arguments are valid. When multiple parameters use the same generic type (e.g.: T) this may not be possible and the attribute may generate invalid test cases. See Also Sequential Attribute Pairwise Attribute"
  },
  "articles/nunit/writing-tests/attributes/culture.html": {
    "href": "articles/nunit/writing-tests/attributes/culture.html",
    "title": "Culture | NUnit Docs",
    "keywords": "Culture The Culture attribute is used to specify cultures for which a test or fixture should be run. It does not affect the culture setting, but merely uses it to determine whether to run the test. If you wish to change the culture when running a test, use the SetCulture attribute instead. If the specified culture requirements for a test are not met it is skipped. In the gui, the tree node for the test remains gray and the status bar color is not affected. One use of the Culture attribute is to provide alternative tests under different cultures. You may specify either specific cultures, like \"en-GB\" or neutral cultures like \"de\". Test Fixture Syntax namespace NUnit.Tests { using System; using NUnit.Framework; [TestFixture] [Culture(\"fr-FR\")] public class FrenchCultureTests { // ... } } Test Syntax namespace NUnit.Tests { using System; using NUnit.Framework; [TestFixture] public class SuccessTests { [Test] [Culture(Exclude=\"en,de\")] public void SomeTest() { /* ... */ } } See Also SetCulture Attribute"
  },
  "articles/nunit/writing-tests/attributes/datapoint.html": {
    "href": "articles/nunit/writing-tests/attributes/datapoint.html",
    "title": "Datapoint | NUnit Docs",
    "keywords": "Datapoint The Datapoint attribute is used to provide data for Theories and is ignored for ordinary tests - including tests with parameters. When a Theory is loaded, NUnit creates arguments for each of its parameters by using any fields of the same type as the parameter annotated with the DatapointAttribute . Fields must be members of the class containing the Theory and their Type must exactly match the argument for which data is being supplied. Automatically Supplied Datapoints It is normally not necessary to specify datapoints for boolean or enum arguments. NUnit automatically supplies values of true and false for boolean arguments and will supply all defined values of any enumeration. If for some reason you don't wish to use all possible values, you can override this behavior by supplying your own datapoints. If you supply any datapoints for an argument, automatic datapoint generation is suppressed. Example For an example of use, see Theory Attribute See Also Theory Attribute Parameterized Tests"
  },
  "articles/nunit/writing-tests/attributes/datapointsource.html": {
    "href": "articles/nunit/writing-tests/attributes/datapointsource.html",
    "title": "DatapointSource | NUnit Docs",
    "keywords": "DatapointSource The DatapointSource attribute is used to provide data for Theories and is ignored for ordinary tests - including tests with parameters. Collections of datapoints may be provided by use of the DatapointSourceAttribute . This attribute may be placed on methods or properties in addition to fields. The returned value must be either an array of the required type or an IEnumerable<T> returning an enumeration of the required type. The data Type must exactly match the argument for which data is being supplied. In earlier versions of NUnit, the obsolete DatapointsAttribute was used in place of DatapointSourceAttribute . Automatically Supplied Datapoints It is normally not necessary to specify datapoints for boolean or enum arguments. NUnit automatically supplies values of true and false for boolean arguments and will supply all defined values of any enumeration. If for some reason you don't wish to use all possible values, you can override this behavior by supplying your own datapoints. If you supply any datapoints for an argument, automatic datapoint generation is suppressed. Example For an example of use, see Theory Attribute See Also Theory Attribute Parameterized Tests"
  },
  "articles/nunit/writing-tests/attributes/defaultfloatingpointtolerance.html": {
    "href": "articles/nunit/writing-tests/attributes/defaultfloatingpointtolerance.html",
    "title": "DefaultFloatingPointTolerance | NUnit Docs",
    "keywords": "DefaultFloatingPointTolerance The DefaultFloatingPointToleranceAttribute is used to indicate that comparisons of values of types float and double - within the test method, class, or assembly marked with the attribute - should use the tolerance specified in the constructor unless a specific tolerance is given for the comparison. Examples [TestFixture] [DefaultFloatingPointTolerance(1)] public class ToleranceTest { [Test] public void ComparisonUsingDefaultFloatingPointToleranceFromFixture() { // Passes due to the DefaultFloatingPointToleranceAttribute from the fixture. Assert.That(1f, Is.EqualTo(2)); } [Test] public void ComparisonOfIntegersDoNotUseTolerance() { // Fails as DefaultFloatingPointTolerance only effects comparisons // of floats and doubles. Assert.That(1, Is.EqualTo(2)); } [Test] public void ComparisonUsingSpecificTolerance() { // Fails as 1 is not equal to 2 using the specified tolerance 0. Assert.That(1f, Is.EqualTo(2).Within(0)); } [Test] [DefaultFloatingPointTolerance(2)] public void ComparisonUsingDefaultFloatingPointToleranceFromTest() { // Passes due to the DefaultFloatingPointTolerance from the test. Assert.That(2f, Is.EqualTo(4)); } } See Also Assert.AreEqual EqualConstraint"
  },
  "articles/nunit/writing-tests/attributes/description.html": {
    "href": "articles/nunit/writing-tests/attributes/description.html",
    "title": "Description | NUnit Docs",
    "keywords": "Description The Description attribute is used to apply descriptive text to a Test, TestFixture or Assembly. The text appears in the XML output file and is shown in the Test Properties dialog. Example [assembly: Description(\"Assembly description here\")] namespace NUnit.Tests { using System; using NUnit.Framework; [TestFixture, Description(\"Fixture description here\")] public class SomeTests { [Test, Description(\"Test description here\")] public void OneTest() { /* ... */ } } } Note The Test and TestFixture attributes continue to support an optional Description property. The Description attribute should be used for new applications. If both are used, the Description attribute takes precedence."
  },
  "articles/nunit/writing-tests/attributes/explicit.html": {
    "href": "articles/nunit/writing-tests/attributes/explicit.html",
    "title": "Explicit | NUnit Docs",
    "keywords": "Explicit The Explicit attribute causes a test or test fixture to be skipped unless it is explicitly selected for running. The test or fixture will be run if it is selected by name or if it is included by use of a filter. A not filter, which excludes certain tests, is not treated as an explicit selection and never causes an explicit test to be run. All other filters are considered to explicitly select the tests that they match. See examples below. An optional string argument may be used to give the reason for marking the test Explicit. If a test or fixture with the Explicit attribute is encountered in the course of running tests, it is skipped unless it has been specifically selected by one of the above means. The test does not affect the overall result of the test run. Explicit tests are displayed in the gui as skipped. Warning While the C# syntax allows you to place an Explicit attribute on a SetUpFixture class, the attribute is ignored by NUnit and has no effect in current releases. Examples of Use Using the console command-line to select tests, the following options will include any explicit tests that fall under the selection. --test=My.Namespace.Fixture.Method --test=My.Namespace.Fixture --test=My.Namespace --where test==My.Namespace.Fixture.Method --where test==My.Namespace.Fixture --where test==My.Namespace --where cat==X --where \"cat==X || cat==Y\" However, the following options will not include explicit tests --where test!=My.Namespace.Fixture --where cat!=X Test Fixture Syntax C# namespace NUnit.Tests { using System; using NUnit.Framework; [TestFixture, Explicit] public class ExplicitTests { // ... } } Visual Basic Imports System Imports NUnit.Framework Namespace NUnit.Tests <TestFixture(), Explicit()> Public Class ExplicitTests ' ... End Class End Namespace C++ using namespace System; using namespace NUnit::Framework; namespace NUnitTests { [TestFixture] [Explicit] public __gc class ExplicitTests { // ... }; } # include \"cppsample.h\" namespace NUnitTests { // ... } Test Syntax C# namespace NUnit.Tests { using System; using NUnit.Framework; [TestFixture] public class SuccessTests { [Test, Explicit] public void ExplicitTest() { /* ... */ } } Visual Basic Imports System Imports NUnit.Framework Namespace NUnit.Tests <TestFixture()> Public Class SuccessTests <Test(), Explicit()> Public Sub ExplicitTest() ' ... End Sub End Class End Namespace C++ # using <NUnit.Framework.dll> using namespace System; using namespace NUnit::Framework; namespace NUnitTests { [TestFixture] public __gc class SuccessTests { [Test][Explicit] void ExplicitTest(); }; } # include \"cppsample.h\" namespace NUnitTests { // ... }"
  },
  "articles/nunit/writing-tests/attributes/ignore.html": {
    "href": "articles/nunit/writing-tests/attributes/ignore.html",
    "title": "Ignore | NUnit Docs",
    "keywords": "Ignore IgnoreAttribute is used to indicate that a test should not be executed for some reason. Note that with NUnit 3, the reason must be specified. Ignored tests are displayed by the runners as warnings in order to provide a reminder that the test needs to be corrected or otherwise changed and re-instated. Note that the IgnoreAttribute is attached to a method. If you have multiple test cases using the same method, adding it will ignore all the cases. To ignore individual test cases see Ignoring Individual Test Cases below. Test Fixture Syntax namespace NUnit.Tests { using System; using NUnit.Framework; [TestFixture] [Ignore(\"Ignore a fixture\")] public class SuccessTests { // ... } } Test Syntax namespace NUnit.Tests { using System; using NUnit.Framework; [TestFixture] public class SuccessTests { [Test] [Ignore(\"Ignore a test\")] public void IgnoredTest() { /* ... */ } } Ignore Until The Until named parameter allows you to ignore a test for a specific period of time, after which the test will run normally. The until date must be a string that can be parsed to a date. [TestFixture] [Ignore(\"Waiting for Joe to fix his bugs\", Until = \"2014-07-31 12:00:00Z\"] public class MyTests { [Test] public void Test1() { /* ... */ } } In the above example, it's assumed that the test would fail if run. With the IgnoreAttribute, it will give a warning until the specified date. After that time, it will run normally and either pass or fail. Ignoring Individual Test Cases The IgnoreAttribute causes all the test cases using the method on which it is placed to be ignored. Ignoring individual test cases is possible, depending on how they are specified. Attribute How to ignore a case TestCase Use the Ignore named parameter of the TestCaseAttribute. TestCaseSource Use TestCaseData for the source and set the Ignore property."
  },
  "articles/nunit/writing-tests/attributes/levelofparallelism.html": {
    "href": "articles/nunit/writing-tests/attributes/levelofparallelism.html",
    "title": "LevelOfParallelism | NUnit Docs",
    "keywords": "LevelOfParallelism This is an assembly-level attribute, which may be used to specify the level of parallelism, that is, the maximum number of worker threads executing tests in the assembly. It may be overridden using a command-line option in the console runner. This attribute is optional. If it is not specified, NUnit uses the processor count or 2, whichever is greater. For example, on a four processor machine the default value is 4. Example The following code, which might be placed in AssemblyInfo.cs, sets the level of parallelism to 3: [assembly:LevelOfParallelism(3)] Platform Support Parallel execution is supported by the NUnit framework on desktop .NET runtimes. It is not supported in our Portable or .NET Standard builds at this time, although the attributes are recognized without error in order to allow use in projects that build against multiple targets. See Also Parallelizable Attribute"
  },
  "articles/nunit/writing-tests/attributes/maxtime.html": {
    "href": "articles/nunit/writing-tests/attributes/maxtime.html",
    "title": "MaxTime | NUnit Docs",
    "keywords": "MaxTime The MaxTimeAttribute is used on test methods to specify a maximum time in milliseconds for a test case. If the test case takes longer than the specified time to complete, it is reported as a failure. Example [Test, MaxTime(2000)] public void TimedTest() { /* ... */ } Notes Any assertion failures take precedence over the elapsed time check. This attribute does not cancel the test if the time is exceeded. It merely waits for the test to complete and then compares the elapsed time to the specified maximum. If you want to cancel long-running tests, see Timeout Attribute ."
  },
  "articles/nunit/writing-tests/attributes/nonparallelizable.html": {
    "href": "articles/nunit/writing-tests/attributes/nonparallelizable.html",
    "title": "NonParallelizable | NUnit Docs",
    "keywords": "NonParallelizable This attribute is used to indicate that the test on which it appears may not be run in parallel with any other tests. The attribute takes no arguments and may be used at the assembly, class or method level. When used at the assembly level, its only effect is that execution begins on the non-parallel queue. Test suites, fixtures and test cases will continue to run on the same thread unless a fixture or method is marked with the Parallelizable Attribute . When used on a test fixture or method, that test will be queued on the non-parallel queue and will not run while other tests marked as Parallelizable are being run. Platform Support Parallel execution is not supported by all builds of the NUnit Framework, although the attributes are recognized without error in order to allow use in projects that build against multiple targets. Currently, only the .NET Standard 1.6 build does not support parallelization. See Also Parallelizable Attribute LevelOfParallelism Attribute"
  },
  "articles/nunit/writing-tests/attributes/nontestassembly.html": {
    "href": "articles/nunit/writing-tests/attributes/nontestassembly.html",
    "title": "NonTestAssembly | NUnit Docs",
    "keywords": "NonTestAssembly This is an assembly-level attribute, which may be used to specify that even though the assembly refers to NUnit it does not contain any tests. This attribute can be used in connection with the command line option --skipnontestassemblies of the console to skip assemblies without failing. Example The following code, which might be placed in AssemblyInfo.cs, specifies that the assembly does not contain any tests. [assembly: NonTestAssembly] See Also --skipnontestassemblies in Console-Command-Line"
  },
  "articles/nunit/writing-tests/attributes/onetimesetup.html": {
    "href": "articles/nunit/writing-tests/attributes/onetimesetup.html",
    "title": "OneTimeSetUp | NUnit Docs",
    "keywords": "OneTimeSetUp This attribute is to identify methods that are called once prior to executing any of the tests in a fixture. It may appear on methods of a TestFixture or a SetUpFixture. OneTimeSetUp methods may be either static or instance methods and you may define more than one of them in a fixture. Normally, multiple OneTimeSetUp methods are only defined at different levels of an inheritance hierarchy, as explained below. If a OneTimeSetUp method fails or throws an exception, none of the tests in the fixture are executed and a failure or error is reported. Example namespace NUnit.Tests { using System; using NUnit.Framework; [TestFixture] public class SuccessTests { [OneTimeSetUp] public void Init() { /* ... */ } [OneTimeTearDown] public void Cleanup() { /* ... */ } [Test] public void Add() { /* ... */ } } } Inheritance The OneTimeSetUp attribute is inherited from any base class. Therefore, if a base class has defined a OneTimeSetUp method, that method will be called before any methods in the derived class. You may define a OneTimeSetUp method in the base class and another in the derived class. NUnit will call base class OneTimeSetUp methods before those in the derived classes. Notes Although it is possible to define multiple OneTimeSetUp methods in the same class, you should rarely do so. Unlike methods defined in separate classes in the inheritance hierarchy, the order in which they are executed is not guaranteed. OneTimeSetUp methods may be async if running under .NET 4.0 or higher. OneTimeSetUp methods run in the context of the TestFixture or SetUpFixture, which is separate from the context of any individual test cases. It's important to keep this in mind when using TestContext methods and properties within the method. See Also SetUp Attribute TearDown Attribute OneTimeTearDown Attribute"
  },
  "articles/nunit/writing-tests/attributes/onetimeteardown.html": {
    "href": "articles/nunit/writing-tests/attributes/onetimeteardown.html",
    "title": "OneTimeTearDown | NUnit Docs",
    "keywords": "OneTimeTearDown This attribute is to identify methods that are called once after executing all the tests in a fixture. It may appear on methods of a TestFixture or a SetUpFixture. OneTimeTearDown methods may be either static or instance methods and you may define more than one of them in a fixture. Normally, multiple OneTimeTearDown methods are only defined at different levels of an inheritance hierarchy, as explained below. So long as any OneTimeSetUp method runs without error, the OneTimeTearDown method is guaranteed to run. It will not run if a OneTimeSetUp method fails or throws an exception. Example namespace NUnit.Tests { using System; using NUnit.Framework; [TestFixture] public class SuccessTests { [OneTimeSetUp] public void Init() { /* ... */ } [OneTimeTearDown] public void Cleanup() { /* ... */ } [Test] public void Add() { /* ... */ } } } Inheritance The OneTimeTearDown attribute is inherited from any base class. Therefore, if a base class has defined a OneTimeTearDown method, that method will be called after any test methods in the derived class. You may define a OneTimeTearDown method in the base class and another in the derived class. NUnit will call base class OneTimeTearDown methods after those in the derived classes. Notes Although it is possible to define multiple OneTimeTearDown methods in the same class, you should rarely do so. Unlike methods defined in separate classes in the inheritance hierarchy, the order in which they are executed is not guaranteed. OneTimeTearDown methods may be async if running under .NET 4.0 or higher. OneTimeTearDown methods run in the context of the TestFixture or SetUpFixture, which is separate from the context of any individual test cases. It's important to keep this in mind when using TestContext methods and properties within the method. See Also SetUp Attribute TearDown Attribute OneTimeSetUp Attribute TestFixture Attribute SetUpFixture Attribute"
  },
  "articles/nunit/writing-tests/attributes/order.html": {
    "href": "articles/nunit/writing-tests/attributes/order.html",
    "title": "Order | NUnit Docs",
    "keywords": "Order The OrderAttribute may be placed on a test method or fixture to specify the order in which tests are run within the fixture or other suite in which they are contained. Ordering is given by the required order argument to the attribute, an int . Example The following tests will be run in the order: TestA TestB TestC public class MyFixture { [Test, Order(1)] public void TestA() { /* ... */ } [Test, Order(2)] public void TestB() { /* ... */ } [Test] public void TestC() { /* ... */ } } Notes As stated, ordering is local to the test that contains the ordered tests. For test cases (methods) ordering applies within the containing fixture. For fixtures it applies within the containing namespace. There is no facility in NUnit to order tests globally. Tests with an OrderAttribute argument are started before any tests without the attribute. Ordered tests are started in ascending order of the order argument. Among tests with the same order value or without the attribute, execution order is indeterminate. Tests do not wait for prior tests to finish. If multiple threads are in use, a test may be started while some earlier tests are still being run."
  },
  "articles/nunit/writing-tests/attributes/pairwise.html": {
    "href": "articles/nunit/writing-tests/attributes/pairwise.html",
    "title": "Pairwise | NUnit Docs",
    "keywords": "Pairwise The PairwiseAttribute is used on a test to specify that NUnit should generate test cases in such a way that all possible pairs of values are used. This is a well-known approach for combatting the combinatorial explosion of test cases when more than two features (parameters) are involved. Example Using the Combinatorial attribute, the following test would be executed 12 (3x2x2) times. With Pairwise it is executed only enough times so that each possible pair is covered.. [Test, Pairwise] public void MyTest( [Values(\"a\", \"b\", \"c\")] string a, [Values(\"+\", \"-\")] string b, [Values(\"x\", \"y\")] string c) { Console.WriteLine(\"{0} {1} {2}\", a, b, c); } For this test, NUnit currently calls the method six times, producing the following output: a + y a - x b - y b + x c - x c + y Note that this is not the optimal output. The pairs (-, x) and (+, y) appear twice. NUnit uses a heuristic algorithm to reduce the number of test cases as much as it can. Improvements may be made in the future. Limitations When used on a generic method the programmer must ensure that all possible combinations of arguments are valid. When multiple parameters use the same generic type (e.g.: T) this may not be possible and the attribute may generate invalid test cases. See Also Sequential Attribute Combinatorial Attribute"
  },
  "articles/nunit/writing-tests/attributes/parallelizable.html": {
    "href": "articles/nunit/writing-tests/attributes/parallelizable.html",
    "title": "Parallelizable | NUnit Docs",
    "keywords": "Parallelizable The ParallelizableAttribute is used to indicate that a test and/or its descendants may be run in parallel with other tests. By default, no parallel execution takes place. When used without an argument, Parallelizable causes the test fixture or method on which it is placed to be queued for execution in parallel with other parallelizable tests. It may be used at the assembly, class or method level. The constructor takes an optional ParallelScope enumeration argument (see below), which indicates whether the attribute applies to the item itself, to its descendants or both. It defaults to ParallelScope.Self . The Scope may also be specified using the named property Scope= . ParallelScope Enumeration This is a [Flags] enumeration used to specify which tests may run in parallel. It applies to the test upon which it appears and any subordinate tests. The following values are available to users: Value Meaning Valid On ParallelScope.Self the test itself may be run in parallel with other tests Classes, Methods ParallelScope.Children child tests may be run in parallel with one another Assembly, Classes ParallelScope.Fixtures fixtures may be run in parallel with one another Assembly, Classes ParallelScope.All the test and its descendants may be run in parallel with others at the same level Classes, Methods Notes Some values are invalid on certain elements, although they will compile. NUnit will report any tests so marked as invalid and will produce an error message. The ParallelScope enum has additional values, which are used internally but are not visible to users through Intellisense. The ParallelizableAttribute may be specified on multiple levels of the tests. Settings at a higher level may affect lower level tests, unless those lower-level tests override the inherited settings. See Also NonParallelizable Attribute LevelOfParallelism Attribute"
  },
  "articles/nunit/writing-tests/attributes/platform.html": {
    "href": "articles/nunit/writing-tests/attributes/platform.html",
    "title": "Platform | NUnit Docs",
    "keywords": "Platform The Platform attribute is used to specify platforms for which a test or fixture should be run. Platforms are specified using case-insensitive string values and may be either included or excluded from the run by use of the Include or Exclude properties respectively. Platforms to be included may alternatively be specified as an argument to the PlatformAttribute constructor. In either case, multiple comma-separated values may be specified. If a test or fixture with the Platform attribute does not satisfy the specified platform requirements it is skipped. The test does not affect the outcome of the run at all: it is not considered as ignored and is not even counted in the total number of tests. [Ed.: Check this.] In the gui, the tree node for the test remains gray and the status bar color is not affected. Test Fixture Syntax namespace NUnit.Tests { using System; using NUnit.Framework; [TestFixture] [Platform(\"NET-2.0\")] public class DotNetTwoTests { // ... } } Test Syntax namespace NUnit.Tests { using System; using NUnit.Framework; [TestFixture] public class SuccessTests { [Test] [Platform(Exclude=\"Win98,WinME\")] public void SomeTest() { /* ... */ } } Platform Specifiers The following values are recognized as platform specifiers. They may be expressed in upper, lower or mixed case. Operating System Win Win32 Win32S Win32Windows Win32NT WinCE Win95 Win98 WinMe NT3 NT4 NT5 NT6 Win2K WinXP Win2003Server Vista Win2008Server Win2008ServerR2 Windows7 Win2012Server Windows8 Unix Linux MacOsX XBox Architecture 32-Bit 32-Bit-Process 32-Bit-OS (.NET 4.0 and higher only) 64-Bit 64-Bit-Process 64-Bit-OS (.NET 4.0 and higher only) Runtime Net Net-1.0 Net-1.1 Net-2.0 Net-3.0 (1) Net-3.5 (2) Net-4.0 Net-4.5 (3) NetCF SSCLI Rotor Mono Mono-1.0 Mono-2.0 Mono-3.0 (4) Mono-3.5 (5) Mono-4.0 Notes Includes Net-2.0 Includes Net-2.0 and Net-3.0 Includes Net-4.0 Includes Mono-2.0 Includes Mono-2.0 and Mono-3.0"
  },
  "articles/nunit/writing-tests/attributes/property.html": {
    "href": "articles/nunit/writing-tests/attributes/property.html",
    "title": "Property | NUnit Docs",
    "keywords": "Property PropertyAttribute provides a generalized approach to setting named properties on any test case or fixture, using a name/value pair. In the example below, the fixture class MathTests is given a Location value of 723 while the test case AdditionTest is given a Severity of \"Critical\" Example namespace NUnit.Tests { using System; using NUnit.Framework; [TestFixture, Property(\"Location\", 723)] public class MathTests { [Test, Property(\"Severity\", \"Critical\")] public void AdditionTest() { /* ... */ } } } Usage Note The PropertyAttribute is not currently used for any purpose by NUnit itself, other than to display them in the XML output file and in the Test Properties dialog of the gui. You may also use properties with the --where option on the command-line in order to select tests to run. See Test Selection Language . Note that his filtering will only work for properties where the values have type string. User tests may access properties through the TestContext or by reflection. Custom Property Attributes Users can define custom attributes that derive from PropertyAttribute and have them recognized by NUnit. PropertyAttribute provides a protected constructor that takes the value of the property and sets the property name to the name of the derived class with the 'Attribute' suffix removed. Here's an example that creates a Severity property. It works just like any other property, but has a simpler syntax and is type-safe. A custom test reporting system might make use of the property to provide special reports. public enum SeverityLevel { Critical, Major, Normal, Minor } [AttributeUsage(AttributeTargets.Method, AllowMultiple=false)] public class SeverityAttribute : PropertyAttribute { public SeverityAttribute(SeverityLevel level) : base(level); } ... [Test, Severity(SeverityLevel.Critical)] public void MyTest() { /*...*/ } A PropertyAttribute may contain multiple name/value pairs. This capability is not exposed publicly but may be used by derived property classes."
  },
  "articles/nunit/writing-tests/attributes/random.html": {
    "href": "articles/nunit/writing-tests/attributes/random.html",
    "title": "Random | NUnit Docs",
    "keywords": "Random The RandomAttribute is used to specify a set of random values to be provided for an individual numeric parameter of a parameterized test method. Since NUnit combines the data provided for each parameter into a set of test cases, data must be provided for all parameters if it is provided for any of them. By default, NUnit creates test cases from all possible combinations of the datapoints provided on parameters - the combinatorial approach. This default may be modified by use of specific attributes on the test method itself. RandomAttribute supports the following constructors: public Random(int count); public Random(int min, int max, int count); public Random(uint min, uint max, int count); public Random(long min, long max, int count); public Random(ulong min, ulong max, int count); public Random(short min, short max, int count); public Random(ushort min, ushort max, int count); public Random(byte min, byte max, int count); public Random(sbyte min, sbyte max, int count); public Random(double min, double max, int count); public Random(float min, float max, int count); In the first form, without minimum and maximum values, the attribute automatically generates values of the appropriate numeric Type for the argument provided, using the Randomizer object associated with the current context. See Randomizer Methods for details. In general, the forms that specify a minimum and maximum should be used on arguments of the same type. However, the following exceptions are supported: You may use an int range on arguments of type short, ushort, byte, sbyte and decimal. You may use a double range on arguments of type decimal. Note that there is no constructor taking decimal values for min and max. This is because .NET does not support use of decimal in an attribute constructor. Example The following test will be executed fifteen times, three times for each value of x, each combined with 5 random doubles from -1.0 to +1.0. [Test] public void MyTest( [Values(1, 2, 3)] int x, [Random(-1.0, 1.0, 5)] double d) { ... } See Also Values Attribute Range Attribute Sequential Attribute Combinatorial Attribute Pairwise Attribute"
  },
  "articles/nunit/writing-tests/attributes/range.html": {
    "href": "articles/nunit/writing-tests/attributes/range.html",
    "title": "Range | NUnit Docs",
    "keywords": "Range The RangeAttribute is used to specify a range of values to be provided for an individual parameter of a parameterized test method. Since NUnit combines the data provided for each parameter into a set of test cases, data must be provided for all parameters if it is provided for any of them. By default, NUnit creates test cases from all possible combinations of the datapoints provided on parameters - the combinatorial approach. This default may be modified by use of specific attributes on the test method itself. RangeAttribute supports the following constructors: public RangeAttribute(int from, int to); public RangeAttribute(int from, int to, int step); public RangeAttribute(long from, long to, long step); public RangeAttribute(float from, float to, float step); public RangeAttribute(double from, double to, double step); Example The following test will be executed nine times. [Test] public void MyTest( [Values(1, 2, 3)] int x, [Range(0.2, 0.6, 0.2)] double d) { /* ... */ } The MyTest method is called nine times, as follows: MyTest(1, 0.2) MyTest(1, 0.4) MyTest(1, 0.6) MyTest(2, 0.2) MyTest(2, 0.4) MyTest(2, 0.6) MyTest(3, 0.2) MyTest(3, 0.4) MyTest(3, 0.6) See Also Values Attribute Random Attribute Sequential Attribute Combinatorial Attribute Pairwise Attribute"
  },
  "articles/nunit/writing-tests/attributes/repeat.html": {
    "href": "articles/nunit/writing-tests/attributes/repeat.html",
    "title": "Repeat | NUnit Docs",
    "keywords": "Repeat RepeatAttribute is used on a test method to specify that it should be executed multiple times. If any repetition fails, the remaining ones are not run and a failure is reported. Notes If RepeatAttribute is used on a parameterized method, each individual test case created for that method is repeated. It is not currently possible to use RepeatAttribute on a TestFixture or any higher level suite. Only test cases may be repeated."
  },
  "articles/nunit/writing-tests/attributes/requiresthread.html": {
    "href": "articles/nunit/writing-tests/attributes/requiresthread.html",
    "title": "RequiresThread | NUnit Docs",
    "keywords": "RequiresThread The RequiresThreadAttribute is used to indicate that a test method, class or assembly should be run on a separate thread. Optionally, the desired apartment for the thread may be specified in the constructor. Note This attribute, used with or without an ApartmentState argument will always result in creation of a new thread. To create a thread only if the current ApartmentState is not appropriate, use the ApartmentAttribute . Examples // A thread will be created and used to run // all the tests in the assembly [assembly:RequiresThread] /* ... */ // TestFixture requiring a separate thread [TestFixture, RequiresThread] public class FixtureOnThread { // A separate thread will be created and all // tests in the fixture will run on it. } [TestFixture] public class AnotherFixture { [Test, RequiresThread] public void TestRequiringThread() { // A separate thread will be created for this test } [Test, RequiresThread(ApartmentState.STA)] public void TestRequiringSTAThread() { // A separate STA thread will be created for this test. } } See Also Apartment Attribute"
  },
  "articles/nunit/writing-tests/attributes/retry.html": {
    "href": "articles/nunit/writing-tests/attributes/retry.html",
    "title": "Retry | NUnit Docs",
    "keywords": "Retry RetryAttribute is used on a test method to specify that it should be rerun if it fails, up to a maximum number of times. Notes: The argument you specify is the total number of attempts and not the number of retries after an initial failure. So [Retry(1)] does nothing and should not be used. It is not currently possible to use RetryAttribute on a TestFixture or any other type of test suite. Only single tests may be repeated. If a test has an unexpected exception, an error result is returned and it is not retried. Only assertion failures can trigger a retry. To convert an unexpected exception into an assertion failure, see the ThrowsConstraint ."
  },
  "articles/nunit/writing-tests/attributes/sequential.html": {
    "href": "articles/nunit/writing-tests/attributes/sequential.html",
    "title": "Sequential | NUnit Docs",
    "keywords": "Sequential The SequentialAttribute is used on a test to specify that NUnit should generate test cases by selecting individual data items provided for the parameters of the test, without generating additional combinations. Note If parameter data is provided by multiple attributes, the order in which NUnit uses the data items is not guaranteed. However, it can be expected to remain constant for a given runtime and operating system. For best results with SequentialAttribute use only one data attribute on each parameter. Example The following test will be executed three times. [Test, Sequential] public void MyTest( [Values(1, 2, 3)] int x, [Values(\"A\", \"B\")] string s) { /* ... */ } MyTest is called three times, as follows: MyTest(1, \"A\") MyTest(2, \"B\") MyTest(3, null) See also Combinatorial Attribute Pairwise Attribute"
  },
  "articles/nunit/writing-tests/attributes/setculture.html": {
    "href": "articles/nunit/writing-tests/attributes/setculture.html",
    "title": "SetCulture | NUnit Docs",
    "keywords": "SetCulture The SetCulture attribute is used to set the current Culture for the duration of a test. It may be specified at the level of a test, fixture or assembly. The culture remains set until the test or fixture completes and is then reset to its original value. If you wish to use the current culture setting to decide whether to run a test, use the Culture attribute instead of this one. Only one culture may be specified. Running a test under multiple cultures is a planned future enhancement. At this time, you can achieve the same result by factoring out your test code into a private method that is called by each individual test method. Examples namespace NUnit.Tests { using System; using NUnit.Framework; [TestFixture] [SetCulture(\"fr-FR\")] public class FrenchCultureTests { // ... } } See also Culture Attribute"
  },
  "articles/nunit/writing-tests/attributes/setuiculture.html": {
    "href": "articles/nunit/writing-tests/attributes/setuiculture.html",
    "title": "SetUICulture | NUnit Docs",
    "keywords": "SetUICulture The SetUICulture attribute is used to set the current UI Culture for the duration of a test. It may be specified at the level of a test or a fixture. The UI culture remains set until the test or fixture completes and is then reset to its original value. If you wish to use the current culture setting to decide whether to run a test, use the Culture attribute instead of this one. Only one culture may be specified. Running a test under multiple cultures is a planned future enhancement. At this time, you can achieve the same result by factoring out your test code into a private method that is called by each individual test method. Examples namespace NUnit.Tests { using System; using NUnit.Framework; [TestFixture] [SetUICulture(\"fr-FR\")] public class FrenchCultureTests { // ... } } See also Culture Attribute ] SetCulture Attribute"
  },
  "articles/nunit/writing-tests/attributes/setup.html": {
    "href": "articles/nunit/writing-tests/attributes/setup.html",
    "title": "SetUp | NUnit Docs",
    "keywords": "SetUp This attribute is used inside a TestFixture to provide a common set of functions that are performed just before each test method is called. SetUp methods may be either static or instance methods and you may define more than one of them in a fixture. Normally, multiple SetUp methods are only defined at different levels of an inheritance hierarchy, as explained below. If a SetUp method fails or throws an exception, the test is not executed and a failure or error is reported. Example namespace NUnit.Tests { using System; using NUnit.Framework; [TestFixture] public class SuccessTests { [SetUp] public void Init() { /* ... */ } [TearDown] public void Cleanup() { /* ... */ } [Test] public void Add() { /* ... */ } } } Inheritance The SetUp attribute is inherited from any base class. Therefore, if a base class has defined a SetUp method, that method will be called before each test method in the derived class. You may define a SetUp method in the base class and another in the derived class. NUnit will call base class SetUp methods before those in the derived classes. Notes Although it is possible to define multiple SetUp methods in the same class, you should rarely do so. Unlike methods defined in separate classes in the inheritance hierarchy, the order in which they are executed is not guaranteed. You may specify an async method ( async keyword in c#) if necessary, when running under .NET 4.0 or higher. See also TearDown Attribute OneTimeSetUp Attribute OneTimeTearDown Attribute testfixture attribute"
  },
  "articles/nunit/writing-tests/attributes/setupfixture.html": {
    "href": "articles/nunit/writing-tests/attributes/setupfixture.html",
    "title": "SetUpFixture | NUnit Docs",
    "keywords": "SetUpFixture This is the attribute that marks a class that contains the one-time setup or teardown methods for all the test fixtures under a given namespace. The class may contain at most one method marked with the OneTimeSetUpAttribute and one method marked with the OneTimeTearDownAttribute. There are a few restrictions on a class that is used as a setup fixture. It must be a publicly exported type or NUnit will not see it. It must have a default constructor or NUnit will not be able to construct it. The OneTimeSetUp method in a SetUpFixture is executed once before any of the fixtures contained in its namespace. The OneTimeTearDown method is executed once after all the fixtures have completed execution. In the examples below, the method RunBeforeAnyTests() is called before any tests or setup methods in the NUnit.Tests namespace. The method RunAfterAnyTests() is called after all the tests in the namespace as well as their individual or fixture teardowns have completed execution. Multiple SetUpFixtures may be created in a given namespace. The order of execution of such fixtures is indeterminate. A SetUpFixture outside of any namespace provides SetUp and TearDown for the entire assembly. Example using System; using NUnit.Framework; namespace NUnit.Tests { [SetUpFixture] public class MySetUpClass { [OneTimeSetUp] public void RunBeforeAnyTests() { // ... } [OneTimeTearDown] public void RunAfterAnyTests() { // ... } } } Note Prior to NUnit 3.0, SetUpFixture used the SetUp and TearDown attributes rather than OneTimeSetUp and OneTimeTearDown. The older attributes are no longer supported in SetUpFixtures in NUnit 3.0 and later. See also SetUp Attribute TearDown Attribute OneTimeSetUp Attribute OneTimeTearDown Attribute"
  },
  "articles/nunit/writing-tests/attributes/singlethreaded.html": {
    "href": "articles/nunit/writing-tests/attributes/singlethreaded.html",
    "title": "SingleThreaded | NUnit Docs",
    "keywords": "SingleThreaded SingleThreadedAttribute is used on a TestFixture and indicates that the OneTimeSetUp, OneTimeTearDown and all the child tests must run on the same thread."
  },
  "articles/nunit/writing-tests/attributes/teardown.html": {
    "href": "articles/nunit/writing-tests/attributes/teardown.html",
    "title": "TearDown | NUnit Docs",
    "keywords": "TearDown This attribute is used inside a TestFixture to provide a common set of functions that are performed after each test method. TearDown methods may be either static or instance methods and you may define more than one of them in a fixture. Normally, multiple TearDown methods are only defined at different levels of an inheritance hierarchy, as explained below. So long as any SetUp method runs without error, the TearDown method is guaranteed to run. It will not run if a SetUp method fails or throws an exception. Example namespace NUnit.Tests { using System; using NUnit.Framework; [TestFixture] public class SuccessTests { [SetUp] public void Init() { /* ... */ } [TearDown] public void Cleanup() { /* ... */ } [Test] public void Add() { /* ... */ } } } Inheritance The TearDown attribute is inherited from any base class. Therefore, if a base class has defined a TearDown method, that method will be called after each test method in the derived class. You may define a TearDown method in the base class and another in the derived class. NUnit will call base class TearDown methods after those in the derived classes. Notes Although it is possible to define multiple TearDown methods in the same class, you should rarely do so. Unlike methods defined in separate classes in the inheritance hierarchy, the order in which they are executed is not guaranteed. TearDown methods may be async if running under .NET 4.0 or higher. See also SetUp Attribute OneTimeSetUp Attribute OneTimeTearDown Attribute TestFixture Attribute"
  },
  "articles/nunit/writing-tests/attributes/test.html": {
    "href": "articles/nunit/writing-tests/attributes/test.html",
    "title": "Test | NUnit Docs",
    "keywords": "Test The Test attribute is one way of marking a method inside a TestFixture class as a test. It is normally used for simple (non-parameterized) tests but may also be applied to parameterized tests without causing any extra test cases to be generated. See Parameterized Tests for more info. The test method may be either an instance or a static method. Test methods targeting .Net 4.0 or higher may be marked as async and NUnit will wait for the method to complete before recording the result and moving on to the next test. Async test methods must return Task if no value is returned, or Task<T> if a value of type T is returned. If the programmer marks a test method that does not have the correct signature it will be considered as not runnable and be indicated as such by the console or gui runner. In the Gui, such tests are marked in red. If the test method returns a value, you must pass in the ExpectedResult named parameter to the Test attribute. This expected return value will be checked for equality with the return value of the test method. The test Description may be specified as a named parameter. This is exactly equivalent to using the DescriptionAttribute on the test. Examples namespace NUnit.Tests { using System; using NUnit.Framework; [TestFixture] public class SuccessTests { // A simple test [Test] public void Add() { /* ... */ } // A test with a description property [Test(Description=\"My really cool test\")] public void Add() { /* ... */ } // Alternate way to specify description as a separate attribute [Test, Description(\"My really really cool test\")] public void Add() { /* ... */ } // A simple async test [Test] public async Task AddAsync() { /* ... */ } // Test with an expected result [Test(ExpectedResult = 4)] public int TestAdd() { return 2 + 2; } // Async test with an expected result [Test(ExpectedResult = 4)] public async Task<int> TestAdd() { await ... return 2 + 2; } } }"
  },
  "articles/nunit/writing-tests/attributes/testcase.html": {
    "href": "articles/nunit/writing-tests/attributes/testcase.html",
    "title": "TestCase | NUnit Docs",
    "keywords": "TestCase TestCaseAttribute serves the dual purpose of marking a method with parameters as a test method and providing inline data to be used when invoking that method. Here is an example of a test being run three times, with three different sets of data: [TestCase(12, 3, 4)] [TestCase(12, 2, 6)] [TestCase(12, 4, 3)] public void DivideTest(int n, int d, int q) { Assert.AreEqual(q, n / d); } Note Because arguments to .NET attributes are limited in terms of the Types that may be used, NUnit will make some attempt to convert the supplied values using Convert.ChangeType() before supplying it to the test. TestCaseAttribute may appear one or more times on a test method, which may also carry other attributes providing test data. The method may optionally be marked with the Test Attribute as well. By using the named parameter ExpectedResult this test set may be simplified further: [TestCase(12, 3, ExpectedResult=4)] [TestCase(12, 2, ExpectedResult=6)] [TestCase(12, 4, ExpectedResult=3)] public int DivideTest(int n, int d) { return n / d; } In the above example, NUnit checks that the return value of the method is equal to the expected result provided on the attribute. TestCaseAttribute supports a number of additional named parameters: Author sets the author of the test. Category provides a comma-delimited list of categories for this test. Description sets the description property of the test. ExcludePlatform specifies a comma-delimited list of platforms on which the test should not run. ExpectedResult sets the expected result to be returned from the method, which must have a compatible return type. Explicit is set to true in order to make the individual test case Explicit. Use Reason to explain why. Ignore causes the test case to be ignored and specifies the reason. IgnoreReason causes this test case to be ignored and specifies the reason. IncludePlatform specifies a comma-delimited list of platforms on which the test should run. Reason specifies the reason for not running this test case. Use in conjunction with Explicit . TestName provides a name for the test. If not specified, a name is generated based on the method name and the arguments provided. See Template Based Test Naming . TestOf specifies the Type that this test is testing Order of Execution Individual test cases are executed in the order in which NUnit discovers them. This order does not necessarily follow the lexical order of the attributes and will often vary between different compilers or different versions of the CLR. As a result, when TestCaseAttribute appears multiple times on a method or when other data-providing attributes are used in combination with TestCaseAttribute , the order of the test cases is undefined."
  },
  "articles/nunit/writing-tests/attributes/testcasesource.html": {
    "href": "articles/nunit/writing-tests/attributes/testcasesource.html",
    "title": "TestCaseSource | NUnit Docs",
    "keywords": "TestCaseSource TestCaseSourceAttribute is used on a parameterized test method to identify the source from which the required arguments will be provided. The attribute additionally identifies the method as a test method. The data is kept separate from the test itself and may be used by multiple test methods. See Parameterized Tests for a general introduction to tests with arguments. Usage Consider a test of the divide operation, taking three arguments: the numerator, the denominator and the expected result. We can specify the test and its data using one of the forms of TestCaseSourceAttribute : Form 1 - [TestCaseSource(string sourceName)] public class MyTestClass { [TestCaseSource(\"DivideCases\")] public void DivideTest(int n, int d, int q) { Assert.AreEqual(q, n / d); } static object[] DivideCases = { new object[] { 12, 3, 4 }, new object[] { 12, 2, 6 }, new object[] { 12, 4, 3 } }; } The single attribute argument in this form is a string representing the name of the source used to provide test cases. It has the following characteristics: It may be a field, property or method in the test class. It must be static. This is a change from NUnit 2.x. It must return an IEnumerable or a type that implements IEnumerable . For fields an array is generally used. For properties and methods, you may return an array or implement your own iterator. The individual items returned by the enumerator must be compatible with the signature of the method on which the attribute appears. See the Test Case Construction section below for details. Sometimes we would like to parameterize the source, e.g. if we use the same source for multiple tests, to this end it is possible to pass parameters to the source, if the source is a method. The parameters are specified as an array of parameters that are passed to the source method. public class MyTestClass { [TestCaseSource(nameof(TestStrings), new object[] { true })] public void LongNameWithEvenNumberOfCharacters(string name) { Assert.That(name.Length, Is.GreaterThan(5)); bool hasEvenNumOfCharacters = (name.Length / 2) == 0; } [TestCaseSource(nameof(TestStrings), new object[] { false })] public void ShortName(string name) { Assert.That(name.Length, Is.LessThan(15)); } static IEnumerable<string> TestStrings(bool generateLongTestCase) { if (generateLongTestCase) yield return \"ThisIsAVeryLongNameThisIsAVeryLongName\"; yield return \"SomeName\"; yield return \"YetAnotherName\"; } } Form 2 - [TestCaseSource(Type sourceType, string sourceName)] public class MyTestClass { [TestCaseSource(typeof(AnotherClass), \"DivideCases\")] public void DivideTest(int n, int d, int q) { Assert.AreEqual(q, n / d); } } class AnotherClass { static object[] DivideCases = { new object[] { 12, 3, 4 }, new object[] { 12, 2, 6 }, new object[] { 12, 4, 3 } }; } The first argument of the attribute in this form is a Type representing the class that will provide the test cases. The second argument is a string representing the name of the source used to provide test cases. It has the following characteristics: It may be a field, property or method in the test class. It must be static. This is a change from NUnit 2.x. It must return an IEnumerable or a type that implements IEnumerable . For fields an array is generally used. For properties and methods, you may return an array or implement your own iterator. The individual items returned by the enumerator must be compatible with the signature of the method on which the attribute appears. See the Test Case Construction section below for details. Similar to Form 1 it is possible to pass parameters to the source, if the source is a method. Form 3 - [TestCaseSource(Type sourceType)] public class MyTestClass { [TestCaseSource(typeof(DivideCases))] public void DivideTest(int n, int d, int q) { Assert.AreEqual(q, n / d); } } class DivideCases : IEnumerable { public IEnumerator GetEnumerator() { yield return new object[] { 12, 3, 4 }; yield return new object[] { 12, 2, 6 }; yield return new object[] { 12, 4, 3 }; } } The Type argument in this form represents the class that provides test cases. It must have a default constructor and implement IEnumerable . The enumerator should return test case data compatible with the signature of the test on which the attribute appears. See the Test Case Construction section below for details. Note that it is not possible to pass parameters to the source, even if the source is a method. Named Parameters TestCaseSourceAttribute supports one named parameter: Category is used to assign one or more categories to every test case returned from this source. Test Case Construction In constructing tests, NUnit uses each item returned by the enumerator as follows: If it is an object derived from the TestCaseDataParameters class, its properties are used to provide the test case. NUnit provides the TestCaseData type for this purpose. If the test has a single argument and the returned value matches the type of that argument it is used directly. This can eliminate a bit of extra typing by the programmer, as in this example: static int[] EvenNumbers = new int[] { 2, 4, 6, 8 }; [Test, TestCaseSource(\"EvenNumbers\")] public void TestMethod(int num) { Assert.IsTrue(num % 2 == 0); } If it is an object[] , its members are used to provide the arguments for the method. This is the approach taken in the three examples above. If it is an array of some other type, NUnit can use it provided that the arguments to the method are all of that type. For example, the above examples could be modified to make the three nested arrays of type int[] . If anything else is returned, it is used directly as the sole argument to the method. Because every returned value is used, NUnit is able to give an error message in cases where the method requires a different number of arguments or an argument of a different type. Notes It is recommended that the SourceType not be the same as the test fixture class. It may be a nested class, however, and probably should be if the data is only used within that fixture. A generic IEnumerable and IEnumerator may be used but NUnit will actually deal with the underlying IEnumerator in the current release. The GetEnumerator method may use yield statements or simply return the enumerator for an array or other collection held by the class. Order of Execution Individual test cases are executed in the order in which NUnit discovers them. This order does not follow the lexical order of the attributes and will often vary between different compilers or different versions of the CLR. As a result, when TestCaseSourceAttribute appears multiple times on a method or when other data-providing attributes are used in combination with TestCaseSourceAttribute , the order of the test cases is undefined. However, when a single TestCaseSourceAttribute is used by itself, the order of the tests follows exactly the order in which the test cases are returned from the source. Object Construction NUnit locates the test cases at the time the tests are loaded. It creates instances of each class used with the third form of the attribute and builds a list of tests to be executed. Each data source class is only created once at this time and is destroyed after all tests are loaded. By design, no communication is possible between the load and execution phases except through the tests that are created."
  },
  "articles/nunit/writing-tests/attributes/testfixture.html": {
    "href": "articles/nunit/writing-tests/attributes/testfixture.html",
    "title": "TestFixture | NUnit Docs",
    "keywords": "TestFixture This is the attribute that marks a class that contains tests and, optionally, setup or teardown methods. Most restrictions on a class that is used as a test fixture have now been eliminated. A test fixture class: May be public, protected, private or internal. May be a static class. May be generic, so long as any type parameters are provided or can be inferred from the actual arguments. May not be abstract - although the attribute may be applied to an abstract class intended to serve as a base class for test fixtures. If no arguments are provided with the TestFixtureAttribute, the class must have a default constructor. If arguments are provided, they must match one of the constructors. If any of these restrictions are violated, the class is not runnable as a test and will display as an error. It is advisable that the constructor not have any side effects, since NUnit may construct the object multiple times in the course of a session. Beginning with NUnit 2.5, the TestFixture attribute is optional for non-parameterized, non-generic fixtures. So long as the class contains at least one method marked with the Test , TestCase or TestCaseSource attribute, it will be treated as a test fixture. Example namespace NUnit.Tests { using System; using NUnit.Framework; [TestFixture] public class SuccessTests { // ... } } Inheritance The TestFixtureAttribute may be applied to a base class and is inherited by any derived classes. This includes any abstract base class, so the well-known Abstract Fixture pattern may be implemented if desired. In order to facilitate use of generic and/or parameterized classes, where the derived class may require a different number of arguments (or type arguments) from the base class, superfluous TestFixture attributes are ignored, using the following rules: If all TestFixture attributes provide constructor or type arguments, then all of them are used. If some of the attributes provide arguments and others do not, then only those with arguments are used and those without arguments are ignored. If none of the attributes provide arguments, one of them is selected for use by NUnit. It is not possible to predict which will be used, so this situation should generally be avoided. This permits code like the following, which would cause an error if the attribute on the base class were not ignored. [TestFixture] public class AbstractFixtureBase { /* ... */ } [TestFixture(typeof(string))] public class DerivedFixture<T> : AbstractFixtureBase { /* ... */ } Parameterized Test Fixtures Test fixtures may take constructor arguments. Argument values are specified as arguments to the TestFixture attribute. NUnit will construct a separate instance of the fixture for each set of arguments. Individual fixture instances in a set of parameterized fixtures may be ignored. Set the Ignore named parameter of the reason for ignoring the instance. Individual fixture instances may be given categories as well. Set the Category named parameter of the attribute to the name of the category or to a comma-separated list of categories. Example The following test fixture would be instantiated by NUnit three times, passing in each set of arguments to the appropriate constructor. Note that there are three different constructors, matching the data types provided as arguments. [TestFixture(\"hello\", \"hello\", \"goodbye\")] [TestFixture(\"zip\", \"zip\")] [TestFixture(42, 42, 99)] public class ParameterizedTestFixture { private string eq1; private string eq2; private string neq; public ParameterizedTestFixture(string eq1, string eq2, string neq) { this.eq1 = eq1; this.eq2 = eq2; this.neq = neq; } public ParameterizedTestFixture(string eq1, string eq2) : this(eq1, eq2, null) { } public ParameterizedTestFixture(int eq1, int eq2, int neq) { this.eq1 = eq1.ToString(); this.eq2 = eq2.ToString(); this.neq = neq.ToString(); } [Test] public void TestEquality() { Assert.AreEqual(eq1, eq2); if (eq1 != null && eq2 != null) Assert.AreEqual(eq1.GetHashCode(), eq2.GetHashCode()); } [Test] public void TestInequality() { Assert.AreNotEqual(eq1, neq); if (eq1 != null && neq != null) Assert.AreNotEqual(eq1.GetHashCode(), neq.GetHashCode()); } } Generic Test Fixtures You may also use a generic class as a test fixture. In order for NUnit to instantiate the fixture, you must either specify the types to be used as arguments to TestFixtureAttribute or use the named parameter TypeArgs= to specify them. NUnit will construct a separate instance of the fixture for each TestFixtureAttribute you provide. Example The following test fixture would be instantiated by NUnit twice, once using an ArrayList and once using a List<int> . [TestFixture(typeof(ArrayList))] [TestFixture(typeof(List<int>))] public class IList_Tests<TList> where TList : IList, new() { private IList list; [SetUp] public void CreateList() { this.list = new TList(); } [Test] public void CanAddToList() { list.Add(1); list.Add(2); list.Add(3); Assert.AreEqual(3, list.Count); } } Generic Test Fixtures with Parameters If a Generic fixture, uses constructor arguments, there are three approaches to telling NUnit which arguments are type parameters and which are normal constructor parameters. Specify both sets of parameters as arguments to the TestFixtureAttribute . Leading System.Type arguments are used as type parameters, while any remaining arguments are used to construct the instance. In the following example, this leads to some obvious duplication... [TestFixture(typeof(double), typeof(int), 100.0, 42)] [TestFixture(typeof(int) typeof(double), 42, 100.0)] public class SpecifyBothSetsOfArgs<T1, T2> { T1 t1; T2 t2; public SpecifyBothSetsOfArgs(T1 t1, T2 t2) { this.t1 = t1; this.t2 = t2; } [TestCase(5, 7)] public void TestMyArgTypes(T1 t1, T2 t2) { Assert.That(t1, Is.TypeOf<T1>()); Assert.That(t2, Is.TypeOf<T2>()); } } Specify normal parameters as arguments to TestFixtureAttribute and use the named parameter TypeArgs= to specify the type arguments. Again, for this example, the type info is duplicated, but it is at least more cleanly separated from the normal arguments... [TestFixture(100.0, 42, TypeArgs=new Type[] { typeof(double), typeof(int) })] [TestFixture(42, 100.0, TypeArgs=new Type[] { typeof(int), typeof(double) })] public class SpecifyTypeArgsSeparately<T1, T2> { T1 t1; T2 t2; public SpecifyTypeArgsSeparately(T1 t1, T2 t2) { this.t1 = t1; this.t2 = t2; } [TestCase(5, 7)] public void TestMyArgTypes(T1 t1, T2 t2) { Assert.That(t1, Is.TypeOf<T1>()); Assert.That(t2, Is.TypeOf<T2>()); } } In some cases, when the constructor makes use of all the type parameters NUnit may simply be able to deduce them from the arguments provided. That's the case here and the following is the preferred way to write this example... [TestFixture(100.0, 42)] [TestFixture(42, 100.0)] public class DeduceTypeArgsFromArgs<T1, T2> { T1 t1; T2 t2; public DeduceTypeArgsFromArgs(T1 t1, T2 t2) { this.t1 = t1; this.t2 = t2; } [TestCase(5, 7)] public void TestMyArgTypes(T1 t1, T2 t2) { Assert.That(t1, Is.TypeOf<T1>()); Assert.That(t2, Is.TypeOf<T2>()); } }"
  },
  "articles/nunit/writing-tests/attributes/testfixturesetup.html": {
    "href": "articles/nunit/writing-tests/attributes/testfixturesetup.html",
    "title": "TestFixtureSetUp | NUnit Docs",
    "keywords": "TestFixtureSetUp Important The TestFixtureSetUp attribute has been deprecated. Use OneTimeSetUp Attribute instead."
  },
  "articles/nunit/writing-tests/attributes/testfixturesource.html": {
    "href": "articles/nunit/writing-tests/attributes/testfixturesource.html",
    "title": "TestFixtureSource | NUnit Docs",
    "keywords": "TestFixtureSource TestFixtureSourceAttribute is used on a parameterized fixture to identify the source from which the required constructor arguments will be provided. The data is kept separate from the fixture itself and may be used by multiple fixtures. See Parameterized Tests for a general introduction to tests with arguments. Usage Consider a test fixture class taking two parameters in its constructor, a string and an int. We can specify the test and its data using one of the forms of TestFixtureSourceAttribute : Form 1 - [TestFixtureSource(string sourceName)] [TestFixtureSource(\"FixtureArgs\")] public class MyTestClass { public MyTestClass(string word, int num) { ... } /* ... */ static object [] FixtureArgs = { new object[] { \"Question\", 1 }, new object[] { \"Answer\", 42 } }; } The single attribute argument in this form is a string representing the name of the source used to provide arguments for constructing the TestFixture . It has the following characteristics: It may be a field, property or method in the test class. It must be static. It must return an IEnumerable or a type that implements IEnumerable . For fields an array is generally used. For properties and methods, you may return an array or implement your own iterator. The individual items returned by the enumerator must either be object arrays or derive from the TestFixtureParameters class. Arguments must be consistent with the fixture constructor. Form 2 - [TestFixtureSource(Type sourceType, string sourceName)] [TestFixtureSource(typeof(AnotherClass), \"FixtureArgs\")] public class MyTestClass { public MyTestClass(string word, int num) { ... } ... } class AnotherClass { static object [] FixtureArgs = { new object[] { \"Question\", 1 }, new object[] { \"Answer\", 42 } }; } The first argument of the attribute in this form is a Type representing the class that will provide the test fixture data. The second argument is a string representing the name of the source used to provide test fixtures. It has the following characteristics: It may be a field, property or method in the test class. It must be static. It must return an IEnumerable or a type that implements IEnumerable . For fields an array is generally used. For properties and methods, you may return an array or implement your own iterator. The individual items returned by the enumerator must either be object arrays or derive from the TestFixtureParameters class. Arguments must be consistent with the fixture constructor. Form 3 - [TestFixtureSource(Type sourceType)] [TestFixtureSource(typeof(FixtureArgs))] public class MyTestClass { public MyTestClass(string word, int num) { /* ... */ } /* ... */ } class FixtureArgs: IEnumerable { public IEnumerator GetEnumerator() { yield return new object[] { \"Question\", 1 }; yield return new object[] { \"Answer\", 42 }; } } The Type argument in this form represents the class that provides test cases. It must have a default constructor and implement IEnumerable . The individual items returned by the enumerator must either be object arrays or derive from the TestFixtureParameters class. Arguments must be consistent with the fixture constructor. Named Parameters TestCaseSourceAttribute supports one named parameter: Category is used to assign one or more categories to every test case returned from this source. Test Case Construction In constructing tests, NUnit uses each item returned by the enumerator as follows: If it is an object deriving from TestFixtureParameters , its properties are used to provide the test case. NUnit provides the TestFixtureData class for this purpose. If it is an object[] , its members are used to provide the arguments for the method. This is the approach taken in the examples above. Notes It is recommended that the SourceType not be the same as the test fixture class. It may be a nested class, however, and probably should be if the data is only used within that fixture. A generic IEnumerable and IEnumerator may be used but NUnit will actually deal with the underlying IEnumerator in the current release. The GetEnumerator method may use yield statements or simply return the enumerator for an array or other collection held by the class."
  },
  "articles/nunit/writing-tests/attributes/testfixtureteardown.html": {
    "href": "articles/nunit/writing-tests/attributes/testfixtureteardown.html",
    "title": "TestFixtureTearDown | NUnit Docs",
    "keywords": "TestFixtureTearDown Important The TextFixtureTearDown attribute has been deprecated. Use OneTimeTearDown Attribute instead."
  },
  "articles/nunit/writing-tests/attributes/testof.html": {
    "href": "articles/nunit/writing-tests/attributes/testof.html",
    "title": "TestOf | NUnit Docs",
    "keywords": "TestOf The TestOf attribute adds information about the class that is being tested. It can be applied to test fixtures and to tests. The constructor takes the string name or the type of the class being tested. TestOf can also be specified on a TestFixture or Test attribute. [TestFixture] [TestOf(typeof(MyClass)] public class MyTests { [Test] public void Test1() { /* ... */ } [Test] [TestOf(\"MySubClass\")] public void Test2() { /* ... */ } } [TestFixture(TestOf = typeof(MyClass))] public class MyOtherTests { [Test] public void Test1() { /* ... */ } [Test(TestOf = typeof(MySubClass))] public void Test2() { /* ... */ } } Note you can currently only have one TestOf attribute per fixture or test."
  },
  "articles/nunit/writing-tests/attributes/theory.html": {
    "href": "articles/nunit/writing-tests/attributes/theory.html",
    "title": "Theory | NUnit Docs",
    "keywords": "Theory A Theory is a special type of test, used to verify a general statement about the system under development. Normal tests are example-based . That is, the developer supplies one or more examples of inputs and expected outputs either within the code of the test or - in the case of Parameterized Tests - as arguments to the test method. A theory, on the other hand, makes a general statement that all of its assertions will pass for all arguments satisfying certain assumptions. Theories are implemented in NUnit as non-generic methods within a TestFixture , which are annotated with the TheoryAttribute . Theory methods must always have arguments and therefore appears quite similar to Parameterized Tests at first glance. However, a Theory incorporates additional data sources for its arguments and allows special processing for assumptions about that data. The key difference, though, is that theories make general statements and are more than just a set of examples. Data for Theories The primary source of data for a Theory is the Datapoint Attribute or DatapointSource Attribute . NUnit will use any class members of the required types, which are annotated with one of these attributes, to provide data for each parameter of the Theory. NUnit assembles the values for individual arguments combinatorially to provide test cases for the theory. In addition to the Datapoint and Datapoints attributes, it is possible to use any of the approaches for supplying data that are recognized on normal parameterized tests. We suggest that this capability not be overused, since it runs counter to the distinction between a test based on examples and a theory. However, it may be useful in order to guarantee that a specific test case is included. For boolean and enum arguments, NUnit can supply the data without any action by the user. All possible values are supplied to the argument. This feature is disabled if the user supplies any values for the argument. Note Because NUnit searches for datapoints based on the type of the argument, generic methods may not currently be used as theories. This limitation may be removed in a future release. See below for a workaround using a generic fixture. Assumptions The theory itself is responsible for ensuring that all data supplied meets its assumptions. It does this by use of the Assume.That(...) construct, which works just like Assert.That(...) but does not cause a failure. If the assumption is not satisfied for a particular test case, that case returns an Inconclusive result, rather than a Success or Failure. The overall result of executing a Theory over a set of test cases is determined as follows: If the assumptions are violated for all test cases, then the Theory itself is marked as a failure. If any Assertion fails, the Theory itself fails. If at least some cases pass the stated assumptions, and there are no assertion failures or exceptions, then the Theory passes. Since the user does not generally care about inconclusive cases under a theory, they are not normally displayed in the Gui. For situations where they are needed - such as debugging - the context menu for the theory provides an option to display them. Example In the following example, the Theory SquareRootDefinition verifies that the implementation of square root satisfies the following definition: Given a non-negative number, the square root of that number is always non-negative and, when multiplied by itself, gives the original number. public class SqrtTests { [DatapointSource] public double[] values = new double[] { 0.0, 1.0, -1.0, 42.0 }; [Theory] public void SquareRootDefinition(double num) { Assume.That(num >= 0.0); double sqrt = Math.Sqrt(num); Assert.That(sqrt >= 0.0); Assert.That(sqrt * sqrt, Is.EqualTo(num).Within(0.000001)); } } Theories in Generic Fixtures In a generic fixture with Type parameter T individual methods using T as a parameter type or not generic, since T has been resolved to an actual Type in instantiating the fixture instance. You may use such methods as theories and any data of the appropriate type will be used. [TestFixture(typeof(int))] [TestFixture(typeof(double))] public class TheorySampleTestsGeneric<T> { [Datapoint] public double[] ArrayDouble1 = { 1.2, 3.4 }; [Datapoint] public double[] ArrayDouble2 = { 5.6, 7.8 }; [Datapoint] public int[] ArrayInt = { 0, 1, 2, 3 }; [Theory] public void TestGenericForArbitraryArray(T[] array) { Assert.That(array.Length, Is.EqualTo(4)); } } See also Datapoint Attribute DatapointSource Attribute Parameterized Tests"
  },
  "articles/nunit/writing-tests/attributes/timeout.html": {
    "href": "articles/nunit/writing-tests/attributes/timeout.html",
    "title": "Timeout | NUnit Docs",
    "keywords": "Timeout Note From version 3.12 this is also available in the .NET Standard 2.0 builds of the framework. Normally, NUnit simply runs tests and waits for them to terminate - the test may is allowed to run indefinitely. For certain kinds of tests, however, it may be desired to specify a timeout value. The TimeoutAttribute is used to specify a timeout value in milliseconds for a test case. If the test case runs longer than the time specified it is immediately cancelled and reported as a failure, with a message indicating that the timeout was exceeded. The specified timeout value covers the test setup and teardown as well as the test method itself. Before and after actions may also be included, depending on where they were specified. Since the timeout may occur during any of these execution phases, no guarantees can be made as to what will be run and any of these phases of execution may be incomplete. Specifically, once a test has timed out, no further attempt is made to execute its teardown methods. The attribute may also be specified on a fixture or assembly, in which case it indicates the default timeout for any subordinate test cases. When using the console runner, it is also possible to specify a default timeout on the command-line. Example [Test, Timeout(2000)] public void PotentiallyLongRunningTest() { /* ... */ } Note When debugging a unit test - i.e. when a debugger is attached to the process - then the timeout is not enforced. See Also MaxTime Attribute"
  },
  "articles/nunit/writing-tests/attributes/values.html": {
    "href": "articles/nunit/writing-tests/attributes/values.html",
    "title": "Values | NUnit Docs",
    "keywords": "Values The ValuesAttribute is used to specify a set of values to be provided for an individual parameter of a parameterized test method. Since NUnit combines the data provided for each parameter into a set of test cases, data must be provided for all parameters if it is provided for any of them. By default, NUnit creates test cases from all possible combinations of the data values provided on parameters - the combinatorial approach. This default may be modified by use of specific attributes on the test method itself. Example [Test] public void MyTest([Values(1, 2, 3)] int x, [Values(\"A\", \"B\")] string s) { /* ... */ } The above test will be executed six times, as follows: MyTest(1, \"A\") MyTest(1, \"B\") MyTest(2, \"A\") MyTest(2, \"B\") MyTest(3, \"A\") MyTest(3, \"B\") Values with Enum or Boolean The values attribute works in a special way with Enums and Boolean parameters. When used without any arguments, the [Values] attribute on an enum parameter will automatically include all possible values of the enumeration. [Test] public void MyEnumTest([Values]MyEnumType myEnumArgument) { //... } There is the same support for Boolean values. Add the [Values] attribute to a bool and the method will be run with true and false. [Test] public void MyBoolTest([Values]bool value) { //... } See also Range Attribute Random Attribute Sequential Attribute Combinatorial Attribute Pairwise Attribute"
  },
  "articles/nunit/writing-tests/attributes/valuesource.html": {
    "href": "articles/nunit/writing-tests/attributes/valuesource.html",
    "title": "ValueSource | NUnit Docs",
    "keywords": "ValueSource ValueSourceAttribute is used on individual parameters of a test method to identify a named source for the argument values to be supplied. The attribute has two public constructors. ValueSourceAttribute(Type sourceType, string sourceName); ValueSourceAttribute(string sourceName); If sourceType is specified, it represents the class that provides the data. If sourceType is not specified, the class containing the test method is used. The sourceName , represents the name of the source that will provide the arguments. It should have the following characteristics: It may be a field, a non-indexed property or a method taking no arguments. It must be a static member. It must return an IEnumerable or a type that implements IEnumerable. The individual items returned from the enumerator must be compatible with the type of the parameter on which the attribute appears. Order of Execution Individual test cases are executed in the order in which NUnit discovers them. This order does not follow the lexical order of the attributes and will often vary between different compilers or different versions of the CLR. As a result, when ValueSourceAttribute appears multiple times on a parameter or when other data-providing attributes are used in combination with ValueSourceAttribute , the order of the arguments is undefined. However, when a single ValueSourceAttribute is used by itself, the order of the arguments follows exactly the order in which the data is returned from the source. Note on Object Construction NUnit locates the test cases at the time the tests are loaded, creates instances of each class with non-static sources and builds a list of tests to be executed. Each source object is only created once at this time and is destroyed after all tests are loaded. If the data source is in the test fixture itself, the object is created using the appropriate constructor for the fixture parameters provided on the TestFixtureAttribute , or the default constructor if no parameters were specified. Since this object is destroyed before the tests are run, no communication is possible between these two phases - or between different runs - except through the parameters themselves."
  },
  "articles/nunit/writing-tests/constraints/AllItemsConstraint.html": {
    "href": "articles/nunit/writing-tests/constraints/AllItemsConstraint.html",
    "title": "AllItems Constraint | NUnit Docs",
    "keywords": "AllItems Constraint AllItemsConstraint applies a constraint to each item in an IEnumerable , succeeding only if all of them succeed. An exception is thrown if the actual value passed does not implement IEnumerable . Constructor AllItemsConstraint(Constraint itemConstraint) Syntax Is.All... Has.All... Examples of Use int[] iarray = new int[] { 1, 2, 3 }; string[] sarray = new string[] { \"a\", \"b\", \"c\" }; Assert.That(iarray, Is.All.Not.Null); Assert.That(sarray, Is.All.InstanceOf<string>()); Assert.That(iarray, Is.All.GreaterThan(0)); Assert.That(iarray, Has.All.GreaterThan(0));"
  },
  "articles/nunit/writing-tests/constraints/AndConstraint.html": {
    "href": "articles/nunit/writing-tests/constraints/AndConstraint.html",
    "title": "And Constraint | NUnit Docs",
    "keywords": "And Constraint AndConstraint combines two other constraints and succeeds only if they both succeed. Constructor AndConstraint(Constraint left, Constraint right) Syntax <Constraint>.And.<Constraint> Examples of Use Assert.That(2.3, Is.GreaterThan(2.0).And.LessThan(3.0)); Evaluation Order and Precedence Note that the constraint evaluates the sub-constraints left to right, meaning that Assert.That(i, Is.Not.Null.And.GreaterThan(9)); where i is a nullable int will work for 10 , but fail for null with the message Expected: not null and greater than 9. But was: null . Assert.That(i, Is.GreaterThan(9).And.Not.Null); will also succeed for 10 , but throw an exception for null , as null cannot be compared to 9 . The OrConstraint has precedence over the AndConstraint . See also OrConstraint"
  },
  "articles/nunit/writing-tests/constraints/AnyOfConstraint.html": {
    "href": "articles/nunit/writing-tests/constraints/AnyOfConstraint.html",
    "title": "AnyOf Constraint | NUnit Docs",
    "keywords": "AnyOf Constraint AnyOfConstraint is used to determine whether a value is equal to any of the expected values. Constructor AnyOfConstraint(object[] expected) Syntax Is.AnyOf(object[] expected) Modifiers ...Using(IComparer comparer) ...Using<T>(IEqualityComparer comparer) ...Using<T>(Func<T, T, bool>) ...Using<T>(IComparer<T> comparer) ...Using<T>(Comparison<T> comparer) ...Using<T>(IEqualityComparer<T> comparer) Examples of Use int[] iarray = new int[] { 0, -1, 42, 100 } Assert.That(42, Is.AnyOf(iarray)); Assert.That(myOwnObject, Is.AnyOf(myArray).Using(myComparer));"
  },
  "articles/nunit/writing-tests/constraints/AssignableFromConstraint.html": {
    "href": "articles/nunit/writing-tests/constraints/AssignableFromConstraint.html",
    "title": "AssignableFrom Constraint | NUnit Docs",
    "keywords": "AssignableFrom Constraint AssignableFromConstraint tests that one type is assignable from another Constructor AssignableFromConstraint(Type) Syntax Is.AssignableFrom(Type) Is.AssignableFrom<T>() Examples of Use Assert.That(\"Hello\", Is.AssignableFrom(typeof(string))); Assert.That(5, Is.Not.AssignableFrom(typeof(string)));"
  },
  "articles/nunit/writing-tests/constraints/AssignableToConstraint.html": {
    "href": "articles/nunit/writing-tests/constraints/AssignableToConstraint.html",
    "title": "AssignableTo Constraint | NUnit Docs",
    "keywords": "AssignableTo Constraint AssignableToConstraint tests that one type is assignable to another Constructor AssignableToConstraint(Type) Syntax Is.AssignableTo(Type) Is.AssignableTo<T>() Examples of Use Assert.That(\"Hello\", Is.AssignableTo(typeof(object))); Assert.That(5, Is.Not.AssignableTo(typeof(string)));"
  },
  "articles/nunit/writing-tests/constraints/AttributeConstraint.html": {
    "href": "articles/nunit/writing-tests/constraints/AttributeConstraint.html",
    "title": "Attribute Constraint | NUnit Docs",
    "keywords": "Attribute Constraint AttributeConstraint tests for the existence of an attribute on a Type and then applies a constraint to that attribute. Constructor AttributeConstraint(Type type, IConstraint baseConstraint) Syntax Has.Attribute(typeof(TestFixtureAttribute))... Has.Attribute<TestFixtureAttribute>()... Examples of Use Assert.That(someObject, Has.Attribute(typeof(TestFixtureAttribute)) .Property(\"Description\").EqualTo(\"My description\")); Assert.That(someObject, Has.Attribute<TestFixtureAttribute>() .Property(\"Description\").EqualTo(\"My description\")); See also AttributeExistsConstraint"
  },
  "articles/nunit/writing-tests/constraints/AttributeExistsConstraint.html": {
    "href": "articles/nunit/writing-tests/constraints/AttributeExistsConstraint.html",
    "title": "AttributeExists Constraint | NUnit Docs",
    "keywords": "AttributeExists Constraint AttributeExistsConstraint tests for the existence of an attribute on a Type. Constructor AttributeExistsConstraint(Type type) Syntax Has.Attribute(typeof(TestFixtureAttribute)) Has.Attribute<TestFixtureAttribute>() Examples of Use Assert.That(someObject, Has.Attribute(typeof(TestFixtureAttribute))); Assert.That(someObject, Has.Attribute<TestFixtureAttribute>());"
  },
  "articles/nunit/writing-tests/constraints/BinarySerializableConstraint.html": {
    "href": "articles/nunit/writing-tests/constraints/BinarySerializableConstraint.html",
    "title": "BinarySerializable Constraint | NUnit Docs",
    "keywords": "BinarySerializable Constraint BinarySerializableConstraint tests whether an object is serializable in binary format. Constructor BinarySerializableConstraint() Syntax Is.BinarySerializable Examples of Use Assert.That(someObject, Is.BinarySerializable)); See also XmlSerializableConstraint"
  },
  "articles/nunit/writing-tests/constraints/CollectionContainsConstraint.html": {
    "href": "articles/nunit/writing-tests/constraints/CollectionContainsConstraint.html",
    "title": "CollectionContains Constraint | NUnit Docs",
    "keywords": "CollectionContains Constraint CollectionContainsConstraint tests that an IEnumerable contains an object. If the actual value passed does not implement IEnumerable , an exception is thrown. Constructor CollectionContainsConstraint(object) Syntax Has.Member(object) Contains.Item(object) Does.Contain(object) Modifiers ...Using(IComparer comparer) ...Using<T>(IComparer<T> comparer) ...Using<T>(Comparison<T> comparer) Examples of Use int[] iarray = new int[] { 1, 2, 3 }; string[] sarray = new string[] { \"a\", \"b\", \"c\" }; Assert.That(iarray, Has.Member(3)); Assert.That(sarray, Has.Member(\"b\")); Assert.That(sarray, Contains.Item(\"c\")); Assert.That(sarray, Has.No.Member(\"x\")); Assert.That(iarray, Does.Contain(3)); Note Has.Member() , Contains.Item() and Does.Contain() work the same as Has.Some.EqualTo() . The last statement generates a SomeItemsConstraint based on an EqualConstraint and offers additional options such as ignoring case or specifying a tolerance. The syntax on this page may be viewed as a shortcut for specifying simpler cases."
  },
  "articles/nunit/writing-tests/constraints/CollectionEquivalentConstraint.html": {
    "href": "articles/nunit/writing-tests/constraints/CollectionEquivalentConstraint.html",
    "title": "CollectionEquivalent Constraint | NUnit Docs",
    "keywords": "CollectionEquivalent Constraint CollectionEquivalentConstraint tests that two IEnumerables are equivalent - that they contain the same items, in any order. If the actual value passed does not implement IEnumerable an exception is thrown. Constructor CollectionEquivalentConstraint(IEnumerable other) Syntax Is.EquivalentTo(IEnumerable other) Examples of Use int[] iarray = new int[] { 1, 2, 3 }; string[] sarray = new string[] { \"a\", \"b\", \"c\" }; Assert.That(new string[] { \"c\", \"a\", \"b\" }, Is.EquivalentTo(sarray)); Assert.That(new int[] { 1, 2, 2 }, Is.Not.EquivalentTo(iarray)); Notes To compare items in order, use Is.EqualTo()."
  },
  "articles/nunit/writing-tests/constraints/CollectionOrderedConstraint.html": {
    "href": "articles/nunit/writing-tests/constraints/CollectionOrderedConstraint.html",
    "title": "CollectionOrdered Constraint | NUnit Docs",
    "keywords": "CollectionOrdered Constraint CollectionOrderedConstraint tests that an IEnumerable is ordered. If the actual value passed does not implement IEnumerable , an exception is thrown. The constraint supports both simple and property-based ordering (Ordered.By). Simple Ordering Simple ordering is based on the values of the items themselves. It is implied when the By modifier is not used. int[] iarray = new int[] { 1, 2, 3 }; Assert.That(iarray, Is.Ordered); string[] sarray = new string[] { \"c\", \"b\", \"a\" }; Assert.That(sarray, Is.Ordered.Descending); The following modifiers are supported: ...Ascending ...Descending ...Using(IComparer comparer) ...Using<T>(IComparer<T> comparer) ...Using<T>(Comparison<T> comparer) By default, the order is expected to be ascending. Property-Based Ordering Property-based ordering uses one or more properties that are common to every item in the enumeration. It is used when one or more instances of the By modifier appears in the ordering expression. string[] sarray = new string[] (\"a\", \"aa\", \"aaa\"); Assert.That(sarray, Is.Ordered.By(\"Length\")); string[] sarray2 = new string[] (\"aaa\", \"aa\", \"a\"); Assert.That(sarray2, Is.Ordered.Descending.By(\"Length\")); The following Modifiers are supported: ...Then ...Ascending ...Descending ...By(string propertyName) ...Using(IComparer comparer) ...Using<T>(IComparer<T> comparer) ...Using<T>(Comparison<T> comparer) Ordering on Multiple Properties An ordering expression may use multiple By modifiers, each referring to a different property. The following examples assume a collection of items with properties named A and B. Assert.That(collection, Is.Ordered.By(\"A\").Then.By(\"B\")); Assert.That(collection, Is.Ordered.By(\"A\").Then.By(\"B\").Descending); Assert.That(collection, Is.Ordered.Ascending.By(\"A\").Then.Descending.By(\"B\")); Assert.That(collection, Is.Ordered.Ascending.By(\"A\").By(\"B\").Descending); Assert.That(collection, Is.Ordered.Ascending.By(\"A\").Descending.By(\"B\")); // Illegal! Notes The Then modifier divides the expression into ordering steps. Each step may optionally contain one Ascending or Descending modifier and one Using modifier. If Then is not used, each new By modifier marks the beginning of a step. The last example statement is illegal because the first group contains both Ascending and Descending. Use of Then is recommended for clarity."
  },
  "articles/nunit/writing-tests/constraints/CollectionSubsetConstraint.html": {
    "href": "articles/nunit/writing-tests/constraints/CollectionSubsetConstraint.html",
    "title": "CollectionSubset Constraint | NUnit Docs",
    "keywords": "CollectionSubset Constraint CollectionSubsetConstraint tests that one IEnumerable is a subset of another. If the actual value passed does not implement IEnumerable , an exception is thrown. Constructor CollectionSubsetConstraint(IEnumerable) Syntax Is.SubsetOf(IEnumerable) Example of Use int[] iarray = new int[] { 1, 3 }; Assert.That(iarray, Is.SubsetOf(new int[] { 1, 2, 3 }));"
  },
  "articles/nunit/writing-tests/constraints/CollectionSupersetConstraint.html": {
    "href": "articles/nunit/writing-tests/constraints/CollectionSupersetConstraint.html",
    "title": "CollectionSuperset Constraint | NUnit Docs",
    "keywords": "CollectionSuperset Constraint CollectionSupersetConstraint tests that one IEnumerable is a superset of another. If the actual value passed does not implement IEnumerable , an exception is thrown. Constructor CollectionSupersetConstraint(IEnumerable) Syntax Is.SupersetOf(IEnumerable) Example of Use int[] iarray = new int[] { 1, 2, 3 }; Assert.That(iarray, Is.SupersetOf(new int[] { 1, 3 }));"
  },
  "articles/nunit/writing-tests/constraints/Constraints.html": {
    "href": "articles/nunit/writing-tests/constraints/Constraints.html",
    "title": "Constraints | NUnit Docs",
    "keywords": "Constraints This page lists all the constraints available in NUnit. Alphabetical List of Constraints Constraints by Category Alphabetical List of Constraints Constraint Name AllItemsConstraint AndConstraint AssignableFromConstraint AssignableToConstraint AttributeConstraint AttributeExistsConstraint AnyOfConstraint BinarySerializableConstraint CollectionContainsConstraint CollectionEquivalentConstraint CollectionOrderedConstraint CollectionSubsetConstraint CollectionSupersetConstraint DelayedConstraint DictionaryContainsKeyConstraint DictionaryContainsValueConstraint EmptyCollectionConstraint EmptyConstraint EmptyDirectoryConstraint EmptyStringConstraint EndsWithConstraint EqualConstraint ExactCountConstraint ExactTypeConstraint FalseConstraint FileOrDirectoryExistsConstraint GreaterThanConstraint GreaterThanOrEqualConstraint InstanceOfTypeConstraint LessThanConstraint LessThanOrEqualConstraint NaNConstraint NoItemConstraint NotConstraint NullConstraint OrConstraint PropertyConstraint PropertyExistsConstraint RangeConstraint RegexConstraint ReusableConstraint SameAsConstraint SamePathConstraint SamePathOrUnderConstraint SomeItemsConstraint StartsWithConstraint SubPathConstraint SubstringConstraint ThrowsConstraint ThrowsNothingConstraint TrueConstraint UniqueItemsConstraint XmlSerializableConstraint Constraints by Category Collection Constraints Constraint Name AllItemsConstraint AnyOfConstraint CollectionContainsConstraint CollectionEquivalentConstraint CollectionOrderedConstraint CollectionSubsetConstraint CollectionSupersetConstraint DictionaryContainsKeyConstraint DictionaryContainsValueConstraint EmptyCollectionConstraint ExactCountConstraint NoItemConstraint SomeItemsConstraint UniqueItemsConstraint Comparison Constraints Constraint Name GreaterThanConstraint GreaterThanOrEqualConstraint LessThanConstraint LessThanOrEqualConstraint RangeConstraint Compound Constraints Constraint Name AndConstraint NotConstraint OrConstraint Condition Constraints Constraint Name EmptyConstraint FalseConstraint NaNConstraint NullConstraint TrueConstraint File and Directory Constraints Constraint Name EmptyDirectoryConstraint FileOrDirectoryExistsConstraint SamePathConstraint SamePathOrUnderConstraint SubPathConstraint String Constraints Constraint Name EmptyStringConstraint EndsWithConstraint RegexConstraint StartsWithConstraint SubstringConstraint Type Constraints Constraint Name AssignableFromConstraint AssignableToConstraint ExactTypeConstraint InstanceOfTypeConstraint See also Constraint Model"
  },
  "articles/nunit/writing-tests/constraints/DelayedConstraint.html": {
    "href": "articles/nunit/writing-tests/constraints/DelayedConstraint.html",
    "title": "Delayed Constraint | NUnit Docs",
    "keywords": "Delayed Constraint DelayedConstraint delays the application of another constraint until a certain amount of time has passed. In its simplest form, it replaces use of a Sleep in the code but it also supports polling, which may allow use of a longer maximum time while still keeping the tests as fast as possible. The After modifier is permitted on any constraint, and the delay applies to the entire expression up to the point where After appears. Use of a DelayedConstraint with a value argument makes no sense, since the value will be extracted at the point of call. Its intended use is with delegates and references. If a delegate is used with polling, it may be called multiple times so only methods without side effects should be used in this way. Syntax Helper Constructor Operation After(int) DelayedConstraint(Constraint, int) tests that a constraint is satisfied after a delay. After(int, int) DelayedConstraint(Constraint, int, int) tests that a constraint is satisfied after a delay using polling. Enhanced Syntax With NUnit 3.6, an enhanced syntax is available that allows expressing the delay and polling interval more fluently. After(4).Seconds After(1).Minutes.PollEvery(500).MilliSeconds Only Minutes, Seconds and MilliSeconds (note capital-S) are accepted as time modifiers. The default is to use MilliSeconds."
  },
  "articles/nunit/writing-tests/constraints/DictionaryContainsKeyConstraint.html": {
    "href": "articles/nunit/writing-tests/constraints/DictionaryContainsKeyConstraint.html",
    "title": "DictionaryContainsKey Constraint | NUnit Docs",
    "keywords": "DictionaryContainsKey Constraint DictionaryContainsKeyConstraint is used to test whether a dictionary contains an expected object as a key. Constructor DictionaryContainsKeyConstraint(object) Syntax Contains.Key(object) Does.ContainKey(object) Does.Not.ContainKey(object) Modifiers ...Using(IComparer comparer) ...Using(IEqualityComparer comparer) ...Using<T>(IComparer<T> comparer) ...Using<T>(Comparison<T> comparer) ...Using<T>(Func<T, T, bool> comparer) ...Using<T>(IEqualityComparer<T> comparer) ...Using<TCollectionType, TMemberType>(Func<TCollectionType, TMemberType, bool> comparison) Examples of Use IDictionary<int, int> idict = new IDictionary<int, string> { { 1, 4 }, { 2, 5 } }; Assert.That(idict, Contains.Key(1)); Assert.That(idict, Does.ContainKey(2)); Assert.That(idict, Does.Not.ContainKey(3)); Assert.That(mydict, Contains.Key(myOwnObject).Using(myComparer)); See also DictionaryContainsValueConstraint"
  },
  "articles/nunit/writing-tests/constraints/DictionaryContainsValueConstraint.html": {
    "href": "articles/nunit/writing-tests/constraints/DictionaryContainsValueConstraint.html",
    "title": "DictionaryContainsValue Constraint | NUnit Docs",
    "keywords": "DictionaryContainsValue Constraint DictionaryContainsValueConstraint is used to test whether a dictionary contains an expected object as a value. Constructor DictionaryContainsValueConstraint(object) Syntax Contains.Value(object) Does.ContainValue(object) Does.Not.ContainValue(object) Modifiers ...Using(IComparer comparer) ...Using(IEqualityComparer comparer) ...Using<T>(IComparer<T> comparer) ...Using<T>(Comparison<T> comparer) ...Using<T>(Func<T, T, bool> comparer) ...Using<T>(IEqualityComparer<T> comparer) ...Using<TCollectionType, TMemberType>(Func<TCollectionType, TMemberType, bool> comparison) Examples of Use IDictionary<int, int> idict = new IDictionary<int, int> { { 1, 4 }, { 2, 5 } }; Assert.That(idict, Contains.Value(4)); Assert.That(idict, Does.ContainValue(5)); Assert.That(idict, Does.Not.ContainValue(3)); Assert.That(mydict, Contains.Value(myOwnObject).Using(myComparer)); See also DictionaryContainsKeyConstraint"
  },
  "articles/nunit/writing-tests/constraints/EmptyCollectionConstraint.html": {
    "href": "articles/nunit/writing-tests/constraints/EmptyCollectionConstraint.html",
    "title": "EmptyCollection Constraint | NUnit Docs",
    "keywords": "EmptyCollection Constraint The EmptyCollectionConstraint tests if a Collection or other IEnumerable is empty. An ArgumentException is thrown if the actual value is not an IEnumerable or is null. Constructor EmptyCollectionConstraint() Syntax Is.Empty Examples of Use Assert.That(new int[] { }, Is.Empty); Assert.That(new int[] { 1, 2, 3 }, Is.Not.Empty); Note Is.Empty actually creates an EmptyConstraint . Subsequently applying it to an IEnumerable or ICollection causes an EmptyCollectionConstraint to be created."
  },
  "articles/nunit/writing-tests/constraints/EmptyConstraint.html": {
    "href": "articles/nunit/writing-tests/constraints/EmptyConstraint.html",
    "title": "Empty Constraint | NUnit Docs",
    "keywords": "Empty Constraint EmptyConstraint tests that an object is an empty string, directory or collection. Constructor EmptyConstraint() Syntax Is.Empty Examples of Use Assert.That(aString, Is.Empty); Assert.That(dirInfo, Is.Empty); Assert.That(collection, Is.Empty); Notes EmptyConstraint creates and uses either an EmptyStringConstraint , EmptyDirectoryConstraint or EmptyCollectionConstraint depending on the argument tested. A DirectoryInfo argument is required in order to test for an empty directory. To test whether a string represents a directory path, you must first construct a DirectoryInfo ."
  },
  "articles/nunit/writing-tests/constraints/EmptyDirectoryConstraint.html": {
    "href": "articles/nunit/writing-tests/constraints/EmptyDirectoryConstraint.html",
    "title": "EmptyDirectory Constraint | NUnit Docs",
    "keywords": "EmptyDirectory Constraint The EmptyDirectoryConstraint tests if a Directory is empty. Constructor EmptyDirectoryConstraint() Syntax Is.Empty Examples of Use Assert.That(new DirectoryInfo(actual), Is.Empty); Assert.That(new DirectoryInfo(actual), Is.Not.Empty); Note Is.Empty actually creates an EmptyConstraint . Subsequently applying it to a DirectoryInfo causes an EmptyDirectoryConstraint to be created."
  },
  "articles/nunit/writing-tests/constraints/EmptyStringConstraint.html": {
    "href": "articles/nunit/writing-tests/constraints/EmptyStringConstraint.html",
    "title": "EmptyString Constraint | NUnit Docs",
    "keywords": "EmptyString Constraint The EmptyStringConstraint tests if a string is empty. Constructor EmptyStringConstraint() Syntax Is.Empty Examples of Use Assert.That(string.Empty, Is.Empty); Assert.That(\"A String\", Is.Not.Empty); Note Is.Empty actually creates an EmptyConstraint . Subsequently applying it to a string causes an EmptyStringConstraint to be created."
  },
  "articles/nunit/writing-tests/constraints/EndsWithConstraint.html": {
    "href": "articles/nunit/writing-tests/constraints/EndsWithConstraint.html",
    "title": "EndsWith Constraint | NUnit Docs",
    "keywords": "EndsWith Constraint EndsWithConstraint tests for an ending string. Constructor EndsWithConstraint(string expected) Syntax Does.EndWith(string expected) EndsWith(string expected) Modifiers ...IgnoreCase Examples of Use string phrase = \"Make your tests fail before passing!\" Assert.That(phrase, Does.EndWith(\"!\")); Assert.That(phrase, Does.EndWith(\"PASSING!\").IgnoreCase); Notes EndsWith may appear only in the body of a constraint expression or when the inherited syntax is used."
  },
  "articles/nunit/writing-tests/constraints/EqualConstraint.html": {
    "href": "articles/nunit/writing-tests/constraints/EqualConstraint.html",
    "title": "Equal Constraint | NUnit Docs",
    "keywords": "Equal Constraint An EqualConstraint is used to test whether an actual value is equal to the expected value supplied in its constructor, optionally within a specified tolerance. Constructor EqualConstraint(object expected) Syntax Is.EqualTo(object expected) Is.Zero // Equivalent to Is.EqualTo(0) Modifiers ...IgnoreCase ...AsCollection ...NoClip ...WithSameOffset ...Within(object tolerance) .Ulps .Percent .Days .Hours .Minutes .Seconds .Milliseconds .Ticks ...Using(IEqualityComparer comparer) ...Using(IEqualityComparer<T> comparer) ...Using(IComparer comparer) ...Using<T>(IComparer<T> comparer) ...Using<T>(Comparison<T> comparer) Comparing Numerics Numerics are compared based on their values. Different types may be compared successfully if their values are equal. Using the Within modifier, numerics may be tested for equality within a fixed or percent tolerance. Assert.That(2 + 2, Is.EqualTo(4.0)); Assert.That(2 + 2 == 4); Assert.That(2 + 2, Is.Not.EqualTo(5)); Assert.That(2 + 2 != 5); Assert.That(5.0, Is.EqualTo(5); Assert.That(5.5, Is.EqualTo(5).Within(0.075)); Assert.That(5.5, Is.EqualTo(5).Within(1.5).Percent); Comparing Floating Point Values Values of type float and double are normally compared using a tolerance specified by the Within modifier. The special values PositiveInfinity, NegativeInfinity and NaN compare as equal to themselves. Floating-point values may be compared using a tolerance in \"Units in the Last Place\" or ULPs. For certain types of numerical work, this is safer than a fixed tolerance because it automatically compensates for the added inaccuracy of larger numbers. Assert.That(2.1 + 1.2, Is.EqualTo(3.3).Within(.0005)); Assert.That(double.PositiveInfinity, Is.EqualTo(double.PositiveInfinity)); Assert.That(double.NegativeInfinity, Is.EqualTo(double.NegativeInfinity)); Assert.That(double.NaN, Is.EqualTo(double.NaN)); Assert.That(20000000000000004.0, Is.EqualTo(20000000000000000.0).Within(1).Ulps); Comparing Strings String comparisons normally respect case. The IgnoreCase modifier causes the comparison to be case-insensitive. It may also be used when comparing arrays or collections of strings. Assert.That(\"Hello!\", Is.Not.EqualTo(\"HELLO!\")); Assert.That(\"Hello!\", Is.EqualTo(\"HELLO!\").IgnoreCase); string[] expected = new string[] { \"Hello\", World\" }; string[] actual = new string[] { \"HELLO\", \"world\" }; Comparing DateTimes and TimeSpans DateTimes and TimeSpans may be compared either with or without a tolerance. A tolerance is specified using Within with either a TimeSpan as an argument or with a numeric value followed by a one of the time conversion modifiers: Days , Hours , Minutes , Seconds , Milliseconds or Ticks . When comparing DateTimeOffsets you can use the optional WithSameOffset modifier to check the offset along with the date and time. DateTime now = DateTime.Now; DateTime later = now + TimeSpan.FromHours(1.0); Assert.That(now, Is.EqualTo(now)); Assert.That(later. Is.EqualTo(now).Within(TimeSpan.FromHours(3.0)); Assert.That(later, Is.EqualTo(now).Within(3).Hours); Comparing Arrays, Collections and IEnumerables Since version 2.2, NUnit has been able to compare two single-dimensioned arrays. Beginning with version 2.4, multi-dimensioned arrays, nested arrays (arrays of arrays) and collections may be compared. With version 2.5, any IEnumerable is supported. Two arrays, collections or IEnumerables are considered equal if they have the same dimensions and if each of the corresponding elements is equal. If you want to treat two arrays of different shapes as simple collections for purposes of comparison, use the AsCollection modifier, which causes the comparison to be made element by element, without regard for the rank or dimensions of the array. Note that jagged arrays (arrays of arrays) do not have a single underlying collection. The modifier would be applied to each array separately, which has no effect in most cases. The AsCollection modifier is also useful on classes implementing both IEnumerable and IEquatable . Without the modifier, the IEquatable implementation is used to test equality. With the modifier specified, IEquatable is ignored and the contents of the enumeration are compared one by one. int[] i3 = new int[] { 1, 2, 3 }; double[] d3 = new double[] { 1.0, 2.0, 3.0 }; int[] iunequal = new int[] { 1, 3, 2 }; Assert.That(i3, Is.EqualTo(d3)); Assert.That(i3, Is.Not.EqualTo(iunequal)); int array2x2 = new int[,] { { 1, 2 }, { 3, 4 } }; int array4 = new int[] { 1, 2, 3, 4 }; Assert.That(array2x2, Is.Not.EqualTo(array4)); Assert.That(array2x2, Is.EqualTo(array4).AsCollection); Comparing Dictionaries Two dictionaries are considered equal if The list of keys is the same - without regard to ordering. The values associated with each key are equal. You can use this capability to compare any two objects implementing IDictionary . Generic and non-generic dictionaries (Hashtables) may be successfully compared. Comparing DirectoryInfo Two DirectoryInfo objects are considered equal if both have the same path, creation time and last access time. Assert.That(new DirectoryInfo(actual), Is.EqualTo(expected)); User-Specified Comparers If the default NUnit or .NET behavior for testing equality doesn't meet your needs, you can supply a comparer of your own through the Using modifier. When used with EqualConstraint , you may supply an IEqualityComparer , IEqualityComparer<T> , IComparer , IComparer<T> or Comparison<T> as the argument to Using . Assert.That(myObj1, Is.EqualTo(myObj2).Using(myComparer)); Prior to NUnit 2.6, only one comparer could be used. If multiple comparers were specified, all but one was ignored. Beginning with NUnit 2.6, multiple generic comparers for different types may be specified. NUnit will use the appropriate comparer for any two types being compared. As a result, it is now possible to provide a comparer for an array, a collection type or a dictionary. The user-provided comparer will be used directly, bypassing the default NUnit logic for array, collection or dictionary equality. class ListOfIntComparer : IEqualityComparer<List<int>> { /* ... */ } var list1 = new List<int>(); var list2 = new List<int>(); var myComparer = new ListOfIntComparer(); /* ... */ Assert.That(list1, Is.EqualTo(list2).Using(myComparer)); Notes When checking the equality of user-defined classes, NUnit first examines each class to determine whether it implements IEquatable<T> (unless the AsCollection modifier is used). If either object implements the interface for the type of the other object, then that implementation is used in making the comparison. If neither class implements the appropriate interface, NUnit makes use of the Equals override on the expected object. If you neglect to either implement IEquatable<T> or to override Equals , you can expect failures comparing non-identical objects. In particular, overriding operator == without overriding Equals or implementing the interface has no effect. The Within modifier was originally designed for use with floating point values only. Beginning with NUnit 2.4, comparisons of DateTime values may use a TimeSpan as a tolerance. Beginning with NUnit 2.4.2, non-float numeric comparisons may also specify a tolerance. Float and double comparisons for which no tolerance is specified use a default value, which can be specified with DefaultFloatingPointToleranceAttribute . If this is not in place, a tolerance of 0.0d is used. (Prior to NUnit 3.7, default tolerance was instead set via GlobalSettings.DefaultFloatingPointTolerance .) Prior to NUnit 2.2.3, comparison of two NaN values would always fail, as specified by IEEE floating point standards. The new behavior, was introduced after some discussion because it seems more useful in tests. To avoid confusion, consider using Is.NaN where appropriate. When an equality test between two strings fails, the relevant portion of both strings is displayed in the error message, clipping the strings to fit the length of the line as needed. Beginning with 2.4.4, this behavior may be modified by use of the NoClip modifier on the constraint. In addition, the maximum line length may be modified for all tests by setting the value of TextMessageWriter.MaximumLineLength in the appropriate level of setup. When used with arrays, collections or dictionaries, EqualConstraint operates recursively. Any modifiers are saved and used as they apply to individual items. A user-specified comparer will not be called by EqualConstraint if either or both arguments are null. If both are null, the Constraint succeeds. If only one is null, it fails. NUnit has special semantics for comparing Streams and DirectoryInfos . For a Stream , the contents are compared. For a DirectoryInfo , the first-level directory contents are compared. See also Assert.AreEqual DefaultFloatingPointTolerance Attribute"
  },
  "articles/nunit/writing-tests/constraints/ExactCountConstraint.html": {
    "href": "articles/nunit/writing-tests/constraints/ExactCountConstraint.html",
    "title": "ExactCount Constraint | NUnit Docs",
    "keywords": "ExactCount Constraint ExactCountConstraint has two functions. In its simplest use, it simply verifies the number of items in an array, collection or IEnumerable , providing a way to count items that is independent of any Length or Count property. When used with another constraint, it applies that constraint to each item in the array, collection or IEnumerable , succeeding if the specified number of items succeed. An exception is thrown if the actual value passed does not implement IEnumerable . Constructor ExactCountConstraint(int expectedCount) ExactCountConstraint(int expectedCount, Constraint itemConstraint) Syntax Has.Exactly(int expectedCount)... Examples of Use int[] array = new int[] { 1, 2, 3 }; Assert.That(array, Has.Exactly(3).Items); Assert.That(array, Has.Exactly(2).Items.GreaterThan(1)); Assert.That(array, Has.Exactly(3).LessThan(100)); Assert.That(array, Has.Exactly(2).Items.EqualTo(1).Or.EqualTo(3)); Assert.That(array, Has.Exactly(1).EqualTo(1).And.Exactly(1).EqualTo(3)); Note The keyword Items is optional when used before a constraint but required when merely counting items with no constraint specified. See also PropertyConstraint - For constraints on the Count or Length property, e.g. Has.Count.GreaterThan(10) or Has.Length.EqualTo(6) ."
  },
  "articles/nunit/writing-tests/constraints/ExactTypeConstraint.html": {
    "href": "articles/nunit/writing-tests/constraints/ExactTypeConstraint.html",
    "title": "ExactType Constraint | NUnit Docs",
    "keywords": "ExactType Constraint ExactTypeConstraint tests that an object is an exact Type. Constructor ExactTypeConstraint(Type) Syntax Is.TypeOf(Type) Is.TypeOf<T>() Examples of Use Assert.That(\"Hello\", Is.TypeOf(typeof(string))); Assert.That(\"Hello\", Is.Not.TypeOf(typeof(int))); Assert.That(\"World\", Is.TypeOf<string>());"
  },
  "articles/nunit/writing-tests/constraints/FalseConstraint.html": {
    "href": "articles/nunit/writing-tests/constraints/FalseConstraint.html",
    "title": "False Constraint | NUnit Docs",
    "keywords": "False Constraint FalseConstraint tests that a value is false. Constructor FalseConstraint() Syntax Is.False Example of Use Assert.That(condition, Is.False);"
  },
  "articles/nunit/writing-tests/constraints/FileOrDirectoryExistsConstraint.html": {
    "href": "articles/nunit/writing-tests/constraints/FileOrDirectoryExistsConstraint.html",
    "title": "FileOrDirectoryExists Constraint | NUnit Docs",
    "keywords": "FileOrDirectoryExists Constraint FileOrDirectoryExistsConstraint tests that a File or Directory exists. Constructor FileOrDirectoryExistsConstraint() Syntax Does.Exist Does.Not.Exist Modifiers IgnoreDirectories IgnoreFiles Examples of Use Assert.That(fileStr, Does.Exist); Assert.That(dirStr, Does.Exist); Assert.That(fileStr, Does.Not.Exist); Assert.That(dirStr, Does.Not.Exist); Assert.That(new FileInfo(fileStr), Does.Exist); Assert.That(new DirectoryInfo(dirStr), Does.Exist);"
  },
  "articles/nunit/writing-tests/constraints/GreaterThanConstraint.html": {
    "href": "articles/nunit/writing-tests/constraints/GreaterThanConstraint.html",
    "title": "GreaterThan Constraint | NUnit Docs",
    "keywords": "GreaterThan Constraint GreaterThanConstraint tests that one value is greater than another. Constructor GreaterThanConstraint(object expected) Syntax Is.GreaterThan(object expected) Is.Positive // Equivalent to Is.GreaterThan(0) Modifiers ...Using(IComparer comparer) ...Using<T>(IComparer<T> comparer) ...Using<T>(Comparison<T> comparer) Examples of Use Assert.That(7, Is.GreaterThan(3)); Assert.That(myOwnObject, Is.GreaterThan(theExpected).Using(myComparer)); Assert.That(42, Is.Positive);"
  },
  "articles/nunit/writing-tests/constraints/GreaterThanOrEqualConstraint.html": {
    "href": "articles/nunit/writing-tests/constraints/GreaterThanOrEqualConstraint.html",
    "title": "GreaterThanOrEqual Constraint | NUnit Docs",
    "keywords": "GreaterThanOrEqual Constraint GreaterThanOrEqualConstraint tests that one value is greater than or equal to another. Constructor GreaterThanOrEqualConstraint(object expected) Syntax Is.GreaterThanOrEqualTo(object expected) Is.AtLeast(object expected) Modifiers ...Using(IComparer comparer) ...Using<T>(IComparer<T> comparer) ...Using<T>(Comparison<T> comparer) Examples of Use Assert.That(7, Is.GreaterThanOrEqualTo(3)); Assert.That(7, Is.AtLeast(3)); Assert.That(7, Is.GreaterThanOrEqualTo(7)); Assert.That(7, Is.AtLeast(7)); Assert.That(myOwnObject, Is.GreaterThanOrEqualTo(theExpected).Using(myComparer));"
  },
  "articles/nunit/writing-tests/constraints/InstanceOfTypeConstraint.html": {
    "href": "articles/nunit/writing-tests/constraints/InstanceOfTypeConstraint.html",
    "title": "InstanceOfType Constraint | NUnit Docs",
    "keywords": "InstanceOfType Constraint InstanceOfTypeConstraint tests that an object is of the type supplied or a derived type. Constructor InstanceOfTypeConstraint(Type) Syntax Is.InstanceOf(Type) Is.InstanceOf<T>() Examples of Use Assert.That(\"Hello\", Is.InstanceOf(typeof(string))); Assert.That(5, Is.Not.InstanceOf(typeof(string))); Assert.That(5, Is.Not.InstanceOf<string>());"
  },
  "articles/nunit/writing-tests/constraints/LessThanConstraint.html": {
    "href": "articles/nunit/writing-tests/constraints/LessThanConstraint.html",
    "title": "LessThan Constraint | NUnit Docs",
    "keywords": "LessThan Constraint LessThanConstraint tests that one value is less than another. Constructor LessThanConstraint(object expected) Syntax Is.LessThan(object expected) Is.Negative // Equivalent to Is.LessThan(0) Modifiers ...Using(IComparer comparer) ...Using<T>(IComparer<T> comparer) ...Using<T>(Comparison<T> comparer) Examples of Use Assert.That(3, Is.LessThan(7)); Assert.That(myOwnObject, Is.LessThan(theExpected).Using(myComparer)); Assert.That(-5, Is.Negative);"
  },
  "articles/nunit/writing-tests/constraints/LessThanOrEqualConstraint.html": {
    "href": "articles/nunit/writing-tests/constraints/LessThanOrEqualConstraint.html",
    "title": "LessThanOrEqual Constraint | NUnit Docs",
    "keywords": "LessThanOrEqual Constraint LessThanOrEqualConstraint tests that one value is less than or equal to another. Constructor LessThanOrEqualConstraint(object expected) Syntax Is.LessThanOrEqualTo(object expected) Is.AtMost(object expected) Modifiers ...Using(IComparer comparer) ...Using<T>(IComparer<T> comparer) ...Using<T>(Comparison<T> comparer) Examples of Use Assert.That(3, Is.LessThanOrEqualTo(7)); Assert.That(3, Is.AtMost(7)); Assert.That(3, Is.LessThanOrEqualTo(3)); Assert.That(3, Is.AtMost(3)); Assert.That(myOwnObject, Is.LessThanOrEqualTo(theExpected).Using(myComparer));"
  },
  "articles/nunit/writing-tests/constraints/NaNConstraint.html": {
    "href": "articles/nunit/writing-tests/constraints/NaNConstraint.html",
    "title": "NaN Constraint | NUnit Docs",
    "keywords": "NaN Constraint NaNConstraint tests that a value is floating-point NaN. Constructor NaNConstraint() Syntax Is.NaN Examples of Use Assert.That(aDouble, Is.NaN); Assert.That(aDouble, Is.Not.NaN);"
  },
  "articles/nunit/writing-tests/constraints/NoItemConstraint.html": {
    "href": "articles/nunit/writing-tests/constraints/NoItemConstraint.html",
    "title": "NoItem Constraint | NUnit Docs",
    "keywords": "NoItem Constraint NoItemConstraint applies a constraint to each item in a collection, succeeding only if all of them fail. An exception is thrown if the actual value passed does not implement IEnumerable . Constructor NoItemConstraint(Constraint itemConstraint) Syntax Has.None... Examples of Use int[] iarray = new int[] { 1, 2, 3 }; string[] sarray = new string[] { \"a\", \"b\", \"c\" }; Assert.That(iarray, Has.None.Null); Assert.That(sarray, Has.None.EqualTo(\"d\")); Assert.That(iarray, Has.None.LessThan(0));"
  },
  "articles/nunit/writing-tests/constraints/NotConstraint.html": {
    "href": "articles/nunit/writing-tests/constraints/NotConstraint.html",
    "title": "Not Constraint | NUnit Docs",
    "keywords": "Not Constraint NotConstraint reverses the effect of another constraint. If the base constraint fails, NotConstraint succeeds. If the base constraint succeeds, NotConstraint fails. Constructor NotConstraint() Syntax Is.Not... Examples of Use Assert.That(collection, Is.Not.Unique); Assert.That(2 + 2, Is.Not.EqualTo(5));"
  },
  "articles/nunit/writing-tests/constraints/NullConstraint.html": {
    "href": "articles/nunit/writing-tests/constraints/NullConstraint.html",
    "title": "Null Constraint | NUnit Docs",
    "keywords": "Null Constraint NullConstraint tests that a value is null. Constructor NullConstraint() Syntax Is.Null Examples of Use Assert.That(anObject, Is.Null); Assert.That(anObject, Is.Not.Null);"
  },
  "articles/nunit/writing-tests/constraints/OrConstraint.html": {
    "href": "articles/nunit/writing-tests/constraints/OrConstraint.html",
    "title": "Or Constraint | NUnit Docs",
    "keywords": "Or Constraint OrConstraint combines two other constraints and succeeds if either of them succeeds. Constructor OrConstraint(Constraint left, Constraint right) Syntax <Constraint>.Or.<Constraint> Examples of Use Assert.That(3, Is.LessThan(5).Or.GreaterThan(10)); Evaluation Order and Precedence Note that the constraint evaluates the sub-constraints left to right, meaning that Assert.That(i, Is.Null.Or.GreaterThan(9)); where i is a nullable int will work for both 12 and null . On the other hand, Assert.That(i, Is.GreaterThan(9).Or.Null); will only work for 12 , but throw an exception for null , as null cannot be compared to 9 . The OrConstraint has precedence over the AndConstraint . See also AndConstraint"
  },
  "articles/nunit/writing-tests/constraints/PropertyConstraint.html": {
    "href": "articles/nunit/writing-tests/constraints/PropertyConstraint.html",
    "title": "Property Constraint | NUnit Docs",
    "keywords": "Property Constraint PropertyConstraint tests for the existence of a named property on an object and then applies a constraint test to the property value. Constructor PropertyConstraint(string name, IConstraint baseConstraint) Syntax Has.Property(string name)... // followed by further constraint syntax Examples of Use Assert.That(someObject, Has.Property(\"Version\").EqualTo(\"2.0\")); Assert.That(collection, Has.Property(\"Count\").GreaterThan(10)); Assert.That(collection, Has.Count.GreaterThan(10); As shown in the example, certain common properties are known to NUnit and may be tested using a shorter form. The following properties are supported: Has.Length... Has.Count... Has.Message... Has.InnerException... See also PropertyExistsConstraint"
  },
  "articles/nunit/writing-tests/constraints/PropertyExistsConstraint.html": {
    "href": "articles/nunit/writing-tests/constraints/PropertyExistsConstraint.html",
    "title": "PropertyExists Constraint | NUnit Docs",
    "keywords": "PropertyExists Constraint The PropertyExistsConstraint tests for the existence of a named property on an object. Constructor PropertyExistsConstraint(string name) Syntax Has.Property(string) Examples of Use Assert.That(someObject, Has.Property(\"Version\")); See also PropertyConstraint"
  },
  "articles/nunit/writing-tests/constraints/RangeConstraint.html": {
    "href": "articles/nunit/writing-tests/constraints/RangeConstraint.html",
    "title": "Range Constraint | NUnit Docs",
    "keywords": "Range Constraint RangeConstraint tests that a value is in an (inclusive) range. Constructor RangeConstraint(IComparable from, IComparable to) Syntax Is.InRange(IComparable from, IComparable to) Modifiers ...Using(IComparer comparer) ...Using<T>(IComparer<T> comparer) ...Using<T>(Comparison<T> comparer) Examples of Use int[] iarray = new int[] { 1, 2, 3 } Assert.That(42, Is.InRange(1, 100)); Assert.That(iarray, Is.All.InRange(1, 3)); Assert.That(myOwnObject, Is.InRange(lowExpected, highExpected).Using(myComparer));"
  },
  "articles/nunit/writing-tests/constraints/RegexConstraint.html": {
    "href": "articles/nunit/writing-tests/constraints/RegexConstraint.html",
    "title": "RegexConstraint | NUnit Docs",
    "keywords": "RegexConstraint RegexConstraint tests that a pattern is matched. Constructor RegexConstraint(string pattern) Syntax Does.Match(string pattern) Matches(string pattern) Modifiers ...IgnoreCase Examples of Use string phrase = \"Make your tests fail before passing!\" Assert.That(phrase, Does.Match(\"Make.*tests.*pass\")); Assert.That(phrase, Does.Not.Match(\"your.*passing.*tests\")); Notes Matches may appear only in the body of a constraint expression or when the inherited syntax is used."
  },
  "articles/nunit/writing-tests/constraints/ReusableConstraint.html": {
    "href": "articles/nunit/writing-tests/constraints/ReusableConstraint.html",
    "title": "Reusable Constraint | NUnit Docs",
    "keywords": "Reusable Constraint Normally constraints just work. However, attempting to reuse the same constraint in several places can lead to unexpected results. Consider the following code as an example: Constraint myConstraint = Is.Not.Null; Assert.That(\"not a null\", myConstraint); // Passes, of course Assert.That(\"not a null\", myConstraint); // Fails! What's that about? We'll save the technical explanation for later and show the solution first: ReusableConstraint myConstraint = Is.Not.Null; Assert.That(\"not a null\", myConstraint); // Passes Assert.That(\"not a null\", myConstraint); // Passes Or alternatively.. var myConstraint = new ReusableConstraint(Is.Not.Null); Assert.That(\"not a null\", myConstraint); // Passes Assert.That(\"not a null\", myConstraint); // Passes Technical Explanation In the original example, the value assigned to myConstraint is known as an unresolved constraint. In fact, it's an unresolved NullConstraint, because that was the last constraint encountered in the expression. It's associated with a Not operator that has not yet been applied. That's OK for use with Assert.That(), because the method knows how to resolve a constraint before using it. Assert.That() resolves this constraint to a NotConstraint referencing the original NullConstraint. Of course, the original reference in myConstraint is left unchanged in all of this. But the EqualConstraint it points to has now been resolved. It is now a resolved constraint and can't be resolved again by the second Assert.That(), which only sees the NullConstraint and not the NotConstraint. So, for reusability, what we want to save is the result of resolving the constraint, in this case NotConstraint => NullConstraint That's what ReusableConstraint does for us. It resolves the full expression and saves the result. Then it passes all operations on to that saved result. When to Use It Use this constraint any time you want to reuse a constraint expression and you'll be safe. If you like to take chances, you'll find that you can avoid using it in the following cases... With a simple constraint involving no operators, like... Constraint myConstraint = Is.Null; Constraint myConstraint = Is.EqualTo(42); With any constraint you construct using new, without using the \"dotted\" constraint syntax... Constraint myConstraint = new NotConstraint(new NullConstraint()); Constraint myConstraint = new AndConstraint( new GreaterThanConstraint(0), new LessThanConstraint(100)); However, there is no significant penalty to using ReusableConstraint . It makes your intent much clearer and the exceptions listed are accidents of the internal implementation and could disappear in future releases."
  },
  "articles/nunit/writing-tests/constraints/SameAsConstraint.html": {
    "href": "articles/nunit/writing-tests/constraints/SameAsConstraint.html",
    "title": "SameAs Constraint | NUnit Docs",
    "keywords": "SameAs Constraint A SameAsConstraint is used to test whether the object passed as an actual value has the same identity as the object supplied in its constructor. Constructor SameAsConstraint(object expected) Syntax Is.SameAs(object expected) Examples of Use Exception ex1 = new Exception(); Exception ex2 = ex1; Assert.That(ex2, Is.SameAs(ex1)); Exception ex3 = new Exception(); Assert.That(ex3, Is.Not.SameAs(ex1));"
  },
  "articles/nunit/writing-tests/constraints/SamePathConstraint.html": {
    "href": "articles/nunit/writing-tests/constraints/SamePathConstraint.html",
    "title": "SamePath Constraint | NUnit Docs",
    "keywords": "SamePath Constraint SamePathConstraint tests that two paths are equivalent. Constructor SamePathConstraint(string expectedPath) Syntax Is.SamePath(string expectedPath) Modifiers ...IgnoreCase ...RespectCase Examples of Use Assert.That(\"/folder1/./junk/../folder2\", Is.SamePath(\"/folder1/folder2\")); Assert.That(\"/folder1/./junk/../folder2/x\", Is.Not.SamePath(\"/folder1/folder2\")); Assert.That(@\"C:\\folder1\\folder2\", Is.SamePath(@\"C:\\Folder1\\Folder2\").IgnoreCase); Assert.That(\"/folder1/folder2\", Is.Not.SamePath(\"/Folder1/Folder2\").RespectCase); Notes Path constraints perform tests on paths, without reference to any actual files or directories. This allows testing paths that are created by an application for reference or later use, without any effect on the environment. Path constraints are intended to work across multiple file systems, and convert paths to a canonical form before comparing them. It is usually not necessary to know the file system of the paths in order to compare them. Where necessary, the programmer may use the IgnoreCase and RespectCase modifiers to provide behavior other than the system default. See also SubPathConstraint SamePathOrUnderConstraint"
  },
  "articles/nunit/writing-tests/constraints/SamePathOrUnderConstraint.html": {
    "href": "articles/nunit/writing-tests/constraints/SamePathOrUnderConstraint.html",
    "title": "SamePathOrUnder Constraint | NUnit Docs",
    "keywords": "SamePathOrUnder Constraint SamePathOrUnderConstraint tests that one path is equivalent to another path or that it is under it. Constructor SamePathOrUnderConstraint(string expectedPath) Syntax Is.SamePathOrUnder(string expectedPath) Modifiers ...IgnoreCase ...RespectCase Examples of Use Assert.That(\"/folder1/./junk/../folder2\", Is.SamePathOrUnder(\"/folder1/folder2\")); Assert.That(\"/folder1/junk/../folder2/./folder3\", Is.SamePathOrUnder(\"/folder1/folder2\")); Assert.That(\"/folder1/junk/folder2/folder3\", Is.Not.SamePathOrUnder(\"/folder1/folder2\")); Assert.That(@\"C:\\folder1\\folder2\\folder3\", Is.SamePathOrUnder(@\"C:\\Folder1\\Folder2\").IgnoreCase); Assert.That(\"/folder1/folder2/folder3\", Is.Not.SamePathOrUnder(\"/Folder1/Folder2\").RespectCase); Notes Path constraints perform tests on paths, without reference to any actual files or directories. This allows testing paths that are created by an application for reference or later use, without any effect on the environment. Path constraints are intended to work across multiple file systems, and convert paths to a canonical form before comparing them. It is usually not necessary to know the file system of the paths in order to compare them. Where necessary, the programmer may use the IgnoreCase and RespectCase modifiers to provide behavior other than the system default. See also SamePathConstraint SubPathConstraint"
  },
  "articles/nunit/writing-tests/constraints/SomeItemsConstraint.html": {
    "href": "articles/nunit/writing-tests/constraints/SomeItemsConstraint.html",
    "title": "SomeItems Constraint | NUnit Docs",
    "keywords": "SomeItems Constraint SomeItemsConstraint applies a constraint to each item in an IEnumerable , succeeding if at least one of them succeeds. An exception is thrown if the actual value passed does not implement IEnumerable . Constructor SomeItemsConstraint(Constraint itemConstraint) Syntax Has.Some... Examples of Use int[] iarray = new int[] { 1, 2, 3 }; string[] sarray = new string[] { \"a\", \"b\", \"c\" }; Assert.That(iarray, Has.Some.GreaterThan(2)); Assert.That(sarray, Has.Some.Length(1));"
  },
  "articles/nunit/writing-tests/constraints/StartsWithConstraint.html": {
    "href": "articles/nunit/writing-tests/constraints/StartsWithConstraint.html",
    "title": "StartsWith Constraint | NUnit Docs",
    "keywords": "StartsWith Constraint StartsWithConstraint tests for an initial string. Constructor StartsWithConstraint(string expected) Syntax Does.StartWith(string expected) StartsWith(string expected) Modifiers ...IgnoreCase Examples of Use string phrase = \"Make your tests fail before passing!\" Assert.That(phrase, Does.StartWith(\"Make\")); Assert.That(phrase, Does.Not.StartWith(\"Break\")); Notes StartsWith may appear only in the body of a constraint expression or when the inherited syntax is used."
  },
  "articles/nunit/writing-tests/constraints/SubPathConstraint.html": {
    "href": "articles/nunit/writing-tests/constraints/SubPathConstraint.html",
    "title": "SubPath Constraint | NUnit Docs",
    "keywords": "SubPath Constraint SubPathConstraint tests that one path is under another path. Constructor SubPathConstraint(string expectedPath) Syntax Is.SubPath(string expectedPath) Modifiers ...IgnoreCase ...RespectCase Examples of Use Assert.That(\"/folder1/./junk/../folder2\", Is.SubPath(\"/folder1/folder2\")); Assert.That(\"/folder1/junk/folder2\", Is.Not.SubPath(\"/folder1/folder2\")); Assert.That(@\"C:\\folder1\\folder2\\folder3\", Is.SubPath(@\"C:\\Folder1\\Folder2/Folder3\").IgnoreCase); Assert.That(\"/folder1/folder2/folder3\", Is.Not.SubPath(\"/Folder1/Folder2/Folder3\").RespectCase); Notes Path constraints perform tests on paths, without reference to any actual files or directories. This allows testing paths that are created by an application for reference or later use, without any effect on the environment. Path constraints are intended to work across multiple file systems, and convert paths to a canonical form before comparing them. It is usually not necessary to know the file system of the paths in order to compare them. Where necessary, the programmer may use the IgnoreCase and RespectCase modifiers to provide behavior other than the system default. See also SamePathConstraint SamePathOrUnderConstraint"
  },
  "articles/nunit/writing-tests/constraints/SubstringConstraint.html": {
    "href": "articles/nunit/writing-tests/constraints/SubstringConstraint.html",
    "title": "Substring Constraint | NUnit Docs",
    "keywords": "Substring Constraint SubstringConstraint tests for a substring. Constructor SubstringConstraint(string expected) Syntax Does.Contain(string expected) Modifiers ...IgnoreCase Examples of Use string phrase = \"Make your tests fail before passing!\" Assert.That(phrase, Does.Contain(\"tests fail\")); Assert.That(phrase, Does.Not.Contain(\"tests pass\")); Assert.That(phrase, Does.Contain(\"make\").IgnoreCase);"
  },
  "articles/nunit/writing-tests/constraints/ThrowsConstraint.html": {
    "href": "articles/nunit/writing-tests/constraints/ThrowsConstraint.html",
    "title": "Throws Constraint | NUnit Docs",
    "keywords": "Throws Constraint ThrowsConstraint is used to test that some code, represented as a delegate, throws a particular exception. It may be used alone, to merely test the type of constraint, or with an additional constraint to be applied to the exception specified as an argument. The related ThrowsNothingConstraint simply asserts that the delegate does not throw an exception. Constructors ThrowsConstraint(Type expectedType) ThrowsConstraint<T>() ThrowsConstraint(Type expectedType, Constraint constraint) ThrowsConstraint<T>(Constraint constraint) Syntax Throws.Exception Throws.TargetInvocationException Throws.ArgumentException Throws.ArgumentNullException Throws.InvalidOperationException Throws.TypeOf(Type expectedType) Throws.TypeOf<T>() Throws.InstanceOf(Type expectedType) Throws.InstanceOf<T>() Throws.InnerException Examples of Use Assert.That(SomeMethod, Throws.TypeOf<ArgumentException>()); Assert.That(SomeMethod, Throws.Exception.TypeOf<ArgumentException>()); Assert.That(SomeMethod, Throws.TypeOf<ArgumentException>() .With.Property(\"Parameter\").EqualTo(\"myParam\")); Assert.That(SomeMethod, Throws.ArgumentException); Assert.That(SomeMethod, Throws.TargetInvocationException .With.InnerException.TypeOf<ArgumentException>()); Assert.That(() => { throw new ArgumentException(); }, Throws.ArgumentException); Notes Throws.Exception may be followed by further constraints, which are applied to the exception itself as shown in the last two examples above. It may also be used alone to verify that some exception has been thrown, without regard to type. This is not a recommended practice since you should normally know what exception you are expecting. Throws.TypeOf and Throws.InstanceOf are provided as a shorter syntax for this common test. They work exactly like the corresponding forms following Throws.Exception . Throws.TargetInvocationException , Throws.ArgumentException and Throws.InvalidOperationException provide a shortened form for some common exceptions. Used alone, Throws.InnerException simply tests the InnerException value of the thrown exception. More commonly, it will be used in combination with a test for the type of the outer exception as shown in the examples above."
  },
  "articles/nunit/writing-tests/constraints/ThrowsNothingConstraint.html": {
    "href": "articles/nunit/writing-tests/constraints/ThrowsNothingConstraint.html",
    "title": "ThrowsNothing Constraint | NUnit Docs",
    "keywords": "ThrowsNothing Constraint ThrowsNothingConstraint asserts that the delegate passed as its argument does not throw an exception. Constructor ThrowsNothingConstraint() Syntax Throws.Nothing Example of Use Assert.That(() => SomeMethod(actual), Throws.Nothing);"
  },
  "articles/nunit/writing-tests/constraints/TrueConstraint.html": {
    "href": "articles/nunit/writing-tests/constraints/TrueConstraint.html",
    "title": "True Constraint | NUnit Docs",
    "keywords": "True Constraint TrueConstraint tests that a value is true. Constructor TrueConstraint() Syntax Is.True Example of Use Assert.That(condition, Is.True);"
  },
  "articles/nunit/writing-tests/constraints/UniqueItemsConstraint.html": {
    "href": "articles/nunit/writing-tests/constraints/UniqueItemsConstraint.html",
    "title": "UniqueItems Constraint | NUnit Docs",
    "keywords": "UniqueItems Constraint UniqueItemsConstraint tests that an array, collection or other IEnumerable is composed of unique items with no duplicates. Constructor UniqueItemsConstraint() Syntax Is.Unique Example of Use Assert.That(collection, Is.Unique);"
  },
  "articles/nunit/writing-tests/constraints/XmlSerializableConstraint.html": {
    "href": "articles/nunit/writing-tests/constraints/XmlSerializableConstraint.html",
    "title": "XmlSerializable Constraint | NUnit Docs",
    "keywords": "XmlSerializable Constraint XmlSerializableConstraint tests whether an object is serializable in XML format. Constructor XmlSerializableConstraint() Syntax Is.XmlSerializable Examples of Use Assert.That(someObject, Is.XmlSerializable)); See also BinarySerializableConstraint"
  },
  "articles/nunit/writing-tests/ListMapper.html": {
    "href": "articles/nunit/writing-tests/ListMapper.html",
    "title": "ListMapper | NUnit Docs",
    "keywords": "ListMapper Unlike Constraint classes, ListMapper is used to modify the actual value argument to Assert.That() . It transforms the actual value, which must be a collection, creating a new collection to be tested against the supplied constraint. Currently, ListMapper supports one transformation: creating a collection of property values. Normally, ListMapper will be used through the List.Map() syntax helper. The following example shows two forms of the same assert. string[] strings = new string[] { \"a\", \"ab\", \"abc\" }; int[] lengths = new int[] { 1, 2, 3 }; Assert.That(List.Map(strings).Property(\"Length\"), Is.EqualTo(lengths)); Assert.That(new ListMapper(strings).Property(\"Length\"), Is.EqualTo(lengths));"
  },
  "articles/nunit/writing-tests/Randomizer-Methods.html": {
    "href": "articles/nunit/writing-tests/Randomizer-Methods.html",
    "title": "Randomizer Methods | NUnit Docs",
    "keywords": "Randomizer Methods The Randomizer object exposed by TestContext.CurrentContext.Random extends System.Random to provide random data for a wide range of numeric types as well as enums and strings. Each test context has access to its own Randomizer which is used to generate random values for the RandomAttribute as well as for use by the user calling its methods. The benefit of using Randomizer rather than System.Random directly is twofold: A wide range of types are provided in a uniform manner. Randomizer produces repeatable values for the test run so long as no tests are changed and the same seed is used to initialize the run. A future extension is planned, which would provide repeatability at the individual method level, even if other methods are changed. Int (System.Int32) Next() Returns the next random non-negative int. (Inherited from System.Random ) Next(int max) Returns the next random non-negative int less than max, which must be positive. (Inherited from System.Random ) Next(int min, int max) Returns the next random int in the range min to max, excluding max. (Inherited from System.Random ) UInt (System.UInt32) NextUInt() Returns the next random uint. NextUInt(uint max) Returns the next random uint less than max. NextUInt(uint min, uint max) Returns the next random uint in the range min to max, excluding max. Long (System.Int64) NextLong() Returns the next random non-negative long. NextLong(long max) Returns the next random non-negative long less than max, which must be positive. NextLong(long min, long max) Returns the next random long in the range min to max, excluding max. ULong (System.UInt64) NextULong() Returns the next random ulong. NextULong(ulong max) Returns the next random ulong less than max. NextULong(ulong min, ulong max) Returns the next random ulong in the range min to max, excluding max. Short (System.Int16) NextShort() Returns the next random non-negative short. NextShort(short max) Returns the next random non-negative short less than max, which must be positive. NextShort(short min, short max) Returns the next random short in the range min to max, excluding max. UShort (System.UInt16) NextUShort() Returns the next random ushort. NextUShort(ushort max) Returns the next random ushort less than max. NextUShort(ushort min, ushort max) Returns the next random ushort in the range min to max, excluding max. SByte (System.SByte) NextSByte() Returns the next random non-negative sbyte. NextSByte(sbyte max) Returns the next random non-negative sbyte less than max, which must be positive. NextSByte(sbyte min, sbyte max) Returns the next random sbyte in the range min to max, excluding max. Byte (System.Byte) NextByte() Returns the next random byte. NextByte(byte max) Returns the next random byte less than max. NextByte(byte min, byte max) Returns the next random byte in the range min to max, excluding max. Double (System.Double) NextDouble() Returns the next double in the range 0.0 to 1.0, exclusive. (Inherited from System.Random .) NextDouble(double max) Returns the next non-negative double less than max. NextDouble(double min, double max) Returns the next double in the range min to max, excluding max. Float (System.Float) NextFloat() Returns the next float in the range 0.0f to 1.0f, exclusive. NextFloat(float max) Returns the next non-negative float less than max. NextFloat(float min, float max) Returns the next float in the range min to max, excluding max. Decimal (System.Decimal) NextDecimal() Returns the next non-negative random decimal. NextDecimal(decimal max) Returns the next non-negative decimal less than max. NextDecimal(decimal min, decimal max) Returns the next decimal in the range min to max, excluding max. Notes on Decimal Implementation In the current implementation, the scale is always set to zero. That is, the values are all integral, with no decimal places. This may be enhanced in a future release by allowing the user to specify the scale. In the third form, an exception is currently thrown if the range is greater than decimal.MaxValue . This can only occur if min is negative and max is positive. Bool (System.Boolean) NextBool() Returns a random bool with equal probability of true or false . NextBool(double probability) Returns a random bool with the specified probability of being true . Probability argument must be in the range 0.0 to 1.0, inclusive. Enum (System.Enum) NextEnum<T>() Returns a random enum value of type T. All the values of the enum are returned with equal probability. Note that this may not be useful in all cases for enums with the FlagsAttribute specified. NextEnum(Type type) Returns a random enum value of the type specified as an object, which the caller will normally cast to the specified type. String (System.String) GetString() Returns a random string of default length, composed using a default set of characters. In the current implementation, the default length is hard-coded as 25 and the default characters are \"abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNOPQRSTUVWXYZ0123456789_\". GetString(int length) Returns a random string of the specified length. GetString(int outputLength, string allowedChars) Returns a random string of the specified length using the characters in the string given as the second argument. Guid (System.Guid) NextGuid() (available in version 3.8) Generates a version 4 Guid conforming the RFC 4122 . Version 4 Guids are made of random data."
  },
  "articles/nunit/writing-tests/setup-teardown/index.html": {
    "href": "articles/nunit/writing-tests/setup-teardown/index.html",
    "title": "SetUp and TearDown | NUnit Docs",
    "keywords": "SetUp and TearDown Attribute Usage SetUpAttribute is now used exclusively for per-test setup. TearDownAttribute is now used exclusively for per-test teardown. OneTimeSetUpAttribute is used for one-time setup per test-run. If you run n tests, this event will only occur once. OneTimeTearDownAttribute is used for one-time teardown per test-run. If you run n tests, this event will only occur once SetUpFixtureAttribute continues to be used as at before, but with changed method attributes. Attribute Usage by Fixture Type TestFixture SetUpFixture OneTimeSetUp Supported Supported OneTimeTearDown Supported Supported TestFixtureSetUp Deprecated Not Allowed TestFixtureTearDown Deprecated Not Allowed SetUp Supported Not Allowed TearDown Supported Not Allowed How Setup and TearDown Methods Are Called Multiple SetUp, OneTimeSetUp, TearDown and OneTimeTearDown methods may exist within a class. Setup methods (both types) are called on base classes first, then on derived classes. If any setup method throws an exception, no further setups are called. Teardown methods (again, both types) are called on derived classes first, then on the base class. The teardown methods at any level in the inheritance hierarchy will be called only if a setup method at the same level was called. The following example is illustrates the difference. public class BaseClass { [SetUp] public void BaseSetUp() { /* ... */ } // Exception thrown! [TearDown] public void BaseTearDown() { /* ... */ } } [TestFixture] public class DerivedClass : BaseClass { [SetUp] public void DerivedSetUp() { /* ... */ } [TearDown] public void DerivedTearDown() { /* ... */ } [Test] public void TestMethod() { ... } } Execution will proceed as follows: BaseSetUp BaseTearDown rather than BaseSetUp DerivedTearDown BaseTearDown See also: SetUp and TearDown Changes"
  },
  "articles/nunit/writing-tests/setup-teardown/SetUp-and-TearDown-Changes.html": {
    "href": "articles/nunit/writing-tests/setup-teardown/SetUp-and-TearDown-Changes.html",
    "title": "SetUp And TearDown Changes | NUnit Docs",
    "keywords": "SetUp And TearDown Changes This page describes significant changes in SetUp and TearDown in NUnit 3.0 Existing NUnit 2.6.4 attributes used for SetUp and TearDown were SetUpAttribute TearDownAttribute TestFixtureSetUpAttribute TestFixtureTearDownAttribute SetUpFixtureAttribute Taken together, these attributes provided per-test setup and teardown at the fixture level and one-time setup and teardown at the fixture, namespace and assembly levels. These features were somewhat confusing: SetUpFixture seems not very well understood by users in general. TestFixtureSetUp and TestFixtureTearDown could do with better names. SetUp and TearDown designate per-test setup/teardown within a test fixture, one-time setup/teardown within a setup fixture For NUnit 3.0 we standardized the use of attributes for setup and teardown and renamed some of them to make their function clearer. Attribute Usage SetUpAttribute is now used exclusively for per-test setup. TearDownAttribute is now used exclusively for per-test teardown. OneTimeSetUpAttribute is used for one-time setup per test-run. If you run n tests, this event will only occur once. OneTimeTearDownAttribute is used for one-time teardown per test-run. If you run n tests, this event will only occur once SetUpFixtureAttribute continues to be used as at before, but with changed method attributes. Attribute Usage by Fixture Type TestFixture SetUpFixture OneTimeSetUp Supported Supported OneTimeTearDown Supported Supported TestFixtureSetUp Deprecated Not Allowed TestFixtureTearDown Deprecated Not Allowed SetUp Supported Not Allowed TearDown Supported Not Allowed Backward Compatibility TestFixtureSetUpAttribute and TestFixtureTearDownAttribute continue to be supported as synonyms for OneTimeSetUpAttribute and OneTimeTearDownAttribute in test fixtures, but are deprecated. Since SetUpAttribute and TearDownAttribute are used in two different ways, it's not possible to simply deprecate their usage in SetUpFixture. They have been disallowed in that context, which is a breaking change . How Setup and TearDown Methods Are Called Multiple SetUp, OneTimeSetUp, TearDown and OneTimeTearDown methods may exist within a class. The rules for how the setup methods are called will be the same in NUnit 3.0 as in NUnit 2.6. However, there is a change in the calling of the teardown methods. Setup methods (both types) are called on base classes first, then on derived classes. If any setup method throws an exception, no further setups are called. This is the same as in NUnit 2.6. Teardown methods (again, both types) are called on derived classes first, then on the base class. In NUnit 2.6, all teardown methods were called so long as any setup method was called. It was entirely up to the teardown method to determine how much of the initialization took place. In NUnit 3.0, the teardown methods at any level in the inheritance hierarchy will be called only if a setup method at the same level was called. The following example is illustrates the difference. public class BaseClass { [SetUp] public void BaseSetUp() { /* ... */ } // Exception thrown! [TearDown] public void BaseTearDown() { /* ... */ } } [TestFixture] public class DerivedClass : BaseClass { [SetUp] public void DerivedSetUp() { /* ... */ } [TearDown] public void DerivedTearDown() { /* ... */ } [Test] public void TestMethod() { /* ... */ } } Assume that an exception is thrown in BaseSetUp. In NUnit 2.6, methods would be executed as follows: BaseSetUp DerivedTearDown BaseTearDown In NUnit 3.0, execution will proceed as follows: BaseSetUp BaseTearDown This is potentially a breaking change for some users. Unresolved Issues We need to define how setup and teardown methods are ordered with respect to the newly introduced Action Attributes and how they interact."
  },
  "articles/nunit/writing-tests/TestCaseData.html": {
    "href": "articles/nunit/writing-tests/TestCaseData.html",
    "title": "TestCaseData | NUnit Docs",
    "keywords": "TestCaseData The TestCaseData class provides extended test case information for a parameterized test, although any object deriving from TestCaseParameters may be used. Unlike NUnit 2, you cannot implement ITestCaseData , you must derive from TestCaseParameters . [TestFixture] public class MyTests { [TestCaseSource(typeof(MyDataClass), \"TestCases\")] public int DivideTest(int n, int d) { return n / d; } } public class MyDataClass { public static IEnumerable TestCases { get { yield return new TestCaseData(12, 3).Returns(4); yield return new TestCaseData(12, 2).Returns(6); yield return new TestCaseData(12, 4).Returns(3); } } } This example uses the fluent interface supported by TestCaseData to make the program more readable. TestCaseData supports the following properties and methods, which may be appended to an instance in any order. Explicit() or Explicit(string) causes the test case to be marked explicit, optionally specifying the reason for doing so. Ignore(string) causes the test case to be ignored and specifies the reason, which is required. Returns specifies the expected result to be returned from the method, which must have a compatible return type. SetCategory(string) applies a category to the test. SetDescription(string) sets the description property of the test. SetName(string) provides a name for the test. If not specified, a name is generated based on the method name and the arguments provided. See Template Based Test Naming . SetProperty(string, string) , SetProperty(string, int) and SetProperty(string, double) apply a named property and value to the test."
  },
  "articles/nunit/writing-tests/TestContext.html": {
    "href": "articles/nunit/writing-tests/TestContext.html",
    "title": "TestContext | NUnit Docs",
    "keywords": "TestContext Each NUnit test runs in an execution context, which includes information about the environment as well as the test itself. The TestContext class allows tests to access certain information about the execution context. Note It's important to remember that \"test\" in NUnit may refer to an individual test cases or a suite such as a TestFixture . Within a test method, SetUp method or TearDown method, the context is that of the individual test case. Within a OneTimeSetUp or OneTimeTearDown method, the context refers to the fixture as a whole. This can lead to confusion, since most runners display information about fixtures differently from test cases. In fact, some runners may not display information about fixtures at all! Static Properties CurrentContext Gets the context of the currently executing test. This context is created separately for each test before it begins execution. See below for properties of the current context. Out Gets a TextWriter used for sending output to the current test result. Error Gets a TextWriter used for sending error output intended for immediate display. Progress Gets a TextWriter used for sending normal (non-error) output intended for immediate display. TestParameters Test parameters may be supplied to a run in various ways, depending on the runner used. For example, the console runner provides a command-line argument and v3.4 of the NUnit 3 VS Adapter will supports specifying them in a .runsettings file. The static TestParameters property returns an object representing those passed-in parameters. The TestParameters object supports the following properties: Count - The number of parameters. Names - A collection of the names of the supplied parameters. this[string name] - The value of a parameter. In Vb, use Item . The TestParameters object supports the following methods: Exists(string name) - Returns true if a parameter of that name exists. Get(string name) - Returns the same value as the indexer. Get<T>(string name, T defaultValue) - Returns the value of the parameter converted from a string to type T or the specified default if the parameter doesn't exist. Throws an exception if conversion fails. Note that all parameter values are strings. You may convert them to other Types using the generic Get method listed above or using your own code. An exception may be thrown if the supplied value cannot be converted correctly. Static Methods Write Writes text to the current test result. Write(bool value) Write(char value) Write(char[] value) Write(double value) Write(Int32 value) Write(Int64 value) Write(decimal value) Write(object value) Write(Single value) Write(string value) Write(UInt32 value) Write(UInt64 value) Write(string format, object arg1) Write(string format, object arg1, object arg2) Write(string format, object arg1, object arg2, object arg3) Write(string format, params object[] args) WriteLine Writes text to the current test result, followed by a newline. WriteLine() WriteLine(bool value) WriteLine(char value) WriteLine(char[] value) WriteLine(double value) WriteLine(Int32 value) WriteLine(Int64 value) WriteLine(decimal value) WriteLine(object value) WriteLine(Single value) WriteLine(string value) WriteLine(UInt32 value) WriteLine(UInt64 value) WriteLine(string format, object arg1) WriteLine(string format, object arg1, object arg2) WriteLine(string format, object arg1, object arg2, object arg3) WriteLine(string format, params object[] args) AddFormatter (3.2+) Adds a formatter for values based on some criterion, such as the Type of the value. The provided formatter will be used when an expected or actual value needs to be displayed as part of a message from a constraint. AddFormatter(ValueFormatter formatter); AddFormatter(ValueFormatterFactory formatterFactory); Both ValueFormatter and ValueFormatterFactory are delegates. ValueFormatter takes a single object as an argument and returns its string representation. The AddFormatter overload that takes a ValueFormatter is intended for use in most cases that arise. AddTestAttachment (3.7+) Attaches a file, with optional description, to the current test. AddTestAttachment(string filePath, string description = null); The file will be attached to the test result in the xml report. Test runners, such as the NUnit 3 VS Adapter, may also present the file to the user. Notes: The file must exist at the time of attachment. File paths will be resolved as fully rooted paths, relative to TestContext.CurrentContext.WorkDirectory , which can be set by the user. Properties of the CurrentContext Test Gets a representation of the current test, with the following properties: ID - The unique Id of the test Name - The name of the test, whether set by the user or generated automatically FullName - The fully qualified name of the test MethodName - The name of the method representing the test, if any Properties - An IPropertyBag of the test properties Result Gets a representation of the test result, with the following properties: Outcome - A ResultState representing the outcome of the test. ResultState has the following properties: Status - A TestStatus with four possible values: Inconclusive Skipped Passed Failed Label - An optional string value, which can provide sub-categories for each Status. See below for a list of common outcomes supported internally by NUnit. Site - A FailureSite value, indicating the stage of execution in which the test generated its result. Possible values are Test SetUp TearDown Parent Child Although the outcome of the test may be accessed during setup or test execution, it only has a useful value in the teardown stage. Common Outcomes The following is a list of outcomes currently produced by NUnit. Others may be added in the future. Success: the test passed. (Status=Passed) Inconclusive: the test was inconclusive. (Status=Inconclusive) Failure: a test assertion failed. (Status=Failed, Label=empty) Error: an unexpected exception occurred. (Status=Failed, Label=Error) NotRunnable: the test was invalid and could not be run. (Status=Failed, Label=Invalid) Cancelled: the user cancelled while this test was running. (Status=Failed, Label=Cancelled) Ignored: the test was ignored. (Status=Skipped, Label=Ignored) Explicit: the test was not run because it is marked Explicit. (Status=Skipped, Label=Explicit) Skipped: the test was skipped for some other reason. (Status=Skipped, Label=empty) TestDirectory Gets the full path of the directory containing the current test assembly. WorkDirectory Gets the full path of the directory to be used for output from this test run. The XML result file and any redirected output files are located under this directory. This is normally the directory that was current when execution of NUnit began but may be changed by use of the --work option of nunit-console. Random Returns a Randomizer object, which may be used in the test code to generate random values. These values are repeatable on reruns of the tests so long as (a) the test assembly is not changed and (b) the same seed is used. The initial random seed used in any test run may be found in the XML result file and may be provided to a subsequent run on the command line. See Randomizer Methods for details about each available random data type."
  },
  "articles/nunit/writing-tests/TestFixtureData.html": {
    "href": "articles/nunit/writing-tests/TestFixtureData.html",
    "title": "TestFixtureData | NUnit Docs",
    "keywords": "TestFixtureData The TestFixtureData class provides specific instance information for a parameterized fixture, although any object deriving from TestFixtureParameters may be used. Unlike NUnit 2, you cannot implement IFixtureData , you must derive from TestFixtureParameters . The following example varies the example shown under TestFixture Attribute by using a TestFixtureSourceAttribute with a data source in a separately defined class. [TestFixtureSource(typeof(MyFixtureData), \"Fixtureparams\")] public class ParameterizedTestFixture { private string eq1; private string eq2; private string neq; public ParameterizedTestFixture(string eq1, string eq2, string neq) { this.eq1 = eq1; this.eq2 = eq2; this.neq = neq; } public ParameterizedTestFixture(string eq1, string eq2) : this(eq1, eq2, null) { } public ParameterizedTestFixture(int eq1, int eq2, int neq) { this.eq1 = eq1.ToString(); this.eq2 = eq2.ToString(); this.neq = neq.ToString(); } [Test] public void TestEquality() { Assert.AreEqual(eq1, eq2); if (eq1 != null && eq2 != null) Assert.AreEqual(eq1.GetHashCode(), eq2.GetHashCode()); } [Test] public void TestInequality() { Assert.AreNotEqual(eq1, neq); if (eq1 != null && neq != null) Assert.AreNotEqual(eq1.GetHashCode(), neq.GetHashCode()); } } public class MyFixtureData { public static IEnumerable Fixtureparams { get { yield return new TestFixtureData(\"hello\", \"hello\", \"goodbye\"); yield return new TestFixtureData(\"zip\", \"zip\"); yield return new TestFixtureData(42, 42, 99); } } }"
  },
  "articles/nunit/writing-tests/Warnings.html": {
    "href": "articles/nunit/writing-tests/Warnings.html",
    "title": "Warnings | NUnit Docs",
    "keywords": "Warnings Sometimes - especially in integration testing - it's desirable to give a warning message but continue execution. Beginning with release 3.6, NUnit supports this with the Warn class and the Assert.Warn method. Syntax // Use Warn with reversed condition Warn.If(2+2 != 5); Warn.If(() => 2 + 2 != 5); Warn.If(2+2, Is.Not.EqualTo(5)); Warn.If(() => 2+2, Is.Not.EqualTo(5).After(3000)); // Use Warn with original condition Warn.Unless(2+2 == 5); Warn.Unless(() => 2 + 2 == 5); Warn.Unless(2+2, Is.EqualTo(5)); Warn.Unless(() => 2+2, Is.EqualTo(5).After(3000)); // Issue a warning message Assert.Warn(\"Warning message\"); Each of the above items would fail. The test would continue to execute, however, and the warning messages would only be reported at the end of the test. If the test subsequently fails, the warnings will be reported along with the failure message or - in the case of Assert.Multiple - messages. All of the overloads above also have a variant that accepts a function, Func<string> , that is used to build the message included with the Exception. Note The framework reports warnings by including information about them in the XML result that is sent to the runner in use. If you are using this facility, make sure the runner you use supports warnings. Generally, the runners released by the NUnit team after the release of the 3.6 framework will have this support. Earlier releases will not. Many third party runners will not know what to do with warnings either."
  },
  "articles/nunit-analyzers/NUnit1001.html": {
    "href": "articles/nunit-analyzers/NUnit1001.html",
    "title": "NUnit1001 | NUnit Docs",
    "keywords": "NUnit1001 The individual arguments provided by a TestCaseAttribute must match the type of the matching parameter of the method. Topic Value Id NUnit1001 Severity Error Enabled True Category Structure Code TestCaseUsageAnalyzer Description The individual arguments provided by a TestCaseAttribute must match the type of the matching parameter of the method. Motivation To prevent tests that will fail at runtime due to improper construction. How to fix violations Example Violation [TestCase(true)] public void SampleTest(int numberValue) { Assert.That(numberValue, Is.EqualTo(1)); } Problem In the test case above, true in the test case indicates that numberValue should be a boolean. However, the test declares that numberValue is an integer. This will lead to a runtime failure. Fix Ensure that the type of the test case and the input matches. So, this fix would be acceptable: // TestCase input and parameter are both of type bool [TestCase(true)] public void SampleTest(bool booleanValue) { Assert.That(booleanValue, Is.True); } And this would also work: // TestCase input and parameter are both of type int [TestCase(1)] public void SampleTest(int numberValue) { Assert.That(numberValue, Is.EqualTo(1)); } <!-- start generated config severity --> Configure severity Via ruleset file. Configure the severity per project, for more info see MSDN . Via #pragma directive. #pragma warning disable NUnit1001 // The individual arguments provided by a TestCaseAttribute must match the type of the matching parameter of the method. Code violating the rule here #pragma warning restore NUnit1001 // The individual arguments provided by a TestCaseAttribute must match the type of the matching parameter of the method. Or put this at the top of the file to disable all instances. #pragma warning disable NUnit1001 // The individual arguments provided by a TestCaseAttribute must match the type of the matching parameter of the method. Via attribute [SuppressMessage] . [System.Diagnostics.CodeAnalysis.SuppressMessage(\"Structure\", \"NUnit1001:The individual arguments provided by a TestCaseAttribute must match the type of the matching parameter of the method.\", Justification = \"Reason...\")] <!-- end generated config severity -->"
  },
  "articles/nunit-analyzers/NUnit1002.html": {
    "href": "articles/nunit-analyzers/NUnit1002.html",
    "title": "NUnit1002 | NUnit Docs",
    "keywords": "NUnit1002 TestCaseSource should use nameof operator to specify target. Topic Value Id NUnit1002 Severity Warning Enabled True Category Structure Code TestCaseSourceUsesStringAnalyzer Description TestCaseSource should use nameof operator to specify target. Motivation Prevent test rot by ensuring that future renames don't accidentally break tests in an unexpected way. nameof adds some compile-time support in these situations. How to fix violations Example Violation [TestCaseSource(\"MyTestSource\")] public void SampleTest(string stringValue) { Assert.That(stringValue.Length, Is.EqualTo(3)); } public static object[] MyTestSource() { return new object[] {\"One\", \"Two\"}; } Problem In this case, we're referring to \"MyTestSource\" as a string directly. This is brittle; should the name of the property change, the test case source would become invalid, and we would not know this until executing tests. Fix The fix is to use the C# nameof operator, which produces a string but references the field name. This way, when refactoring and changing the name of your test source, it would also update the name within the nameof() operator. The fix in action: [TestCaseSource(nameof(MyTestSource))] // using nameof public void SampleTest(string stringValue) { Assert.That(stringValue.Length, Is.EqualTo(3)); } public static object[] MyTestSource() { return new object[] {\"One\", \"Two\"}; } <!-- start generated config severity --> Configure severity Via ruleset file. Configure the severity per project, for more info see MSDN . Via #pragma directive. #pragma warning disable NUnit1002 // TestCaseSource should use nameof operator to specify target. Code violating the rule here #pragma warning restore NUnit1002 // TestCaseSource should use nameof operator to specify target. Or put this at the top of the file to disable all instances. #pragma warning disable NUnit1002 // TestCaseSource should use nameof operator to specify target. Via attribute [SuppressMessage] . [System.Diagnostics.CodeAnalysis.SuppressMessage(\"Structure\", \"NUnit1002:TestCaseSource should use nameof operator to specify target.\", Justification = \"Reason...\")] <!-- end generated config severity -->"
  },
  "articles/nunit-analyzers/NUnit1003.html": {
    "href": "articles/nunit-analyzers/NUnit1003.html",
    "title": "NUnit1003 | NUnit Docs",
    "keywords": "NUnit1003 Too few arguments provided by TestCaseAttribute. Topic Value Id NUnit1003 Severity Error Enabled True Category Structure Code TestCaseUsageAnalyzer Description The number of arguments provided by a TestCaseAttribute must match the number of parameters of the method. Motivation To prevent tests that will fail at runtime due to improper construction. How to fix violations Example Violation [TestCase(\"1\")] public void NUnit1003SampleTest(string parameter1, string parameter2) { Assert.That(parameter1, Is.EqualTo(\"1\")); Assert.That(parameter2, Is.EqualTo(\"2\")); } Explanation In the sample above, the test expects two parameters ( (string parameter1, string parameter2) ), but only one argument is supplied by the test case ( TestCase(\"1\") ). Fix Either add the additional argument: [TestCase(\"1\", \"2\")] public void NUnit1003SampleTest(string parameter1, string parameter2) { Assert.That(parameter1, Is.EqualTo(\"1\")); Assert.That(parameter2, Is.EqualTo(\"2\")); } Or remove the use of that parameter: [TestCase(\"1\")] public void NUnit1003SampleTest(string parameter1) { Assert.That(parameter1, Is.EqualTo(\"1\")); } <!-- start generated config severity --> Configure severity Via ruleset file. Configure the severity per project, for more info see MSDN . Via #pragma directive. #pragma warning disable NUnit1003 // Too few arguments provided by TestCaseAttribute. Code violating the rule here #pragma warning restore NUnit1003 // Too few arguments provided by TestCaseAttribute. Or put this at the top of the file to disable all instances. #pragma warning disable NUnit1003 // Too few arguments provided by TestCaseAttribute. Via attribute [SuppressMessage] . [System.Diagnostics.CodeAnalysis.SuppressMessage(\"Structure\", \"NUnit1003:Too few arguments provided by TestCaseAttribute.\", Justification = \"Reason...\")] <!-- end generated config severity -->"
  },
  "articles/nunit-analyzers/NUnit1004.html": {
    "href": "articles/nunit-analyzers/NUnit1004.html",
    "title": "NUnit1004 | NUnit Docs",
    "keywords": "NUnit1004 Too many arguments provided by TestCaseAttribute. Topic Value Id NUnit1004 Severity Error Enabled True Category Structure Code TestCaseUsageAnalyzer Description The number of arguments provided by a TestCaseAttribute must match the number of parameters of the method. Motivation To prevent tests that will fail at runtime due to improper construction. How to fix violations Example Violation [TestCase(\"1\", \"2\")] public void NUnit1004SampleTest(string parameter1) { Assert.That(parameter1, Is.EqualTo(\"1\")); } Explanation In the sample above, there are two arguments provided by test case ( TestCase(\"1\", \"2\") ), but only one parameter is being expected by the test itself ( (string parameter1) ). Fix Either make use of the additional argument: [TestCase(\"1\", \"2\")] public void NUnit1003SampleTest(string parameter1, string parameter2) { Assert.That(parameter1, Is.EqualTo(\"1\")); Assert.That(parameter2, Is.EqualTo(\"2\")); } Or remove it: [TestCase(\"1\")] public void NUnit1003SampleTest(string parameter1) { Assert.That(parameter1, Is.EqualTo(\"1\")); } <!-- start generated config severity --> Configure severity Via ruleset file. Configure the severity per project, for more info see MSDN . Via #pragma directive. #pragma warning disable NUnit1004 // Too many arguments provided by TestCaseAttribute. Code violating the rule here #pragma warning restore NUnit1004 // Too many arguments provided by TestCaseAttribute. Or put this at the top of the file to disable all instances. #pragma warning disable NUnit1004 // Too many arguments provided by TestCaseAttribute. Via attribute [SuppressMessage] . [System.Diagnostics.CodeAnalysis.SuppressMessage(\"Structure\", \"NUnit1004:Too many arguments provided by TestCaseAttribute.\", Justification = \"Reason...\")] <!-- end generated config severity -->"
  },
  "articles/nunit-analyzers/NUnit1005.html": {
    "href": "articles/nunit-analyzers/NUnit1005.html",
    "title": "NUnit1005 | NUnit Docs",
    "keywords": "NUnit1005 The type of ExpectedResult must match the return type. Topic Value Id NUnit1005 Severity Error Enabled True Category Structure Code TestMethodUsageAnalyzer Description The type of ExpectedResult must match the return type. This will lead to an error at run-time. Motivation To prevent tests that will fail at runtime due to improper construction. How to fix violations Example Violation [TestCase(1, ExpectedResult = true)] public int NUnit1005SampleTest(int inputValue) { return inputValue; } Explanation The sample above uses NUnit's ExpectedResult syntax. It defines a result of true (a bool ) but the return type of the method is int . Fix Either modify the TestCase parameter: [TestCase(1, ExpectedResult = 1)] public int NUnit1005SampleTest(int inputValue) { return inputValue; } Or modify the return type and logic of the method: [TestCase(1, ExpectedResult = true)] public bool NUnit1005SampleTest(int inputValue) { return inputValue > 0; } <!-- start generated config severity --> Configure severity Via ruleset file. Configure the severity per project, for more info see MSDN . Via #pragma directive. #pragma warning disable NUnit1005 // The type of ExpectedResult must match the return type. Code violating the rule here #pragma warning restore NUnit1005 // The type of ExpectedResult must match the return type. Or put this at the top of the file to disable all instances. #pragma warning disable NUnit1005 // The type of ExpectedResult must match the return type. Via attribute [SuppressMessage] . [System.Diagnostics.CodeAnalysis.SuppressMessage(\"Structure\", \"NUnit1005:The type of ExpectedResult must match the return type.\", Justification = \"Reason...\")] <!-- end generated config severity -->"
  },
  "articles/nunit-analyzers/NUnit1006.html": {
    "href": "articles/nunit-analyzers/NUnit1006.html",
    "title": "NUnit1006 | NUnit Docs",
    "keywords": "NUnit1006 ExpectedResult must not be specified when the method returns void. Topic Value Id NUnit1006 Severity Error Enabled True Category Structure Code TestMethodUsageAnalyzer Description ExpectedResult must not be specified when the method returns void. This will lead to an error at run-time. Motivation To prevent tests that will fail at runtime due to improper construction. How to fix violations Example Violation [TestCase(1, ExpectedResult = \"1\")] public void NUnit1006SampleTest(int inputValue) { return; } Explanation An ExpectedResult was defined, but the return type of the method in our sample is of type void , meaning it does not return a result. Fix Either modify the TestCase to remove the ExpectedResult : [TestCase(1)] public void NUnit1006SampleTest(int inputValue) { Assert.That(inputValue, Is.EqualTo(1)); } Or modify the return type of the test method: [TestCase(1, ExpectedResult = \"1\")] public string NUnit1006SampleTest(int inputValue) { return inputValue.ToString(); } <!-- start generated config severity --> Configure severity Via ruleset file. Configure the severity per project, for more info see MSDN . Via #pragma directive. #pragma warning disable NUnit1006 // ExpectedResult must not be specified when the method returns void. Code violating the rule here #pragma warning restore NUnit1006 // ExpectedResult must not be specified when the method returns void. Or put this at the top of the file to disable all instances. #pragma warning disable NUnit1006 // ExpectedResult must not be specified when the method returns void. Via attribute [SuppressMessage] . [System.Diagnostics.CodeAnalysis.SuppressMessage(\"Structure\", \"NUnit1006:ExpectedResult must not be specified when the method returns void.\", Justification = \"Reason...\")] <!-- end generated config severity -->"
  },
  "articles/nunit-analyzers/NUnit1007.html": {
    "href": "articles/nunit-analyzers/NUnit1007.html",
    "title": "NUnit1007 | NUnit Docs",
    "keywords": "NUnit1007 Method has non-void return type, but no result is expected in ExpectedResult. Topic Value Id NUnit1007 Severity Error Enabled True Category Structure Code TestMethodUsageAnalyzer Description Method has non-void return type, but no result is expected in ExpectedResult. Motivation To prevent tests that will fail at runtime due to improper construction. How to fix violations Example Violation [TestCase(1)] public string NUnit1007SampleTest(int inputValue) { return \"\"; } Explanation No ExpectedResult was defined, but the return type of the method in our sample is of type string , meaning it does indeed return a result and we should use the ExpectedResult syntax in order to capture it. Fix Either modify the TestCase to add an ExpectedResult : [TestCase(1, ExpectedResult = \"\")] public string NUnit1007SampleTest(int inputValue) { return \"\"; } Or modify the return type of the test method to be void : [TestCase(1)] public void NUnit1007SampleTest(int inputValue) { return Assert.That(inputValue, Is.EqualTo(1)); } <!-- start generated config severity --> Configure severity Via ruleset file. Configure the severity per project, for more info see MSDN . Via #pragma directive. #pragma warning disable NUnit1007 // Method has non-void return type, but no result is expected in ExpectedResult. Code violating the rule here #pragma warning restore NUnit1007 // Method has non-void return type, but no result is expected in ExpectedResult. Or put this at the top of the file to disable all instances. #pragma warning disable NUnit1007 // Method has non-void return type, but no result is expected in ExpectedResult. Via attribute [SuppressMessage] . [System.Diagnostics.CodeAnalysis.SuppressMessage(\"Structure\", \"NUnit1007:Method has non-void return type, but no result is expected in ExpectedResult.\", Justification = \"Reason...\")] <!-- end generated config severity -->"
  },
  "articles/nunit-analyzers/NUnit1008.html": {
    "href": "articles/nunit-analyzers/NUnit1008.html",
    "title": "NUnit1008 | NUnit Docs",
    "keywords": "NUnit1008 Specifying ParallelScope.Self on assembly level has no effect. Topic Value Id NUnit1008 Severity Warning Enabled True Category Structure Code ParallelizableUsageAnalyzer Description Specifying ParallelScope.Self on assembly level has no effect. Motivation Bring developers' attention to a scenario in which they may believe they are parallelizing something when in fact they are not and their efforts will have no effect. How to fix violations Example Violation In AssemblyInfo.cs : [assembly: Parallelizable(ParallelScope.Self)] Explanation ParallelScope.Self only applies to classes and methods , not to assemblies. Fix Either remove it or change to a valid option, such as: [assembly: Parallelizable(ParallelScope.Children)] Or: [assembly: Parallelizable(ParallelScope.Fixtures)] <!-- start generated config severity --> Configure severity Via ruleset file. Configure the severity per project, for more info see MSDN . Via #pragma directive. #pragma warning disable NUnit1008 // Specifying ParallelScope.Self on assembly level has no effect. Code violating the rule here #pragma warning restore NUnit1008 // Specifying ParallelScope.Self on assembly level has no effect. Or put this at the top of the file to disable all instances. #pragma warning disable NUnit1008 // Specifying ParallelScope.Self on assembly level has no effect. Via attribute [SuppressMessage] . [System.Diagnostics.CodeAnalysis.SuppressMessage(\"Structure\", \"NUnit1008:Specifying ParallelScope.Self on assembly level has no effect.\", Justification = \"Reason...\")] <!-- end generated config severity -->"
  },
  "articles/nunit-analyzers/NUnit1009.html": {
    "href": "articles/nunit-analyzers/NUnit1009.html",
    "title": "NUnit1009 | NUnit Docs",
    "keywords": "NUnit1009 No ParallelScope.Children on a non-parameterized test method. Topic Value Id NUnit1009 Severity Error Enabled True Category Structure Code ParallelizableUsageAnalyzer Description One may not specify ParallelScope.Children on a non-parameterized test method. Motivation To prevent tests that will fail at runtime due to improper construction. How to fix violations Example Violation [Parallelizable(ParallelScope.Children)] [Test] public void NUnit1009SampleTest() { Assert.Pass(); } Explanation In the sample above, the Parallelizable attribute is used with ParallelScope.Children . However, in a non-parameterized test, such as a [Test] and not a [TestCase] , there will be no children generated, and thus this type of parallelization does not make sense. Fix Remove the attribute: [Test] public void NUnit1009SampleTest() { Assert.Pass(); } Or, turn the test into one that will have children generated, such as a TestCase : [Parallelizable(ParallelScope.Children)] // These will now run in parallel [TestCase(1)] [TestCase(2)] public void NUnit1009SampleTest(int numberValue) { Assert.That(numberValue, Is.GreaterThan(0)); } <!-- start generated config severity --> Configure severity Via ruleset file. Configure the severity per project, for more info see MSDN . Via #pragma directive. #pragma warning disable NUnit1009 // No ParallelScope.Children on a non-parameterized test method. Code violating the rule here #pragma warning restore NUnit1009 // No ParallelScope.Children on a non-parameterized test method. Or put this at the top of the file to disable all instances. #pragma warning disable NUnit1009 // No ParallelScope.Children on a non-parameterized test method. Via attribute [SuppressMessage] . [System.Diagnostics.CodeAnalysis.SuppressMessage(\"Structure\", \"NUnit1009:No ParallelScope.Children on a non-parameterized test method.\", Justification = \"Reason...\")] <!-- end generated config severity -->"
  },
  "articles/nunit-analyzers/NUnit1010.html": {
    "href": "articles/nunit-analyzers/NUnit1010.html",
    "title": "NUnit1010 | NUnit Docs",
    "keywords": "NUnit1010 No ParallelScope.Fixtures on a test method. Topic Value Id NUnit1010 Severity Error Enabled True Category Structure Code ParallelizableUsageAnalyzer Description One may not specify ParallelScope.Fixtures on a test method. Motivation To prevent tests that will fail at runtime due to improper construction. How to fix violations Example Violation [Parallelizable(ParallelScope.Fixtures)] [Test] public void NUnit1010SampleTest() { Assert.Pass(); } Explanation In the sample above, ParallelScope.Fixtures is specified. However, in the context of a test method, a scope of Fixtures does not make sense. This scope only applies at the assembly or class level . Fix Remove the attribute: [Test] public void NUnit1010SampleTest() { Assert.Pass(); } Or apply this attribute at the class level: [Parallelizable(ParallelScope.Fixtures)] public class MyTests { [Test] public void NUnit1010SampleTest() { Assert.Pass(); } } Or use a different attribute that applies at the test level: [Parallelizable(ParallelScope.Self)] [Test] public void NUnit1010SampleTest() { Assert.Pass(); } <!-- start generated config severity --> Configure severity Via ruleset file. Configure the severity per project, for more info see MSDN . Via #pragma directive. #pragma warning disable NUnit1010 // No ParallelScope.Fixtures on a test method. Code violating the rule here #pragma warning restore NUnit1010 // No ParallelScope.Fixtures on a test method. Or put this at the top of the file to disable all instances. #pragma warning disable NUnit1010 // No ParallelScope.Fixtures on a test method. Via attribute [SuppressMessage] . [System.Diagnostics.CodeAnalysis.SuppressMessage(\"Structure\", \"NUnit1010:No ParallelScope.Fixtures on a test method.\", Justification = \"Reason...\")] <!-- end generated config severity -->"
  },
  "articles/nunit-analyzers/NUnit1011.html": {
    "href": "articles/nunit-analyzers/NUnit1011.html",
    "title": "NUnit1011 | NUnit Docs",
    "keywords": "NUnit1011 TestCaseSource argument does not specify an existing member. Topic Value Id NUnit1011 Severity Error Enabled True Category Structure Code TestCaseSourceUsesStringAnalyzer Description TestCaseSource argument does not specify an existing member. This will lead to an error at run-time. Motivation To prevent tests that will fail at runtime due to improper construction. How to fix violations Example Violation [TestCaseSource(\"MyIncorrectTestSource\")] public void NUnit1011SampleTest(string stringValue) { Assert.That(stringValue.Length, Is.EqualTo(3)); } public static object[] MyTestSource() { return new object[] {\"One\", \"Two\"}; } Explanation In the example above, the test case source is named MyIncorrectTestCaseSource , but the test case source is actually named MyTestSource . Because the names don't match, this will be an error. Fix Rename the TestCaseSource to match: [TestCaseSource(\"MyTestSource\")] public void NUnit1011SampleTest(string stringValue) { Assert.That(stringValue.Length, Is.EqualTo(3)); } public static object[] MyTestSource() { return new object[] {\"One\", \"Two\"}; } Or even better, use nameof so that the compiler may assist with mis-matched names in the future: [TestCaseSource(nameof(MyTestSource))] public void NUnit1011SampleTest(string stringValue) { Assert.That(stringValue.Length, Is.EqualTo(3)); } public static object[] MyTestSource() { return new object[] {\"One\", \"Two\"}; } <!-- start generated config severity --> Configure severity Via ruleset file. Configure the severity per project, for more info see MSDN . Via #pragma directive. #pragma warning disable NUnit1011 // TestCaseSource argument does not specify an existing member. Code violating the rule here #pragma warning restore NUnit1011 // TestCaseSource argument does not specify an existing member. Or put this at the top of the file to disable all instances. #pragma warning disable NUnit1011 // TestCaseSource argument does not specify an existing member. Via attribute [SuppressMessage] . [System.Diagnostics.CodeAnalysis.SuppressMessage(\"Structure\", \"NUnit1011:TestCaseSource argument does not specify an existing member.\", Justification = \"Reason...\")] <!-- end generated config severity -->"
  },
  "articles/nunit-analyzers/NUnit1012.html": {
    "href": "articles/nunit-analyzers/NUnit1012.html",
    "title": "NUnit1012 | NUnit Docs",
    "keywords": "NUnit1012 Async test method must have non-void return type. Topic Value Id NUnit1012 Severity Error Enabled True Category Structure Code TestMethodUsageAnalyzer Description Async test method must have non-void return type. Motivation To prevent tests that will fail at runtime due to improper construction. How to fix violations Example Violation [Test] public async void NUnit1012SampleTest() { var result = await Task.FromResult(true); Assert.That(result, Is.True); } Explanation async methods should generally not return void in C#. For example if an exception is thrown (as they are in the case of an assertion violation), the exception is actually a part of the task object. If the return type is void , no such object exists, to the exception is effectively swallowed. Fix Make the async test method return a Task : [Test] public async Task NUnit1012SampleTest() { var result = await Task.FromResult(true); Assert.That(result, Is.True); } Or modify the test to not use async behavior: [Test] public void NUnit1012SampleTest() { var result = true; Assert.That(result, Is.True); } <!-- start generated config severity --> Configure severity Via ruleset file. Configure the severity per project, for more info see MSDN . Via #pragma directive. #pragma warning disable NUnit1012 // Async test method must have non-void return type. Code violating the rule here #pragma warning restore NUnit1012 // Async test method must have non-void return type. Or put this at the top of the file to disable all instances. #pragma warning disable NUnit1012 // Async test method must have non-void return type. Via attribute [SuppressMessage] . [System.Diagnostics.CodeAnalysis.SuppressMessage(\"Structure\", \"NUnit1012:Async test method must have non-void return type.\", Justification = \"Reason...\")] <!-- end generated config severity -->"
  },
  "articles/nunit-analyzers/NUnit1013.html": {
    "href": "articles/nunit-analyzers/NUnit1013.html",
    "title": "NUnit1013 | NUnit Docs",
    "keywords": "NUnit1013 Async test method must have non-generic Task return type when no result is expected. Topic Value Id NUnit1013 Severity Error Enabled True Category Structure Code TestMethodUsageAnalyzer Description Async test method must have non-generic Task return type when no result is expected. Motivation To prevent tests that will fail at runtime due to improper construction. How to fix violations Example Violation [TestCase(1)] public async Task<string> NUnit1013SampleTest(int numberValue) { return await ConvertNumber(numberValue); } public Task<string> ConvertNumber(int numberValue) { return Task.FromResult(numberValue.ToString()); } Explanation The NUnit ExpectedResult syntax is not used, so it's an error for this method to return something that isn't being checked. Fix Utilize the ExpectedResult syntax: [TestCase(1, ExpectedResult = \"1\")] public async Task<string> NUnit1013SampleTest(int numberValue) { return await ConvertNumber(numberValue); } public Task<string> ConvertNumber(int numberValue) { return Task.FromResult(numberValue.ToString()); } Or, use an assertion and a generic Task rather than Task<string> : [TestCase(1)] public async Task NUnit1013SampleTest(int numberValue) { var result = await ConvertNumber(numberValue); Assert.That(result, Is.EqualTo(\"1\")); } public Task<string> ConvertNumber(int numberValue) { return Task.FromResult(numberValue.ToString()); } <!-- start generated config severity --> Configure severity Via ruleset file. Configure the severity per project, for more info see MSDN . Via #pragma directive. #pragma warning disable NUnit1013 // Async test method must have non-generic Task return type when no result is expected. Code violating the rule here #pragma warning restore NUnit1013 // Async test method must have non-generic Task return type when no result is expected. Or put this at the top of the file to disable all instances. #pragma warning disable NUnit1013 // Async test method must have non-generic Task return type when no result is expected. Via attribute [SuppressMessage] . [System.Diagnostics.CodeAnalysis.SuppressMessage(\"Structure\", \"NUnit1013:Async test method must have non-generic Task return type when no result is expected.\", Justification = \"Reason...\")] <!-- end generated config severity -->"
  },
  "articles/nunit-analyzers/NUnit1014.html": {
    "href": "articles/nunit-analyzers/NUnit1014.html",
    "title": "NUnit1014 | NUnit Docs",
    "keywords": "NUnit1014 Async test method must have Task<T> return type when a result is expected Topic Value Id NUnit1014 Severity Error Enabled True Category Structure Code TestMethodUsageAnalyzer Description Async test method must have Task<T> return type when a result is expected Motivation To prevent tests that will fail at runtime due to improper construction. How to fix violations Example Violation [TestCase(1, ExpectedResult = true)] public async Task NUnit1014SampleTest(int numberValue) { return; } Explanation The NUnit ExpectedResult syntax is used, so this method needs to return a type that matches the type of expected result you're looking for. Fix Remove the ExpectedResult syntax: [TestCase(1)] public async Task NUnit1014SampleTest(int numberValue) { Assert.Pass(); } Or, update the return task type to be what you're looking for, e.g. Task<bool> below: [TestCase(1, ExpectedResult = true)] public async Task<bool> NUnit1014SampleTest(int numberValue) { return Task.FromResult(true); } <!-- start generated config severity --> Configure severity Via ruleset file. Configure the severity per project, for more info see MSDN . Via #pragma directive. #pragma warning disable NUnit1014 // Async test method must have `Task<T>` return type when a result is expected Code violating the rule here #pragma warning restore NUnit1014 // Async test method must have `Task<T>` return type when a result is expected Or put this at the top of the file to disable all instances. #pragma warning disable NUnit1014 // Async test method must have `Task<T>` return type when a result is expected Via attribute [SuppressMessage] . [System.Diagnostics.CodeAnalysis.SuppressMessage(\"Structure\", \"NUnit1014:Async test method must have `Task<T>` return type when a result is expected\", Justification = \"Reason...\")] <!-- end generated config severity -->"
  },
  "articles/nunit-analyzers/NUnit2001.html": {
    "href": "articles/nunit-analyzers/NUnit2001.html",
    "title": "NUnit2001 | NUnit Docs",
    "keywords": "NUnit2001 Consider using Assert.That(expr, Is.False) instead of Assert.False(expr). Topic Value Id NUnit2001 Severity Info Enabled True Category Assertion Code ClassicModelAssertUsageAnalyzer Description Consider using the constraint model, Assert.That(expr, Is.False) , instead of the classic model, Assert.False(expr) . Motivation The classic Assert model contains less flexibility than the constraint model, so this analyzer marks usages of Assert.False from the classic Assert model. [Test] public void Test() { Assert.False(expression); } How to fix violations The analyzer comes with a code fix that will replace Assert.False(expression) with Assert.That(expression, Is.False) . So the code block above will be changed into. [Test] public void Test() { Assert.That(expression, Is.False); } <!-- start generated config severity --> Configure severity Via ruleset file. Configure the severity per project, for more info see MSDN . Via #pragma directive. #pragma warning disable NUnit2001 // Consider using Assert.That(expr, Is.False) instead of Assert.False(expr). Code violating the rule here #pragma warning restore NUnit2001 // Consider using Assert.That(expr, Is.False) instead of Assert.False(expr). Or put this at the top of the file to disable all instances. #pragma warning disable NUnit2001 // Consider using Assert.That(expr, Is.False) instead of Assert.False(expr). Via attribute [SuppressMessage] . [System.Diagnostics.CodeAnalysis.SuppressMessage(\"Assertion\", \"NUnit2001:Consider using Assert.That(expr, Is.False) instead of Assert.False(expr).\", Justification = \"Reason...\")] <!-- end generated config severity -->"
  },
  "articles/nunit-analyzers/NUnit2002.html": {
    "href": "articles/nunit-analyzers/NUnit2002.html",
    "title": "NUnit2002 | NUnit Docs",
    "keywords": "NUnit2002 Consider using Assert.That(expr, Is.False) instead of Assert.IsFalse(expr). Topic Value Id NUnit2002 Severity Info Enabled True Category Assertion Code ClassicModelAssertUsageAnalyzer Description Consider using the constraint model, Assert.That(expr, Is.False) , instead of the classic model, Assert.IsFalse(expr) . Motivation The classic Assert model contains less flexibility than the constraint model, so this analyzer marks usages of Assert.IsFalse from the classic Assert model. [Test] public void Test() { Assert.IsFalse(expression); } How to fix violations The analyzer comes with a code fix that will replace Assert.IsFalse(expression) with Assert.That(expression, Is.False) . So the code block above will be changed into. [Test] public void Test() { Assert.That(expression, Is.False); } <!-- start generated config severity --> Configure severity Via ruleset file. Configure the severity per project, for more info see MSDN . Via #pragma directive. #pragma warning disable NUnit2002 // Consider using Assert.That(expr, Is.False) instead of Assert.IsFalse(expr). Code violating the rule here #pragma warning restore NUnit2002 // Consider using Assert.That(expr, Is.False) instead of Assert.IsFalse(expr). Or put this at the top of the file to disable all instances. #pragma warning disable NUnit2002 // Consider using Assert.That(expr, Is.False) instead of Assert.IsFalse(expr). Via attribute [SuppressMessage] . [System.Diagnostics.CodeAnalysis.SuppressMessage(\"Assertion\", \"NUnit2002:Consider using Assert.That(expr, Is.False) instead of Assert.IsFalse(expr).\", Justification = \"Reason...\")] <!-- end generated config severity -->"
  },
  "articles/nunit-analyzers/NUnit2003.html": {
    "href": "articles/nunit-analyzers/NUnit2003.html",
    "title": "NUnit2003 | NUnit Docs",
    "keywords": "NUnit2003 Consider using Assert.That(expr, Is.True) instead of Assert.IsTrue(expr). Topic Value Id NUnit2003 Severity Info Enabled True Category Assertion Code ClassicModelAssertUsageAnalyzer Description Consider using the constraint model, Assert.That(expr, Is.True) , instead of the classic model, Assert.IsTrue(expr) . Motivation The classic Assert model contains less flexibility than the constraint model, so this analyzer marks usages of Assert.IsTrue from the classic Assert model. [Test] public void Test() { Assert.IsTrue(expression); } How to fix violations The analyzer comes with a code fix that will replace Assert.IsTrue(expression) with Assert.That(expression, Is.True) . So the code block above will be changed into. [Test] public void Test() { Assert.That(expression, Is.True); } <!-- start generated config severity --> Configure severity Via ruleset file. Configure the severity per project, for more info see MSDN . Via #pragma directive. #pragma warning disable NUnit2003 // Consider using Assert.That(expr, Is.True) instead of Assert.IsTrue(expr). Code violating the rule here #pragma warning restore NUnit2003 // Consider using Assert.That(expr, Is.True) instead of Assert.IsTrue(expr). Or put this at the top of the file to disable all instances. #pragma warning disable NUnit2003 // Consider using Assert.That(expr, Is.True) instead of Assert.IsTrue(expr). Via attribute [SuppressMessage] . [System.Diagnostics.CodeAnalysis.SuppressMessage(\"Assertion\", \"NUnit2003:Consider using Assert.That(expr, Is.True) instead of Assert.IsTrue(expr).\", Justification = \"Reason...\")] <!-- end generated config severity -->"
  },
  "articles/nunit-analyzers/NUnit2004.html": {
    "href": "articles/nunit-analyzers/NUnit2004.html",
    "title": "NUnit2004 | NUnit Docs",
    "keywords": "NUnit2004 Consider using Assert.That(expr, Is.True) instead of Assert.True(expr). Topic Value Id NUnit2004 Severity Info Enabled True Category Assertion Code ClassicModelAssertUsageAnalyzer Description Consider using the constraint model, Assert.That(expr, Is.True) , instead of the classic model, Assert.True(expr) . Motivation The classic Assert model contains less flexibility than the constraint model, so this analyzer marks usages of Assert.True from the classic Assert model. [Test] public void Test() { Assert.True(expression); } How to fix violations The analyzer comes with a code fix that will replace Assert.True(expression) with Assert.That(expression, Is.True) . So the code block above will be changed into. [Test] public void Test() { Assert.That(expression, Is.True); } <!-- start generated config severity --> Configure severity Via ruleset file. Configure the severity per project, for more info see MSDN . Via #pragma directive. #pragma warning disable NUnit2004 // Consider using Assert.That(expr, Is.True) instead of Assert.True(expr). Code violating the rule here #pragma warning restore NUnit2004 // Consider using Assert.That(expr, Is.True) instead of Assert.True(expr). Or put this at the top of the file to disable all instances. #pragma warning disable NUnit2004 // Consider using Assert.That(expr, Is.True) instead of Assert.True(expr). Via attribute [SuppressMessage] . [System.Diagnostics.CodeAnalysis.SuppressMessage(\"Assertion\", \"NUnit2004:Consider using Assert.That(expr, Is.True) instead of Assert.True(expr).\", Justification = \"Reason...\")] <!-- end generated config severity -->"
  },
  "articles/nunit-analyzers/NUnit2005.html": {
    "href": "articles/nunit-analyzers/NUnit2005.html",
    "title": "NUnit2005 | NUnit Docs",
    "keywords": "NUnit2005 Consider using Assert.That(expr2, Is.EqualTo(expr1)) instead of Assert.AreEqual(expr1, expr2). Topic Value Id NUnit2005 Severity Warning Enabled True Category Assertion Code ClassicModelAssertUsageAnalyzer Description Consider using the constraint model, Assert.That(expr2, Is.EqualTo(expr1)) , instead of the classic model, Assert.AreEqual(expr1, expr2) . Motivation The classic Assert model, Assert.AreEqual(expected, actual) , makes it easy to mix the expected and the actual parameter, so this analyzer marks usages of Assert.AreEqual from the classic Assert model. [Test] public void Test() { Assert.AreEqual(expression1, expression2); } How to fix violations The analyzer comes with a code fix that will replace Assert.AreEqual(expression1, expression2) with Assert.That(expression2, Is.EqualTo(expression1)) . So the code block above will be changed into. [Test] public void Test() { Assert.That(expression2, Is.EqualTo(expression1)); } <!-- start generated config severity --> Configure severity Via ruleset file. Configure the severity per project, for more info see MSDN . Via #pragma directive. #pragma warning disable NUnit2005 // Consider using Assert.That(expr2, Is.EqualTo(expr1)) instead of Assert.AreEqual(expr1, expr2). Code violating the rule here #pragma warning restore NUnit2005 // Consider using Assert.That(expr2, Is.EqualTo(expr1)) instead of Assert.AreEqual(expr1, expr2). Or put this at the top of the file to disable all instances. #pragma warning disable NUnit2005 // Consider using Assert.That(expr2, Is.EqualTo(expr1)) instead of Assert.AreEqual(expr1, expr2). Via attribute [SuppressMessage] . [System.Diagnostics.CodeAnalysis.SuppressMessage(\"Assertion\", \"NUnit2005:Consider using Assert.That(expr2, Is.EqualTo(expr1)) instead of Assert.AreEqual(expr1, expr2).\", Justification = \"Reason...\")] <!-- end generated config severity -->"
  },
  "articles/nunit-analyzers/NUnit2006.html": {
    "href": "articles/nunit-analyzers/NUnit2006.html",
    "title": "NUnit2006 | NUnit Docs",
    "keywords": "NUnit2006 Consider using Assert.That(expr2, Is.Not.EqualTo(expr1)) instead of Assert.AreNotEqual(expr1, expr2). Topic Value Id NUnit2006 Severity Warning Enabled True Category Assertion Code ClassicModelAssertUsageAnalyzer Description Consider using the constraint model, Assert.That(expr2, Is.Not.EqualTo(expr1)) , instead of the classic model, Assert.AreNotEqual(expr1, expr2) . Motivation The classic Assert model, Assert.AreNotEqual(expected, actual) , makes it easy to mix the expected and the actual parameter, so this analyzer marks usages of Assert.AreNotEqual from the classic Assert model. [Test] public void Test() { Assert.AreNotEqual(expression1, expression2) } How to fix violations The analyzer comes with a code fix that will replace Assert.AreNotEqual(expression1, expression2) with Assert.That(expression2, Is.Not.EqualTo(expression1)) . So the code block above will be changed into. [Test] public void Test() { Assert.That(expression2, Is.Not.EqualTo(expression1)); } <!-- start generated config severity --> Configure severity Via ruleset file. Configure the severity per project, for more info see MSDN . Via #pragma directive. #pragma warning disable NUnit2006 // Consider using Assert.That(expr2, Is.Not.EqualTo(expr1)) instead of Assert.AreNotEqual(expr1, expr2). Code violating the rule here #pragma warning restore NUnit2006 // Consider using Assert.That(expr2, Is.Not.EqualTo(expr1)) instead of Assert.AreNotEqual(expr1, expr2). Or put this at the top of the file to disable all instances. #pragma warning disable NUnit2006 // Consider using Assert.That(expr2, Is.Not.EqualTo(expr1)) instead of Assert.AreNotEqual(expr1, expr2). Via attribute [SuppressMessage] . [System.Diagnostics.CodeAnalysis.SuppressMessage(\"Assertion\", \"NUnit2006:Consider using Assert.That(expr2, Is.Not.EqualTo(expr1)) instead of Assert.AreNotEqual(expr1, expr2).\", Justification = \"Reason...\")] <!-- end generated config severity -->"
  },
  "articles/nunit-analyzers/NUnit2007.html": {
    "href": "articles/nunit-analyzers/NUnit2007.html",
    "title": "NUnit2007 | NUnit Docs",
    "keywords": "NUnit2007 Actual value should not be constant. Topic Value Id NUnit2007 Severity Warning Enabled True Category Assertion Code ConstActualValueUsageAnalyzer Description Actual value should not be constant. This indicates that the actual and expected values have switched places. Motivation Bring developers' attention to a scenario in which their test is most likely testing the wrong thing, or to cases where their actual and expected values may be accidentally swapped. How to fix violations Example Violation [Test] public void NUnit2007SampleTest() { var x = 5; Assert.That(5, Is.EqualTo(x)); Assert.AreEqual(x, 5); } Explanation Both asserts above will trigger this warning. That's because the actual value should be the value produced by your code, not a constant value that you're expecting (which should be in the place of the expected value). In the case of equality, etc. this might seem like no big deal, but it really comes into play in the exceptions that are raised by error messages. It's important that if your test fails, the message can correctly tell you what the expected and actual values are. As an aside, this is another reason why the Assert.That syntax is often preferred when asserting equality. Fix Flip the actual and expected values so that your expected value is the constant and your actual value has been generated by code. [Test] public void NUnit2007SampleTest() { var x = 5; Assert.That(x, Is.EqualTo(5)); Assert.AreEqual(5, x); } <!-- start generated config severity --> Configure severity Via ruleset file. Configure the severity per project, for more info see MSDN . Via #pragma directive. #pragma warning disable NUnit2007 // Actual value should not be constant. Code violating the rule here #pragma warning restore NUnit2007 // Actual value should not be constant. Or put this at the top of the file to disable all instances. #pragma warning disable NUnit2007 // Actual value should not be constant. Via attribute [SuppressMessage] . [System.Diagnostics.CodeAnalysis.SuppressMessage(\"Assertion\", \"NUnit2007:Actual value should not be constant.\", Justification = \"Reason...\")] <!-- end generated config severity -->"
  },
  "articles/nunit-analyzers/NUnit2008.html": {
    "href": "articles/nunit-analyzers/NUnit2008.html",
    "title": "NUnit2008 | NUnit Docs",
    "keywords": "NUnit2008 Incorrect IgnoreCase usage. Topic Value Id NUnit2008 Severity Warning Enabled True Category Assertion Code IgnoreCaseUsageAnalyzer Description IgnoreCase modifier should only be used for string or char arguments. Using it on another type will not have any effect. Motivation To bring developers' attention to a scenario in which their code is actually having no effect and may reveal that their test is not doing what they expect. How to fix violations Example Violation [Test] public void NUnit2008SampleTest() { var date = DateTime.Now; Assert.That(date, Is.Not.EqualTo(date.AddDays(1)).IgnoreCase); } Explanation Using IgnoreCase here doesn't make any sense, because the types we're comparing don't have the concept of case. Therefore, it's only suitable to use on textual primitives (e.g. string and char ). Fix Remove the errant call to IgnoreCase : [Test] public void NUnit2008SampleTest() { var date = DateTime.Now; Assert.That(date, Is.Not.EqualTo(date.AddDays(1))); } Or update the code to compare based on the primitives that are supported by IgnoreCase : [Test] public void NUnit2008SampleTest() { var date = DateTime.Now; Assert.That(date.ToString(), Is.Not.EqualTo(date.AddDays(1).ToString()).IgnoreCase); } <!-- start generated config severity --> Configure severity Via ruleset file. Configure the severity per project, for more info see MSDN . Via #pragma directive. #pragma warning disable NUnit2008 // Incorrect IgnoreCase usage. Code violating the rule here #pragma warning restore NUnit2008 // Incorrect IgnoreCase usage. Or put this at the top of the file to disable all instances. #pragma warning disable NUnit2008 // Incorrect IgnoreCase usage. Via attribute [SuppressMessage] . [System.Diagnostics.CodeAnalysis.SuppressMessage(\"Assertion\", \"NUnit2008:Incorrect IgnoreCase usage.\", Justification = \"Reason...\")] <!-- end generated config severity -->"
  },
  "articles/nunit-analyzers/NUnit2009.html": {
    "href": "articles/nunit-analyzers/NUnit2009.html",
    "title": "NUnit2009 | NUnit Docs",
    "keywords": "NUnit2009 Same value provided as actual and expected argument. Topic Value Id NUnit2009 Severity Warning Enabled True Category Structure Code SameActualExpectedValueAnalyzer Description The same value has been provided as both actual and expected argument. This indicates a coding error. Motivation To bring developers' attention to a situation in which their code may not be operating as expected and their test may not be testing what they expect. How to fix violations Sample Violation [Test] public void NUnit2009SampleTest() { var x = 1; Assert.That(x, Is.EqualTo(x)); } Explanation In the above example, the test will always be correct, because we're comparing the same value. That is to say, we're not actually testing anything. Fix Ensure the expected and actual values come from different places. [Test] public void NUnit2009SampleTest() { var x = 1; Assert.That(x, Is.EqualTo(1)); } <!-- start generated config severity --> Configure severity Via ruleset file. Configure the severity per project, for more info see MSDN . Via #pragma directive. #pragma warning disable NUnit2009 // Same value provided as actual and expected argument. Code violating the rule here #pragma warning restore NUnit2009 // Same value provided as actual and expected argument. Or put this at the top of the file to disable all instances. #pragma warning disable NUnit2009 // Same value provided as actual and expected argument. Via attribute [SuppressMessage] . [System.Diagnostics.CodeAnalysis.SuppressMessage(\"Structure\", \"NUnit2009:Same value provided as actual and expected argument.\", Justification = \"Reason...\")] <!-- end generated config severity -->"
  },
  "articles/nunit-analyzers/NUnit2010.html": {
    "href": "articles/nunit-analyzers/NUnit2010.html",
    "title": "NUnit2010 | NUnit Docs",
    "keywords": "NUnit2010 Use EqualConstraint. Topic Value Id NUnit2010 Severity Info Enabled True Category Assertion Code EqualConstraintUsageAnalyzer Description Using EqualConstraint will lead to better assertion messages in case of failure. Motivation Using Is.EqualTo (or Is.Not.EqualTo ) constraint will lead to better assertion messages in case of failure, so this analyzer marks all usages of == operator and Equals method where it is possible to replace with Is.EqualTo constraint. [Test] public void Test() { Assert.True(actual == expected); } How to fix violations The analyzer comes with a code fix that will replace Assert.True(actual == expected) with Assert.That(actual, Is.EqualTo(expected)) . So the code block above will be changed into [Test] public void Test() { Assert.That(actual, Is.EqualTo(expected)); } <!-- start generated config severity --> Configure severity Via ruleset file. Configure the severity per project, for more info see MSDN . Via #pragma directive. #pragma warning disable NUnit2010 // Use EqualConstraint. Code violating the rule here #pragma warning restore NUnit2010 // Use EqualConstraint. Or put this at the top of the file to disable all instances. #pragma warning disable NUnit2010 // Use EqualConstraint. Via attribute [SuppressMessage] . [System.Diagnostics.CodeAnalysis.SuppressMessage(\"Assertion\", \"NUnit2010:Use EqualConstraint.\", Justification = \"Reason...\")] <!-- end generated config severity -->"
  },
  "articles/nunit-analyzers/NUnit2011.html": {
    "href": "articles/nunit-analyzers/NUnit2011.html",
    "title": "NUnit2011 | NUnit Docs",
    "keywords": "NUnit2011 Use ContainsConstraint. Topic Value Id NUnit2011 Severity Info Enabled True Category Assertion Code StringConstraintUsageAnalyzer Description Using constraints instead of boolean methods will lead to better assertion messages in case of failure. Motivation Using Does.Contain (or Does.Not.Contain ) constraint will lead to better assertion messages in case of failure, so this analyzer marks all usages of string Contains method where it is possible to replace with Does.Contain constraint. [Test] public void Test() { string actual = \"...\"; string expected = \"...\"; Assert.True(actual.Contains(expected)); } How to fix violations The analyzer comes with a code fix that will replace Assert.True(actual.Contains(expected)) with Assert.That(actual, Does.Contain(expected)) . So the code block above will be changed into [Test] public void Test() { string actual = \"...\"; string expected = \"...\"; Assert.That(actual, Does.Contain(expected)); } <!-- start generated config severity --> Configure severity Via ruleset file. Configure the severity per project, for more info see MSDN . Via #pragma directive. #pragma warning disable NUnit2011 // Use ContainsConstraint. Code violating the rule here #pragma warning restore NUnit2011 // Use ContainsConstraint. Or put this at the top of the file to disable all instances. #pragma warning disable NUnit2011 // Use ContainsConstraint. Via attribute [SuppressMessage] . [System.Diagnostics.CodeAnalysis.SuppressMessage(\"Assertion\", \"NUnit2011:Use ContainsConstraint.\", Justification = \"Reason...\")] <!-- end generated config severity -->"
  },
  "articles/nunit-analyzers/NUnit2012.html": {
    "href": "articles/nunit-analyzers/NUnit2012.html",
    "title": "NUnit2012 | NUnit Docs",
    "keywords": "NUnit2012 Use StartsWithConstraint. Topic Value Id NUnit2012 Severity Info Enabled True Category Assertion Code StringConstraintUsageAnalyzer Description Using constraints instead of boolean methods will lead to better assertion messages in case of failure. Motivation Using Does.StartWith (or Does.Not.StartWith ) constraint will lead to better assertion messages in case of failure, so this analyzer marks all usages of string StartsWith method where it is possible to replace with Does.StartWith constraint. [Test] public void Test() { string actual = \"...\"; string expected = \"...\"; Assert.True(actual.StartsWith(expected)); } How to fix violations The analyzer comes with a code fix that will replace Assert.True(actual.StartWith(expected)) with Assert.That(actual, Does.StartWith(expected)) . So the code block above will be changed into [Test] public void Test() { string actual = \"...\"; string expected = \"...\"; Assert.That(actual, Does.StartWith(expected)); } <!-- start generated config severity --> Configure severity Via ruleset file. Configure the severity per project, for more info see MSDN . Via #pragma directive. #pragma warning disable NUnit2012 // Use StartsWithConstraint. Code violating the rule here #pragma warning restore NUnit2012 // Use StartsWithConstraint. Or put this at the top of the file to disable all instances. #pragma warning disable NUnit2012 // Use StartsWithConstraint. Via attribute [SuppressMessage] . [System.Diagnostics.CodeAnalysis.SuppressMessage(\"Assertion\", \"NUnit2012:Use StartsWithConstraint.\", Justification = \"Reason...\")] <!-- end generated config severity -->"
  },
  "articles/nunit-analyzers/NUnit2013.html": {
    "href": "articles/nunit-analyzers/NUnit2013.html",
    "title": "NUnit2013 | NUnit Docs",
    "keywords": "NUnit2013 Use EndsWithConstraint. Topic Value Id NUnit2013 Severity Info Enabled True Category Assertion Code StringConstraintUsageAnalyzer Description Using constraints instead of boolean methods will lead to better assertion messages in case of failure. Motivation Using Does.EndWith (or Does.Not.EndWith ) constraint will lead to better assertion messages in case of failure, so this analyzer marks all usages of string EndsWith method where it is possible to replace with Does.EndWith constraint. [Test] public void Test() { string actual = \"...\"; string expected = \"...\"; Assert.True(actual.EndsWith(expected)); } How to fix violations The analyzer comes with a code fix that will replace Assert.True(actual.EndsWith(expected)) with Assert.That(actual, Does.EndWith(expected)) . So the code block above will be changed into [Test] public void Test() { string actual = \"...\"; string expected = \"...\"; Assert.That(actual, Does.EndWith(expected)); } <!-- start generated config severity --> ## Configure severity ### Via ruleset file. Configure the severity per project, for more info see [MSDN](https://msdn.microsoft.com/en-us/library/dd264949.aspx). ### Via #pragma directive. ```csharp #pragma warning disable NUnit2013 // Use EndsWithConstraint. Code violating the rule here #pragma warning restore NUnit2013 // Use EndsWithConstraint. Or put this at the top of the file to disable all instances. #pragma warning disable NUnit2013 // Use EndsWithConstraint. Via attribute [SuppressMessage] . [System.Diagnostics.CodeAnalysis.SuppressMessage(\"Assertion\", \"NUnit2013:Use EndsWithConstraint.\", Justification = \"Reason...\")] <!-- end generated config severity -->"
  },
  "articles/nunit-analyzers/NUnit2014.html": {
    "href": "articles/nunit-analyzers/NUnit2014.html",
    "title": "NUnit2014 | NUnit Docs",
    "keywords": "NUnit2014 Use SomeItemsConstraint. Topic Value Id NUnit2014 Severity Info Enabled True Category Assertion Code SomeItemsConstraintUsageAnalyzer Description Using SomeItemsConstraint will lead to better assertion messages in case of failure. Motivation Using Does.Contain (or Does.Not.Contain ) constraint will lead to better assertion messages in case of failure, so this analyzer marks all usages of string Contains method where it is possible to replace with Does.Contain constraint. [Test] public void Test() { var actual = new List<int> {1,2,3}; int expected = 1; Assert.True(actual.Contains(expected)); } How to fix violations The analyzer comes with a code fix that will replace Assert.True(actual.Contains(expected)) with Assert.That(actual, Does.Contain(expected)) . So the code block above will be changed into [Test] public void Test() { var actual = new List<int> {1,2,3}; int expected = 1; Assert.That(actual, Does.Contain(expected)); } <!-- start generated config severity --> Configure severity Via ruleset file. Configure the severity per project, for more info see MSDN . Via #pragma directive. #pragma warning disable NUnit2014 // Use SomeItemsConstraint. Code violating the rule here #pragma warning restore NUnit2014 // Use SomeItemsConstraint. Or put this at the top of the file to disable all instances. #pragma warning disable NUnit2014 // Use SomeItemsConstraint. Via attribute [SuppressMessage] . [System.Diagnostics.CodeAnalysis.SuppressMessage(\"Assertion\", \"NUnit2014:Use SomeItemsConstraint.\", Justification = \"Reason...\")] <!-- end generated config severity -->"
  },
  "articles/nunit-analyzers/NUnit2015.html": {
    "href": "articles/nunit-analyzers/NUnit2015.html",
    "title": "NUnit2015 | NUnit Docs",
    "keywords": "NUnit2015 Consider using Assert.That(expr2, Is.SameAs(expr1)) instead of Assert.AreSame(expr1, expr2). Topic Value Id NUnit2015 Severity Warning Enabled True Category Assertion Code ClassicModelAssertUsageAnalyzer Description Consider using the constraint model, Assert.That(expr2, Is.SameAs(expr1)), instead of the classic model, Assert.AreSame(expr1, expr2). Motivation The assert Assert.AreSame from the classic Assert model makes it easy to confuse the expected and the actual argument, so this analyzer marks usages of Assert.AreSame . [Test] public void Test() { Assert.AreSame(expected, actual); } How to fix violations The analyzer comes with a code fix that will replace Assert.AreSame(expected, actual) with Assert.That(actual, Is.SameAs(expected)) . So the code block above will be changed into. [Test] public void Test() { Assert.That(actual, Is.SameAs(expected)); } <!-- start generated config severity --> Configure severity Via ruleset file. Configure the severity per project, for more info see MSDN . Via #pragma directive. #pragma warning disable NUnit2015 // Consider using Assert.That(expr2, Is.SameAs(expr1)) instead of Assert.AreSame(expr1, expr2). Code violating the rule here #pragma warning restore NUnit2015 // Consider using Assert.That(expr2, Is.SameAs(expr1)) instead of Assert.AreSame(expr1, expr2). Or put this at the top of the file to disable all instances. #pragma warning disable NUnit2015 // Consider using Assert.That(expr2, Is.SameAs(expr1)) instead of Assert.AreSame(expr1, expr2). Via attribute [SuppressMessage] . [System.Diagnostics.CodeAnalysis.SuppressMessage(\"Assertion\", \"NUnit2015:Consider using Assert.That(expr2, Is.SameAs(expr1)) instead of Assert.AreSame(expr1, expr2).\", Justification = \"Reason...\")] <!-- end generated config severity -->"
  },
  "articles/nunit-analyzers/NUnit2016.html": {
    "href": "articles/nunit-analyzers/NUnit2016.html",
    "title": "NUnit2016 | NUnit Docs",
    "keywords": "NUnit2016 Consider using Assert.That(expr, Is.Null) instead of Assert.Null(expr). Topic Value Id NUnit2016 Severity Info Enabled True Category Assertion Code ClassicModelAssertUsageAnalyzer Description Consider using the constraint model, Assert.That(expr, Is.Null) , instead of the classic model, Assert.Null(expr) . Motivation The classic Assert model contains less flexibility than the constraint model, so this analyzer marks usages of Assert.Null from the classic Assert model. [Test] public void Test() { object obj = null; Assert.Null(obj); } How to fix violations The analyzer comes with a code fix that will replace Assert.Null(expression) with Assert.That(expression, Is.Null) . So the code block above will be changed into. [Test] public void Test() { object obj = null; Assert.That(obj, Is.Null); } <!-- start generated config severity --> Configure severity Via ruleset file. Configure the severity per project, for more info see MSDN . Via #pragma directive. #pragma warning disable NUnit2016 // Consider using Assert.That(expr, Is.Null) instead of Assert.Null(expr). Code violating the rule here #pragma warning restore NUnit2016 // Consider using Assert.That(expr, Is.Null) instead of Assert.Null(expr). Or put this at the top of the file to disable all instances. #pragma warning disable NUnit2016 // Consider using Assert.That(expr, Is.Null) instead of Assert.Null(expr). Via attribute [SuppressMessage] . [System.Diagnostics.CodeAnalysis.SuppressMessage(\"Assertion\", \"NUnit2016:Consider using Assert.That(expr, Is.Null) instead of Assert.Null(expr).\", Justification = \"Reason...\")] <!-- end generated config severity -->"
  },
  "articles/nunit-analyzers/NUnit2017.html": {
    "href": "articles/nunit-analyzers/NUnit2017.html",
    "title": "NUnit2017 | NUnit Docs",
    "keywords": "NUnit2017 Consider using Assert.That(expr, Is.Null) instead of Assert.IsNull(expr). Topic Value Id NUnit2017 Severity Info Enabled True Category Assertion Code ClassicModelAssertUsageAnalyzer Description Consider using the constraint model, Assert.That(expr, Is.Null) , instead of the classic model, Assert.IsNull(expr) . Motivation The classic Assert model contains less flexibility than the constraint model, so this analyzer marks usages of Assert.IsNull from the classic Assert model. [Test] public void Test() { object obj = null; Assert.IsNull(obj); } How to fix violations The analyzer comes with a code fix that will replace Assert.IsNull(expression) with Assert.That(expression, Is.Null) . So the code block above will be changed into. [Test] public void Test() { object obj = null; Assert.That(obj, Is.Null); } <!-- start generated config severity --> Configure severity Via ruleset file. Configure the severity per project, for more info see MSDN . Via #pragma directive. #pragma warning disable NUnit2017 // Consider using Assert.That(expr, Is.Null) instead of Assert.IsNull(expr). Code violating the rule here #pragma warning restore NUnit2017 // Consider using Assert.That(expr, Is.Null) instead of Assert.IsNull(expr). Or put this at the top of the file to disable all instances. #pragma warning disable NUnit2017 // Consider using Assert.That(expr, Is.Null) instead of Assert.IsNull(expr). Via attribute [SuppressMessage] . [System.Diagnostics.CodeAnalysis.SuppressMessage(\"Assertion\", \"NUnit2017:Consider using Assert.That(expr, Is.Null) instead of Assert.IsNull(expr).\", Justification = \"Reason...\")] <!-- end generated config severity -->"
  },
  "articles/nunit-analyzers/NUnit2018.html": {
    "href": "articles/nunit-analyzers/NUnit2018.html",
    "title": "NUnit2018 | NUnit Docs",
    "keywords": "NUnit2018 Consider using Assert.That(expr, Is.Not.Null) instead of Assert.NotNull(expr). Topic Value Id NUnit2018 Severity Info Enabled True Category Assertion Code ClassicModelAssertUsageAnalyzer Description Consider using the constraint model, Assert.That(expr, Is.Not.Null) , instead of the classic model, Assert.NotNull(expr) . Motivation The classic Assert model contains less flexibility than the constraint model, so this analyzer marks usages of Assert.NotNull from the classic Assert model. [Test] public void Test() { object obj = null; Assert.NotNull(obj); } How to fix violations The analyzer comes with a code fix that will replace Assert.NotNull(expression) with Assert.That(expression, Is.Not.Null) . So the code block above will be changed into. [Test] public void Test() { object obj = null; Assert.That(obj, Is.Not.Null); } <!-- start generated config severity --> Configure severity Via ruleset file. Configure the severity per project, for more info see MSDN . Via #pragma directive. #pragma warning disable NUnit2018 // Consider using Assert.That(expr, Is.Not.Null) instead of Assert.NotNull(expr). Code violating the rule here #pragma warning restore NUnit2018 // Consider using Assert.That(expr, Is.Not.Null) instead of Assert.NotNull(expr). Or put this at the top of the file to disable all instances. #pragma warning disable NUnit2018 // Consider using Assert.That(expr, Is.Not.Null) instead of Assert.NotNull(expr). Via attribute [SuppressMessage] . [System.Diagnostics.CodeAnalysis.SuppressMessage(\"Assertion\", \"NUnit2018:Consider using Assert.That(expr, Is.Not.Null) instead of Assert.NotNull(expr).\", Justification = \"Reason...\")] <!-- end generated config severity -->"
  },
  "articles/nunit-analyzers/NUnit2019.html": {
    "href": "articles/nunit-analyzers/NUnit2019.html",
    "title": "NUnit2019 | NUnit Docs",
    "keywords": "NUnit2019 Consider using Assert.That(expr, Is.Not.Null) instead of Assert.IsNotNull(expr). Topic Value Id NUnit2019 Severity Info Enabled True Category Assertion Code ClassicModelAssertUsageAnalyzer Description Consider using the constraint model, Assert.That(expr, Is.Not.Null) , instead of the classic model, Assert.IsNotNull(expr) . Motivation The classic Assert model contains less flexibility than the constraint model, so this analyzer marks usages of Assert.IsNotNull from the classic Assert model. [Test] public void Test() { object obj = null; Assert.IsNotNull(obj); } How to fix violations The analyzer comes with a code fix that will replace Assert.IsNotNull(expression) with Assert.That(expression, Is.Not.Null) . So the code block above will be changed into. [Test] public void Test() { object obj = null; Assert.That(obj, Is.Not.Null); } <!-- start generated config severity --> Configure severity Via ruleset file. Configure the severity per project, for more info see MSDN . Via #pragma directive. #pragma warning disable NUnit2019 // Consider using Assert.That(expr, Is.Not.Null) instead of Assert.IsNotNull(expr). Code violating the rule here #pragma warning restore NUnit2019 // Consider using Assert.That(expr, Is.Not.Null) instead of Assert.IsNotNull(expr). Or put this at the top of the file to disable all instances. #pragma warning disable NUnit2019 // Consider using Assert.That(expr, Is.Not.Null) instead of Assert.IsNotNull(expr). Via attribute [SuppressMessage] . [System.Diagnostics.CodeAnalysis.SuppressMessage(\"Assertion\", \"NUnit2019:Consider using Assert.That(expr, Is.Not.Null) instead of Assert.IsNotNull(expr).\", Justification = \"Reason...\")] <!-- end generated config severity -->"
  },
  "articles/nunit-analyzers/NUnit2020.html": {
    "href": "articles/nunit-analyzers/NUnit2020.html",
    "title": "NUnit2020 | NUnit Docs",
    "keywords": "NUnit2020 Incompatible types for SameAs constraint. Topic Value Id NUnit2020 Severity Warning Enabled True Category Assertion Code SameAsIncompatibleTypesAnalyzer Description Provided actual and expected arguments cannot have same type, therefore SameAs assertion will always fail. Motivation class Foo { } class Bar { } var foo = new Foo(); var bar = new Bar(); Assert.That(foo, Is.SameAs(bar)); There is no way that the same instance can be of type Foo and type Bar, therefore such assertion will always fail. How to fix violations Fix your assertion (i.e. fix actual or expected value, or choose another constraint) <!-- start generated config severity --> Configure severity Via ruleset file. Configure the severity per project, for more info see MSDN . Via #pragma directive. #pragma warning disable NUnit2020 // Incompatible types for SameAs constraint. Code violating the rule here #pragma warning restore NUnit2020 // Incompatible types for SameAs constraint. Or put this at the top of the file to disable all instances. #pragma warning disable NUnit2020 // Incompatible types for SameAs constraint. Via attribute [SuppressMessage] . [System.Diagnostics.CodeAnalysis.SuppressMessage(\"Assertion\", \"NUnit2020:Incompatible types for SameAs constraint.\", Justification = \"Reason...\")] <!-- end generated config severity -->"
  },
  "articles/nunit-analyzers/NUnit2021.html": {
    "href": "articles/nunit-analyzers/NUnit2021.html",
    "title": "NUnit2021 | NUnit Docs",
    "keywords": "NUnit2021 Incompatible types for EqualTo constraint. Topic Value Id NUnit2021 Severity Warning Enabled True Category Assertion Code EqualToIncompatibleTypesAnalyzer Description Provided actual and expected arguments cannot be equal, therefore assertion is invalid. Motivation class Foo { } class Bar { } var foo = new Foo(); var bar = new Bar(); Assert.That(foo, Is.EqualTo(bar)); There is no way that instances of types Foo and Bar could be considered equal, therefore such assertion will always fail. How to fix violations Fix your assertion (i.e. fix actual or expected value, or choose another constraint). <!-- start generated config severity --> Configure severity Via ruleset file. Configure the severity per project, for more info see MSDN . Via #pragma directive. #pragma warning disable NUnit2021 // Incompatible types for EqualTo constraint. Code violating the rule here #pragma warning restore NUnit2021 // Incompatible types for EqualTo constraint. Or put this at the top of the file to disable all instances. #pragma warning disable NUnit2021 // Incompatible types for EqualTo constraint. Via attribute [SuppressMessage] . [System.Diagnostics.CodeAnalysis.SuppressMessage(\"Assertion\", \"NUnit2021:Incompatible types for EqualTo constraint.\", Justification = \"Reason...\")] <!-- end generated config severity -->"
  },
  "articles/nunit-analyzers/NUnit2022.html": {
    "href": "articles/nunit-analyzers/NUnit2022.html",
    "title": "NUnit2022 | NUnit Docs",
    "keywords": "NUnit2022 Missing property required for constraint. Topic Value Id NUnit2022 Severity Warning Enabled True Category Assertion Code MissingPropertyAnalyzer Description Provided 'actual' argument should have required property for constraint. Motivation Using property constraints (e.g. Has.Count.EqualTo(1) , Has.Property(\"Prop\").EqualTo(expected) , etc) makes sense only when provided actual argument has those properties defined. [Test] public void Test() { var enumerable = new [] {1,2,3}.Where(i => i > 1); // Actual argument type 'IEnumerable<int>' has no property 'Count'. Assert.That(enumerable, Has.Count.EqualTo(2)); } How to fix violations Fix your property name, or use another constraint. <!-- start generated config severity --> Configure severity Via ruleset file. Configure the severity per project, for more info see MSDN . Via #pragma directive. #pragma warning disable NUnit2022 // Missing property required for constraint. Code violating the rule here #pragma warning restore NUnit2022 // Missing property required for constraint. Or put this at the top of the file to disable all instances. #pragma warning disable NUnit2022 // Missing property required for constraint. Via attribute [SuppressMessage] . [System.Diagnostics.CodeAnalysis.SuppressMessage(\"Assertion\", \"NUnit2022:Missing property required for constraint.\", Justification = \"Reason...\")] <!-- end generated config severity -->"
  },
  "articles/nunit-analyzers/NUnit2023.html": {
    "href": "articles/nunit-analyzers/NUnit2023.html",
    "title": "NUnit2023 | NUnit Docs",
    "keywords": "NUnit2023 Invalid NullConstraint usage. Topic Value Id NUnit2023 Severity Warning Enabled True Category Assertion Code NullConstraintUsageAnalyzer Description NullConstraint is allowed only for reference types or nullable value types. Motivation Non-nullable value types cannot have null value, therefore Is.Null assertions will always fail (or will always pass for Is.Not.Null ). How to fix violations Use suitable constraint. <!-- start generated config severity --> Configure severity Via ruleset file. Configure the severity per project, for more info see MSDN . Via #pragma directive. #pragma warning disable NUnit2023 // Invalid NullConstraint usage. Code violating the rule here #pragma warning restore NUnit2023 // Invalid NullConstraint usage. Or put this at the top of the file to disable all instances. #pragma warning disable NUnit2023 // Invalid NullConstraint usage. Via attribute [SuppressMessage] . [System.Diagnostics.CodeAnalysis.SuppressMessage(\"Assertion\", \"NUnit2023:Invalid NullConstraint usage.\", Justification = \"Reason...\")] <!-- end generated config severity -->"
  },
  "articles/nunit-analyzers/NUnit-Analyzers.html": {
    "href": "articles/nunit-analyzers/NUnit-Analyzers.html",
    "title": "Analyzers | NUnit Docs",
    "keywords": "Analyzers Id Title Enabled by Default NUnit1001 The individual arguments provided by a TestCaseAttribute must match the type of the matching parameter of the method. âœ… NUnit1002 TestCaseSource should use nameof operator to specify target. âœ… NUnit1003 Too few arguments provided by TestCaseAttribute. âœ… NUnit1004 Too many arguments provided by TestCaseAttribute. âœ… NUnit1005 The type of ExpectedResult must match the return type. âœ… NUnit1006 ExpectedResult must not be specified when the method returns void. âœ… NUnit1007 Method has non-void return type, but no result is expected in ExpectedResult. âœ… NUnit1008 Specifying ParallelScope.Self on assembly level has no effect. âœ… NUnit1009 No ParallelScope.Children on a non-parameterized test method. âœ… NUnit1010 No ParallelScope.Fixtures on a test method. âœ… NUnit1011 TestCaseSource argument does not specify an existing member. âœ… NUnit1012 Async test method must have non-void return type. âœ… NUnit1013 Async test method must have non-generic Task return type when no result is expected. âœ… NUnit1014 Async test method must have Task<T> return type when a result is expected âœ… NUnit2001 Consider using Assert.That(expr, Is.False) instead of Assert.False(expr). âœ… NUnit2002 Consider using Assert.That(expr, Is.False) instead of Assert.IsFalse(expr). âœ… NUnit2003 Consider using Assert.That(expr, Is.True) instead of Assert.IsTrue(expr). âœ… NUnit2004 Consider using Assert.That(expr, Is.True) instead of Assert.True(expr). âœ… NUnit2005 Consider using Assert.That(expr2, Is.EqualTo(expr1)) instead of Assert.AreEqual(expr1, expr2). âœ… NUnit2006 Consider using Assert.That(expr2, Is.Not.EqualTo(expr1)) instead of Assert.AreNotEqual(expr1, expr2). âœ… NUnit2007 Actual value should not be constant. âœ… NUnit2008 Incorrect IgnoreCase usage. âœ… NUnit2009 Same value provided as actual and expected argument. âœ… NUnit2010 Use EqualConstraint. âœ… NUnit2011 Use ContainsConstraint. âœ… NUnit2012 Use StartsWithConstraint. âœ… NUnit2013 Use EndsWithConstraint. âœ… NUnit2014 Use SomeItemsConstraint. âœ… NUnit2015 Consider using Assert.That(expr2, Is.SameAs(expr1)) instead of Assert.AreSame(expr1, expr2). âœ… NUnit2016 Consider using Assert.That(expr, Is.Null) instead of Assert.Null(expr). âœ… NUnit2017 Consider using Assert.That(expr, Is.Null) instead of Assert.IsNull(expr). âœ… NUnit2018 Consider using Assert.That(expr, Is.Not.Null) instead of Assert.NotNull(expr). âœ… NUnit2019 Consider using Assert.That(expr, Is.Not.Null) instead of Assert.IsNotNull(expr). âœ… NUnit2020 Incompatible types for SameAs constraint. âœ… NUnit2021 Incompatible types for EqualTo constraint. âœ… NUnit2022 Missing property required for constraint. âœ… NUnit2023 Invalid NullConstraint usage. âœ…"
  },
  "articles/vs-test-adapter/Adapter-Installation.html": {
    "href": "articles/vs-test-adapter/Adapter-Installation.html",
    "title": "Adapter Installation | NUnit Docs",
    "keywords": "Adapter Installation There are two ways of installing the adapter within Visual Studio. See below for info on how to choose. Use the Extension Manager Add it as a NuGet package to your solution. (Requires VS 2012 Update 1 or later) Installing With the Extension Manager To install the NUnit Test Adapter using the Extension Manager, follow these steps: From within Visual Studio, select Tools | Extension Manager. In the left panel of the Extension Manager, select Online Extensions Locate (search for) the NUnit 3.0 Test Adapter in the center panel and highlight it. Click 'Download' and follow the instructions. Use the Extension Manager to ensure that the NUnit 3.0 Test Adapter is enabled. Installing the NuGet Package To add it is a NuGet package, you must have an active solution, then follow these steps: From Tools menu, use Library Package Manager and select Manage NuGet packages for solution In the left panel, select Online Locate (search for) NUnit 3.0 Test Adapter in the center panel and highlight it Click 'Install' In the \"Select Projects\" dialog, you need to select at least one project to add the adapter to, see notes below. How to choose between Extension and NuGet package The Extension will apply to Visual Studio itself, and will work for all projects you use. All users of your solution need to install the Extension. If you use TFS Build you must also install the extension to the build system there. The NuGet Package will apply to the solution, and will work for any other user too, as it follows the solution, but requires the user to have VS 2012 Update 1 or above. It will also work for any TFS 2012 Update 1 or above server build, including TF Service and requires no further installation. If you are testing .NET Core or .NET Standard you must use the NuGet package and Visual Studio 2017 or newer. Visual Studio does not support running .NET Core tests using an extension. The extension will only work with the full .NET Framework."
  },
  "articles/vs-test-adapter/Adapter-License.html": {
    "href": "articles/vs-test-adapter/Adapter-License.html",
    "title": "License - NUnit and NUnit3 Test Adapters for Visual Studio | NUnit Docs",
    "keywords": "License - NUnit and NUnit3 Test Adapters for Visual Studio Copyright Â© 2015-2016 Charlie Poole Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE."
  },
  "articles/vs-test-adapter/Adapter-Release-Notes.html": {
    "href": "articles/vs-test-adapter/Adapter-Release-Notes.html",
    "title": "Adapter Release Notes | NUnit Docs",
    "keywords": "Adapter Release Notes NUnit3 Test Adapter for Visual Studio - Version 4.0.0-alpha.1 - July 12, 2020 This is an early pre-release version. The code has been rewritten/refactored in order to get some of the more complex issues fixed. It does pass all the automatic tests we have, but there are still more tests we would like to take it through, before we release a beta. We would really appreciate it if you give this alpha a spin. and report whatever you find back to us. The major fixes now are Explicit runs are fully back, both in Visual Studio and on command line with dotnet test and vstest.console. Further there has been a significant performance improvement for large test sets, and in particular when you run with categories or other filters. For those interested in details, some of this has been achieved by converting the VSTest type of filters to NUnit native filters (Thanks to Charlie Poole for his excellent contribution here.). 497 Dotnet test with category filter is slow with a lot of tests 545 Setting TestCaseSource to Explicit makes other tests in fixture explicit 612 It is not possible to run an explicit test from Test Explorer 658 Explicit tests are automatically run in Visual Studio 2019 767 Replace use of VSTest filters with NUnit filters NUnit3 Test Adapter for Visual Studio - Version 3.17.0 - July 11, 2020 This release has a series of enhancements and bugfixes. There have been two 3.17 beta releases (beta.1 and beta.2) published earlier on nuget.org. A major bugfix is that the console output now is properly appearing. There are also a series of fixes for corner cases. StopOnError can be very useful to reduce time of long test runs that are failing. The ability to set custom paths for the test code can be useful with data driven tests, where you want to point to the data file (and line number therein) instead of the default C# test code. See here for all details on the settings. Features and Enhancements 640 Allow use of FullName as the DisplayName for Converted Tests 675 Ability to set StopOnError via .runsettings 723 and 735 CodeFilePath like in nunit2 and TestCaseData: Missing Feature \"Jump to File\" 740 Allow Warnings to be mapped to any outcome 758 Feature Request: Adapter to support NonTestAssemblyAttribute Resolved issues/bugs 301 Issue Revisited: Console Output 343 Console.WriteLine() does not write to console when running dotnet test 697 Test adapter props files should not add assemblies to Content ItemGroup 737 An assembly specified in the application dependencies manifest was not found 745 NUnit engine IDriverFactory extensions don't load using the adapter. Thanks to aolszowka for PR 749 750 ShadowCopyFiles doesn't work on .NET Framework. Thanks to DavidSimner for PR 751 Internal development stuff 746 EditorConfig for *.props Types. Thanks to aolszowka for PR 747 753 EditorConfig for *.csproj Types. Thanks to aolszowka for PR 754 NUnit3 Test Adapter for Visual Studio - Version 3.17.0-beta.2 - June 8, 2020 This is the 2nd beta for 3.17, published on Nuget . Features and Enhancements 758 Feature Request: Adapter to support NonTestAssemblyAttribute 740 Allow Warnings to be mapped to any outcome 640 Allow use of FullName as the DisplayName for Converted Tests Resolved issues/bugs 750 ShadowCopyFiles doesn't work on .NET Framework. Thanks to DavidSimner for PR 751 745 NUnit engine IDriverFactory extensions don't load using the adapter. Thanks to aolszowka for PR 749 Internal development stuff 746 EditorConfig for *.props Types. Thanks to aolszowka for PR 747 753 EditorConfig for *.csproj Types. Thanks to aolszowka for PR 754 NUnit3 Test Adapter for Visual Studio - Version 3.17.0-beta.1 - April 19, 2020 This is the first beta release published on Nuget . It contains new features and some bugfixes. Features and Enhancements 675 Ability to set StopOnError via .runsettings 723 and 735 CodeFilePath like in nunit2 and TestCaseData: Missing Feature \"Jump to File\" Resolved issues/bugs 301 Issue Revisited: Console Output 343 Console.WriteLine() does not write to console when running dotnet test 697 Test adapter props files should not add assemblies to Content ItemGroup 737 An assembly specified in the application dependencies manifest was not found NUnit3 Test Adapter for Visual Studio - Version 3.16.1 - January 16, 2020 This release is a hotfix release intended to fix three major issues: 686 NUnit3TestAdapter3.16. dotnet filter argument is not applied 690 Can run only one test case from combinatorial test 692 NUnit Test Adaptor 3.16.0 never displays results of test under Visual Studio 2015 Together with these, the following issues are changed: 676 Test cases are skipped with TestCaseSource under Visual Studio 2019. This works under 3.16.0, but need the changes below in a runsettings file under 3.16.1 Note that this hotfix changes some of the new defaults introduced in 3.16.0. These can be set back using the two new runsettings UseParentFQNForParametrizedTests and UseNUnitIdforTestCaseId NUnit3 Test Adapter for Visual Studio - Version 3.16.0 - January 3, 2020 This release has three major changes. The support for .NET Core 1.* has been removed. This is done to open up more functionality for the later .NET Core versions. Also, since .NET Core 1.* is no longer supported by Microsoft, we decided to remove the support too. If you do have .NET Core 1.* solutions and can't upgrade, you should stay with the the adapter 3.15.1 or lower. The change also means we now support dump files in .NET Core :-). It also means the total size of the package has been reduced by around 30%. The filter syntax issues we've had with special names and characters have been mostly solved, thanks to excellent work by John M.Wright . The filter syntax is now closer to a correct FQN (Full Qualified Name), but this might cause some issues with your own filter in some rare cases. The fix done resolves a lot of issues, all of them listed below. For a detailed explanation of what has been done, see the Pull Request #668 . You can now use the NUnit filter syntax, either from command line or through settings in the runsettings file. This was due to an idea by Michael Letterle and a subsequent implementation Pull Request #669 . Michael also wrote a great blog post to explain how this works, and how he arrived at the solution. For more information see the NUnit Test Selection Language . Resolved issues All the following are solved by Pull Request #668 622 An exception occurred while invoking executor 'executor://nunit3testexecutor/': Incorrect format for TestCaseFilter Error: Missing ')' 549 Invalid characters in test name breaks test runner 607 VS Test Explorer does not show results for test cases that have custom names 613 TestCaseSource tests get wrongly displayed 672 VS Test Explorer fails to run tests with test cases mocked with NSubstitute 644 Test Explorer shows excess class name for tests with multiple TestCaseAttribute 615 Dynamic TestCaseSource from reflection are not listed as sub-tests of the test method The following are resolved (fully or partially) by Pull Request #669 655 How to run parameterized NUnit tests on .NET Core? 425 Partly resolved using NUnit Test Selection Language. Run only specific tests when using dotnet test? The following is also resolved, but can't repro the original 582 TestCase with enclosed double quotes error Other resolved issues 679 Build.cake does not work in a pure visual studio preview installation. Fixed by PR #680 by Ove Bastiansen NUnit3 Test Adapter for Visual Studio - Version 3.15.1 - August 30, 2019 This is a hotfix release due to some issues with special cases in NUnit, causing the tests to not run. The major difference is that this release makes PreFiltering which was introduced in 3.15, optional - and default off. It can be enabled by setting PreFilter to true in a runsettings file. Resolved Issues 651 Add feature flag to enable/disable pre-filtering. This one contains the links to the issues below: 648 NUnit3TestAdapter 3.15.0 fails to run test: \"NUnit failed to load\" (when using NUnit framework less than version 3.11) 649 NUnit3TestAdapter 3.15 OneTimeSetUp not working anymore (When a SetupFixture is being used) 650 NUnit3TestAdapter 3.15 not running tests with custom TestCaseSource (when using SetName instead of SetArgDisplayNames) NUnit3 Test Adapter for Visual Studio - Version 3.15 - August 23, 2019 This release is a major performance improvement release. When used from Visual Studio, and used with a selection of tests, it will significantly speed up the discovery of those. Note that discovery is also a part of the execution, so you will also see the performance improvement for execution. It will be mostly noticeable when you have a large set of tests. Features and Enhancements 529 Use framework prefilter for massive perf improvement when running fraction of tests. Thanks to MatthewBeardmore for the Pull request and patience Resolved Issues 645 NUnit3TestAdapter 3.14.0 includes NUnit3.TestAdapter.dll versioned 3.13. Version number of dll corrected to match package version 3.15 580 Fix licenseUrl in nuspec, will be deprecated NUnit3 Test Adapter for Visual Studio - Version 3.14 - August 8, 2019 Features and Enhancements 609 Request to change working directory from Windows/System32 to another directory and 303 Directory.GetCurrentDirectory is C:\\WINDOWS\\system32 for NUnit3TestAdapter. If your current directory points to either Windows directory or the Program Files folders, it will be redirected to your temp folder. 621 TestContext.Progress output. It will only go to the console, not the test output. 222 NUnit3TestAdapter errors when running xUnit tests. Thanks to nvborisenko for the Pull Request Resolved Issues 629 NUnit3TestAdapter errors when running xUnit tests 630 Assert.Multiple produces new tests in the report if inner assertions fail. Thanks again to nvborisenko for the Pull Request Comments This version also includes the latest version 3.10 of the NUnit.Engine.dll NUnit3 Test Adapter for Visual Studio - Version 3.13 - February 20, 2019 This release focuses on producing NUnit test result XML which can be useful when you need reports using tools that support the NUnit format. This can be enabled using a new setting in the runsettings file . The VSIX is also made compatible with the upcoming VS 2019. Please note support for the VSIX is being deprecated in Visual Studio, and we strongly recommend you to change your test projects to use the NuGet adapter version . The NUnit internal properties have been \"over-populating\" in the Test Explorer. These are now filtered out, although you may still see these when you have Source Based Discovery (SBD) turned on (which is the default in VS). Once you have run, they will be gone. We expect this part of the issue (SBD) to be fixed in VS. If you still want to see the properties, you can enable that again setting a runsettings property ShowInternalProperties to true. Enhancements 323 Add support for producing XML test results in NUnit format 474 Skip surfacing certain properties as UI groupings (Internal NUnit properties are no longer visible in Test Explorer) 590 Support for Visual Studio 2019 (VSIX) Resolved Issues 302 BadImageFormatException building solution with unmanaged projects) Extra fix for this, see PR 592 Issue302 native execution in execution. Thanks to Oski Kervinen for fixing this. 596 TestOutputXml should handle relative paths relative to the Workfolder 600 TestOutputXml setting ignored on netcore2.1, works on net461 Other fixes 599 Url in the repo header pointing to nunit.org changed to https, also some other similar changes other places. Thanks to Julian Verdurmen for fixing these. NUnit3 Test Adapter for Visual Studio - Version 3.12 - December 19, 2018 Enhancements 215 Generate NUnit xml file of test results, specified in .runsettings file for reporting 573 NUnit3TestDiscoverer Could not load file or assembly 'nunit.engine' NUnit3 Test Adapter for Visual Studio - Version 3.11.2 - November 22, 2018 This is a yet another hotfix release to fix the missing categories issue. Resolved Issues 568 NUnit3TestAdapter 3.11.1 TestCategory from VSTest no longer working (No tests selected) Reopened issues This issue was fixed, with a workaround, in 3.11 but had unforeseen consequences, and has been reopened as of this release 506 Test categories aren't propagated to vstest trx logs This probably need to be fixed in VSTest itself. NUnit3 Test Adapter for Visual Studio - Version 3.11.1 - November 21, 2018 This is a hotfix release to fix the duplicated traits issue. Resolved Issues 559 Duplicating tags in Test Explorer when using NUnit3TestAdapter 3.11.0 561 Test task aborted when using TestCategory filters NUnit3 Test Adapter for Visual Studio - Version 3.11 - October 28, 2018 Features PR 500 NUnit3VsAdapter to support managed sources only based on RFC (Thanks to mayankbansal018 for this PR) 543 Adapter should pass Error and Progress messages to vstest engine as well as stdOut messages (Thanks to NikolayPianikov for PR 544 ). Also fixes this TeamCity issue Mono.Cecil is now embedded with the adapter, so user dependencies are no longer overwritten. Indentation of the test log format makes it easier to see what information belongs to which assembly. Quiet mode added, if you don't want all the information, see Tips and Tricks . Resolved Issues 426 Exception thrown while loading tests if In-Proc VSTest DataCollector is used (Thanks to drognanar for PR 510 ) 490 Fix Causes Build Error (Somewhat Indirectly) by published pdb files from Issue 461 494 TestContext.AddTestAttachment does not work on Linux environment with specified dotnet logger (Thanks to Kira-Lappo for PR 527 ) 495 Category as filter not working in single agent flow in vstest task 506 Test categories aren't propagated to vstest trx logs 516 ArgumentException when whitespace sent to logger 538 NuGet Package : Add repository metadata (Thanks to MaximRouiller for PR 539 ) 540 Missing null check before runner dispose Notes 518 NUnit VSIX test adapters deprecation notice added. NUnit will still deliver a vsix for this version. NUnit3 Test Adapter for Visual Studio - Version 3.10 - March 5, 2018 Features 461 Publish symbols with the adapter for debugging into the adapter and NUnit Resolved Issues 47 Adapter runs explicit tests when TFS TestCaseFilter is used 296 Mono.Cecil causes OutOfMemoryException with new .csproj PDBs 310 Consistent Category Display in Test Explorer Window 365 An exception occurred while invoking executor: Could not load file or assembly System.Runtime.InteropServices.RuntimeInformation (Thanks to halex2005 for PR 418 ) 419 Test result is Skipped when an exception has been thrown and the only warning is in TearDown 444 Dump file is not created when the test crashes 452 Adapter does not seem to respect any TestCategory filtering 460 Failure to load dependency assembly causes hang Also see Release Readiness Review Special thanks Special thanks to : Joseph Musser for awesome work on this release, and to Loren Halvorsen for the workaround for VSTest issue 261 . NUnit3 Test Adapter for Visual Studio - Version 3.9 - October 29, 2017 Change in supported versions This version supports Visual Studio from version 2012, Update 1 and upwards, and all subsequent versions in 2013, 2015 and 2017. Visual Studio 2012 RTM is then no longer supported. Features 390 Pass DisableAppDomain and DisableParallelization settings to the Engine 392 Improve performance of discovery (Thanks to Navin (Microsoft) for PR 393 , PR 406 ) 394 The adapter tests are updated to use NUnit 3.8.1 Resolved Issues 372 netcoreapp + CultureInfo.CurrentCulture = bad time (Thanks to Aaron Housh (Dispersia) for PR 380 ) 386 DateTime.Parse issue during test discovery with certain cultures (Also fixed by PR 380 ) 302 BadImageFormatException building solution with unmanaged projects NUnit3 Test Adapter for Visual Studio - Version 3.8 - July 19, 2017 Features The adapter now support running .net core projects. See this post for details. Note: Only supported by the nuget adapter, not the vsix. The adapter now uses version 3.7 of the engine to run tests ( 360 ) Attachments can be added to tests ( 358 ) Prepared for new upcoming Test Explorer functionality, as documented in this RFC ( 351 ) Resolved Issues 298 $RANDOM_SEED$ is appearing in non-test project build output 259 An exception occurred while invoking executor 'executor://nunit3testexecutor/' 314 Any TestFixture deriving from a base-class which defines unit-tests will fail when the base-class is from another class-library 231 Improved message on failed loading. See also PR 309 338 Unhandled Exception when running through vstest.console.exe /listtests NUnit3 Test Adapter for Visual Studio - Version 3.7 - January 25, 2017 Features The adapter now uses version 3.6 of the engine to run tests Warning messages are displayed. Note that Visual Studio currently lists them as skipped. Multiple assertion failures in a Multiple Assert block are displayed. Resolved Issues 218 No tests found to run when TestFixture is a nested class 256 Rename $RANDOM_SEED$ 258 Modify adapter to display multiple assert information 268 Make the Icon Larger 272 URL for \"More information\" should point to correct landing page 273 Report Warnings in VS adapter 276 Adapter requires test project PDBs to be generated for tests to be executed 288 Test parameters containing semicolons are truncated NUnit3 Test Adapter for Visual Studio - Version 3.6.1 - December 5, 2016 Note This was a hotfix release of the vsix package only, fixing an issue that prevented it from installing under VS2012 and 2013. Resolved Issues 260 VSIX no longer visible in Visual Studio 2012 NUnit3 Test Adapter for Visual Studio - Version 3.6 - November 15, 2016 Features Adds support for Visual Studio \"15\" Resolved Issues 253 Warnings about $RANDOM_SEED$ during build 262 Support for VS 15 NUnit3 Test Adapter for Visual Studio - Version 3.5 - October 22, 2016 Features The adapter now uses version 3.5 of the NUnit engine The NuGet package is now installed as a tool and no longer creates unnecessary references in the project Resolved Issues 97 Tests with dynamic/random parameters are never run closed:done is:bug pri:normal 204 If a test writes to Console.Error, the test passes but the session fails 220 Visual Studio Test Adapter - Writing to test output throws an error 221 Change adapter package to use tools directory 236 Update adapter to use Version 3.5 of the Engine 238 Just warn upon failing to restore random seed 239 Remove Error-level log messages from adapter where we don't want run to fail 243 NuGet package and copy local NUnit3 Test Adapter for Visual Studio - Version 3.4.1 - August 5, 2016 Features We now use Cake to build and package the adapter. Resolved Issues 198 Create Cake script for build 202 NUnit3 Test Adapter not running all tests in Visual Studio 2015 205 Adapter fails to find Mono.Cecil when targeting .NET 3.5 NUnit3 Test Adapter for Visual Studio - Version 3.4 - July 2, 2016 Features The adapter now uses the NUnit 3.4.1 TestEngine. TestRunParameters may now be provided in the .runsettings file. Immediate text output from tests now displays in the Output window. This includes any output produced through Console.Error, TestContext.Error or TestContext.Progress. Resolved Issues 132 Print to console not shown with v3 of adapter 138 Cannot run navigation tests under the console runner 145 Implement TestRunParameters inside .runsettings for runtime parameters 180 Upgrade to NUnit 3.4.1 181 Can't run requiring a 32-bit process 183 Use Mono.Cecil to retrieve source code locations 190 NUnit30Settings.xml is used by other process leads to hidden tests 192 Corrupt NUnit3Settings.xml causes crash NUnit3 Test Adapter for Visual Studio - Version 3.2 - June 3, 2016 Features The adapter now uses the NUnit 3.2.1 TestEngine. Resolved Issues 131 NUnit test adapter not running all tests - only on VS2015 135 Upgrade TestEngine to 3.2.1 162 Visual Studio 15 support 163 No source location when inheriting test methods from base test fixture 174 Clarify that NUnit v2 tests are not discovered by v3 adapter 176 More Information link in vsix broken NUnit3 Test Adapter for Visual Studio - Version 3.0 - April 2, 2016 Features This is the final production release of the 3.0 adapter. It continues to use the 3.0.1 release of the NUnit TestEngine. The adapter now uses a .runsettings file for all optional settings. Registry entries used in the CTP releases are no longer used. Resolved Issues 49 Need a way to specify test settings 52 Having ApartmentAttribute on both classes and methods causes test runner to hang 85 Failure to run tests under vstest.console from VS2015 92 Provide option to run in parallel for parallelized tests 120 The ability to set the LevelOfParallelism attribute through the VS adapter 153 TFS Filter that matches no names runs all tests NUnit3 Test Adapter for Visual Studio - Version 3.0 CTP 9 - April 2, 2016 Features The adapter continues to use the 3.0.1 release of the NUnit TestEngine. Resolved Issues 2 CI Build 34 Identifying Non-Primitive Parameterized Inputs in Adapter vs Console 50 NuGet version install script doesn't work with VS 2015 66 Build the adapter in AppVeyor 84 CopyLocal=False is an issue in a specific use case 94 More Information Link in Adapter Broken 96 Working directory is set to VS TestWindow extension directory 102 Package VS2012 assemblies as a private NuGet Package 104 Can't overload async/await methods with NUnit Test Adapter 106 Explicit tests appear as warnings in NUnit 3.0 109 NUnit 2 tests are detected as errors 112 Test adapter fails to load an assembly that references a class from NUnit.Framework but contains no tests 117 Version 3.0.8.0 as NuGet package only. No tests detected in Visual Studio 2015 118 Corrupted ignore.addins file in installation NUnit3 Test Adapter for Visual Studio - Version 3.0 CTP 8 - December 2, 2015 Features The adapter now uses the 3.0.1 release of the NUnit TestEngine. Resolved Issues 81 Cannot run tests with '>' in name 86 Generic Test Fixtures are not getting triggered 88 Upgrade adapter to use NUnit 3.0.1 NUnit3 Test Adapter for Visual Studio - Version 3.0 CTP 7 - November 16, 2015 Features The adapter now uses the released NUnit 3.0 TestEngine. Resolved Issues 75 Update adapter to use final release of NUnit 3.0 NUnit3 Test Adapter for Visual Studio - Version 3.0 CTP 6 - November 10, 2015 Features This release continues to use the NUnit RC 2 Engine. Resolved Issues 14 NUnit Adapter throws System.Reflection.TargetInvocationException, even if the solution build is OK 56 Exception System.Reflection.TargetInvocationException after NUnit 3.0.0-beta-5 upgrade 68 NUnit3TestExecutor.MakeTestFilter does not create valid xml 69 NUnit 3.0.0-rc-2 : System.Reflection.TargetInvocationException 70 NUnit3TestExecutor.MakeTestFilter creates element not handled by NUnit.Framework.Internal.TestFilter NUnit3 Test Adapter for Visual Studio - Version 3.0 CTP 5 - November 9, 2015 Features This release uses the NUnit RC 2 Engine. Resolved Issues 27 Async void methods do not show up as not runnable 43 Remove Wrappers for Engine Classes 45 Remove workaround for tests not sending events 53 Replace core engine 57 Confusing message when an NUnit V2 test is detected NUnit3 Test Adapter for Visual Studio - Version 3.0 CTP 4 - July 20, 2015 Features This release continues to use the NUnit 3.0 beta-2 engine but is nevertheless able to run tests that reference NUnit 3.0 beta-3 framework. When a debugger is attached, only a single worker thread is used to run tests. The adapter now compensates for the fact that NUnit does not send results for tests that were skipped due to an attribute on the fixture by generating those results itself. Resolved Issues 16 Adapter does not detect C++/CLI assemblies 26 Ignored test case does not show up as ignored 33 Inconsistent display behavior in Test Explorer 36 Option to set number of worker threads NUnit3 Test Adapter for Visual Studio - Version 3.0 CTP 3 - May 22, 2015 Features This release was issued to correct a problem with locking of assemblies in ctp-2. Resolved Issues 29 Latest test adapter locking dlls NUnit3 Test Adapter for Visual Studio - Version 3.0 CTP 2 - May 16, 2015 Features The adapter now uses the new nunit.core.engine to load and run tests, eliminating ad-hoc code that worked directly with the framework. This will allow us to much greater flexibility in the future. The adapter has been upgraded to use the beta-2 release of the NUnit core engine. Because the API has changed from beta-1, the adapter can only run tests built against the beta-2 release of NUnit. Resolved Issues 13 Adapter will not load as a NuGet package 17 Can't read app.config settings within test methods 18 Separate NUnit3TestDemo from NUnitTestAdapter solution 19 Use core engine 20 Upgrade NUnit to beta-2 NUnit3 Test Adapter for Visual Studio - Version 3.0 CTP 1 - April 6, 2015 Features Initial release of the test adapter using NUnit 3.0. Note that the adapter may not be used to run tests written against earlier versions of NUnit. The original adapter is still available for that purpose and both adapters may be installed if necessary. NUnit Test Adapter for Visual Studio - Version 2.0 - April 1, 2015 Features Tested for up to VS2015 Pre-release CTP 6 Updated to use NUnit 2.6.4 Adapter does not try to discover tests if the nunit.framework version is 3.0 or greater Bug Fixes #61 Confusing NUnit version message made clearer #62 Adapter uses shadowcopy setting in discoverer but not in the executor NUnit Test Adapter for Visual Studio (RTM) - Version 1.2 - September 17, 2014 Features Tested for up to VS2013 Update 3 Bugs 39 and 40 was inability to run under VS2012. This is now fixed. Bug Fixes #24 Long-running tests ignored #34 Adapter causes ArgumentException to be thrown by Microsoft logger proxy's SendMessage method #37 TestExecution throws Exception System.InvalidOperationException in TFS Build #38 NUnit only accepts absolute paths to test assembly #39 VSTest unable to find NUnit tests since 1.1.0.0 #40 NUnit version 1.1.0.0 is broken with test class which ran under 1.0.0.0 NUnit Test Adapter for Visual Studio (RTM) - Version 1.1 - April 26, 2014 Features Support for NUnit 2.6.3 Tested for up to VS2013 Update 2 RC Shadow copy now disabled by default, see issue #7 Unable to disable shadow copy. Registry settings added for some customization options, see Tips and Tricks All code moved to github Bug Fixes #13 Category attribute not working with TFS test case filter #21 Xamarin.iOS NUnit project causes adapter to throw NUnit Test Adapter for Visual Studio (RTM) - Version 1.0 - September 12, 2013 Features This is the release version 1.0 of the test adapter. Bug Fixes #1208148 The test result output node is not shown for debug/trace statements NUnit Test Adapter for Visual Studio (RC) - Version 0.97 - September 12, 2013 Features This is the release candidate for version 1.0 of the test adapter. Bug Fixes #1208161 NUnit Test Adapter runs [Explicit] unit tests in TFS Build #1210536 No Source Available for Async Tests #1165188 Clicking \"Run Selected Tests\" doesn't show Trace.WriteLine() output NUnit Test Adapter for Visual Studio (Beta 6) - Version 0.96 - June 28, 2013 Features Support for Visual Studio 2013 Preview Bug Fixes #1189268 Profile a test will crash with exception NUnit Test Adapter for Visual Studio (Beta 5) - Version 0.95.2 - June 7, 2013 Bug Fixes #1188000, adapter don't work with solutions with only .net 2.0/3.5 project NUnit Test Adapter for Visual Studio (Beta 5) - Version 0.95.1 Hotfix- May 28, 2013 Bug Fixes Hotfix for debug issue NUnit Test Adapter for Visual Studio (Beta 5) - Version 0.95 - May 10, 2013 Features #1174925 Add support for installing the adapter from NuGet Bug Fixes #1155617 Grouping by class name in VS 2012 doesn't work #1165359 Exception after building Coded UI test #1116747 vstest.executionengine.x86.exe does not terminate #1093178 Eliminate unnecessary files from VSIX NUnit Test Adapter for Visual Studio (Beta 4) - Version 0.94 - December 22, 2012 Features Works with Visual Studio 2012 Update 1 as well as the RTM. Supports filtering and sorting tests by Traits under Update 1. Supports use of standard filter expressions when running under TFS Update 1. NUnit Categories specified on the fixture class are now recognized and honored. Bug Fixes 1074891 Can't test multiple assemblies referencing different NUnit versions 1075893 Test execution fails if solution contains native C++ project 1076012 No source information found for async test methods 1087629 TestFixture Category not being recognized as traits in VS2012 update 1 1091020 Adapter doesn't support TFS Build traits/test case filtering NUnit Test Adapter for Visual Studio (Beta 3-2) - Version 0.93.2 - November 2, 2012 Bug Fixes 1074544 Failures in Test Discovery not reporting sufficient information NUnit Test Adapter for Visual Studio (Beta 3-1) - Version 0.93.1 - October 26, 2012 Bug Fixes 1072150 NUnit adapter 0.93 won't run selected tests NUnit Test Adapter for Visual Studio (Beta 3) - Version 0.93 - October 24, 2012 Features Works with Visual Studio 2012 RTM. Some features require the November CTP update. The adapter now uses NUnit 2.6.2. Among other things, this allows us to support async test methods. See the NUnit Release Notes for more info. Source file and line number can now be found for test cases that have an alternate name set. Console output from tests is now displayed in the Visual Studio Output window. TestFixtureSetUp and TestFixtureTearDown errors are now displayed in the Output window. The caret line (------^) is no longer displayed in the IDE since it depends on use of a fixed font. Tests may now be grouped and filtered by Category (only under the November CTP update for VS2012). Bug Fixes 1021144 Text output from tests not displayed in Visual Studio IDE 1033623 Not possible to include or exclude tests based on [Category] attribute Released 1040779 Null reference exception on generic test fixtures 1064620 Support async test methods 1065209 Should call both RecordEnd and RecordResult at end of a test 1065212 Upgrade NUnit to 2.6.2 1065223 Error messages assume a fixed font, but don't get one 1065225 No display for TestFixtureSetUp/TearDown or SetUpFixture errors 1065254 Cannot open test from Test Explorer for tests in a Parameterized Test Fixture 1065306 Generic Fixtures aren't discovered. 1066393 Unable to display source for test cases with an alternate name set 1066518 Executed fast test appears in Not Run category in Test Explorer NUnit Test Adapter for Visual Studio (Beta 2) - Version 0.92 - May 3, 2012 Features Works with Visual Studio 2012 Release Candidate Uses NUnit 2.6 Bug Fixes 992837 Unable to Debug using VS Test Adapter 994146 Can't run tests under .NET 2.0/3.5 NUnit Test Adapter for Visual Studio (Beta 1) - Version 0.91 - February 29, 2012 Features Built against Visual Studio 11 Beta 1 Uses NUnit 2.6 NUnit Test Adapter for Visual Studio (Alpha) - Version 0.90 - February 21, 2012 Features First release of the test adapter. Compatible with the Visual Studio 11 Developer Preview. Uses NUnit 2.6."
  },
  "articles/vs-test-adapter/Adapter-Source-Stepping.html": {
    "href": "articles/vs-test-adapter/Adapter-Source-Stepping.html",
    "title": "Adapter Source Stepping | NUnit Docs",
    "keywords": "Adapter Source Stepping As of version 3.10, the NUnit3TestAdapter NuGet package and VSIX contain source-indexed PDBs for the adapter. Debuggers can step into the source code, set breakpoints, watch variables, etc. Itâ€™s easy to drop into NUnit adapter code any time you want to understand whatâ€™s going on. If youâ€™re getting ready to report a bug in the adapter, figuring out how to create a minimal repro is much easier since you arenâ€™t dealing with a black box! How to step into adapter source in the Visual Studio debugger The NUnit adapter PDBs are source-linked and work with Visual Studio 2017 or later. Turn off Debug > Options > â€˜Enable Just My Code.â€™ Note This is something youâ€™ll want to leave on and only turn off when you want to step into source that isnâ€™t contained in your solution. (Next time you can make this faster by installing the excellent extension Just My Code Toggle . This allows you to set a keyboard shortcut along with adding a toolbar button and call stack context menu item.) If needed, turn on Debug > Options > â€˜Enable Source Link support.â€™ This can usually be left on. Congratulations! You can now use the debugger to step into method calls to the NUnit adapter and to set breakpoints and watch variables in the source! Keep in mind that itâ€™s still a release build of the adapter, so variables and sequence points may not be available depending on runtime optimizations."
  },
  "articles/vs-test-adapter/AdapterV2-Release-Notes.html": {
    "href": "articles/vs-test-adapter/AdapterV2-Release-Notes.html",
    "title": "Adapter V2 Release Notes | NUnit Docs",
    "keywords": "Adapter V2 Release Notes NUnit Test Adapter for Visual Studio - Version 2.3.0 - June 8, 2020 NUnit Test Adapter for Visual Studio - Version 2.3.0-beta01 - May 7, 2020 Updates the NUnit framework to 2.7.1 #186 How to change used NUnit 2 version of test adapter to e.g. v2.7.1 ? #184 Update NUnit library to 2.7.1 Thanks to BobSilent for #188 solving #184 and #186 . Bugs 189 NUnit adapter is failing when PropertyAttribute is used with NULL value NUnit Test Adapter for Visual Studio - Version 2.2.0 - June 5, 2019 Features #180 NUnit 2 test adapter does not support Visual Studio 2019 #175 NuGet Package : Add repository metadata. Thanks to MaximRouiller for the PR #174 NUnitTestAdapter 2.1.1 not working with Visual Studio 2017 15.8.0 Bugfixes #147 Fails to resolve assembly for base type of TestFixture if placed in a different dll #178 Test Explorer Picks up Zero Tests in VS 2017 for NUnit 2 NUnit Test Adapter for Visual Studio - Version 2.1.1 - March 19, 2017 Hotfix release Bug Fixes #142 NUnit Test Adapter 2.1 doesn't work with projects that target .NET Framework 3.5 / CLR 2.0 #144 Adapter requires test project PDBs to be generated for tests to be executed NUnit Test Adapter for Visual Studio - Version 2.1 - March 4, 2017 Features #135 Support for VS 2017 #127 Change adapter package to use tools directory #116 Use Mono.Cecil to retrieve source code locations Bug Fixes #84 NUnit load failure #87 Can't overload async/await methods Notes The NUnit V2 adapter does not support the Live Unit Testing feature in VS 2017. That support is only included with the NUnit V3 adapter. The package including both the adapter and the framework are discontinued. Please install the separate packages instead when upgrading. NUnit Test Adapter for Visual Studio - Version 2.0 - April 1, 2015 Features Tested for up to VS2015 Pre-release CTP 6 Updated to use NUnit 2.6.4 Adapter does not try to discover tests if the nunit.framework version is 3.0 or greater Bug Fixes #61 Confusing NUnit version message made clearer #62 Adapter uses shadowcopy setting in discoverer but not in the executor NUnit Test Adapter for Visual Studio (RTM) - Version 1.2 - September 17, 2014 Features Tested for up to VS2013 Update 3 Bugs 39 and 40 was inability to run under VS2012. This is now fixed. Bug Fixes #24 Long-running tests ignored #34 Adapter causes ArgumentException to be thrown by Microsoft logger proxy's SendMessage method #37 TestExecution throws Exception System.InvalidOperationException in TFS Build #38 NUnit only accepts absolute paths to test assembly #39 VSTest unable to find NUnit tests since 1.1.0.0 #40 NUnit version 1.1.0.0 is broken with test class which ran under 1.0.0.0 NUnit Test Adapter for Visual Studio (RTM) - Version 1.1 - April 26, 2014 Features Support for NUnit 2.6.3 Tested for up to VS2013 Update 2 RC Shadow copy now disabled by default, see issue #7 Unable to disable shadow copy. Registry settings added for some customization options, see Tips and Tricks All code moved to github Bug Fixes #13 Category attribute not working with TFS test case filter #21 Xamarin.iOS NUnit project causes adapter to throw NUnit Test Adapter for Visual Studio (RTM) - Version 1.0 - September 12, 2013 Features This is the release version 1.0 of the test adapter. Bug Fixes #1208148 The test result output node is not shown for debug/trace statements NUnit Test Adapter for Visual Studio (RC) - Version 0.97 - September 12, 2013 Features This is the release candidate for version 1.0 of the test adapter. Bug Fixes #1208161 NUnit Test Adapter runs [Explicit] unit tests in TFS Build #1210536 No Source Available for Async Tests #1165188 Clicking \"Run Selected Tests\" doesn't show Trace.WriteLine() output NUnit Test Adapter for Visual Studio (Beta 6) - Version 0.96 - June 28, 2013 Features Support for Visual Studio 2013 Preview Bug Fixes #1189268 Profile a test will crash with exception NUnit Test Adapter for Visual Studio (Beta 5) - Version 0.95.2 - June 7, 2013 Bug Fixes #1188000, adapter don't work with solutions with only .net 2.0/3.5 project NUnit Test Adapter for Visual Studio (Beta 5) - Version 0.95.1 Hotfix- May 28, 2013 Bug Fixes Hotfix for debug issue NUnit Test Adapter for Visual Studio (Beta 5) - Version 0.95 - May 10, 2013 Features #1174925 Add support for installing the adapter from NuGet Bug Fixes #1155617 Grouping by class name in VS 2012 doesn't work #1165359 Exception after building Coded UI test #1116747 vstest.executionengine.x86.exe does not terminate #1093178 Eliminate unnecessary files from VSIX NUnit Test Adapter for Visual Studio (Beta 4) - Version 0.94 - December 22, 2012 Features Works with Visual Studio 2012 Update 1 as well as the RTM. Supports filtering and sorting tests by Traits under Update 1. Supports use of standard filter expressions when running under TFS Update 1. NUnit Categories specified on the fixture class are now recognized and honored. Bug Fixes 1074891 Can't test multiple assemblies referencing different NUnit versions 1075893 Test execution fails if solution contains native C++ project 1076012 No source information found for async test methods 1087629 TestFixture Category not being recognized as traits in VS2012 update 1 1091020 Adapter doesn't support TFS Build traits/test case filtering NUnit Test Adapter for Visual Studio (Beta 3-2) - Version 0.93.2 - November 2, 2012 Bug Fixes 1074544 Failures in Test Discovery not reporting sufficient information NUnit Test Adapter for Visual Studio (Beta 3-1) - Version 0.93.1 - October 26, 2012 Bug Fixes 1072150 NUnit adapter 0.93 won't run selected tests NUnit Test Adapter for Visual Studio (Beta 3) - Version 0.93 - October 24, 2012 Features Works with Visual Studio 2012 RTM. Some features require the November CTP update. The adapter now uses NUnit 2.6.2. Among other things, this allows us to support async test methods. See the NUnit Release Notes for more info. Source file and line number can now be found for test cases that have an alternate name set. Console output from tests is now displayed in the Visual Studio Output window. TestFixtureSetUp and TestFixtureTearDown errors are now displayed in the Output window. The caret line (------^) is no longer displayed in the IDE since it depends on use of a fixed font. Tests may now be grouped and filtered by Category (only under the November CTP update for VS2012). Bug Fixes 1021144 Text output from tests not displayed in Visual Studio IDE 1033623 Not possible to include or exclude tests based on [Category] attribute Released 1040779 Null reference exception on generic test fixtures 1064620 Support async test methods 1065209 Should call both RecordEnd and RecordResult at end of a test 1065212 Upgrade NUnit to 2.6.2 1065223 Error messages assume a fixed font, but don't get one 1065225 No display for TestFixtureSetUp/TearDown or SetUpFixture errors 1065254 Cannot open test from Test Explorer for tests in a Parameterized Test Fixture 1065306 Generic Fixtures aren't discovered. 1066393 Unable to display source for test cases with an alternate name set 1066518 Executed fast test appears in Not Run category in Test Explorer NUnit Test Adapter for Visual Studio (Beta 2) - Version 0.92 - May 3, 2012 Features Works with Visual Studio 2012 Release Candidate Uses NUnit 2.6 Bug Fixes 992837 Unable to Debug using VS Test Adapter 994146 Can't run tests under .NET 2.0/3.5 NUnit Test Adapter for Visual Studio (Beta 1) - Version 0.91 - February 29, 2012 Features Built against Visual Studio 11 Beta 1 Uses NUnit 2.6 NUnit Test Adapter for Visual Studio (Alpha) - Version 0.90 - February 21, 2012 Features First release of the test adapter. Compatible with the Visual Studio 11 Developer Preview. Uses NUnit 2.6."
  },
  "articles/vs-test-adapter/Debugging.html": {
    "href": "articles/vs-test-adapter/Debugging.html",
    "title": "Debugging the NUnit3TestAdapter | NUnit Docs",
    "keywords": "Debugging the NUnit3TestAdapter Debugging the adapter is done by creating a debug version of the adapter and enabling the LAUNCHDEBUGGER symbols where appropriate in the code base. A detailed explanation of the process can be found in this blog post ."
  },
  "articles/vs-test-adapter/Index.html": {
    "href": "articles/vs-test-adapter/Index.html",
    "title": "Visual Studio Test Adapter | NUnit Docs",
    "keywords": "Visual Studio Test Adapter The NUnit 3 Test Adapter allows you to run NUnit 3 tests inside Visual Studio. This is a new adapter, based partly on the code of the original NUnit Test Adapter, but modified to work with NUnit 3. It is not possible to run NUnit 2.x tests using this adapter. Use the original adapter for that purpose. If you need to work with projects using NUnit 2.x and other projects using NUnit 3, you may install both versions of the adapter. The current release is designed to work with Visual Studio 2012, 2013, 2015, 2017 and 2019. Some features are not available under VS2012 RTM. It also works om command line using either vstest.console or dotnet test, and is also used by JetBrains ReSharper for Visual Studio and Rider IDE, and their corresponding command line tool. The current release works with .net framework 3.5 and higher, and with .net core 2.* and 3.* . Releases of Visual Studio prior to VS 2012 did not have the ability to directly run tests built with Open Source testing frameworks like NUnit. Download Released versions Download Pre-release versions The adapter is delivered as a nuget package, to be installed into all test projects. Note There is also a VSIX extension version, which was used earlier for Visual Studio. The support for this has been deprecated, although it still works. The recommendation is to avoid this and use the nuget version."
  },
  "articles/vs-test-adapter/Known-Problems.html": {
    "href": "articles/vs-test-adapter/Known-Problems.html",
    "title": "Known Problems | NUnit Docs",
    "keywords": "Known Problems Using both the VSIX adapter and nuget adapters at the same time can lead to discovery issues; see nunit3-vs-adapter/issues #769 . The resolution is to uninstall the VSIX adapter, and only use the nuget adapters. The VSIX adapters are being deprecated in later VS versions. Support for Explicit keyword 1 Adapter versions in the 3.XX series: From version 16.2 (Visual Studio 2019) the Explicit keyword is no longer explicitly supported by Visual Studio. If you want to use it, it does exist as a Category also, so you can use it as a category filter. 2 Adapter versions in the 4.XX series support the explicit keyword. There is no test status in Visual Studio corresponding to NUnit's Inconclusive result, so tests with this result are reported as Not Run. Click on the individual test to see the result. Theories are reported as individual cases, rather as a single unit. In NUnit, tests have names, which are not necessarily unique. Visual Studio wants the names to be unique. So if two tests have the same name, VS displays a warning message in the output window. The message may be ignored. Two separate results will be shown under the single test in the explorer pane. Startup performance is substantially improved but is still slower than using NUnit directly. Applies to pre-VS2017: When using a VSIX adapter and the NuGet adapter, the VSIX adapter will be used regardless of the NuGet adapter version. Workaround: Make sure you have upgraded VSIX adapter to latest version, or uninstalled it if you have the NuGet adapter in a solution. The adapter will display its version number in the Output window under Tests. Avoid using the VSIX adapter for VS2017 and upwards. It is being deprecated, but is still supported optionally in VS2019. Visual Studio 2017 Live Unit Testing require NUnit3. The NUnit2 adapter doesn't support Live Unit Testing. Exception: Could not load file or assembly 'nunit.engine' - Is caused by an incomplete copy of the adapter in the Visual Studio cache. Close Visual Studio and delete C:\\Users\\username\\AppData\\Local\\Temp\\VisualStudioTestExplorerExtensions\\NUnit3TestAdapter.{{version}} Issues with other tools Versions of ReSharper earlier than the 8.2 version has an issue with the NuGet adapter, which will prevent NUnit tests from running. Make sure you have updated Reshaper to at least version 8.2. ReSharper version 2018.1 are not able to work with adapter versions >= 3.12. This is fixed in 2018.3. See Issue638 for details."
  },
  "articles/vs-test-adapter/Resources.html": {
    "href": "articles/vs-test-adapter/Resources.html",
    "title": "Resources | NUnit Docs",
    "keywords": "Resources Further information For more information see the blogs by Charlie Poole , Rob Prouse and Terje Sandstrom The MSDN ALM blog post series on How to Manage Unit Tests in Visual Studio 2012 Update 1 is useful for later versions as well: Part 1â€“Using Traits in the Unit Test Explorer Part 2â€“Using Traits with different test frameworks in the Unit Test Explorer Part 3: Unit testing with Traits and code coverage in Visual Studio 2012 using the TFS Build For Information on testing .Net core see Testing .NET Core with NUnit in Visual Studio 2017 Reporting Problems Bugs should be reported using the issue tracker on Github."
  },
  "articles/vs-test-adapter/Supported-Frameworks.html": {
    "href": "articles/vs-test-adapter/Supported-Frameworks.html",
    "title": "Supported Frameworks | NUnit Docs",
    "keywords": "Supported Frameworks The table below show which versions of frameworks are supported for the different versions of the adapter Framework version Supported by Adapter versions Comment Net Core 1.0 3.8 - 3.15.1 Net Core 2.0 3.8 - 3.15.1 Net Core 2.1 3.8 - up to latest Net Core 3.0 3.8 - up to latest Net Core 3.1 3.8 - up to latest Net Framework 3.5 All up to latest Net Framework 4.X All up to latest Net 5 preview Works with 3.15.1 and upwards May also work with earlier versions, but not tested"
  },
  "articles/vs-test-adapter/Tips-And-Tricks.html": {
    "href": "articles/vs-test-adapter/Tips-And-Tricks.html",
    "title": "Tips and Tricks | NUnit Docs",
    "keywords": "Tips and Tricks NUnit 3.x VS Test .Runsettings configuration Certain NUnit Test Adapter settings are configurable using a .runsettings file. The following options are available: Key Type Options Default InternalTraceLevel enum Off, Error, Warning, Info, Verbose, Debug Nothing => Off NumberOfTestWorkers int nr of workers -1 ShadowCopyFiles bool True, False False Verbosity int -1, 0-5 . -1 means quiet mode 0 UseVsKeepEngineRunning bool True, False False BasePath string path ? PrivateBinPath string directory1;directory2;etc ? RandomSeed int seed integer random DefaultTimeout int timeout in mS, 0 means infinite 0 DefaultTestNamePattern string Pattern for display name {m}{a} WorkDirectory string specify directory Test assembly location TestOutputXml string specify directory Test Result Xml output folder DumpXmlTestDiscovery bool Enable dumping of NUnit discovery response xml false DumpXmlTestResults bool Enable dumping of NUnit execution response xml false PreFilter bool Enable pre-filtering to increase performance for Visual Studio testing false ShowInternalProperties bool Turn on showing internal NUnit properties in Test Explorer false Where string NUnit Filter expression UseParentFQNForParametrizedTests bool Enable parent as FQN for parametrized tests false UseNUnitIdforTestCaseId bool Uses NUnit test id as VSTest Testcase Id, instead of FullyQualifiedName false ConsoleOut int Sends standard console output to the output window 1 StopOnError bool Stops on first error false SkipNonTestAssemblies bool Adapter supports NonTestAssemblyAttribute false MapWarningTo enum Map Assert.Warn to either Passed, Failed or Skipped Skipped DisplayName enum Set what a DisplayName is, options: Name, FullName or FullNameSep Name FullnameSeparator string FullNameSep separator ':' DiscoveryMethod enum How execution discovery is done, options are Legacy or Current Current AssemblySelectLimit int Number of tests accepted before filters are turned off 2000 Visual Studio templates for runsettings You can install item templates for runsettings in Visual Studio (applies to version 2017, 2019 and upwards) which includes the NUnit settings mentioned here. Note that there are available separate installs for earlier Visual Studio versions, links to these can be found in the above. Example implementation See https://github.com/nunit/nunit3-vs-adapter/blob/8a9b8a38b7f808a4a78598542ddaf557950c6790/demo/demo.runsettings NUnit .runsettings implementation https://github.com/nunit/nunit3-vs-adapter/blob/master/src/NUnitTestAdapter/AdapterSettings.cs#L143 Details WorkDirectory Our WorkDirectory is the place where output files are intended to be saved for the run, whether created by NUnit or by the user, who can access the work directory using TestContext. It's different from TestDirectory, which is the directory containing the test assembly. For a run with multiple assemblies, there could be multiple TestDirectories, but only one WorkDirectory. User sets work directory to tell NUnit where to put stuff like the XML or any text output. User may also access it in the code and save other things there. Think of it as the directory for saving stuff. TestOutputXml If this is specified, the adapter will generate NUnit Test Result Xml data in the folder specified here. If not specified, no such output will be generated. The folder can be An absolute path A relative path, which is then relative to either WorkDirectory, or if this is not specified, relative to the current directory, as defined by .net runtime. (From version 3.12) InternalTraceLevel This setting is a diagnostic setting forwarded to NUnit, and not used by the adapter itself. For further information see the NUnit Tracelevel documentation NumberOfTestWorkers This setting is sent to NUnit to determine how parallelization should be performed. Note in particular that NUnit can either run directly or for parallel runs use queue of threads. Set to 0, it will run directly, set to 1 it will use a queue with a single thread. ShadowCopyFiles This setting is sent to NUnit to enable/disable shadow-copying. Verbosity This controls the outputs from the adapter to the Visual Studio Output/Tests window. A higher number includes the information from the lower numbers. It has the following actual levels: -1 : Quiet mode. Only shows errors and warnings. 0 : Default, normal information verbosity 1-3: Some more information from setting are output (in particular regarding parallelization) 4: Outputs the values from the runsettings it has discovered. 5: Outputs all debug statements in the adapter UseVsKeepEngineRunning This setting is used by the adapter to signal to the VSTest.Execution engine to keep running after the tests have finished running. This can speed up execution of subsequent test runs, as the execution engine already is loaded, but running the risks of either holding onto test assemblies and having some tests not properly cleaned out. The settings is the same as using the Visual Studio Test/Test Settings/Keep Test Execution Engine running. DumpXmlTestDiscovery and DumpXmlTestResults These settings are used to dump the output from NUnit, as it is received by the adapter, before any processing in the adapter is done, to disk. It is part of the diagnostics tools for the adapter. You can find the files under your current output folder, in a sub-folder named Dump. (Note: This is not the same as the TestResults folder, this data is not testresults, but diagnostics dumps) PreFilter A prefilter will improve performance when testing a selection of tests from the Test Explorer. It is default off, because there are issues in certain cases, see below. If you don't have any of the cases below, you can turn PreFilter on. Your code contains a SetupFixture #649 Your code uses a TestCaseSource and uses SetName to set the display name instead of SetArgDisplayNames #650 You are using a version of NUnit lower than 3.11 #648 If you just need to add this, you can add a runsettings file (any filename, extension .runsettings) containing: <RunSettings> <NUnit> <PreFilter>true</PreFilter> </NUnit> </RunSettings> (From version 3.15.1) ShowInternalProperties The NUnit internal properties have been \"over-populating\" in the Test Explorer. These are default filtered out, although you may still see these when you have Source Based Discovery (SBD) turned on (which is the default in VS). Once you have run test execution, they will be gone. We expect this part of the issue (SBD) to be fixed in VS. If you still want to see them, set this property to true. Where A NUnit Test Selection Language filter can be added to the runsettings file. The details are described in this blog post Using the runsettings should be like: <RunSettings> <NUnit> <Where>cat == SomeCategory or method == SomeMethodName or namespace == My.Name.Space or name == 'TestMethod(5)'</Where> </NUnit> </RunSettings> (From version 3.16.0) UseParentFQNForParametrizedTests Setting this may give more stable results when you have complex data driven/parametrized tests. However, when this is set selecting a single test within such a group, means that all tests in that group is executed. Note that this often has to be set together with UseNUnitIdforTestCaseId (From version 3.16.1) UseNUnitIdforTestCaseId The default setting is false, causes the VSTest Testcase ID to be based on the NUnit fullname property, which is nearly equal to a FullyQualifiedName. The fullname is also set into the Testcase FullyQualifiedName property. By setting this property true, it shifts to using the NUnit id as the basis for the testcase id. This may in certain cases give more stable results, and are more correct. However, it has been seen to also have adverse effects, so use with caution. (From version 3.16.1) ConsoleOut When set to 1, default, will send Console standard output to the Visual Studio Output/Test window, and also with dotnet test, it will appear here. (Note: You have to use the '-v n' option) Disable this by setting it to 0, which is also the default for version earlier than 3.17.0. See Issue 343 for more information and discussion (From version 3.17.0) StopOnError When enabled (set to true), the tests will stop after the first test failed. Useful when working with a system with many tests running for a long time, where a few fails. It can then speed up by stopping at the first one. See Issue 675 for more information and discussion (From version 3.17.0) MapWarningTo Assert Warnings will default map to Skipped , but you can set this to any other state, using MapWarningTo. The options are: Passed , Failed or Skipped . (From version 3.17.0) SkipNonTestAssemblies If the attribute NonTestAssembly is added in an assembly, it will be skipped from further testing. If RTD is enabled in Visual Studio, the tests will be displayed, but running will skip them. See explanation for the NonTestAssembly Attribute , and Issue explanation here . (From version 3.17.0) DisplayName The default for Test Explorer DisplayName is to use the Name of the test, which normally is the method name. Using DisplayName you can change between Name , FullName or FullNameSep . The last one will then use the FullNameSeparator,which defaults to ' : '. See Issue 640 for explanations of use and sample code here. (From version 3.17.0) FullNameSeparator The separator character used when DisplayName is FullNameSep. It is default ' : ', but can be changed to anything. (From version 3.17.0) DiscoveryMethod The 4.0 version of the NUnit3TestAdapter has a rewritten discovery mechanism and also other redesigns/refactoring done. This setting let you switch back to the old form of discovery, using the setting Legacy . The default value is Current . The Current setting enables the Explicit feature back. It also performs better (approx 30% faster for large test sets). It might affect certain special cases, so therefore you can switch back. (From version 4.0.0) AssemblySelectLimit If you run from the IDE (Visual Studio) the adapter will receive a list of tests to process. This is heavy when the number of tests are large. If the number of tests exceeds this limit, the list will be skipped and all tests in the assembly will be run (except those tests that are Explicit or Ignored). This might have an adverse effect if you select a category and you have more than 2000 tests, the category setting will be ignored. In that case, just increase this limit to higher than your number of tests. You might also receive a list from the command line, and in that case it will also be skipped the same way. Here the category will be honoured since the category filter will be converted to a NUnit filter. (From version 4.0.0) Some further information on directories (From comment on issue 575 by Charlie ) NUnit also supports TestContext.TestDirectory, which is the directory where the current test assembly is located. Note that if you have several test assemblies in different directories, the value will be different when each one of them accesses it. Note also that there is no way you can set the TestDirectory because it's always where the assembly is located. The BasePath is a .NET thing. It's the base directory where assemblies are searched for. You can also have subdirectories listed in the PrivateBinPath. NUnit take scare of all this automatically now, so the old console options are no longer supported. For finding things you want to read at runtime, the TestDirectory and the BasePath will usually be the same thing. Registry Settings Note As of the 3.0 final release, the registry settings are no longer recognized. Instead, use settings in the .runsettings file. NUnit 2.x NUnit 2.X does not support runsettings. Registry Settings Certain settings in the registry affect how the adapter runs. All these settings are added by using RegEdit under the key HKCU\\Software\\nunit.org\\VSAdapter . ShadowCopy By default NUnit no longer uses shadowcopy. If this causes an issue for you shadowcopy can be enabled by setting the DWORD value UseShadowCopy to 1. KeepEngineRunning By default the NUnit adapter will \"Kill\" the Visual Studio Test Execution engine after each run. Visual Studio 2013 and later has a new setting under its top menu, Test | Test Settings | Keep Test Execution Engine Running . The adapter normally ignores this setting. In some cases it can be useful to have the engine running, e.g. during debugging of the adapter itself. You can then set the adapter to follow the VS setting by setting the DWORD value UseVsKeepEngineRunning to 1. Verbosity Normally the adapter reports exceptions using a short format, consisting of the message only. You can change it to report a verbose format that includes the stack trace, by setting a the DWORD value Verbosity to 1."
  },
  "articles/vs-test-adapter/Usage.html": {
    "href": "articles/vs-test-adapter/Usage.html",
    "title": "Usage | NUnit Docs",
    "keywords": "Usage In preparation for using the test adapter, make sure that the Unit Test Explorer is shown in your window. If you don't see it, use the menu ( Test | Windows | Test Explorer ) to show it and position the window where you would like it within Visual Studio. When you initially open a solution, no tests will be displayed. After compiling the assemblies in the solution, Visual Studio will interact with the NUnit Test Adapter to discover tests and a list of them will be shown in the Test Explorer. Click on Run All in the Test Explorer to run all the tests. You may also select one or more tests in the list and run them by right-clicking and using the context menu. The context menu also contains entries for debugging tests and for navigating to the source code of a test. Tests may be grouped by Duration and Outcome under VS2012 RTM and also by Traits and Project using Update 1 or later, and Class using Update 2 or later. NUnit translates any Categories and Properties used on your tests to Visual Studio as Traits. Tests may be filtered in Visual Studio under Update 1 or later by Trait, Project, Error Message, File Path, Fully Qualified Name, Output and Outcome. Use the search edit box at the top of the list of tests to specify a filter. Tests may be organized by play lists in Visual Studio under Update 2 or later. Playlists are more or less equal to the old test lists from VS 2010. Parameterized tests will show up as separate test cases for each set of parameters. For settings options, see the Tips and Tricks"
  },
  "articles/vs-test-generator/TestGenerator-Installation.html": {
    "href": "articles/vs-test-generator/TestGenerator-Installation.html",
    "title": "TestGenerator Extension for NUnit in Visual Studio Installation | NUnit Docs",
    "keywords": "TestGenerator Extension for NUnit in Visual Studio Installation You can download this extension from inside Visual Studio, choosing Tools/Extensions and Updates and search for Test Generator. You will then find the appropriate extension for VS 2015 or VS 2017/2019. For Visual Studio 2015 You can download from the marketplace Visual Studio Gallery or from the GitHub Release page For Visual Studio 2017/2019 You can download from the marketplace Visual Studio Gallery or from the GitHub Release page"
  },
  "articles/vs-test-generator/TestGenerator-Release-Notes.html": {
    "href": "articles/vs-test-generator/TestGenerator-Release-Notes.html",
    "title": "TestGenerator Release Notes - VS 2017 and 2019 | NUnit Docs",
    "keywords": "TestGenerator Release Notes - VS 2017 and 2019 TestGenerator Extension for NUnit in Visual Studio 2017 and 2019 - Version 2.3 - September 20, 2019 Features PR 33 [Create Unit Test] Fixing package versions. This is needed in order to work for .net core projects. With Visual Studio 2019, Update 3, it is possible to use this extension to create tests. TestGenerator Extension for NUnit in Visual Studio 2017/2019 - Version 2.1 - November 22, 2018 Visual Studio 2017 15.9 and forward should have the adapter added to each test project. This release ensures that by fixing #25. Features 25 Add the test adapter as part of the package. Thanks to yowko for the PR TestGenerator Extension for NUnit in Visual Studio 2017/2019 - Version 2 - March 5, 2017 Features #8 Support for VS 2017/2019 Bugs and minor fixes #6 NUnit3 tests using removed ExpectedException attribute #10 Specify NUnit versions as v2 and v3 #11 Update more information link #14 Update NUnit version (will use latest version) Notes The TestGenerator extension is released as separate VSIXes for VS 2015 and VS 2017/2019. See Installation for details. The Version 2 is for VS2017/2019, the Version 1 is for VS 2015."
  },
  "articles/vs-test-generator/TestGenerator-Release-Notes-VS2015.html": {
    "href": "articles/vs-test-generator/TestGenerator-Release-Notes-VS2015.html",
    "title": "TestGenerator Release Notes - VS2015 | NUnit Docs",
    "keywords": "TestGenerator Release Notes - VS2015 TestGenerator Extension for NUnit in Visual Studio 2015 - Version 1.1 - March 5, 2017 Bugs and minor fixes #6 NUnit3 tests using removed ExpectedException attribute #10 Specify NUnit versions as v2 and v3 #11 Update more information link #14 Update NUnit version (will use latest version) Notes The TestGenerator extension is released as separate VSIXes for VS 2015 and VS 2017/2019. See Installation for details. The Version 2.X is for VS2017/2019, the Version 1.X is for VS 2015."
  },
  "articles/vs-test-generator/Visual-Studio-Test-Generator.html": {
    "href": "articles/vs-test-generator/Visual-Studio-Test-Generator.html",
    "title": "Visual Studio Test Generator | NUnit Docs",
    "keywords": "Visual Studio Test Generator This is an extension for Visual Studio 2015 and 2017 that extends the test functionality to allow you to create unit tests and IntelliTests. This extension extends the built in test generator functionality allowing developers to generate tests using NUnit 2.6.x or NUnit 3.X. Please note that IntelliTest is only available in Visual Studio Enterprise edition. Other versions of Visual Studio only have the Create Unit Tests menu option. Download You can download this extension in Visual Studio using Tools | Extensions and Updates... and searching for Test Generator NUnit Extension . You can also download from the Visual Studio Gallery for VS 2015 and here for VS 2017 , or from the GitHub Releases Page . How to Use For more information on using IntelliTest and this extension, please see the Microsoft documentation . Right-Click to Create Tests Select NUnit from the Test Framework dropdown"
  },
  "articles/xamarin-runners/Getting-Started-in-Visual-Studio.html": {
    "href": "articles/xamarin-runners/Getting-Started-in-Visual-Studio.html",
    "title": "Getting Started In Visual Studio | NUnit Docs",
    "keywords": "Getting Started In Visual Studio The easiest way to get started is to install the NUnit Templates extension for Visual Studio . It will add project templates for the various Xamarin platforms. For more general information, see Testing Xamarin Projects using NUnit 3 . Getting started In your solution; Add new test projects to your solution. These project types are included in the NUnit Templates Extension : NUnit 3 Test Project (Android) . NUnit 3 Test Project (iOS) , NUnit 3 Test Project (Universal Windows) Write your unit tests in this project, in a portable project, or in a shared project, referencing the project with the tests. Build and run the tests on your device or emulator If you tests are in a separate portable project, note that: You need to add that assembly to the NUnit.Runner.App in the startup code nunit.AddTestAssembly(typeof(MyTests).Assembly); Your portable project must reference the same NUnit Framework version as your nunit.xamarin version, e.g. if using nunit.xamarin 3.01, reference nunit.framework 3.01. The startup code for each platform is as follows; Android MainActivity.cs [Activity(Label = \"NUnit 3\", MainLauncher = true, Theme = \"@android:style/Theme.Holo.Light\", ConfigurationChanges = ConfigChanges.ScreenSize | ConfigChanges.Orientation)] public class MainActivity : global::Xamarin.Forms.Platform.Android.FormsApplicationActivity { protected override void OnCreate(Bundle savedInstanceState) { base.OnCreate(savedInstanceState); global::Xamarin.Forms.Forms.Init(this, savedInstanceState); // This will load all tests within the current project var nunit = new NUnit.Runner.App(); // If you want to add tests in another assembly //nunit.AddTestAssembly(typeof(MyTests).Assembly); // Do you want to automatically run tests when the app starts? nunit.Options = new TestOptions { AutoRun = true }; LoadApplication(nunit); } } iOS AppDelegate.cs [Register(\"AppDelegate\")] public partial class AppDelegate : global::Xamarin.Forms.Platform.iOS.FormsApplicationDelegate { // // This method is invoked when the application has loaded and is ready to run. In this // method you should instantiate the window, load the UI into it and then make the window // visible. // // You have 17 seconds to return from this method, or iOS will terminate your application. // public override bool FinishedLaunching(UIApplication app, NSDictionary options) { global::Xamarin.Forms.Forms.Init(); // This will load all tests within the current project var nunit = new NUnit.Runner.App(); // If you want to add tests in another assembly //nunit.AddTestAssembly(typeof(MyTests).Assembly); // Do you want to automatically run tests when the app starts? nunit.Options = new TestOptions { AutoRun = true }; LoadApplication(nunit); return base.FinishedLaunching(app, options); } } Windows 10 Universal MainPage.xaml <forms:WindowsPage x:Class=\"NUnit.Runner.Tests.MainPage\" xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\" xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\" xmlns:local=\"using:NUnit.Runner.Tests\" xmlns:d=\"http://schemas.microsoft.com/expression/blend/2008\" xmlns:mc=\"http://schemas.openxmlformats.org/markup-compatibility/2006\" xmlns:forms=\"using:Xamarin.Forms.Platform.WinRT\" mc:Ignorable=\"d\"> <Grid Background=\"{ThemeResource ApplicationPageBackgroundThemeBrush}\"> </Grid> </forms:WindowsPage> MainPage.xaml.cs public sealed partial class MainPage : WindowsPage { public MainPage() { InitializeComponent(); // Windows Universal will not load all tests within the current project, // you must do it explicitly below var nunit = new NUnit.Runner.App(); // If you want to add tests in another assembly, add a reference and // duplicate the following line with a type from the referenced assembly nunit.AddTestAssembly(typeof(MainPage).GetTypeInfo().Assembly); // Do you want to automatically run tests when the app starts? nunit.Options = new TestOptions { AutoRun = true }; LoadApplication(nunit); } } App.xaml.cs protected override void OnLaunched(LaunchActivatedEventArgs e) { // <SNIP> Frame rootFrame = Window.Current.Content as Frame; // Do not repeat app initialization when the Window already has content, // just ensure that the window is active if (rootFrame == null) { // Create a Frame to act as the navigation context and navigate to the first page rootFrame = new Frame(); rootFrame.NavigationFailed += OnNavigationFailed; // ==> ADD THIS LINE <== Xamarin.Forms.Forms.Init(e); if (e.PreviousExecutionState == ApplicationExecutionState.Terminated) { // TODO: Load state from previously suspended application } // Place the frame in the current Window Window.Current.Content = rootFrame; } // <SNIP> }"
  },
  "articles/xamarin-runners/Getting-Started-in-Visual-Studio-for-Mac.html": {
    "href": "articles/xamarin-runners/Getting-Started-in-Visual-Studio-for-Mac.html",
    "title": "Getting Started In Visual Studio For Mac | NUnit Docs",
    "keywords": "Getting Started In Visual Studio For Mac If you're using Visual Studio for Mac the NUnit templates extension can't be used. This guide assumes that you have a solution with either a PCL or a Shared project and a number of platform specific projects. It doesn't matter if you're using Xamarin.Forms or Xamarin.iOS/Xamarin.Android directly. Your solution might look something like this: Project Solution ...Project (Contains Shared Code) ...Project.iOS ...Project.Android Shared Test Project First, create a new PCL that holds your shared testing code, so the test code doesn't end up in production builds. Right Click on the Project Solution and Add a new project using the Cross-Platform Shared Library Template. Use Project.Tests as a name. Afterwards, your solution should look like this: Project Solution ...Project (Contains Shared Code) ...Project.iOS ...Project.Android ...Project.Tests (Holds your testing code) Edit the references of the newly created test project so that it contains a reference to the standard PCL. Afterwards, add a NuGet dependency on NUnit by right-clicking on Project.Tests and selection Add -> Add NuGet Package. Note Ensure you reference the same version of NUnit as the version of nunit.xamarin you are using. e.g. If you are using nunit.xamarin 3.0.1, add the v3.0.1 NUnit NuGet package. Afterwards, your test project is ready. Platform runners In order to run the tests it's necessary to create a project for each platform you'd like to support (iOS, Android and so on). Do so using the standard Xamarin templates for new platform projects. It's probably sensible to use a naming scheme like Project.Tests.iOS for the individual test projects do keep your solution structured. Project Solution ...Project (Contains Shared Code) ...Project.iOS ...Project.Android ...Project.Tests (Holds your testing code) ...Project.Tests.iOS ...Project.Tests.Android The NUnit.Xamarin runners are built using Xamarin.Forms, so you need to add NUnit, NUnit.Xamarin and Xamarin.Forms as NuGet dependencies to the newly created projects. It's also necessary to add a reference to the shared test project containing the tests. If you've followed the steps above, you can now replace the AppDelegate.cs or MainActivity.cs with the code shown below. Since your tests are not in the same assembly as the runner it's a good idea to create a canary test class in the Shared Test Projects that you can use to reference the test assembly explicitly. In the example below, the name of this class is MyTest.cs. Android MainActivity.cs [Activity(Label = \"NUnit 3\", MainLauncher = true, Theme = \"@android:style/Theme.Holo.Light\", ConfigurationChanges = ConfigChanges.ScreenSize | ConfigChanges.Orientation)] public class MainActivity : global::Xamarin.Forms.Platform.Android.FormsApplicationActivity { protected override void OnCreate(Bundle savedInstanceState) { base.OnCreate(savedInstanceState); global::Xamarin.Forms.Forms.Init(this, savedInstanceState); // This will load all tests within the current project var nunit = new NUnit.Runner.App(); // If you want to add tests in another assembly //nunit.AddTestAssembly(typeof(MyTests).Assembly); // Do you want to automatically run tests when the app starts? nunit.Options = new TestOptions { AutoRun = true }; LoadApplication(nunit); } } iOS AppDelegate.cs [Register(\"AppDelegate\")] public partial class AppDelegate : global::Xamarin.Forms.Platform.iOS.FormsApplicationDelegate { // // This method is invoked when the application has loaded and is ready to run. In this // method you should instantiate the window, load the UI into it and then make the window // visible. // // You have 17 seconds to return from this method, or iOS will terminate your application. // public override bool FinishedLaunching(UIApplication app, NSDictionary options) { global::Xamarin.Forms.Forms.Init(); // This will load all tests within the current project var nunit = new NUnit.Runner.App(); // If you want to add tests in another assembly //nunit.AddTestAssembly(typeof(MyTests).Assembly); // Do you want to automatically run tests when the app starts? nunit.Options = new TestOptions { AutoRun = true }; LoadApplication(nunit); return base.FinishedLaunching(app, options); } }"
  },
  "articles/xamarin-runners/index.html": {
    "href": "articles/xamarin-runners/index.html",
    "title": "NUnit Xamarin Runners | NUnit Docs",
    "keywords": "NUnit Xamarin Runners The NUnit Xamarin Runners provide NUnit 3 test runners for Xamarin and mobile devices. See Testing Xamarin projects using NUnit 3 for more general information. Options Runner options are set inside a TestOptions object. For example: var nunit = new NUnit.Runner.App(); nunit.Options = new TestOptions { AutoRun = true }; The following options are available: Option Version added Type Usage AutoRun 3.0 Boolean If True, the tests will run automatically when the app starts, otherwise you must run them manually. TerminateAfterExecution 3.6.1 Boolean If True, app will exit cleanly after test execution. TcpWriterParameters 3.6.1 TcpWriterInfo Provide a TCP listener host and port, sends result as XML to the listening server. Takes a TcpWriterInfo - see below . CreateXmlResultFile 3.6.1 Boolean If True, create a xml file containing results. ResultFilePath 3.6.1 String Specify file path to save xml result file. TcpWriterInfo TcpWriterInfo takes three parameters: hostname, port, and an optional timeout in seconds (default 10). TcpWriterParameters = new TcpWriterInfo(\"192.168.0.108\", 13000, 10);"
  },
  "index.html": {
    "href": "index.html",
    "title": "NUnit Documentation Site | NUnit Docs",
    "keywords": "NUnit Documentation Site This web site contains the documentation for all active NUnit projects as well as developer documentation for those working on NUnit or wishing to do so. User Documentation NUnit covers NUnit itself, including the framework, engine and console runner. NUnit VS Adapter covers the Visual Studio test adapters for both NUnit V2 and V3. NUnit VS Test Generator covers the Visual Studio extension for generating tests in both NUnit V2 and V3. NUnit Xamarin Runners covers the NUnit test runners for Xamarin and mobile devices. NUnit Analyzers covers the NUnit Analyzers for NUnit V3. Developer Documentation Team practices describe how NUnit works and how our teams work. Specifications are descriptions of features we plan to add. Legacy (NUnit V2) Documentation Documentation for NUnit V2, which is no longer developed, remains available. <!--markdownlint-disable--> <!--markdownlint-enable --> NUnit 2.6.4 NUnit 2.6.3 NUnit 2.6.2 NUnit 2.6.1 NUnit 2.6 NUnit 2.5.10 NUnit 2.5.9 NUnit 2.5.8 NUnit 2.5.7 NUnit 2.5.6 NUnit 2.5.5 NUnit 2.5.4 NUnit 2.5.3 NUnit 2.5.2 NUnit 2.5.1 NUnit 2.5 NUnit 2.4.8 NUnit 2.4.7 NUnit 2.4.6 NUnit 2.4.5 NUnit 2.4.4 NUnit 2.4.3 NUnit 2.4.2 NUnit 2.4.1 NUnit 2.4 NUnit 2.2.10 NUnit 2.2.9 NUnit 2.2.8 NUnit 2.2.7 NUnit 2.2.6 NUnit 2.2.5 NUnit 2.2.4 NUnit 2.2.3 NUnit 2.2.2 NUnit 2.2.1 NUnit 2.2 <!--markdownlint-disable --> <!--markdownlint-enable -->"
  }
}