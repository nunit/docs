<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html lang="en">

  <head>
    <meta charset="utf-8">
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-PCB5BYBNM2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag() { dataLayer.push(arguments); }
      gtag('js', new Date());
      gtag('config', 'G-PCB5BYBNM2');
    </script>
      <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
      <title>Equal Constraint | NUnit Docs </title>
      <meta name="viewport" content="width=device-width">
      <meta name="title" content="Equal Constraint | NUnit Docs ">
    
    
      <link rel="shortcut icon" href="../../../../favicon.ico">
      <link rel="stylesheet" href="../../../../styles/docfx.vendor.min.css">
      <link rel="stylesheet" href="../../../../styles/docfx.css">
      <link rel="stylesheet" href="../../../../styles/main.css">
      <meta property="docfx:navrel" content="../../../../toc.html">
      <meta property="docfx:tocrel" content="../../../toc.html">
    
    <meta property="docfx:rel" content="../../../../">
    
  </head>
  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>

        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>

              <a class="navbar-brand" href="../../../../index.html">
                <img id="logo" class="svg" src="../../../../logo.svg" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>

        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div class="container body-content">

        <div id="search-results">
          <div class="search-list">Search Results for <span></span></div>
          <div class="sr-items">
            <p><i class="glyphicon glyphicon-refresh index-loading"></i></p>
          </div>
          <ul id="pagination" data-first=First data-prev=Previous data-next=Next data-last=Last></ul>
        </div>
      </div>
      <div role="main" class="container body-content hide-when-search">

        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="equalconstraint">
<h1 id="equal-constraint">Equal Constraint</h1>

<p>An EqualConstraint is used to test whether an actual value is equal to the expected value supplied in its constructor,
optionally within a specified tolerance.</p>
<h2 id="constructor">Constructor</h2>
<pre><code class="lang-csharp">EqualConstraint(object expected)
</code></pre>
<h2 id="syntax">Syntax</h2>
<pre><code class="lang-csharp">Is.EqualTo(object expected)
Is.Zero // Equivalent to Is.EqualTo(0)
</code></pre>
<h2 id="modifiers">Modifiers</h2>
<pre><code class="lang-csharp">...IgnoreCase
...IgnoreWhiteSpace  // From version 4.2
...AsCollection
...NoClip
...WithSameOffset
...Within(object tolerance)
      .Ulps
      .Percent
      .Days
      .Hours
      .Minutes
      .Seconds
      .Milliseconds
      .Ticks
...IgnoreCase
...IgnoreWhiteSpace
...Using(IEqualityComparer comparer)
...Using(IComparer comparer)
...Using&lt;T&gt;(IEqualityComparer&lt;T&gt; comparer)
...Using&lt;T&gt;(IComparer&lt;T&gt; comparer)
...Using&lt;T&gt;(Comparison&lt;T&gt; comparer)
...Using&lt;T&gt;(Func&lt;T, T, bool&gt; comparer)
...Using&lt;TActual, TExpected&gt;(Func&lt;TActual, TExpected, bool&gt; comparer)
...UsingPropertiesComparer()  // From version 4.1
...UsingPropertiesComparer(
      Func&lt;PropertiesComparerConfiguration,
           PropertiesComparerConfiguration&gt; configure) // From version 4.4
</code></pre>
<h2 id="comparing-numerics">Comparing Numerics</h2>
<p>Numerics are compared based on their values. Different types may be compared successfully if their values are equal.</p>
<p>Using the <strong>Within</strong> modifier, numerics may be tested for equality within a fixed or percent tolerance.</p>
<pre><code class="lang-csharp">Assert.That(2 + 2, Is.EqualTo(4.0));
Assert.That(2 + 2 == 4);
Assert.That(2 + 2, Is.Not.EqualTo(5));
Assert.That(2 + 2 != 5);
Assert.That(5.0, Is.EqualTo(5));
Assert.That(5.5, Is.EqualTo(5).Within(0.075));
Assert.That(5.5, Is.EqualTo(5).Within(1.5).Percent);
</code></pre>
<h2 id="comparing-floating-point-values">Comparing Floating Point Values</h2>
<p>Values of type float and double are normally compared using a tolerance specified by the <strong>Within</strong> modifier. The
special values PositiveInfinity, NegativeInfinity and NaN compare as equal to themselves.</p>
<p>Floating-point values may be compared using a tolerance in &quot;Units in the Last Place&quot; or ULPs. For certain types of
numerical work, this is safer than a fixed tolerance because it automatically compensates for the added inaccuracy of
larger numbers.</p>
<pre><code class="lang-csharp">Assert.That(2.1 + 1.2, Is.EqualTo(3.3).Within(.0005));
Assert.That(double.PositiveInfinity, Is.EqualTo(double.PositiveInfinity));
Assert.That(double.NegativeInfinity, Is.EqualTo(double.NegativeInfinity));
Assert.That(double.NaN, Is.EqualTo(double.NaN));
Assert.That(20000000000000004.0, Is.EqualTo(20000000000000000.0).Within(1).Ulps);
</code></pre>
<h2 id="comparing-strings">Comparing Strings</h2>
<p>String comparisons normally respect case. The <code>IgnoreCase</code> modifier causes the comparison to be case-insensitive. It may
also be used when comparing arrays or collections of strings.</p>
<pre><code class="lang-csharp">Assert.That(&quot;Hello!&quot;, Is.Not.EqualTo(&quot;HELLO!&quot;));
Assert.That(&quot;Hello!&quot;, Is.EqualTo(&quot;HELLO!&quot;).IgnoreCase);

string[] expected = new string[] { &quot;Hello&quot;, &quot;World&quot; };
string[] actual = new string[] { &quot;HELLO&quot;, &quot;world&quot; };
</code></pre>
<p>Sometimes we need to compare strings irrespective of white space characters, e.g.: when comparing Json strings.
This can be done with the <code>IgnoreWhiteSpace</code> modifier.
It allows using pretty formatted Json in NUnit tests regardless
whether the code under test uses different formatting or no white space at all.</p>
<pre><code class="lang-csharp">const string prettyJson = &quot;&quot;&quot;
    &quot;persons&quot;:[
      {
        &quot;name&quot;: &quot;John&quot;,
        &quot;surname&quot;: &quot;Smith&quot;
      },
      {
        &quot;name&quot;: &quot;Jane&quot;,
        &quot;surname&quot;: &quot;Doe&quot;
      }
    ]
    &quot;&quot;&quot;;
    
const string condensedJson = &quot;&quot;&quot;
    &quot;persons&quot;:[{&quot;name&quot;:&quot;John&quot;,&quot;surname&quot;:&quot;Smith&quot;,},{&quot;name&quot;: &quot;Jane&quot;,&quot;surname&quot;: &quot;Doe&quot;}]
    &quot;&quot;&quot;;

Assert.That(condensedJson, Is.EqualTo(prettyJson).IgnoreWhiteSpace);
</code></pre>
<p>The above tests fails and the messages has been updated to include two carrets
to indicate the mismatched location in both <em>expected</em> and <em>actual</em> values:</p>
<pre><code class="lang-text"> Assert.That(condensedJson, Is.EqualTo(prettyJson).IgnoreWhiteSpace)
 Expected string length 122 but was 79. Strings differ at index 65.
 Expected: &quot;...,\r\n    &quot;surname&quot;: &quot;Smith&quot;\r\n  },\r\n  {\r\n    &quot;name&quot;: &quot;Jane&quot;,\r...&quot;, ignoring white-space
 -----------------------------------------------^
 But was:  &quot;&quot;persons&quot;:[{&quot;name&quot;:&quot;John&quot;,&quot;surname&quot;:&quot;Smith&quot;,},{&quot;name&quot;: &quot;Jane&quot;...&quot;
 ------------------------------------------------------^
</code></pre>
<p>The <code>IgnoreWhiteSpace</code> can also be specified when comparing collections of strings.</p>
<h2 id="comparing-datetimes-and-timespans">Comparing DateTimes and TimeSpans</h2>
<p><strong>DateTimes</strong> and <strong>TimeSpans</strong> may be compared either with or without a tolerance. A tolerance is specified using
<strong>Within</strong> with either a <strong>TimeSpan</strong> as an argument or with a numeric value followed by a one of the time conversion
modifiers: <strong>Days</strong>, <strong>Hours</strong>, <strong>Minutes</strong>, <strong>Seconds</strong>, <strong>Milliseconds</strong> or <strong>Ticks</strong>.</p>
<p>When comparing <strong>DateTimeOffsets</strong> you can use the optional <strong>WithSameOffset</strong> modifier to check the offset along with
the date and time.</p>
<pre><code class="lang-csharp">DateTime now = DateTime.Now;
DateTime later = now + TimeSpan.FromHours(1.0);

Assert.That(now, Is.EqualTo(now));
Assert.That(later, Is.EqualTo(now).Within(TimeSpan.FromHours(3.0));
Assert.That(later, Is.EqualTo(now).Within(3).Hours);
</code></pre>
<h2 id="comparing-arrays-collections-and-ienumerables">Comparing Arrays, Collections and IEnumerables</h2>
<p>Since version 2.2, NUnit has been able to compare two single-dimensioned arrays. Beginning with version 2.4,
multi-dimensioned arrays, nested arrays (arrays of arrays) and collections may be compared. With version 2.5, any
IEnumerable is supported. Two arrays, collections or IEnumerables are considered equal if they have the same dimensions
and if each of the corresponding elements is equal.</p>
<p>If you want to treat two arrays of different shapes as simple collections for purposes of comparison, use the
<strong>AsCollection</strong> modifier, which causes the comparison to be made element by element, without regard for the rank or
dimensions of the array. Note that jagged arrays (arrays of arrays) do not have a single underlying collection. The
modifier would be applied to each array separately, which has no effect in most cases.</p>
<p>The <code>AsCollection</code> modifier is also useful on classes implementing both <code>IEnumerable</code> and <code>IEquatable</code>. Without the
modifier, the <code>IEquatable</code> implementation is used to test equality. With the modifier specified, <code>IEquatable</code> is ignored
and the contents of the enumeration are compared one by one.</p>
<pre><code class="lang-csharp">int[] i3 = new int[] { 1, 2, 3 };
double[] d3 = new double[] { 1.0, 2.0, 3.0 };
int[] iunequal = new int[] { 1, 3, 2 };
Assert.That(i3, Is.EqualTo(d3));
Assert.That(i3, Is.Not.EqualTo(iunequal));

int[,] array2x2 = new int[,] { { 1, 2 }, { 3, 4 } };
int[] array4 = new int[] { 1, 2, 3, 4 };
Assert.That(array2x2, Is.Not.EqualTo(array4));
Assert.That(array2x2, Is.EqualTo(array4).AsCollection);
</code></pre>
<h2 id="comparing-dictionaries">Comparing Dictionaries</h2>
<p>Two dictionaries are considered equal if</p>
<ol>
<li>The list of keys is the same - without regard to ordering.</li>
<li>The values associated with each key are equal.</li>
</ol>
<p>You can use this capability to compare any two objects implementing <strong>IDictionary</strong>. Generic and non-generic
dictionaries (Hashtables) may be successfully compared.</p>
<h2 id="comparing-directoryinfo">Comparing DirectoryInfo</h2>
<p>Two DirectoryInfo objects are considered equal if both have the same path, creation time and last access time.</p>
<pre><code class="lang-csharp">Assert.That(new DirectoryInfo(actual), Is.EqualTo(expected));
</code></pre>
<h2 id="comparing-classesstructures">Comparing Classes/Structures</h2>
<p>If a class/structure implements <code>IEquatable&lt;T&gt;</code> then it is up to the class to define equality.
If not, then the standard .NET <code>Equals</code> is called which means for classes,
it is reference equality and for structures it is value equality.</p>
<pre><code class="lang-csharp">private sealed class Person
{
    public Person(string name, int yearOfBirth)
    {
        Name = name;
        YearOfBirth = yearOfBirth;
    }

    public string Name { get; }
    public int YearOfBirth { get; }
}

[Test]
public void ComparePersons()
{
    var person1 = new Person(&quot;Charlie&quot;, 1985);
    var person2 = new Person(&quot;Charlie&quot;, 1985);

    Assert.That(person2, Is.EqualTo(person1));
}
</code></pre>
<p>The above test fails because even though <em>person1</em> and <em>person2</em> have the same property values,
they are different instances.
If we want to have value equality there are three options:</p>
<ol>
<li>Implement <code>IEquality&lt;Person&gt;</code> on the <code>Person</code> class<br>
This is not always wanted, we may require reference comparison
in most code, but need value equality for NUnit tests.</li>
<li>Specify a specific comparer. See <a href="#user-specified-comparers">User-Specified Comparers</a> below.<br>
This does require writing separate comparers each time one wants
to compare a class for value equality.</li>
<li>Add the <code>.UsingPropertiesComparer()</code> suffix.<br>
This is a special built-in comparer which iterates over all <em>public</em> properties of a class and
compares them one by one. It is useful to get value equality for nunit test, e.g. when
serializing/deserializing instances, but when value equality is not wanted in normal code.
Even if two persons are called <em>Charlie</em> that doesn't mean they are one and the same person.</li>
</ol>
<h2 id="user-specified-comparers">User-Specified Comparers</h2>
<p>If the default NUnit or .NET behavior for testing equality doesn't meet your needs, you can supply a comparer of your
own through the <code>Using</code> modifier. When used with <code>EqualConstraint</code>, you may supply an <code>IEqualityComparer</code>,
<code>IEqualityComparer&lt;T&gt;</code>, <code>IComparer</code>, <code>IComparer&lt;T&gt;</code> or <code>Comparison&lt;T&gt;</code> as the argument to <code>Using</code>.</p>
<pre><code class="lang-csharp">Assert.That(myObj1, Is.EqualTo(myObj2).Using(myComparer));
</code></pre>
<p>Prior to NUnit 2.6, only one comparer could be used. If multiple comparers were specified, all but one was ignored.
Beginning with NUnit 2.6, multiple generic comparers for different types may be specified. NUnit will use the
appropriate comparer for any two types being compared. As a result, it is now possible to provide a comparer for an
array, a collection type or a dictionary. The user-provided comparer will be used directly, bypassing the default NUnit
logic for array, collection or dictionary equality.</p>
<pre><code class="lang-csharp">class ListOfIntComparer : IEqualityComparer&lt;List&lt;int&gt;&gt;
{
    /* ... */
}

var list1 = new List&lt;int&gt;();
var list2 = new List&lt;int&gt;();
var myComparer = new ListOfIntComparer();
/* ... */
Assert.That(list1, Is.EqualTo(list2).Using(myComparer));
</code></pre>
<h2 id="properties-comparer">Properties Comparer</h2>
<p>The properties comparer is enabled when suffixing the constraint with <code>.UsingPropertiesComparer()</code>.
It is only called for instances of the same type which do not implement <code>IEquatable&lt;T&gt;</code>.
The exception is that it will be called for <code>record</code> types that have a compiler generated <code>Equals</code> implementation.
The reason for this is to get better error messages in case of mismatch.</p>
<p>This comparer iterates over all public properties of a type.
For each property, it gets the value for both instances and compares them for equality.
This can be recursive, e.g. if one has a class <code>Group</code> holding a collection of <code>Persons</code>.</p>
<p>The comparer will use the specified tolerance as specified using <code>.Within(amount)</code> if possible.
This can be useful when comparing floating point numbers of calculation results.</p>
<p>The comparer can deal with recursive data structures,
it will stop comparing if it already previously has compared two the same instances.</p>
<p>From version 4.4 there is a new overload of <code>UsingPropertiesComparer</code> which allows tailoring the comparison.
This overload expects delegate that accepts a <code>PropertiesComparerConfiguration</code> and
also returns a <code>PropertiesComparerConfiguration</code>.</p>
<h3 id="comparing-different-types">Comparing Different Types</h3>
<p>By default, the <code>PropertiesComparer</code> only compares instances of the same type.
But sometimes we want to compare the properties of a Dto object with an Domain entity.
If all properties have the same name, this can be done with the <code>AllowDifferentTypes()</code> modifier.</p>
<pre><code class="lang-csharp">private record struct PersonDto(string Name, int YearOfBirth);
private record struct PersonEntity(string Name, int YearOfBirth);

[Test]
public void CompareDifferentTypes()
{
    var dto = new PersonDto(&quot;Hejlsberg&quot;, 1960);
    var entity = new PersonEntity(&quot;Hejlsberg&quot;, 1960);

    Assert.That(dto, Is.EqualTo(entity)
                       .UsingPropertiesComparer(o =&gt; o.AllowDifferentTypes()));
}
</code></pre>
<h3 id="excluding-some-properties-for-comparison">Excluding some Properties for Comparison</h3>
<h4 id="compare-only-common-properties">Compare Only Common Properties</h4>
<p>If our <code>PersonEntity</code> class has an <code>Id</code> property for the database key,
it no longer matches the <code>PersonDto</code>.
We would like to compare the two, but ignore the <code>Id</code> property.</p>
<p>To only compare those properties available on both types, use: <code>.CompareOnlyCommonProperties()</code>.
This method implies <code>.AllowDifferentTypes()</code>.</p>
<pre><code class="lang-csharp">private record struct PersonDto(string Name, int YearOfBirth);
private record struct PersonEntity(Guid Id, string Name, int YearOfBirth);

[Test]
public void CompareDifferentTypesWithExcessFields()
{
   var dto = new PersonDto(&quot;Hejlsberg&quot;, 1960);
   var entity = new PersonEntity(Guid.NewGuid(), &quot;Hejlsberg&quot;, 1960);

   Assert.That(dto, Is.EqualTo(entity)
                      .UsingPropertiesComparer(o =&gt; o.CompareOnlyCommonProperties()));
}
</code></pre>
<h4 id="use-only-specified-properties">Use only specified Properties</h4>
<p>Sometimes you don't want to compare all properties and you only care about some.
You can do this with the <code>Using</code> method.</p>
<p>There are two overloads, one expecting a <code>string</code> and the other a type safe <code>Expression</code>.
The latter has the advantage that you get intellisense helping you with available property names.
However, that overload is only available on some constraints which have been update with a generic type parameter.</p>
<pre><code class="lang-csharp">private record struct Person(string Name, int YearOfBirth);

[Test]
public void CompareDifferentTypesOnNameOnly()
{
   var dto1 = new PersonDto(&quot;Hejlsberg&quot;, 1960);
   var dto2 = new PersonDto(&quot;Hejlsberg&quot;, 1966);

   // Specify name as a string
   Assert.That(dto2, Is.EqualTo(dto1).UsingPropertiesComparer(
      o =&gt; o.Using(&quot;Name&quot;)));

   // Specify name as an expression
   Assert.That(dto2, Is.EqualTo(dto1).UsingPropertiesComparer(
      o =&gt; o.Using(x =&gt; x.Name)));
}
</code></pre>
<h4 id="use-all-but-some-properties">Use all but some properties</h4>
<p>If you don't care about the equality of one property, like database id field,
you can exclude this specifically with the <code>Exclude</code> method.
This method also has two overloads: <code>string</code> and <code>Expression</code>.</p>
<pre><code class="lang-csharp">private record struct PersonEntity(Guid Id, string Name, int YearOfBirth);

[Test]
public void CompareDifferentTypesExcludingId()
{
   var entity1 = new PersonEntity(Guid.NewGuid(), &quot;Hejlsberg&quot;, 1960);
   var entity2 = new PersonEntity(Guid.NewGuid(), &quot;Hejlsberg&quot;, 1960);

   Assert.That(entity2, Is.EqualTo(entity1).UsingPropertiesComparer(
      o =&gt; o.Excluding(nameof(PersonEntity.Id))));
   Assert.That(entity2, Is.EqualTo(entity1).UsingPropertiesComparer(
      o =&gt; o.Excluding(x =&gt; x.Id)));
}
</code></pre>
<h3 id="mapping-property-names">Mapping Property Names</h3>
<p>Sometimes the property names are different between classes.
You can use the <code>Map</code> property to map property names from the <em>expected</em> to the <em>actual</em> name.</p>
<p>Because the constraints are separate from the actual <code>Assert</code> call, you do need to specify the
type of the <em>actual</em> instance when using the type safe <code>Expression</code> overload.</p>
<pre><code class="lang-csharp">private record struct PersonDto(string Name, int YearOfBirth);
private record struct PersonEntity(string LastName, int BirthYear);

[Test]
public void CompareDifferentTypesWithExcessFields()
{
   var dto = new PersonDto(&quot;Hejlsberg&quot;, 1960);
   var entity = new PersonEntity(&quot;Hejlsberg&quot;, 1960);

   Assert.That(dto, Is.EqualTo(entity).UsingPropertiesComparer(
      o =&gt; o.Map(nameof(PersonEntity.LastName), nameof(PersonDto.Name))
            .Map(nameof(PersonEntity.BirthYear), nameof(PersonDto.YearOfBirth))));

   Assert.That(dto, Is.EqualTo(entity).UsingPropertiesComparer(
      o =&gt; o.Map&lt;PersonDto&gt;(entity =&gt; entity.LastName, dto =&gt; dto.Name)
            .Map&lt;PersonDto&gt;(entity =&gt; entity.BirthYear, dto =&gt; dto.YearOfBirth)));
}
</code></pre>
<h3 id="mapping-property-values">Mapping Property Values</h3>
<p>Sometimes one class doesn't have the properties the other has, but we only want to compare
if the value of the other has a specific value.</p>
<pre><code class="lang-csharp">private sealed record Address(string House, string Street, string City, string PostalCode, string Country);
private sealed record USAddress(string House, string Street, string City, string ZipCode);

[Test]
public void CompareMatchingDifferentAddresses()
{
   var address = new Address(&quot;10&quot;, &quot;CSI&quot;, &quot;Las Vegas&quot;, &quot;89030&quot;, &quot;U.S.A.&quot;);
   var usAddress = new USAddress(&quot;10&quot;, &quot;CSI&quot;, &quot;Las Vegas&quot;, &quot;89030&quot;);

   // We can supply a Value for the missing property 'Country'
   Assert.That(usAddress, Is.EqualTo(address).UsingPropertiesComparer(
      o =&gt; o.Map&lt;Address, USAddress&gt;(world =&gt; world.PostalCode, usa =&gt; usa.ZipCode)
            .Map&lt;Address&gt;(world =&gt; world.Country, &quot;U.S.A.&quot;)));
}
</code></pre>
<p>All <code>USAddress</code> instances are assumed to be in the <code>U.S.A</code>.
To compare this with world wide addresses, they should only match
if the world address' <em>Country</em> has the value <code>U.S.A</code>.</p>
<p>We could have excluded the <em>Country</em> property, but then we might get matches of similar addresses in other countries.</p>
<h3 id="configuring-matching-for-nested-type-members">Configuring matching for nested type members</h3>
<p>The above can be combined for nested types:</p>
<pre><code class="lang-csharp">private sealed record Address(string House, string Street, string City, string AreaCode, string Country);
private sealed record Person(string Name, Address Address);

private sealed record USAddress(string House, string Street, string City, string ZipCode);
private sealed record USPerson(string Name, USAddress USAddress);

[Test]
public void CompareMismatchedDifferentTypes()
{
   var person = new Person(&quot;John Doe&quot;, new Address(&quot;10&quot;, &quot;CSI&quot;, &quot;Las Vegas&quot;, &quot;89030&quot;, &quot;U.S.A.&quot;));
   var usPerson = new USPerson(&quot;John Doe&quot;, new USAddress(&quot;10&quot;, &quot;CSI&quot;, &quot;Las Vegas&quot;, &quot;89031&quot;));

   Assert.That(usPerson, Is.EqualTo(person).UsingPropertiesComparer(
   o =&gt; o.Map&lt;Person, USPerson&gt;(x =&gt; x.Address, y =&gt; y.USAddress)
         .Map&lt;Address, USAddress&gt;(x =&gt; x.AreaCode, y =&gt; y.ZipCode)
         .Map&lt;Address&gt;(x =&gt; x.Country, &quot;U.S.A.&quot;)));
}
</code></pre>
<p>The mapped property names and values are shown in the failure message:</p>
<pre><code class="lang-text">Assert.That(usPerson, Is.EqualTo(person).UsingPropertiesComparer(
                  c =&gt; c.Map&lt;Person, USPerson&gt;(x =&gt; x.Address, y =&gt; y.USAddress)
                        .Map&lt;Address, USAddress&gt;(x =&gt; x.AreaCode, y =&gt; y.ZipCode)
                        .Map&lt;Address&gt;(x =&gt; x.Country, &quot;U.S.A.&quot;)))
Expected: &lt;Person { Name = John Doe, Address = Address { House = 10, Street = CSI, City = Las Vegas, AreaCode = 89030, Country = U.S.A. } }&gt;
But was:  &lt;USPerson { Name = John Doe, USAddress = USAddress { House = 10, Street = CSI, City = Las Vegas, ZipCode = 89031 } }&gt;
Values differ at property Person.Address =&gt; USPerson.USAddress:
Expected: &lt;Address { House = 10, Street = CSI, City = Las Vegas, AreaCode = 89030, Country = U.S.A. }&gt;
But was:  &lt;USAddress { House = 10, Street = CSI, City = Las Vegas, ZipCode = 89031 }&gt;
Values differ at property Address.AreaCode =&gt; USAddress.ZipCode:
String lengths are both 5. Strings differ at index 4.
Expected: &quot;89030&quot;
But was:  &quot;89031&quot;
---------------^
</code></pre>
<h2 id="notes">Notes</h2>
<ol>
<li>When checking the equality of user-defined classes, NUnit first examines each class to determine whether it
implements <code>IEquatable&lt;T&gt;</code> (unless the <code>AsCollection</code> modifier is used). If either object implements the interface
for the type of the other object, then that implementation is used in making the comparison. If neither class
implements the appropriate interface, NUnit makes use of the <code>Equals</code> override on the expected object. If you neglect
to either implement <code>IEquatable&lt;T&gt;</code> or to override <code>Equals</code>, you can expect failures comparing non-identical objects.
In particular, overriding <code>operator ==</code> without overriding <code>Equals</code> or implementing the interface has no effect.</li>
<li>The <strong>Within</strong> modifier was originally designed for use with floating point values only. Beginning with NUnit 2.4,
comparisons of <strong>DateTime</strong> values may use a <strong>TimeSpan</strong> as a tolerance. Beginning with NUnit 2.4.2, non-float
numeric comparisons may also specify a tolerance.</li>
<li>Float and double comparisons for which no tolerance is specified use a default value, which can be specified with
<strong>DefaultFloatingPointToleranceAttribute</strong>. If this is not in place, a tolerance of 0.0d is used. (Prior to NUnit
3.7, default tolerance was instead set via <code>GlobalSettings.DefaultFloatingPointTolerance</code>.)</li>
<li>Prior to NUnit 2.2.3, comparison of two NaN values would always fail, as specified by IEEE floating point standards.
The new behavior, was introduced after some discussion because it seems more useful in tests. To avoid confusion,
consider using <strong>Is.NaN</strong> where appropriate.</li>
<li>When an equality test between two strings fails, the relevant portion of both strings is displayed in the error
message, clipping the strings to fit the length of the line as needed. Beginning with 2.4.4, this behavior may be
modified by use of the <strong>NoClip</strong> modifier on the constraint. In addition, the maximum line length may be modified
for all tests by setting the value of <strong>TextMessageWriter.MaximumLineLength</strong> in the appropriate level of setup.</li>
<li>When used with arrays, collections or dictionaries, EqualConstraint operates recursively. Any modifiers are saved and
used as they apply to individual items.</li>
<li>A user-specified comparer will not be called by <strong>EqualConstraint</strong> if either or both arguments are null. If both are
null, the Constraint succeeds. If only one is null, it fails.</li>
<li>NUnit has special semantics for comparing <strong>Streams</strong> and <strong>DirectoryInfos</strong>. For a <strong>Stream</strong>, the contents are
compared. For a <strong>DirectoryInfo</strong>, the first-level directory contents are compared.</li>
</ol>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="../assertions/classic-assertions/Assert.AreEqual.html">Assert.AreEqual</a></li>
<li><a href="../attributes/defaultfloatingpointtolerance.html">DefaultFloatingPointTolerance Attribute</a></li>
</ul>

</article>
          </div>

          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                  <li>
                    <a href="https://github.com/nunit/docs/blob/master/docs/articles/nunit/writing-tests/constraints/EqualConstraint.md/#L1" class="contribution-link">Edit this page</a>
                  </li>
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
                <h5>In this article</h5>
                <div></div>
              </nav>
            </div>
          </div>
        </div>
      </div>

      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
      <span>Generated by <strong>DocFX</strong></span> | Copyright (c) 2018-<span id="currentYear"></span> The NUnit Project - Licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a>
      
          </div>
        </div>
      </footer>
    </div>

    <script type="text/javascript" src="../../../../styles/docfx.vendor.min.js"></script>
    <script type="text/javascript" src="../../../../styles/docfx.js"></script>
    <script type="text/javascript" src="../../../../styles/main.js"></script>
  </body>
</html>
